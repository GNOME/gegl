/* ctx-0.1.3 */
/* 
 * ctx.h is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * ctx.h is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with ctx; if not, see <https://www.gnu.org/licenses/>.
 *
 * 2012, 2015, 2019, 2020, 2021, 2022, 2023, 2024, 2025 Øyvind Kolås <pippin@gimp.org>
 *
 * ctx is a 2D vector graphics protocol, and interactive application
 * development environment for microcontrollers, framebuffers and
 * terminals on unix systems.
 * 
 * To use ctx add ctx.h to the project path and do the following:
 *
 * #define CTX_IMPLEMENTATION
 * #include "ctx.h"
 *
 * Ctx contains a minimal default fallback font with only ascii, so
 * you probably want to also include a font, and perhaps enable
 * SDL2 optional backends, a more complete example:
 *
 * #include <cairo.h>
 * #include <SDL.h>
 * 
 * #define CTX_IMPLEMENTATION
 * #include "ctx.h"
 *
 * The behavior of ctx can be tweaked, and features can be configured, enabled
 * or disabled with other #defines, see further down in the start of this file
 * for details.
 */

#ifndef CTX_H
#define CTX_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <string.h>
#include <strings.h>
#include <stdio.h>

/*** h2: context management */

typedef struct _Ctx            Ctx;

/**
 * ctx_new:
 * @width: with in device units
 * @height: height in device units
 * @backend: backend to use
 *
 *   valid values are:
 *     NULL/"auto", "drawlist", "sdl", "term", "ctx" the strings are
 *     the same as are valid for the CTX_BACKEND environment variable.
 *
 * Create a new drawing context, this context has no pixels but
 * accumulates commands and can be played back on other ctx
 * render contexts, this is a ctx context using the drawlist backend.
 */
Ctx *ctx_new (int width, int height, const char *backend);


/**
 * ctx_new_drawlist:
 *
 * Create a new drawing context that can record drawing commands,
 * this is also the basis for creating more complex contexts with
 * swapped out backend.
 */
Ctx * ctx_new_drawlist (int width, int height);

/** CtxEntry:
 *
 * A pointer to a command in binary ctx protocol.
 */
typedef struct _CtxEntry   CtxEntry;
/** CtxCommand:
 *
 * A pointer to a command in binary ctx protocol.
 */
typedef struct _CtxCommand CtxCommand;

/* The pixel formats supported as render targets, depending on
 * compile-time configuration not all formats are usable.
 */
enum _CtxPixelFormat
{
  CTX_FORMAT_NONE=0,
  CTX_FORMAT_GRAY8,  // 1  - these enum values are not coincidence
  CTX_FORMAT_GRAYA8, // 2  - but match bpp, for the common gray and
  CTX_FORMAT_RGB8,   // 3  - rgb cases up to 4bpp = RGBA8
  CTX_FORMAT_RGBA8,  // 4  -
  CTX_FORMAT_BGRA8,  // 5
  CTX_FORMAT_RGB565, // 6
  CTX_FORMAT_RGB565_BYTESWAPPED, // 7
  CTX_FORMAT_RGB332, // 8 // matching flags
  CTX_FORMAT_RGBAF,  // 9
  CTX_FORMAT_GRAYF,  // 10
  CTX_FORMAT_GRAYAF, // 11
  CTX_FORMAT_GRAY1,  // 12
  CTX_FORMAT_CMYK8,  // 13
  CTX_FORMAT_CMYKAF, // 14
  CTX_FORMAT_CMYKA8, // 15 
  CTX_FORMAT_GRAY2,  // 16 // matching flags
  CTX_FORMAT_YUV420, // 17
  CTX_FORMAT_BGR8,   // 
  CTX_FORMAT_RGBA8_SEPARATE_ALPHA, //
  CTX_FORMAT_GRAY4 =32, // to match flags
  CTX_FORMAT_BGRA8Z,    // 
};
typedef enum   _CtxPixelFormat CtxPixelFormat;

/**
 * ctx_new_for_framebuffer:
 *
 * Create a new drawing context for a framebuffer, rendering happens
 * immediately.
 */
Ctx *ctx_new_for_framebuffer (void *data,
                              int   width,
                              int   height,
                              int   stride,
                              CtxPixelFormat pixel_format);



/**
 * ctx_get_drawlist:
 * @ctx: a ctx context.
 * @count: return location for length of drawlist
 *
 * The returned pointer is only valid as long as no further drawing has been
 * done.
 *
 * Returns a read only pointer to the first entry of the contexts drawlist.
 */
const CtxEntry *ctx_get_drawlist (Ctx *ctx, int *count);


/**
 * ctx_new_for_drawlist:
 *
 * Create a new drawing context for a pre-existing raw drawlist.
 */
Ctx *ctx_new_for_drawlist   (int    width,
                             int    height,
                             void  *data,
                             size_t length);

/**
 * ctx_set_drawlist:
 *
 * Replaces the drawlist of a ctx context with a new one.  the length of the
 * data is expected to be length * 9;
 */
int  ctx_set_drawlist       (Ctx *ctx, void *data, int length);

/**
 * ctx_append_drawlist:
 *
 * Appends the commands in a binary drawlist, the length of the data is expected to
 * be length * 9;
 */
int  ctx_append_drawlist    (Ctx *ctx, void *data, int length);

/**
 * ctx_drawlist_clear:
 *
 * Clears the drawlist associated with the context.
 */
void  ctx_drawlist_clear (Ctx *ctx);

/**
 * ctx_drawlist_force_count:
 * @ctx: a ctx context
 * @count: new count to set, must be lower than the current count.
 *
 * Shortens the length of the internal drawlist, dropping the last
 * items.
 */
void ctx_drawlist_force_count (Ctx *ctx, int count);


/**
 * ctx_destroy:
 * @ctx: a ctx context
 */
void ctx_destroy (Ctx *ctx);



/*** h2: drawing api */


/*** h3: frame start/end */

/* most backends, apart from PDF expect to have the separate frames
 * to be shown bracketed by ctx_start_frame() and ctx_end_frame() calls.
 *
 * The combination of the calls are blocking if rendering is congested.
 */

/**
 * ctx_start_frame:
 *
 * Prepare for rendering a new frame, clears internal drawlist and initializes
 * the state.
 *
 * Returns time in seconds since previous start_frame.
 */
float ctx_start_frame    (Ctx *ctx);

/**
 * ctx_end_frame:
 *
 * We're done rendering a frame, this does nothing on a context created for a
 * framebuffer, where drawing commands are immediate.
 */
void ctx_end_frame      (Ctx *ctx);


/* create a new page
 */
void ctx_new_page         (Ctx *ctx);

/**
 * ctx_view_box:
 *
 * Specify the view box for the current page, should immediately follow
 * new_page if present, the PDF backend in particular makes use of this.
 */
void ctx_view_box         (Ctx *ctx,
                           float x0, float y0,
                           float w, float h);


/*** h3: path construction/manipulation */


/**
 * ctx_x:
 * @ctx: a context
 *
 * Returns the current path append x-coordinate.
 */
float ctx_x                    (Ctx *ctx);

/**
 * ctx_y:
 * @ctx: a context
 *
 * Returns the current path append y-coordinate.
 */
float ctx_y                    (Ctx *ctx);

/**
 * ctx_get_current_point:
 * @ctx: a context
 * @x: a pointer to store x coordinate in, or NULL
 * @y: a pointer to store y coordinate in, or NULL
 *
 * Returns the same value as ctx_x() and ctx_y()
 */
void  ctx_current_point        (Ctx *ctx, float *x, float *y);

/**
 * ctx_reset_path:
 * @ctx: a context
 *
 * Clears the current path if any, fill and stroke commands without a preceding preserve do an implicit reset_path.
 */
void ctx_reset_path     (Ctx *ctx);

#define ctx_begin_path(ctx) ctx_reset_path(ctx) // compatibility with old API

/**
 * ctx_move_to:
 * @ctx: a context
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Move the tip of the virtual pen to x,y, starting a new sub-path.
 */
void  ctx_move_to         (Ctx *ctx, float x, float y);

/**
 * ctx_line_to:
 * @ctx: a context
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Add a straight line segment to the current path. moving the
 * thip of the virtual pen to x,y.
 */
void  ctx_line_to         (Ctx *ctx, float x, float y);

/**
 * ctx_curve_to:
 * @ctx: a context
 * @cx0: control point x coordinate
 * @cy0: control point y coordinate
 * @cx1: control point x coordinate
 * @cy1: control point y coordinate
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Adds a quad curve segment to x, y to the current path.
 */
void  ctx_curve_to        (Ctx *ctx,
                           float cx0, float cy0,
                           float cx1, float cy1,
                           float x, float y);
/**
 * ctx_quad_to:
 * @ctx: a context
 * @cx: control point x coordinate
 * @cy: control point y coordinate
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Adds a quad curve segment to x, y to the current path.
 */
void  ctx_quad_to         (Ctx  *ctx,
                           float cx, float cy,
                           float x,  float y);
/**
 * ctx_arc:
 *
 * Add an arc segment for a circle centered at x,y with radius fromg angle1 to angle2 in radians,
 * XXX : look into specification of direction on other APIs
 */
void  ctx_arc             (Ctx  *ctx,
                           float x, float y,
                           float radius,
                           float angle1, float angle2,
                           int   direction);
/**
 * ctx_arc_to:
 * @ctx: a context
 */
void  ctx_arc_to          (Ctx *ctx,
                           float x1, float y1,
                           float x2, float y2,
                           float radius);
/**
 * ctx_rel_arc_to:
 * @ctx: a context
 */
void  ctx_rel_arc_to      (Ctx *ctx,
                           float x1, float y1,
                           float x2, float y2,
                           float radius);


/**
 * ctx_rectangle:
 * @ctx: a context
 * @x0: upper left x coordinate
 * @y0: upper left y coordiante
 * @width: width in user space coordinate
 * @height: height in user space coordinate
 *
 * Add rectangle to the current path.
 */
void  ctx_rectangle       (Ctx *ctx,
                           float x0, float y0,
                           float w, float h);
/**
 * ctx_round_rectangle:
 * @ctx: a context
 * @x0: upper left x coordinate
 * @y0: upper left y coordiante
 * @width: width in user space coordinate
 * @height: height in user space coordinate
 * @radius: rounding radius, if width or height are too small radius is clamped accordingly.
 *
 * Add a rectangle with rounded corners to the current path.
 */
void  ctx_round_rectangle (Ctx *ctx,
                           float x0, float y0,
                           float w, float h,
                           float radius);
/**
 * ctx_rel_line_to:
 * @ctx: a context
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Adds a straight segment to ctx_x()+x, ctx_y()+y to the current path.
 */
void  ctx_rel_line_to     (Ctx *ctx,
                           float x, float y);
/**
 * ctx_rel_move_to:
 * @ctx: a context
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Stop current sub path and move path append point to ctx_x()+x, ctx_y()+y
 */
void  ctx_rel_move_to     (Ctx *ctx,
                           float x, float y);
/**
 * ctx_rel_quad_to:
 * @ctx: a context
 * @cx0: control point x coordinate
 * @cy0: control point y coordinate
 * @cx: control point x coordinate
 * @cy: control point y coordinate
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Adds a cubic curve segment to ctx_x()+x, ctx_y()+y to the current path.
 */
void  ctx_rel_curve_to    (Ctx *ctx,
                           float cx0, float cy0,
                           float cx1, float cy1,
                           float x, float y);
/**
 * ctx_rel_quad_to:
 * @ctx: a context
 * @cx: control point x coordinate
 * @cy: control point y coordinate
 * @x: target x coordinate
 * @y: target y coordinate
 *
 * Adds a quad curve segment to ctx_x()+x, ctx_y()+y to the current path.
 */
void  ctx_rel_quad_to     (Ctx *ctx,
                           float cx, float cy,
                           float x, float y);
/**
 * ctx_close_path:
 * @ctx: a context
 *
 * Closes the currently open sub-path.
 */
void  ctx_close_path      (Ctx *ctx);

/**
 * ctx_in_fill:
 * @ctx: a ctx context
 * @x: x coordinate
 * @y: y coordinate
 *
 * Returns 1 if x, y are inside a fill of the current path with current fill-rule.
 */
int  ctx_in_fill    (Ctx *ctx, float x, float y);

/**
 * ctx_in_stroke:
 * @ctx: a ctx context
 * @x: x coordinate
 * @y: y coordinate
 *
 * Returns 1 if x, y are inside a stroke of the current path with current parameters.
 */
int  ctx_in_stroke  (Ctx *ctx, float x, float y);

typedef struct _CtxDrawlist CtxDrawlist;

/* to be freed with ctx_free
 */
CtxDrawlist * ctx_current_path (Ctx *ctx);

void
ctx_path_extents (Ctx *ctx, float *ex1, float *ey1, float *ex2, float *ey2);

/*** h3: context management  */

/* Attributes like transform, clipping state, fill and stroke sources, font sie,
 * stroking, texture interpolation and dashing are stored in stackable contexts.
 * 
 * This allows building up a hierarchy of transforms, as well as bringing the
 * drawing context back to a known state.
 */

/**
 * ctx_save:
 * @ctx: a context
 *
 * Stores the transform, clipping state, fill and stroke sources, font size,
 * stroking and dashing options.
 */
void ctx_save           (Ctx *ctx);

/**
 * ctx_restore:
 * @ctx: a context
 *
 * Restores the state previously saved with ctx_save, calls to
 * ctx_save/ctx_restore should be balanced.
 */
void ctx_restore        (Ctx *ctx);

/**
 * ctx_start_group:
 * @ctx: a context
 *
 * Start a compositing group.
 *
 */
void ctx_start_group    (Ctx *ctx);

/**
 * ctx_end_group:
 * @ctx: a context
 *
 * End a compositing group, the global alpha, compositing mode and blend mode
 * set before this call is used to apply the group.
 */
void ctx_end_group      (Ctx *ctx);


/**
 * ctx_image_smoothing:
 * @ctx: a context
 * @enabled: 1 for enabled and 0 for disabled
 *
 * Set or unset bilinear / box filtering for textures, turning it off uses the
 * faster nearest neighbor for all cases.
 */
void ctx_image_smoothing  (Ctx *ctx, int enabled);
/**
 * ctx_get_image_smoothing:
 * @ctx: a context
 *
 * Returns the current setting for image_smoothing.
 */
int   ctx_get_image_smoothing  (Ctx *ctx);


/*** h3: drawing commands */


/**
 * ctx_fill:
 * @ctx: a context
 *
 * Fills the current path, and resets it (unless ctx_preserve has been called).
 */
void ctx_fill             (Ctx *ctx);

/**
 * ctx_paint:
 * @ctx: a context
 *
 * Fills the whole canvas with color, is affected by clipping.
 */
void ctx_paint            (Ctx *ctx);

/**
 * ctx_clip:
 * @ctx: a context
 *
 * Use the current path as a clipping mask, subsequent draw calls are limited
 * by the path. The only way to increase the visible area is to first call
 * ctx_save and then later ctx_restore to undo the clip.
 */
void ctx_clip           (Ctx *ctx);

/**
 * ctx_preserve:
 * @ctx: a context
 *
 * Make the following fill or stroke not reset the current path.
 */
void ctx_preserve         (Ctx *ctx);

/**
 * ctx_stroke:
 * @ctx: a context
 *
 * Stroke the current path with current line_width, dashing cap and join options.
 */
void ctx_stroke           (Ctx *ctx);


/*** h4: stroking options */
/**
 * ctx_miter_limit:
 * @ctx: a context.
 * @limit: new miter limit in user coordinates.
 *
 * Specify the miter limit used when stroking.
 */
void ctx_miter_limit      (Ctx *ctx, float limit);

/**
 * ctx_get_miter_limit:
 * @ctx: a context.
 *
 * Returns the current miter limit.
 */
float ctx_get_miter_limit (Ctx *ctx);


#define CTX_LINE_WIDTH_HAIRLINE -1000.0
#define CTX_LINE_WIDTH_ALIASED  -1.0
#define CTX_LINE_WIDTH_FAST     -1.0  /* aliased 1px wide line */

/**
 * ctx_line_width:
 * @ctx: a context.
 * @width: new stroking width in user space coordinates.
 *
 * Set the line width used when stroking.
 */
void ctx_line_width       (Ctx *ctx, float with);

/**
 * ctx_get_line_width:
 * @ctx: a context.
 *
 * Returns the current stroking line-width.
 */
float ctx_get_line_width  (Ctx *ctx);

/**
 * ctx_line_dash_offset:
 * @ctx: a context.
 * @offset: number of user-space units to wait before starting dash pattern.
 *
 * Specify phase offset for line dash pattern.
 */
void ctx_line_dash_offset (Ctx *ctx, float offset);

/**
 * ctx_get_line_dash_offset:
 * @ctx: a context.
 *
 * Returns the current setting for image_smoothing.
 */
float ctx_get_line_dash_offset (Ctx *ctx);

/**
 * ctx_line_dash:
 * @ctx: a context.
 * @dashes: pointer to an array of floats
 * @count: number of items in dash array.
 *
 * Specify the line dash pattern.
 */
void  ctx_line_dash       (Ctx *ctx, const float *dashes, int count);


/*** h3: transforms */

/**
 * ctx_identity:
 * @ctx: a context.
 *
 * Restore context to identity transform, NOTE: a bug makes this call currently
 * breaks mult-threaded rendering when used; since the rendering threads are
 * expecting an initial transform on top of the base identity.
 */
void ctx_identity       (Ctx *ctx);

/**
 * ctx_scale:
 * @ctx: a context.
 * @x: x scale factor
 * @y: y scale factor
 *
 * Scales the user to device transform.
 */
void  ctx_scale         (Ctx *ctx, float x, float y);

/**
 * ctx_translate:
 * @ctx: a context.
 * @x: x translation
 * @y: y translation
 *
 * Adds translation to the user to device transform.
 */
void  ctx_translate     (Ctx *ctx, float x, float y);

/**
 * ctx_rotate:
 * @ctx: a context.
 * @a: angle to rotate in radians.
 *
 * Add rotatation to the user to device space transform.
 */
void ctx_rotate         (Ctx *ctx, float a);

/**
 * ctx_apply_transform:
 * @ctx: a context.
 * @a..i: matrix components.
 *
 * Adds a 3x3 matrix on top of the existing user to device space transform.
 */
void ctx_apply_transform (Ctx *ctx, float a, float b, float c,
                                    float d, float e, float f,
                                    float g, float h, float i);

typedef struct _CtxMatrix     CtxMatrix;
struct _CtxMatrix { float m[3][3]; };

/**
 * @ctx: a context.
 * @matrix: a 3x3 matrix components.
 *
 * Adds a 3x3 matrix on top of the existing user to device space transform.
 */
void ctx_apply_matrix           (Ctx *ctx, CtxMatrix *matrix);
/**
 * ctx_set_transform:
 * @ctx: a context.
 * @a..i: matrix components.
 *
 * Set the user to device transform, * Redundant with identity+apply? XXX
 */
void ctx_set_transform    (Ctx *ctx, float a, float b, float c,
                                     float d, float e, float f,
                                     float g, float h, float i);


/*** h3: filling options */

typedef enum
{
  CTX_FILL_RULE_WINDING = 0,
  CTX_FILL_RULE_EVEN_ODD
} CtxFillRule;

/**
 * ctx_fill_rule:
 * @ctx: a ctx context.
 * @mode: new fill_rule to set, CTX_FULL_RULE_WINDING or CTX_FILL_RULE_EVEN_ODD.
 *
 * Sets the current fill rule.
 */
void        ctx_fill_rule      (Ctx *ctx, CtxFillRule        fill_rule);


/**
 * ctx_get_fill_rule:
 * @ctx: a context.
 *
 * Returns the current fill rule.
 */
CtxFillRule ctx_get_fill_rule  (Ctx *ctx);

typedef enum
{
#if 0
  CTX_COMPOSITE_SOURCE_OVER      = 0,
  CTX_COMPOSITE_COPY             = 32,
  CTX_COMPOSITE_SOURCE_IN        = 64,
  CTX_COMPOSITE_SOURCE_OUT       = 96,
  CTX_COMPOSITE_SOURCE_ATOP      = 128,
  CTX_COMPOSITE_CLEAR            = 160,

  CTX_COMPOSITE_DESTINATION_OVER = 192,
  CTX_COMPOSITE_DESTINATION      = 224,
  CTX_COMPOSITE_DESTINATION_IN   = 256,
  CTX_COMPOSITE_DESTINATION_OUT  = 288,
  CTX_COMPOSITE_DESTINATION_ATOP = 320,
  CTX_COMPOSITE_XOR              = 352,
  CTX_COMPOSITE_ALL              = (32+64+128+256)
#else
  CTX_COMPOSITE_SOURCE_OVER      = 0,
  CTX_COMPOSITE_COPY             ,
  CTX_COMPOSITE_SOURCE_IN        ,
  CTX_COMPOSITE_SOURCE_OUT       ,
  CTX_COMPOSITE_SOURCE_ATOP      ,
  CTX_COMPOSITE_CLEAR            ,

  CTX_COMPOSITE_DESTINATION_OVER ,
  CTX_COMPOSITE_DESTINATION      ,
  CTX_COMPOSITE_DESTINATION_IN   ,
  CTX_COMPOSITE_DESTINATION_OUT  ,
  CTX_COMPOSITE_DESTINATION_ATOP ,
  CTX_COMPOSITE_XOR              ,
#endif
} CtxCompositingMode;
#define CTX_COMPOSITE_LAST CTX_COMPOSITE_XOR

/**
 * ctx_compositing_mode:
 * @ctx: a ctx context.
 * @mode: new compositing mode to set.
 *
 * Sets the current compositing mode
 */
void               ctx_compositing_mode     (Ctx *ctx, CtxCompositingMode mode);
/**
 * ctx_get_compositing_mode:
 * @ctx: a ctx context.
 *
 * Return the current compositing mode
 */
CtxCompositingMode ctx_get_compositing_mode (Ctx *ctx);

typedef enum
{
  CTX_BLEND_NORMAL,
  CTX_BLEND_MULTIPLY,
  CTX_BLEND_SCREEN,
  CTX_BLEND_OVERLAY,
  CTX_BLEND_DARKEN,
  CTX_BLEND_LIGHTEN,
  CTX_BLEND_COLOR_DODGE,
  CTX_BLEND_COLOR_BURN,
  CTX_BLEND_HARD_LIGHT,
  CTX_BLEND_SOFT_LIGHT,
  CTX_BLEND_DIFFERENCE,
  CTX_BLEND_EXCLUSION,
  CTX_BLEND_HUE, 
  CTX_BLEND_SATURATION, 
  CTX_BLEND_COLOR, 
  CTX_BLEND_LUMINOSITY,  // 15
  CTX_BLEND_DIVIDE,
  CTX_BLEND_ADDITION,
  CTX_BLEND_SUBTRACT,    // 18
} CtxBlend;
#define CTX_BLEND_LAST CTX_BLEND_SUBTRACT

/**
 * ctx_blend_mode:
 * @ctx: a ctx context.
 * @mode: new blend mode to set.
 *
 * Sets the current blending mode
 */
void     ctx_blend_mode     (Ctx *ctx, CtxBlend mode);

/**
 * ctx_get_blend_mode:
 * @ctx: a ctx context.
 *
 * Returns the blending mode of the current graphics context.
 */
CtxBlend ctx_get_blend_mode (Ctx *ctx);

/*** h3: paint/stroke sources */

/**
 * ctx_set_pixel_u8:
 * @ctx: a ctx context
 * @x: x coordinate
 * @y: y coordinate
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set a single pixel to the nearest possible the specified r,g,b,a value. Fast
 * for individual few pixels, slow for doing textures.
 */
void
ctx_set_pixel_u8 (Ctx *ctx, uint16_t x, uint16_t y,
                  uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/**
 * ctx_global_alpha:
 * @ctx: a ctx context
 * @global_alpha: a value in the range 0.0f-1.0f
 *
 * Set a global alpha value that the colors, textures and gradients are
 * modulated by.
 */
void  ctx_global_alpha (Ctx *ctx, float global_alpha);
/**
 * ctx_get_global_alpha:
 * @ctx: a ctx context
 *
 * Returns the current global_alpha value.
 */
float ctx_get_global_alpha     (Ctx *ctx);


/**
 * ctx_stroke_source:
 *
 * The next source definition applies to stroking rather than filling, when a stroke source is
 * not explicitly set the value of filling is inherited.
 */
void ctx_stroke_source (Ctx *ctx); // next source definition is for stroking

/**
 * ctx_rgba_stroke:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set the current stroking color to the color specified by parameters.
 */
void ctx_rgba_stroke   (Ctx *ctx, float r, float g, float b, float a);

/**
 * ctx_rgb_stroke:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 *
 * Set the current stroking color to the color specified by parameters.
 */
void ctx_rgb_stroke    (Ctx *ctx, float r, float g, float b);

/**
 * ctx_rgba_u8_stroke:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set the current stroking color to the color specified by parameters.
 */
void ctx_rgba8_stroke  (Ctx *ctx, uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/**
 * ctx_gray_stroke:
 * @gray: value
 *
 * Set a grayscale value, valid value range 0.0-1.0f
 */
void ctx_gray_stroke   (Ctx *ctx, float gray);

/**
 * ctx_drgba_stroke:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set the current stroking color to the color specified by parameters directly
 * in device-space without any color transformation.
 */
void ctx_drgba_stroke  (Ctx *ctx, float r, float g, float b, float a);

/**
 * ctx_cmyka_stroke:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 * @a: alpha component
 *
 * Set the current stroking color to the color specified by parameters.
 */
void ctx_cmyka_stroke  (Ctx *ctx, float c, float m, float y, float k, float a);
/**
 * ctx_cmyk_stroke:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 *
 * Set the current stroking color to the color specified by parameters.
 */
void ctx_cmyk_stroke   (Ctx *ctx, float c, float m, float y, float k);
/**
 * ctx_dcmyka_stroke:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 * @a: alpha component
 *
 * Set the current stroking color to the color specified by parameters directly
 * in device-space without any color transformation.
 */
void ctx_dcmyka_stroke (Ctx *ctx, float c, float m, float y, float k, float a);

/**
 * ctx_dcmyka_stroke:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 *
 * Set the current stroking color to the color specified by parameters directly
 * in device-space without any color transformation.
 */
void ctx_dcmyk_stroke  (Ctx *ctx, float c, float m, float y, float k);

/**
 * ctx_rgba:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set the current fill and text color to the color specified by parameters.
 */

void ctx_rgba  (Ctx *ctx, float r, float g, float b, float a);

/**
 * ctx_rgba:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 *
 * Set the current fill and text color to the color specified by parameters.
 */
void ctx_rgb    (Ctx *ctx, float r, float g, float b);

/**
 * ctx_rgba_u8:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set the current fill and text color to the color specified by parameters.
 */
void ctx_rgba8  (Ctx *ctx, uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/**
 * ctx_rgba_u8:
 * @ctx: a ctx context
 * @gray:  value
 *
 * Set the current fill and text color to the grayscale color specified by parameters.
 */
void ctx_gray   (Ctx *ctx, float gray);

/**
 * ctx_drgba:
 * @ctx: a ctx context
 * @r: red component
 * @g: green component
 * @b: blue component
 * @a: alpha component
 *
 * Set the current fill and text color to the color specified by parameters in
 * device space, without any color transforms.
 */
void ctx_drgba  (Ctx *ctx, float r, float g, float b, float a);

/**
 * ctx_cmyka:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 * @a: alpha component
 *
 * Set the current fill and text color to the grayscale color specified by parameters.
 */
void ctx_cmyka  (Ctx *ctx, float c, float m, float y, float k, float a);

/**
 * ctx_cmyk:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 *
 * Set the current fill and text color to the grayscale color specified by parameters.
 */
void ctx_cmyk   (Ctx *ctx, float c, float m, float y, float k);

/**
 * ctx_dcmyka:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 * @a: alpha component
 *
 * Set the current fill and text color to the color specified by parameters in
 * device space, without any color transforms.
 */
void ctx_dcmyka (Ctx *ctx, float c, float m, float y, float k, float a);

/**
 * ctx_dcmyk:
 * @ctx: a ctx context
 * @c: cyan component
 * @m: magenta component
 * @y: yellow component
 * @k: black component
 *
 * Set the current fill and text color to the color specified by parameters in
 * device space, without any color transforms.
 */
void ctx_dcmyk  (Ctx *ctx, float c, float m, float y, float k);

/* there is also getters for colors, by first setting a color in one format and getting
 * it with another color conversions can be done
 */
void ctx_get_rgba   (Ctx *ctx, float *rgba);
void ctx_get_graya  (Ctx *ctx, float *ya);
void ctx_get_drgba  (Ctx *ctx, float *drgba);
void ctx_get_cmyka  (Ctx *ctx, float *cmyka);
void ctx_get_dcmyka (Ctx *ctx, float *dcmyka);



/**
 * ctx_linear_gradient:
 * Change the source to a linear gradient from x0,y0 to x1 y1, an empty gradient
 * is interpreted as grayscale from black to white, add stops with ctx_gradient_add_stop to specify a custom gradient.
 */
void ctx_linear_gradient (Ctx *ctx, float x0, float y0, float x1, float y1);

/**
 * ctx_radial_gradient:
 * Change the source to a radial gradient from a circle x0,y0 with radius r0 to an outher circle x1, y1 with radius r1. (NOTE: currently ctx is only using the second circles origin, both radiuses are in use.)
 */
void ctx_radial_gradient (Ctx *ctx, float x0, float y0, float r0,
                          float x1, float y1, float r1);

/**
 * ctx_conic_gradient:
 * Change the source to a conic/conic gradient cenetered at cx,cy with gradient starting at angle start_angle.
 */
void ctx_conic_gradient (Ctx *ctx, float cx, float cy, float start_angle, float cycles);


/**
 * ctx_gradient_add_stop_rgba:
 *
 * Add an RGBA gradient stop to the current gradient at position pos.
 *
 */
void ctx_gradient_add_stop_rgba (Ctx *ctx, float pos, float r, float g, float b, float a);
#define ctx_gradient_add_stop ctx_gradient_add_stop_rgba // compat

/**
 * ctx_gradient_add_stop_u8:
 *
 * Add an RGBA gradient stop to the current gradient at position pos.
 */
void ctx_gradient_add_stop_u8 (Ctx *ctx, float pos, uint8_t r, uint8_t g, uint8_t b, uint8_t a);

/* ctx_define_texture:
 */
void ctx_define_texture (Ctx        *ctx,
                         const char *eid,
                         int         width,
                         int         height,
                         int         stride,
                         int         format,
                         void       *data,
                         char       *ret_eid);

/** ctx_drop_eid:
 *
 * Drops the relevant texture eid freeing resources.
 */
void ctx_drop_eid (Ctx *ctx, const char *eid);

/* ctx_source_transform:
 */
void
ctx_source_transform (Ctx *ctx, float a, float b,  float c,
                      float d, float e, float f, 
                      float g, float h, float i); 

/* ctx_source_transform_matrix:
 */
void
ctx_source_transform_matrix (Ctx *ctx, CtxMatrix *matrix);


/*** h3: shadow */

/**
 * ctx_shadow_rgba:
 * sets the color of the shadow-blur, use a < 1.0 for softer blur
 */
void ctx_shadow_rgba      (Ctx *ctx, float r, float g, float b, float a);

/**
 * ctx_shadow_blur:
 * set the shadow_blur radius, which in HTML5 canvas is double the standard
 * deviation of an expected gaussian blur.
 */
void ctx_shadow_blur      (Ctx *ctx, float stddev_x_2);

/**
 * ctx_shadow_offset_x:
 * specify offset of generated shadow blur
 */
void ctx_shadow_offset_x  (Ctx *ctx, float x);

/**
 * ctx_shadow_offset_y:
 * specify offset of generated shadow blur
 */
void ctx_shadow_offset_y  (Ctx *ctx, float y);


/**
 * ctx_width:
 *
 * Returns the width of the ctx canvas in pixels.
 */
int   ctx_width                (Ctx *ctx);

/**
 * ctx_height:
 *
 * Returns the height of the ctx canvas in pixels.
 */
int   ctx_height               (Ctx *ctx);


/**
 * ctx_get_transform:
 *
 * Returns the currently set transform matrix coefficients in a..i.
 */
void  ctx_get_transform        (Ctx *ctx, float *a, float *b,
                                float *c, float *d,
                                float *e, float *f,
                                float *g, float *h,
                                float *i);

/**
 * ctx_clip_extents::
 *
 * Returns the upper-left, x0,y0  and lower-right x1,y1 coordinates for the currently set clip bounding box,
 * useful for getting culling bounds.
 */
void
ctx_clip_extents (Ctx *ctx, float *x0, float *y0,
                            float *x1, float *y1);

/**
 * ctx_get_image_data:
 *
 * Get a copy of pixel values - depending on backend might cause rendering
 * temporary rendering or providing the data directly from an immediate buffer.
 *
 */
void
ctx_get_image_data (Ctx *ctx, int sx, int sy, int sw, int sh,
                    CtxPixelFormat format, int dst_stride,
                    uint8_t *dst_data);

/**
 * ctx_put_image_data:
 *
 * draws a texture at the given coordinates.
 */
void
ctx_put_image_data (Ctx *ctx, int w, int h, int stride, int format,
                    uint8_t *data,
                    int ox, int oy,
                    int dirtyX, int dirtyY,
                    int dirtyWidth, int dirtyHeight);


/**
 * ctx_texture_load:
 *
 * loads an image file from disk into texture, returning pixel width, height
 * and eid, the eid is based on the path; not the contents - avoiding doing
 * sha1 checksum of contents. The width and height of the image is returned
 * along with the used eid, width height or eid can be NULL if we
 * do not care about their values.
 */
void ctx_texture_load (Ctx        *ctx,
                       const char *path,
                       int        *width,
                       int        *height,
                       char       *eid);

/**
 * ctx_texture:
 *
 * sets the paint source to be a texture by eid
 */
void ctx_texture              (Ctx *ctx, const char *eid, float x, float y);

/**
 * ctx_draw_texture:
 *
 * draw a texture at given coordinates with specified with/height.
 */
void ctx_draw_texture         (Ctx *ctx, const char *eid, float x, float y, float w, float h);

void ctx_draw_texture_clipped (Ctx *ctx, const char *eid, float x, float y, float w, float h, float sx, float sy, float swidth, float sheight);

/**
 * ctx_draw_image:
 *
 * Load an possibly cache an image from a png/svg/jpg sufficed file, at x, y with width and height
 */
void ctx_draw_image           (Ctx *ctx, const char *path, float x, float y, float w, float h);

void ctx_draw_image_clipped   (Ctx *ctx, const char *path, float x, float y, float w, float h, float sx, float sy, float swidth, float sheight);

/**
 * ctx_set_texture_source:
 *
 * used by the render threads of fb and sdl backends.
 */
void ctx_set_texture_source (Ctx *ctx, Ctx *texture_source);

/**
 * ctx_set_texture_cache:
 *
 * used when sharing cache state of eids between clients
 */
void ctx_set_texture_cache (Ctx *ctx, Ctx *texture_cache);


/**
 * ctx_pixel_format_bits_per_pixel:
 *
 * Returns bits per pixel for a pixel format.
 */
int ctx_pixel_format_bits_per_pixel (CtxPixelFormat format); // bits per pixel
/**
 * ctx_pixel_format_get_stride:
 *
 * Computes the stride of a scanline in bytes, rounding up to the neatest byte for 1/2/4bits
 */
int ctx_pixel_format_get_stride     (CtxPixelFormat format, int width);

/**
 * ctx_hasher_new:
 *
 * Create a new hashing context, for use with replays from another master context.
 */
Ctx *ctx_hasher_new          (int width, int height, int cols, int rows, CtxDrawlist *drawlist);

/**
 * ctx_hasher_get_hash:
 */
uint32_t ctx_hasher_get_hash (Ctx *ctx, int col, int row);



/*  In progress for implementing rubber spacing or space bands, in one pass layouting.
 */
void ctx_deferred_scale       (Ctx *ctx, const char *name, float x, float y);

/**
 * ctx_deferred_translate:
 */
void ctx_deferred_translate   (Ctx *ctx, const char *name, float x, float y);
/**
 * ctx_deferred_move_to:
 */
void ctx_deferred_move_to     (Ctx *ctx, const char *name, float x, float y);
/**
 * ctx_deferred_rel_line_to:
 */
void ctx_deferred_rel_line_to (Ctx *ctx, const char *name, float x, float y);
/**
 * ctx_deferred_rel_move_to:
 */
void ctx_deferred_rel_move_to (Ctx *ctx, const char *name, float x, float y);
/**
 * ctx_deferred_rectangle:
 */
void ctx_deferred_rectangle   (Ctx *ctx, const char *name, float x, float y,
                                                           float width, float height);

/**
 * ctx_resolve:
 *
 */
void ctx_resolve              (Ctx *ctx, const char *name,
                               void (*set_dim) (Ctx *ctx,
                                                void *userdata,
                                                const char *name,
                                                int         count,
                                                float *x,
                                                float *y,
                                                float *width,
                                                float *height),
                               void *userdata);


/* these are configuration flags for a ctx renderer, not all
 * flags are applicable for all rendereres, the cb backend
 * has the widest support currently.
 */
typedef enum CtxFlags {
  //CTX_FLAG_DEFAULTS    = 0,      // most of these flags apply to cb-backend
  CTX_FLAG_GRAY8         = 1 << 0, // use GRAY8, implies LOWFI
  CTX_FLAG_HASH_CACHE    = 1 << 1, // use a hashcache to determine which parts to redraw, implied by LOWFI
  CTX_FLAG_LOWFI         = 1 << 2, // lower res preview for performance during animations
  CTX_FLAG_SUBPIXEL      = 1 << 3, // re-render with subpixel precision
  CTX_FLAG_DAMAGE_CONTROL = 1 << 4,
  CTX_FLAG_SHOW_FPS      = 1 << 5, // possibly show fps in titlebar or shown in overlay
  CTX_FLAG_KEEP_DATA     = 1 << 6, // keep existing fb-data instead of doing an initial clear
  CTX_FLAG_RENDER_THREAD = 1 << 7,  // do rendering in separate thread
                                     
  CTX_FLAG_POINTER       = 1 << 8,  //  draw software cursor

  CTX_FLAG_HANDLE_ESCAPES = 1 << 9, // applies to parser config
  CTX_FLAG_FORWARD_EVENTS = 1 << 10, // applies to parser config

  CTX_FLAG_SYNC           = 1 << 11, // applies to ctx-backend
  CTX_FLAG_COMPRESS       = 1 << 12, // applies to ctx-backend
  CTX_FLAG_FULL_FB        = 1 << 13, // only valid with a fb pointer passed in,
                                     // swap/render the whole frame when drawlist
                                     // is full, this is slower than hash cache
                                     // unless geometry is simpler, can not be
                                     // combined with CTX_FLAG_HASH_CACHE
} CtxFlags;

typedef struct CtxCbConfig {
   CtxPixelFormat format;
   int            buffer_size;
   void          *buffer;    // scratch buffer should be in sram if possible
   int            flags;

   int            chunk_size; // number of entries in drawlist before flush,
                              // full flush on end-frame

   void          *fb;        // if provided is a backing-fb for rendering
                             // buffer comes on top as a scratch area;
   void          *user_data; // provided to the callback functions
                             //
   void (*set_pixels)     (Ctx *ctx, void *user_data, 
                           int x, int y, int w, int h, void *buf);
   void  *set_pixels_user_data;

   // runs after all subregion updates in renderer thread
   // if CTX_FLAG_RENDER_THREAD then this is run in renderer thread.
   int (*update_fb)       (Ctx *ctx, void *user_data, int x, int y, int w, int h);
   void  *update_fb_user_data;

   // run as an idle call in render thread, between chunks
   int (*intra)       (Ctx *ctx, void *user_data);
   void  *intra_user_data;

   int  (*renderer_init)  (Ctx *ctx, void *user_data); // return non 0 on failure to init
   void  *renderer_init_user_data;
   void (*renderer_idle)  (Ctx *ctx, void *user_data);
   void  *renderer_idle_user_data;

   void (*renderer_stop)  (Ctx *ctx, void *user_data);
   void  *renderer_stop_user_data;

   void (*consume_events) (Ctx *ctx, void *user_data); // runs in the main (not renderer thread)
   void  *consume_events_user_data;

   void (*set_fullscreen)  (Ctx *ctx, void *user_data, int fullscreen);
   void *set_fullscreen_user_data;

   int  (*get_fullscreen)  (Ctx *ctx, void *user_data);
   void *get_fullscreen_user_data;

   void (*windowtitle)     (Ctx *ctx, void *user_data, const char *utf8);
   void *windowtitle_user_data;

   void (*set_clipboard)  (Ctx *ctx, void *user_data, const char *text);
   void *set_clipboard_user_data;

   char *(*get_clipboard) (Ctx *ctx, void *user_data);
   void *get_clipboard_user_data;

   void *padding[10];
} CtxCbConfig;

/**
 * ctx_new_cb:
 */
Ctx *ctx_new_cb (int width, int height, CtxCbConfig *config);

/**
 * ctx_new_cb_old:
 */
Ctx *ctx_new_cb_old (int width, int height, CtxPixelFormat format,
                 void (*set_pixels) (Ctx *ctx, void *user_data, 
                                     int x, int y, int w, int h, void *buf),
                 void *set_pixels_user_data,
                 int (*update_fb) (Ctx *ctx, void *user_data),
                 void *update_fb_user_data,
                 int   memory_budget,
                 void *scratch_fb,
                 int   flags);

/**
 * ctx_cb_set_flags:
 */
void ctx_cb_set_flags (Ctx *ctx, int flags);
/**
 * ctx_cb_get_flags:
 */
int  ctx_cb_get_flags (Ctx *ctx);

/**
 * ctx_cb_set_memory_budget:
 */
void ctx_cb_set_memory_budget (Ctx *ctx, int memory_budget);

/***h3: serialization/formatting API */

typedef enum CtxFormatterFlag{
  CTX_FORMATTER_FLAG_NONE = 0,
  CTX_FORMATTER_FLAG_LONGFORM = (1<<0),
  CTX_FORMATTER_FLAG_FLUSH = (1<<1),
} CtxFormatterFlag;

/**
 * ctx_render_string:
 * @ctx: a ctx context containing a drawing
 * @longform: if 1 use human readable encoding, 0 for compact
 * @retlen: optional location to store length of returned string.
 *
 * returns an allocated string containing serialization of the drawing in ctx,
 * free with ctx_free.
 */
char *ctx_render_string (Ctx *ctx, CtxFormatterFlag flags, int *retlen);

/**
 * ctx_render_stream:
 * @ctx: a ctx context containing a drawing
 * @stream: stream to serialize to
 * @longform: 0 for compact, 1 for human readable
 *
 * Render a ctx context to a stream.
 */
void ctx_render_stream  (Ctx *ctx, FILE *stream, CtxFormatterFlag flags);

/**
 * ctx_render_fd:
 * @ctx: a ctx context containing a drawing
 * @fd: an open file descriptor to write to
 * @longform: 0 for compact, 1 for human readable
 *
 * Render a ctx context to an open file.
 */
void ctx_render_fd      (Ctx *ctx, int fd, CtxFormatterFlag flag);

/**
 * ctx_render_ctx:
 * @ctx: a source context containing a drawing
 * @d_ctx: destination context.
 *
 * Render one context onto another.
 */
void ctx_render_ctx     (Ctx *ctx, Ctx *d_ctx);

/**
 * ctx_render_ctx_textures:
 * @ctx: a source context containing a drawing
 * @d_ctx: destination context.
 *
 * Render one context onto another, without doing any drawing - but using all used textures.
 */
void ctx_render_ctx_textures (Ctx *ctx, Ctx *d_ctx);

typedef enum
{
  CTX_JOIN_BEVEL = 0,
  CTX_JOIN_ROUND = 1,
  CTX_JOIN_MITER = 2
} CtxLineJoin;
void ctx_line_join  (Ctx *ctx, CtxLineJoin        join);
CtxLineJoin          ctx_get_line_join        (Ctx *ctx);

typedef enum
{
  CTX_CAP_NONE   = 0,
  CTX_CAP_ROUND  = 1,
  CTX_CAP_SQUARE = 2
} CtxLineCap;
void       ctx_line_cap     (Ctx *ctx, CtxLineCap         cap);
CtxLineCap ctx_get_line_cap (Ctx *ctx);

typedef enum
{
  CTX_EXTEND_NONE    = 0,
  CTX_EXTEND_REPEAT  = 1,
  CTX_EXTEND_REFLECT = 2,
  CTX_EXTEND_PAD     = 3
} CtxExtend;
#define CTX_EXTEND_LAST CTX_EXTEND_PAD
void      ctx_extend     (Ctx *ctx, CtxExtend extend);
CtxExtend ctx_get_extend (Ctx *ctx);

void ctx_gradient_add_stop_string (Ctx *ctx, float pos, const char *color);


/*** h3: text */

/**
 * ctx_font_size:
 */
void  ctx_font_size       (Ctx *ctx, float x);

/**
 * ctx_get_font_size:
 *
 * Returns the current font_size.
 */
float ctx_get_font_size        (Ctx *ctx);

/**
 * ctx_font_family:
 */
void  ctx_font_family     (Ctx *ctx, const char *font_family);

/**
 * ctx_font:
 */
void  ctx_font            (Ctx *ctx, const char *font);

/**
 * ctx_get_font:
 *
 * Returns the currently set font.
 */
const char *ctx_get_font       (Ctx *ctx);

int
ctx_font_extents (Ctx   *ctx,
                  float *ascent,
                  float *descent,
                  float *line_gap);


/**
 * ctx_wrap_left:
 *
 * Specify left edge of text column for word-wrapping, default value is 0.0f for
 * none.
 */
void ctx_wrap_left   (Ctx *ctx, float x);
float ctx_get_wrap_left        (Ctx *ctx);

/**
 * ctx_wrap_right:
 *
 * Specify right edge of text column for word-wrapping, default value is 0.0f for
 * none.
 */
void ctx_wrap_right  (Ctx *ctx, float x);
float ctx_get_wrap_right       (Ctx *ctx);

/**
 * ctx_line_height:
 *
 * Specify right edge of text column for word-wrapping, default value is 0.0f for
 * none.
 */
void ctx_line_height (Ctx *ctx, float y);
float ctx_get_line_height      (Ctx *ctx);



typedef enum
{
  CTX_TEXT_ALIGN_START = 0,  // in mrg these didnt exist
  CTX_TEXT_ALIGN_END,        // but left/right did
  CTX_TEXT_ALIGN_JUSTIFY, // not handled in ctx
  CTX_TEXT_ALIGN_CENTER,
  CTX_TEXT_ALIGN_LEFT,
  CTX_TEXT_ALIGN_RIGHT
} CtxTextAlign;
void         ctx_text_align     (Ctx *ctx, CtxTextAlign align);
CtxTextAlign ctx_get_text_align (Ctx *ctx);

typedef enum
{
  CTX_TEXT_BASELINE_ALPHABETIC = 0,
  CTX_TEXT_BASELINE_TOP,
  CTX_TEXT_BASELINE_HANGING,
  CTX_TEXT_BASELINE_MIDDLE,
  CTX_TEXT_BASELINE_IDEOGRAPHIC,
  CTX_TEXT_BASELINE_BOTTOM
} CtxTextBaseline;
void            ctx_text_baseline     (Ctx *ctx, CtxTextBaseline    baseline);
CtxTextBaseline ctx_get_text_baseline (Ctx *ctx);


typedef enum
{
  CTX_TEXT_DIRECTION_INHERIT = 0,
  CTX_TEXT_DIRECTION_LTR,
  CTX_TEXT_DIRECTION_RTL
} CtxTextDirection;
void               ctx_text_direction       (Ctx *ctx, CtxTextDirection   direction);
CtxTextDirection   ctx_get_text_direction   (Ctx *ctx);

/**
 * ctx_text:
 *
 * Draw the UTF8 string at current position, wrapping if ctx_wrap_left and ctx_wrap_right have been set.
 */
void  ctx_text          (Ctx        *ctx,
                         const char *utf8);

/**
 * ctx_text_width:
 *
 * returns the total horizontal advance if string had been rendered
 */
float ctx_text_width    (Ctx        *ctx,
                         const char *utf8);


/**
 * ctx_get_font_name:
 *
 * Get the name a font is registered under, substrings are often sufficient for
 * specifying, iterating up from 0 until NULL is retrieved is the current way
 * to enumerate registered fonts.
 */
const char *ctx_get_font_name (Ctx *ctx, int no);

int   ctx_load_font_file     (Ctx *ctx, const char *name, const char *path);
int   ctx_load_font          (Ctx *ctx, const char *name, const char *data, unsigned int length);

float ctx_glyph_width   (Ctx *ctx, int glyph_id);

/*
 * low level glyph drawing calls, unless you are integrating harfbuzz
 * you probably want to use ctx_text instead.
 */
typedef struct _CtxGlyph CtxGlyph;
struct
_CtxGlyph
{
  uint32_t index; // glyph index in font
  float    x;
  float    y;
};

/**
 * ctx_glyph_allocate:
 */
CtxGlyph *ctx_glyph_allocate     (int n_glyphs);

/**
 * ctx_glyph_free:
 */
void      ctx_glyph_free         (Ctx *ctx, CtxGlyph *glyphs);

/**
 * ctx_glyph_id:
 */
int       ctx_glyph_id           (Ctx *ctx, uint32_t glyphid, int stroke);

int       ctx_glyph_unichar      (Ctx *ctx, uint32_t unichar, int stroke);

void      ctx_glyphs             (Ctx      *ctx,
                                  CtxGlyph *glyphs,
                                  int       n_glyphs);

int       ctx_glyph_lookup       (Ctx *ctx, uint32_t unichar);

/**
 */
void  ctx_glyphs_stroke  (Ctx        *ctx,
                          CtxGlyph   *glyphs,
                          int         n_glyphs);


/**
 * ctx_dirty_rect:
 *
 * Query the dirtied bounding box of drawing commands thus far.
 */
void  ctx_dirty_rect (Ctx *ctx, int *x, int *y, int *width, int *height);


#ifdef CTX_X86_64
int ctx_x86_64_level (void);
#endif


enum _CtxModifierState
{
  CTX_MODIFIER_STATE_SHIFT   = (1<<0),
  CTX_MODIFIER_STATE_CONTROL = (1<<1),
  CTX_MODIFIER_STATE_ALT     = (1<<2),
  CTX_MODIFIER_STATE_BUTTON1 = (1<<3),
  CTX_MODIFIER_STATE_BUTTON2 = (1<<4),
  CTX_MODIFIER_STATE_BUTTON3 = (1<<5),
  CTX_MODIFIER_STATE_DRAG    = (1<<6), // pointer button is down (0 or any)
};
typedef enum _CtxModifierState CtxModifierState;

enum _CtxScrollDirection
{
  CTX_SCROLL_DIRECTION_UP,
  CTX_SCROLL_DIRECTION_DOWN,
  CTX_SCROLL_DIRECTION_LEFT,
  CTX_SCROLL_DIRECTION_RIGHT
};
typedef enum _CtxScrollDirection CtxScrollDirection;

typedef struct _CtxEvent CtxEvent;

/**
 * ctx_handle_events:
 *
 * Calls the backends consume events, to consume events until none pending, this also
 * deals with client events.
 */
void ctx_handle_events (Ctx *ctx);

/**
 * ctx_need_redraw:
 *
 * Returns non 0 if the ctx context needs a redraw, as queued by ctx_queue_draw since the last
 * end_frame.
 *
 */
int ctx_need_redraw (Ctx *ctx);

/**
 * ctx_queue_draw:
 *
 * Mark the current ctx output as dirty and in need of recomputation.
 */
void ctx_queue_draw (Ctx *ctx);

/**
 * ctx_exit:
 * @ctx: a context
 *
 * Set a flag on the context indicating that execution is finished.
 */
void ctx_exit (Ctx *ctx);
/**
 * ctx_has_exited:
 * @ctx: a context
 *
 * returns 1 if ctx_exit() has been called
 */
int  ctx_has_exited (Ctx *ctx);

/**
 * ctx_reset_has_exited:
 * @ctx: a context
 *
 * Reset the has_exited flag of context.
 */
void ctx_reset_has_exited (Ctx *ctx);

/**
 * ctx_ticks:
 *
 * Returns number of microseconds since startup.
 */
unsigned long ctx_ticks (void);

/**
 * ctx_ms:
 * @ctx: a context
 *
 * Returns number of milliseconds since startup.
 */
uint32_t ctx_ms         (Ctx *ctx);

/**
 * ctx_strhash:
 * @string: a string
 *
 * Returns an integer that is a hash/compaction of string
 */
uint32_t    ctx_strhash    (const char *string);

/**
 * ctx_str_decode:
 * @number: an integer, previously encoded with ctx_strhash
 *
 * Returns a constant string decoding the number, if it is reversible -
 * this is mostly possible with strings <5 or 6 chars.
 */
const char *ctx_str_decode (uint32_t number);

/**
 * ctx_set_float:
 * @ctx: a context
 * @hash: a key - as created with ctx_strhash
 * @value: a value
 *
 * Set a key/value mapping maintained in the graphics context to value, the values
 * are maintained by ctx_save.
 */
void        ctx_set_float  (Ctx *ctx, uint32_t hash, float value);

/**
 * ctx_get_float:
 * @ctx: a context
 * @hash: a key - as created with ctx_strhash
 *
 * Get a key/value mapping maintained in the graphics context to value as previously
 * set by ctx_set_float, if not set returns 0.0f.
 */
float       ctx_get_float  (Ctx *ctx, uint32_t hash);

/**
 * ctx_is_set:
 * @ctx: a context
 * @hash: a key - as created with ctx_strhash
 *
 * Check if a value has been set at all (when 0.0f needs to be explicitly detected).
 */
int         ctx_is_set     (Ctx *ctx, uint32_t hash);

/**
 * ctx_set_clipboard:
 * @ctx: a context
 * @text: new clipboard text.
 *
 * Set clipboard text, this is the copy action in copy+paste.
 */
void ctx_set_clipboard (Ctx *ctx, const char *text);

/**
 * ctx_get_clipboard:
 * @ctx: a context
 *
 * Get clipboard contents or NULL if a result the result should be freed with ctx_free.
 */
char *ctx_get_clipboard (Ctx *ctx);

/**
 * ctx_windowtitle:
 *
 * Set window title.
 */
void ctx_windowtitle (Ctx *ctx, const char *text);

void _ctx_events_init     (Ctx *ctx);
typedef struct _CtxIntRectangle CtxIntRectangle;
struct _CtxIntRectangle {
  int x;
  int y;
  int width;
  int height;
};
typedef struct _CtxFloatRectangle CtxFloatRectangle;
struct _CtxFloatRectangle {
  float x;
  float y;
  float width;
  float height;
};


typedef void (*CtxCb) (CtxEvent *event,
                       void     *data,
                       void     *data2);

enum _CtxEventType {
  CTX_PRESS        = 1 << 0,
  CTX_MOTION       = 1 << 1,
  CTX_RELEASE      = 1 << 2,
  CTX_ENTER        = 1 << 3,
  CTX_LEAVE        = 1 << 4,
  CTX_TAP          = 1 << 5,
  CTX_TAP_AND_HOLD = 1 << 6,

  /* NYI: SWIPE, ZOOM ROT_ZOOM, */

  CTX_DRAG_PRESS   = 1 << 7,
  CTX_DRAG_MOTION  = 1 << 8,
  CTX_DRAG_RELEASE = 1 << 9,
  CTX_KEY_PRESS    = 1 << 10,
  CTX_KEY_DOWN     = 1 << 11,
  CTX_KEY_UP       = 1 << 12,
  CTX_SCROLL       = 1 << 13,
  CTX_MESSAGE      = 1 << 14,
  CTX_DROP         = 1 << 15,

  CTX_SET_CURSOR   = 1 << 16, // used internally

  /* client should store state - preparing
                                 * for restart
                                 */
  CTX_POINTER  = (CTX_PRESS | CTX_MOTION | CTX_RELEASE | CTX_DROP),
  CTX_TAPS     = (CTX_TAP | CTX_TAP_AND_HOLD),
  CTX_CROSSING = (CTX_ENTER | CTX_LEAVE),
  CTX_DRAG     = (CTX_DRAG_PRESS | CTX_DRAG_MOTION | CTX_DRAG_RELEASE),
  CTX_KEY      = (CTX_KEY_DOWN | CTX_KEY_UP | CTX_KEY_PRESS),
  CTX_MISC     = (CTX_MESSAGE),
  CTX_ANY      = (CTX_POINTER | CTX_DRAG | CTX_CROSSING | CTX_KEY | CTX_MISC | CTX_TAPS),
};
typedef enum _CtxEventType CtxEventType;

#define CTX_CLICK   CTX_PRESS   // SHOULD HAVE MORE LOGIC
typedef struct _CtxClient CtxClient;

struct _CtxEvent {
  CtxEventType  type;
  uint32_t time;
  Ctx     *ctx;
  int stop_propagate; /* when set - propagation is stopped */

  CtxModifierState state;

  int     device_no; /* 0 = left mouse button / virtual focus */
                     /* 1 = middle mouse button */
                     /* 2 = right mouse button */
                     /* 4 = first multi-touch .. (NYI) */

  float   device_x; /* untransformed (device) coordinates  */
  float   device_y;

  /* coordinates; and deltas for motion/drag events in user-coordinates: */
  float   x;
  float   y;
  float   start_x; /* start-coordinates (press) event for drag, */
  float   start_y; /*    untransformed coordinates */
  float   prev_x;  /* previous events coordinates */
  float   prev_y;
  float   delta_x; /* x - prev_x, redundant - but often useful */
  float   delta_y; /* y - prev_y, redundant - ..  */


  unsigned int unicode; /* only valid for key-events, re-use as keycode? */
  const char *string;   /* as key can be "up" "down" "space" "backspace" "a" "b" "ø" etc .. */
                        /* this is also where the message is delivered for
                         * MESSAGE events
                         *
                         * and the data for drop events are delivered
                         *
                         */
                         /* XXX lifetime of this string should be longer
                         * than the events, preferably interned. XXX
                         * maybe add a flag for this?
                         */
  int owns_string; /* if 1 call free.. */
  CtxScrollDirection scroll_direction;

  // would be nice to add the bounding box of the hit-area causing
  // the event, making for instance scissored enter/leave repaint easier.
};

// layer-event "layer"  motion x y device_no 


/**
 * ctx_add_timeout_full:
 * @ctx: a context
 * @ms: milliseconds to elapse before calling 
 * @idle_cb: callback function to call
 * @idle_data: data for callback
 * @destroy_notify: function to call to destroy something when timeout is over
 * @destroy_data: data passed to destroy_notify
 *
 * add an idle callback, which is a function taking a ctx context and a the
 * provided idle_data, returning 1 if the callback should continue being
 * registered and called again after a new delay and 0 if it should be removed.
 *
 * Returns an integer handle that can be used with ctx_remove_idle.
 */
int   ctx_add_timeout_full   (Ctx *ctx, int ms, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data,
                              void (*destroy_notify)(void *destroy_data), void *destroy_data);
/**
 * ctx_add_timeout:
 * @ctx: a context
 * @ms: milliseconds to elapse before calling 
 * @idle_cb: callback function to call
 * @idle_data: data for callback
 *
 * add an idle callback, which is a function taking a ctx context and a the
 * provided idle_data, returning 1 if the callback should continue being
 * registered and called again after a new delay and 0 if it should be removed.
 *
 * Returns an integer handle that can be used with ctx_remove_idle.
 */
int   ctx_add_timeout        (Ctx *ctx, int ms, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data);

/**
 * ctx_add_idle_full:
 * @ctx: a context
 * @idle_cb: callback function to call
 * @idle_data: data for callback
 * @destroy_notify: function to call to destroy something when timeout is over
 * @destroy_data: data passed to destroy_notify
 *
 * add an idle callback, which is a function taking a ctx context and a the provided idle_data, returning
 * 1 if the callback should continue being registered and 0 if it should be removed.
 *
 * Returns an integer handle that can be used with ctx_remove_idle.
 */
int   ctx_add_idle_full      (Ctx *ctx, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data,
                              void (*destroy_notify)(void *destroy_data), void *destroy_data);
/**
 * ctx_add_idle:
 * @ctx: a context
 * @idle_cb: callback function to call
 * @idle_data: data for callback
 *
 * add an idle callback, which is a function taking a ctx context and a the provided idle_data, returning
 * 1 if the callback should continue being registered and 0 if it should be removed.
 *
 * Returns an integer handle that can be used with ctx_remove_idle.
 */
int   ctx_add_idle           (Ctx *ctx, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data);

/**
 * ctx_remove_idle:
 * @ctx: a context
 * @handle: a handle referencing a timeout or idle.
 *
 * Remove a previously registered idle callback / timeout.
 */
void  ctx_remove_idle        (Ctx *ctx, int handle);


typedef void (*CtxDestroyNotify) (void *data);

/**
 * ctx_add_key_binding_full:
 * @ctx: a context
 * @key: a string describing the keybinding like "a" "space" "shift-f3"
 * @action: a string action to take, is passed to cb as data2
 * @label: title to use in ui
 * @cb: callback function to call
 * @cb_data: data for callback
 * @destroy_notify: function to call to destroy something when timeout is over
 * @destroy_data: data passed to destroy_notify
 *
 * Register a key binding, with a finalizer.
 */
void ctx_add_key_binding_full (Ctx *ctx,
                               const char *key,
                               const char *action,
                               const char *label,
                               CtxCb       cb,
                               void       *cb_data,
                               CtxDestroyNotify destroy_notify,
                               void       *destroy_data);

/**
 * ctx_add_key_binding:
 * @ctx: a context
 * @key: a string describing the keybinding like "a" "space" "shift-f3"
 * @action: a string action to take, is passed to cb as data2
 * @label: title to use in ui
 * @cb: callback function to call
 * @cb_data: data for callback
 *
 * Register a key binding, with a finalizer.
 */
void ctx_add_key_binding (Ctx *ctx,
                          const char *key,
                          const char *action,
                          const char *label,
                          CtxCb cb,
                          void  *cb_data);





void ctx_add_hit_region (Ctx *ctx, const char *id);

/**
 * ctx_listen_full:
 * @ctx: a context
 * @x: bounding box x coordinate
 * @y: bounding box y coordinate
 * @width: bounding box width
 * @height: bounding box height
 * @types:
 * @cb: callback function to call
 * @cb_data1: data for callback
 * @cb_data2: second data for callback
 * @finalize: function to call to destroy something when timeout is over
 * @finalize_data: data passed to destroy_notify
 *
 * Register a pointer event with a finalizer.
 */
void ctx_listen_full (Ctx     *ctx,
                      float    x,
                      float    y,
                      float    width,
                      float    height,
                      CtxEventType  types,
                      CtxCb    cb,
                      void    *data1,
                      void    *data2,
                      void   (*finalize)(void *listen_data, void *listen_data2,
                                         void *finalize_data),
                      void    *finalize_data);
void  ctx_event_stop_propagate (CtxEvent *event);


/**
 * ctx_listen:
 * @ctx: a context
 * @types:
 * @cb: callback function to call
 * @cb_data1: data for callback
 * @cb_data2: second data for callback
 * @finalize: function to call to destroy something when timeout is over
 * @finalize_data: data passed to destroy_notify
 *
 * Register a pointer event handler, using the extent of the current path
 * as bounding box.
 */
void  ctx_listen               (Ctx          *ctx,
                                CtxEventType  types,
                                CtxCb         cb,
                                void*         data1,
                                void*         data2);
/**
 * ctx_listen_with_finalize:
 * @ctx: a context
 * @types:
 * @cb: callback function to call
 * @cb_data1: data for callback
 * @cb_data2: second data for callback
 * @finalize: function to call to destroy something when timeout is over
 * @finalize_data: data passed to destroy_notify
 *
 * Register a pointer event with a finalizer, using the extent of the current path
 * as bounding box.
 */
void  ctx_listen_with_finalize (Ctx          *ctx,
                                CtxEventType  types,
                                CtxCb         cb,
                                void*         data1,
                                void*         data2,
                      void   (*finalize)(void *listen_data, void *listen_data2,
                                         void *finalize_data),
                      void    *finalize_data);

CtxEvent *ctx_get_event (Ctx *ctx);
void      ctx_get_event_fds (Ctx *ctx, int *fd, int *count);


int   ctx_pointer_is_down (Ctx *ctx, int no);
float ctx_pointer_x (Ctx *ctx);
float ctx_pointer_y (Ctx *ctx);
void  ctx_freeze (Ctx *ctx);
void  ctx_thaw   (Ctx *ctx);
int   ctx_events_frozen (Ctx *ctx);
void  ctx_events_clear_items (Ctx *ctx);
/* The following functions drive the event delivery, registered callbacks
 * are called in response to these being called.
 */

int ctx_key_down  (Ctx *ctx, unsigned int keyval,
                   const char *string, uint32_t time);
int ctx_key_up    (Ctx *ctx, unsigned int keyval,
                   const char *string, uint32_t time);
int ctx_key_press (Ctx *ctx, unsigned int keyval,
                   const char *string, uint32_t time);
int ctx_scrolled  (Ctx *ctx, float x, float y, CtxScrollDirection scroll_direction, uint32_t time);
void ctx_incoming_message (Ctx *ctx, const char *message, long time);
int ctx_pointer_motion    (Ctx *ctx, float x, float y, int device_no, uint32_t time);
int ctx_pointer_release   (Ctx *ctx, float x, float y, int device_no, uint32_t time);
int ctx_pointer_press     (Ctx *ctx, float x, float y, int device_no, uint32_t time);
int ctx_pointer_drop      (Ctx *ctx, float x, float y, int device_no, uint32_t time,
                           char *string);





typedef enum CtxBackendType {
  CTX_BACKEND_NONE,
  CTX_BACKEND_CTX,
  CTX_BACKEND_RASTERIZER,
  CTX_BACKEND_HASHER,
  CTX_BACKEND_TERM,
  CTX_BACKEND_DRAWLIST,
  CTX_BACKEND_PDF,
  CTX_BACKEND_CB,
} CtxBackendType;

CtxBackendType ctx_backend_type (Ctx *ctx);

typedef struct _CtxBuffer CtxBuffer;
CtxBuffer *ctx_buffer_new_for_data (void *data, int width, int height,
                                    int stride,
                                    CtxPixelFormat pixel_format,
                                    void (*freefunc) (void *pixels, void *user_data),
                                    void *user_data);

int   ctx_client_resize        (Ctx *ctx, int id, int width, int height);
void  ctx_client_set_font_size (Ctx *ctx, int id, float font_size);
float ctx_client_get_font_size (Ctx *ctx, int id);
void  ctx_client_maximize      (Ctx *ctx, int id);
void ctx_client_focus          (Ctx *ctx, int id);

typedef struct _VT VT;
void vt_feed_keystring    (VT *vt, CtxEvent *event, const char *str);
void vt_paste             (VT *vt, const char *str);
char *vt_get_selection    (VT *vt);
long vt_rev               (VT *vt);
void vt_set_line_spacing (VT *vt, float line_spacing);
void vt_set_baseline     (VT *vt, float baseline);
int  vt_has_blink         (VT *vt);
int ctx_vt_had_alt_screen (VT *vt);
int  vt_get_cursor_x      (VT *vt);
int  vt_get_cursor_y      (VT *vt);
void vt_draw (VT *vt, Ctx *ctx, double x0, double y0, int has_focus);

void vt_set_palette(int color_no, uint8_t red, uint8_t green, uint8_t blue);

typedef struct _CtxList CtxList;
CtxList *ctx_clients (Ctx *ctx);

void ctx_set_fullscreen (Ctx *ctx, int val);
int ctx_get_fullscreen (Ctx *ctx);


typedef enum CtxClientFlags {
  CTX_CLIENT_UI_RESIZABLE = 1<<0,
  CTX_CLIENT_CAN_LAUNCH   = 1<<1,
  CTX_CLIENT_MAXIMIZED    = 1<<2,
  CTX_CLIENT_ICONIFIED    = 1<<3,
  CTX_CLIENT_SHADED       = 1<<4,
  CTX_CLIENT_TITLEBAR     = 1<<5,
  CTX_CLIENT_LAYER2       = 1<<6,  // used for having a second set
                                   // to draw - useful for splitting
                                   // scrolled and HUD items
                                   // with HUD being LAYER2
                                  
  CTX_CLIENT_KEEP_ALIVE   = 1<<7,  // do not automatically
  CTX_CLIENT_FINISHED     = 1<<8,  // do not automatically
                                   // remove after process quits
  CTX_CLIENT_PRELOAD      = 1<<9,
  CTX_CLIENT_LIVE         = 1<<10
} CtxClientFlags;
typedef void (*CtxClientFinalize)(CtxClient *client, void *user_data);

int ctx_client_id (CtxClient *client);
int ctx_client_flags (CtxClient *client);
VT *ctx_client_vt (CtxClient *client);
void ctx_client_add_event (CtxClient *client, CtxEvent *event);
const char *ctx_client_title (CtxClient *client);
CtxClient *ctx_client_find (Ctx *ctx, const char *label);

void *ctx_client_userdata (CtxClient *client);

void ctx_client_quit (CtxClient *client);
CtxClient *vt_get_client (VT *vt);
CtxClient *ctx_client_new (Ctx *ctx,
                           const char *commandline,
                           int x, int y, int width, int height,
                           float font_size,
                           CtxClientFlags flags,
                           void *user_data,
                           CtxClientFinalize client_finalize);

CtxClient *ctx_client_new_argv (Ctx *ctx, char **argv, int x, int y, int width, int height, float font_size, CtxClientFlags flags, void *user_data,
                CtxClientFinalize client_finalize);
int ctx_clients_need_redraw (Ctx *ctx);

CtxClient *ctx_client_new_thread (Ctx *ctx, void (*start_routine)(Ctx *ctx, void *user_data),
                                  int x, int y, int width, int height, float font_size, CtxClientFlags flags, void *user_data, CtxClientFinalize finalize);

extern float ctx_shape_cache_rate;
extern int _ctx_max_threads;

CtxEvent *ctx_event_copy (CtxEvent *event);

void  ctx_client_move           (Ctx *ctx, int id, int x, int y);
void  ctx_client_shade_toggle   (Ctx *ctx, int id);
float ctx_client_min_y_pos      (Ctx *ctx);
float ctx_client_max_y_pos      (Ctx *ctx);
void  ctx_client_paste          (Ctx *ctx, int id, const char *str);
char  *ctx_client_get_selection (Ctx *ctx, int id);

void  ctx_client_rev_inc      (CtxClient *client);
long  ctx_client_rev          (CtxClient *client);

int   ctx_clients_active      (Ctx *ctx);

CtxClient *ctx_client_by_id (Ctx *ctx, int id);

int ctx_clients_draw            (Ctx *ctx, int layer2);

void ctx_client_feed_keystring  (CtxClient *client, CtxEvent *event, const char *str);
// need not be public?
void ctx_client_register_events (CtxClient *client, Ctx *ctx, double x0, double y0);

void ctx_client_remove          (Ctx *ctx, CtxClient *client);

int  ctx_client_height           (Ctx *ctx, int id);
int  ctx_client_width            (Ctx *ctx, int id);
int  ctx_client_x                (Ctx *ctx, int id);
int  ctx_client_y                (Ctx *ctx, int id);
void ctx_client_raise_top        (Ctx *ctx, int id);
void ctx_client_raise_almost_top (Ctx *ctx, int id);
void ctx_client_lower_bottom     (Ctx *ctx, int id);
void ctx_client_lower_almost_bottom (Ctx *ctx, int id);
void ctx_client_iconify          (Ctx *ctx, int id);
int  ctx_client_is_iconified     (Ctx *ctx, int id);
void ctx_client_uniconify        (Ctx *ctx, int id);
void ctx_client_maximize         (Ctx *ctx, int id);
int  ctx_client_is_maximized     (Ctx *ctx, int id);
void ctx_client_unmaximize       (Ctx *ctx, int id);
void ctx_client_maximized_toggle (Ctx *ctx, int id);
void ctx_client_shade            (Ctx *ctx, int id);
int  ctx_client_is_shaded        (Ctx *ctx, int id);
void ctx_client_unshade          (Ctx *ctx, int id);
void ctx_client_toggle_maximized (Ctx *ctx, int id);
void ctx_client_shade_toggle     (Ctx *ctx, int id);
void ctx_client_move             (Ctx *ctx, int id, int x, int y);
int  ctx_client_resize           (Ctx *ctx, int id, int width, int height);
void ctx_client_set_opacity      (Ctx *ctx, int id, float opacity);
float ctx_client_get_opacity     (Ctx *ctx, int id);
void ctx_client_set_title        (Ctx *ctx, int id, const char *title);
const char *ctx_client_get_title (Ctx *ctx, int id);




typedef enum
{
  CTX_GRAY           = 1,
  CTX_RGB            = 3,
  CTX_DRGB           = 4,
  CTX_CMYK           = 5,
  CTX_DCMYK          = 6,
  CTX_LAB            = 7,
  CTX_LCH            = 8,
  CTX_GRAYA          = 101,
  CTX_RGBA           = 103,
  CTX_DRGBA          = 104,
  CTX_CMYKA          = 105,
  CTX_DCMYKA         = 106,
  CTX_LABA           = 107,
  CTX_LCHA           = 108,
  CTX_GRAYA_A        = 201,
  CTX_RGBA_A         = 203,
  CTX_RGBA_A_DEVICE  = 204,
  CTX_CMYKA_A        = 205,
  CTX_DCMYKA_A       = 206,
  // RGB  device and  RGB  ?
} CtxColorModel;


enum _CtxColorSpace
{
  CTX_COLOR_SPACE_DEVICE_RGB,
  CTX_COLOR_SPACE_DEVICE_CMYK,
  CTX_COLOR_SPACE_USER_RGB,
  CTX_COLOR_SPACE_USER_CMYK,
  CTX_COLOR_SPACE_TEXTURE
};
typedef enum _CtxColorSpace CtxColorSpace;

#define CTX_COLOR_SPACE_LAST CTX_COLOR_SPACE_TEXTURE

/* sets the color space for a slot, the space is either a string of
 * "sRGB" "rec2020" .. etc or an icc profile.
 *
 * The slots device_rgb and device_cmyk is mostly to be handled outside drawing 
 * code, and user_rgb and user_cmyk is to be used. With no user_cmyk set
 * user_cmyk == device_cmyk.
 *
 * The set profiles follows the graphics state.
 */
void ctx_colorspace (Ctx                 *ctx,
                     CtxColorSpace        space_slot,
                     const unsigned char *data,
                     int                  data_length);


enum _CtxCursor
{
  CTX_CURSOR_UNSET,
  CTX_CURSOR_NONE,
  CTX_CURSOR_ARROW,
  CTX_CURSOR_IBEAM,
  CTX_CURSOR_WAIT,
  CTX_CURSOR_HAND,
  CTX_CURSOR_CROSSHAIR,
  CTX_CURSOR_RESIZE_ALL,
  CTX_CURSOR_RESIZE_N,
  CTX_CURSOR_RESIZE_S,
  CTX_CURSOR_RESIZE_E,
  CTX_CURSOR_RESIZE_NE,
  CTX_CURSOR_RESIZE_SE,
  CTX_CURSOR_RESIZE_W,
  CTX_CURSOR_RESIZE_NW,
  CTX_CURSOR_RESIZE_SW,
  CTX_CURSOR_MOVE
};
typedef enum _CtxCursor CtxCursor;

/* to be used immediately after a ctx_listen or ctx_listen_full causing the
 * cursor to change when hovering the listen area.
 */
void ctx_listen_set_cursor (Ctx      *ctx,
                            CtxCursor cursor);


/* lower level cursor setting that is independent of ctx event handling
 */
void      ctx_set_cursor           (Ctx *ctx, CtxCursor cursor);
CtxCursor ctx_get_cursor           (Ctx *ctx);


/* draw the ctx logo */
void ctx_logo (Ctx *ctx, float x, float y, float dim);

/*** h2: parsing */

/**
 * ctx_parse:
 *
 * Parse ctx-syntax interpreting the commands in ctx.
 *
 */
void ctx_parse            (Ctx *ctx, const char *string);

/**
 * ctx_parse_animation:
 * elapsed_time the 
 *
 * Parses a string containg ctx protocol data, including an overlayed
 * scene and key-framing synax.
 *
 * pass in the scene_no you expect to render in the pointer for scene_no
 * actual rendered scene is returned here.
 *
 * elapsed time for scene to render, if we are beyond the specified scene
 * adjust elapsed_time to reflect elapsed time in actually rendered scene.
 */
void
ctx_parse_animation (Ctx *ctx, const char *string,
                     float *elapsed_time, 
                     int   *scene_no);


/* configuration of a parser, with callbacks for customization
 * of behavior.
 */
typedef struct CtxParserConfig {
  int      width;       // <- maybe should be float?
  int      height;
  float    cell_width;
  float    cell_height;
  int      cursor_x;
  int      cursor_y;
  int      flags;
  void    *user_data;

  int   (*set_prop)       (Ctx *ctx, void *user_data, uint32_t key, const char *data, int len);
  void   *set_prop_user_data;

  int   (*get_prop)       (Ctx *ctx, void *user_data, const char *key, char **data, int *len);
  void   *get_prop_user_data;

  void  (*start_frame)    (Ctx *ctx, void *user_data);
  void   *start_frame_user_data;

  void  (*end_frame)      (Ctx *ctx, void *user_data);
  void   *end_frame_user_data;

  void  (*response) (Ctx *ctx, void *user_data, char *response, int len);
  void   *response_user_data;

} CtxParserConfig;

typedef struct _CtxParser CtxParser;
  CtxParser *ctx_parser_new (
  Ctx       *ctx,
  CtxParserConfig *config);

void ctx_parser_destroy (CtxParser *parser);

int ctx_parser_neutral (CtxParser *parser);

void
ctx_parser_set_size (CtxParser *parser,
                     int        width,
                     int        height,
                     float      cell_width,
                     float      cell_height);

void ctx_parser_feed_bytes (CtxParser *parser, const char *data, int count);


typedef struct _CtxBackend CtxBackend;
struct _CtxBackend
{
  Ctx                      *ctx;

  void  (*process)         (Ctx *ctx, const CtxCommand *entry);

  /* for interactive/event-handling backends */
  void  (*start_frame)     (Ctx *ctx);
  void  (*end_frame)       (Ctx *ctx);
  void  (*consume_events)  (Ctx *ctx);
  void  (*get_event_fds)   (Ctx *ctx, int *fd, int *count);

  void  (*set_windowtitle) (Ctx *ctx, const char *text);

  char *(*get_clipboard)   (Ctx *ctx);
  void  (*set_clipboard)   (Ctx *ctx, const char *text);
  void  (*destroy)         (void *backend); /* the free pointers are abused as the differentiatior
                                               between different backends   */
  void  (*reset_caches)    (Ctx *ctx);
  CtxFlags                  flags;
  CtxBackendType            type;
  void                     *user_data; // not used by ctx core
};
void ctx_set_backend  (Ctx *ctx, void *backend);
void *ctx_get_backend (Ctx *ctx);

typedef struct _CtxIterator CtxIterator;

CtxCommand *ctx_iterator_next (CtxIterator *iterator);
void
ctx_iterator_init (CtxIterator  *iterator,
                   CtxDrawlist  *drawlist,  // replace with Ctx*  ? XXX XXX ? for one less type in public API
                   int           start_pos, 
                   int           flags);    // need exposing for font bits
int ctx_iterator_pos (CtxIterator *iterator);


// utility calls not tied directly to Ctx
int
ctx_get_contents (const char     *path,
                   unsigned char **contents,
                   long           *length);
int
ctx_get_contents2 (const char     *path,
                   unsigned char **contents,
                   long           *length,
                   long            max_len);

typedef struct _CtxSHA1 CtxSHA1;

void
ctx_bin2base64 (const void *bin,
                size_t      bin_length,
                char       *ascii);
int
ctx_base642bin (const char    *ascii,
                int           *length,
                unsigned char *bin);


void ctx_matrix_apply_transform (const CtxMatrix *m, float *x, float *y);
void ctx_matrix_apply_transform_distance (const CtxMatrix *m, float *x, float *y);
void ctx_matrix_invert          (CtxMatrix *m);
void ctx_matrix_identity        (CtxMatrix *matrix);
void ctx_matrix_scale           (CtxMatrix *matrix, float x, float y);
void ctx_matrix_rotate          (CtxMatrix *matrix, float angle);
void ctx_matrix_translate       (CtxMatrix *matrix, float x, float y);
void ctx_matrix_multiply        (CtxMatrix       *result,
                                 const CtxMatrix *t,
                                 const CtxMatrix *s);

/* we already have the start of the file available which disambiguates some
 * of our important supported formats, give preference to magic, then extension
 * then text plain vs binary.
 */
const char *ctx_guess_media_type (const char *path, const char *content, int len);

/* get media-type, with preference towards using extension of path and
 * not reading the data at all.
 */
const char *ctx_path_get_media_type (const char *path);

typedef enum {
  CTX_MEDIA_TYPE_NONE=0,
  CTX_MEDIA_TYPE_TEXT,
  CTX_MEDIA_TYPE_HTML,
  CTX_MEDIA_TYPE_IMAGE,
  CTX_MEDIA_TYPE_VIDEO,
  CTX_MEDIA_TYPE_AUDIO,
  CTX_MEDIA_TYPE_INODE,
  CTX_MEDIA_TYPE_APPLICATION,
} CtxMediaTypeClass;

int ctx_media_type_is_text (const char *media_type);
CtxMediaTypeClass ctx_media_type_class (const char *media_type);


float ctx_term_get_cell_width (Ctx *ctx);
float ctx_term_get_cell_height (Ctx *ctx);

Ctx * ctx_new_pdf (const char *path, float width, float height);
void ctx_render_pdf (Ctx *ctx, const char *path);




//#if CTX_GSTATE_PROTECT
/* sets the current gstate stack (number of unpaired ctx_save calls) as a
 * limit that can not be restored beyond. For now can not be used recursively.
 */
void ctx_gstate_protect   (Ctx *ctx);

/* removes the limit set by ctx_gstate_protect, if insufficient ctx_restore
 * calls have been made, 
 */
void ctx_gstate_unprotect (Ctx *ctx);
//#endif

/* set the logical clock used for the texture eviction policy */
void ctx_set_textureclock (Ctx *ctx, int frame);
int  ctx_textureclock (Ctx *ctx);

/* reinitialize an existing rasterizer with new dimensions/pixel_format
 *
 */
void
ctx_rasterizer_reinit (Ctx  *ctx,
                       void *fb,
                       int   x0,
                       int   y0,
                       int   width,
                       int   height,
                       int   stride,
                       CtxPixelFormat pixel_format);

// causes text commands to directly operate instead of expanding
// in backend
void ctx_set_frontend_text (Ctx *ctx, int frontend_text);

/* this is an interface used when CTX_PTY=0 and CTX_VT=1 , it permits
 * interacting with a single terminal on for instance micro controllers
 */
int ctx_vt_available (Ctx *ctx);
void ctx_vt_write    (Ctx *ctx, uint8_t byte);
int ctx_vt_has_data  (Ctx *ctx);
int ctx_vt_read      (Ctx *ctx);

int ctx_vt_cursor_x (CtxClient *client);
int ctx_vt_cursor_y (CtxClient *client);

/* only valid for rasterizer backend, not kept in graphics state
 */
enum _CtxAntialias
{
  CTX_ANTIALIAS_DEFAULT, //
  CTX_ANTIALIAS_NONE, // non-antialiased
  CTX_ANTIALIAS_FAST, // vertical aa 3 for complex scanlines
  CTX_ANTIALIAS_GOOD, // vertical aa 5 for complex scanlines
  CTX_ANTIALIAS_FULL, // vertical aa 15 for complex scanlines
};
typedef enum _CtxAntialias CtxAntialias;
void         ctx_set_antialias (Ctx *ctx, CtxAntialias antialias);
CtxAntialias ctx_get_antialias (Ctx *ctx);

float ctx_get_stroke_pos (Ctx *ctx);
void ctx_stroke_pos (Ctx *ctx, float x);

// used by fontgen
void _ctx_set_transformation (Ctx *ctx, int transformation);


void ctx_write_png (const char *dst_path, int w, int h, int num_chans, void *data);

//////////////////////////////////////////////////////////////////
#pragma pack(push,1)
struct
  _CtxEntry
{
  uint8_t code;
  union
  {
    float    f[2];
    uint8_t  u8[8];
    int8_t   s8[8];
    uint16_t u16[4];
    int16_t  s16[4];
    uint32_t u32[2];
    int32_t  s32[2];
    uint64_t u64[1]; // unused
  } data; // 9bytes long, we're favoring compactness and correctness
  // over performance. By sacrificing float precision, zeroing
  // first 8bit of f[0] would permit 8bytes long and better
  // aglinment and cacheline behavior.
};
#pragma pack(pop)

typedef enum
{
  CTX_CONT             = '\0', // - contains args from preceding entry
  CTX_NOP              = ' ', //
  CTX_DATA             = '(', // size size-in-entries - u32
  CTX_DATA_REV         = ')', // reverse traversal data marker
  CTX_SET_RGBA_U8      = '*', // r g b a - u8
                   //     ,    UNUSED/RESERVED
  CTX_SET_PIXEL        = '-', // 8bit "fast-path" r g b a x y - u8 for rgba, and u16 for x,y
  // set pixel might want a shorter ascii form with hex-color? or keep it an embedded
  // only option?
                   //     ^    used for unit
                   //     &    UNUSED
                   //     +    UNUSED
                   //     !    UNUSED
                   //     "    start/end string
                   //     #    comment in parser
                   //     $    UNUSED
                   //     %    percent of viewport width or height
                   //     '    start/end string
                   //     .    decimal seperator
                   //     /    UNUSED
                   //     ;    UNUSED
                   //     <    UNUSED
                   //     =    UNUSED/RESERVED
                   //     >    UNUSED
                   //     ?    UNUSED
                   //     \    UNUSED
                   //     ^    PARSER - vh unit
                       // ~    UNUSED/textenc
 
  /* optimizations that reduce the number of entries used,
   * not visible outside the drawlist compression, thus
   * using entries that cannot be used directly as commands
   * since they would be interpreted as numbers - if values>127
   * then the embedded font data is harder to escape.
   */
  CTX_REL_LINE_TO_X4            = '0', // x1 y1 x2 y2 x3 y3 x4 y4   -- s8
  CTX_REL_LINE_TO_REL_CURVE_TO  = '1', // x1 y1 cx1 cy1 cx2 cy2 x y -- s8
  CTX_REL_CURVE_TO_REL_LINE_TO  = '2', // cx1 cy1 cx2 cy2 x y x1 y1 -- s8
  CTX_REL_CURVE_TO_REL_MOVE_TO  = '3', // cx1 cy1 cx2 cy2 x y x1 y1 -- s8
  CTX_REL_LINE_TO_X2            = '4', // x1 y1 x2 y2 -- s16
  CTX_MOVE_TO_REL_LINE_TO       = '5', // x1 y1 x2 y2 -- s16
  CTX_REL_LINE_TO_REL_MOVE_TO   = '6', // x1 y1 x2 y2 -- s16
  CTX_FILL_MOVE_TO              = '7', // x y
  CTX_REL_QUAD_TO_REL_QUAD_TO   = '8', // cx1 x1 cy1 y1 cx1 x2 cy1 y1 -- s8
  CTX_REL_QUAD_TO_S16           = '9', // cx1 cy1 x y                 - s16
  CTX_END_FRAME        = 'X',

  CTX_DEFINE_FONT      = 15,

  CTX_DEFINE_GLYPH     = '@', // unichar width - u32
  CTX_ARC_TO           = 'A', // x1 y1 x2 y2 radius
  CTX_ARC              = 'B', // x y radius angle1 angle2 direction
  CTX_CURVE_TO         = 'C', // cx1 cy1 cx2 cy2 x y
  CTX_PAINT            = 'D', // 
                       // 'E' // scientific notation
  CTX_FILL             = 'F', //
  CTX_RESTORE          = 'G', //
  CTX_HOR_LINE_TO      = 'H', // x
  CTX_DEFINE_TEXTURE   = 'I', // "eid" width height format "data"
  CTX_ROTATE           = 'J', // radians
  CTX_COLOR            = 'K', // model, c1 c2 c3 ca - variable arg count
  CTX_LINE_TO          = 'L', // x y
  CTX_MOVE_TO          = 'M', // x y
  CTX_RESET_PATH       = 'N', //
  CTX_SCALE            = 'O', // xscale yscale
  CTX_NEW_PAGE         = 'P', // - NYI optional page-size
  CTX_QUAD_TO          = 'Q', // cx cy x y
  CTX_VIEW_BOX         = 'R', // x y width height
  CTX_SMOOTH_TO        = 'S', // cx cy x y
  CTX_SMOOTHQ_TO       = 'T', // x y
  CTX_CONIC_GRADIENT   = 'U', // cx cy start_angle cycles
  CTX_VER_LINE_TO      = 'V', // y
  CTX_APPLY_TRANSFORM  = 'W', // a b c d e f g h i j - for set_transform combine with identity
  CTX_TRANSLATE        = 'Y', // x y  

  CTX_CLOSE_PATH2      = 'Z', //
                              
  CTX_START_FRAME      = ':', // 
  CTX_KERNING_PAIR     = '[', // glA glB kerning, glA and glB in u16 kerning in s32
  CTX_COLOR_SPACE      = ']', // IccSlot  data  data_len,
                         //    data can be a string with a name,
                         //    icc data or perhaps our own serialization
                         //    of profile data
  CTX_STROKE_SOURCE    = '_', // next source definition applies to strokes
  CTX_SOURCE_TRANSFORM = '`',
  CTX_REL_ARC_TO       = 'a', // x1 y1 x2 y2 radius
  CTX_CLIP             = 'b',
  CTX_REL_CURVE_TO     = 'c', // cx1 cy1 cx2 cy2 x y
  CTX_LINE_DASH        = 'd', // dashlen0 [dashlen1 ...]
                     //  'e'  -- scientific notation for SVG numbers
  CTX_LINEAR_GRADIENT  = 'f', // x1 y1 x2 y2
  CTX_SAVE             = 'g',
  CTX_REL_HOR_LINE_TO  = 'h', // x
  CTX_TEXTURE          = 'i',
  CTX_PRESERVE         = 'j', // XXX - fix!
  CTX_SET_KEY          = 'k', // - used together with another char to identify
                              //   a key to set
  CTX_REL_LINE_TO      = 'l', // x y
  CTX_REL_MOVE_TO      = 'm', // x y
  CTX_FONT             = 'n', // as used by text parser XXX: move to keyvals?
  CTX_RADIAL_GRADIENT  = 'o', // x1 y1 radius1 x2 y2 radius2
  CTX_GRADIENT_STOP    = 'p', // argument count depends on current color model
  CTX_REL_QUAD_TO      = 'q', // cx cy x y
  CTX_RECTANGLE        = 'r', // x y width height
  CTX_REL_SMOOTH_TO    = 's', // cx cy x y
  CTX_REL_SMOOTHQ_TO   = 't', // x y
  CTX_STROKE           = 'u', // string - utf8 string
  CTX_REL_VER_LINE_TO  = 'v', // y
  CTX_GLYPH            = 'w', // unichar fontsize
  CTX_TEXT             = 'x', // string | kern - utf8 data to shape or horizontal kerning amount
  CTX_IDENTITY         = 'y', // XXX remove? - or reset to baseline.. which is what identity expects
  CTX_CLOSE_PATH       = 'z', //
  CTX_START_GROUP      = '{',
  CTX_END_GROUP        = '}',
  CTX_ROUND_RECTANGLE  = '|', // x y width height radius

  /* though expressed as two chars in serialization we have
   * dedicated byte commands for the setters to keep the dispatch
   * simpler. There is no need for these to be human readable thus we go >128
   * they also should not be emitted when outputting, even compact mode ctx.
   *
   * rasterizer:    &^+
   * font:          @[
   *
   * unused:        !&<=>?: =/\`,
   * reserved:      '"&   #. %^@
   */

  CTX_FILL_RULE        = 128, // kr rule - u8, default = CTX_FILLE_RULE_EVEN_ODD
  CTX_BLEND_MODE       = 129, // kB mode - u32 , default=0

  CTX_MITER_LIMIT      = 130, // km limit - float, default = 0.0

  CTX_LINE_JOIN        = 131, // kj join - u8 , default=0
  CTX_LINE_CAP         = 132, // kc cap - u8, default = 0
  CTX_LINE_WIDTH       = 133, // kw width, default = 2.0
  CTX_GLOBAL_ALPHA     = 134, // ka alpha - default=1.0
  CTX_COMPOSITING_MODE = 135, // kc mode - u32 , default=0

  CTX_FONT_SIZE        = 136, // kf size - float, default=?
  CTX_TEXT_ALIGN       = 137, // kt align - u8, default = CTX_TEXT_ALIGN_START
  CTX_TEXT_BASELINE    = 138, // kb baseline - u8, default = CTX_TEXT_ALIGN_ALPHABETIC
  CTX_TEXT_DIRECTION   = 139, // kd

  CTX_SHADOW_BLUR      = 140, // ks
  CTX_SHADOW_COLOR     = 141, // kC
  CTX_SHADOW_OFFSET_X  = 142, // kx
  CTX_SHADOW_OFFSET_Y  = 143, // ky
  CTX_IMAGE_SMOOTHING  = 144, // kS
  CTX_LINE_DASH_OFFSET = 145, // kD lineDashOffset


  CTX_EXTEND           = 146, // ke u32 extend mode, default=0
  CTX_WRAP_LEFT        = 147, // kL
  CTX_WRAP_RIGHT       = 148, // kR
  CTX_LINE_HEIGHT      = 149, // kH
                              
  CTX_STROKE_POS       = 150, // kp
  CTX_FEATHER          = 151, // kp
                             
#define CTX_LAST_COMMAND  CTX_FEATHER

  CTX_STROKE_RECT      = 200, // strokeRect - only exist in long form
  CTX_FILL_RECT        = 201, // fillRect   - only exist in long form


  CTX_FROM_PREV        = 26, // references previous frame
  CTX_FROM_THIS        = 16, //
} CtxCode;


#pragma pack(push,1)
struct
  _CtxCommand
{
  union
  {
    uint8_t  code;
    CtxEntry entry;
    struct
    {
      uint8_t code;
      float scalex;
      float scaley;
    } scale;
    struct
    {
      uint8_t code;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t cont;
      uint8_t data[8]; /* ... and continues */
    } data;
    struct
    {
      uint8_t code;
      uint32_t stringlen;
      uint32_t blocklen;
    } data_rev;
    struct
    {
      uint8_t code;
      uint32_t next_active_mask; // the tilehasher active flags for next
                                 // drawing command
      float pad2;
      uint8_t code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t code_cont;
      uint8_t utf8[8]; /* .. and continues */
    } text;
    struct
    {
      uint8_t  code;
      uint32_t key_hash;
      float    pad;
      uint8_t  code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont;
      uint8_t  utf8[8]; /* .. and continues */
    } set;
    struct
    {
      uint8_t  code;
      uint32_t pad0;
      float    pad1;
      uint8_t  code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont;
      uint8_t  utf8[8]; /* .. and continues */
    } get;
    struct {
      uint8_t  code;
      uint32_t count; /* better than byte_len in code, but needs to then be set   */
      float    pad1;
      uint8_t  code_data;
      uint32_t byte_len;
      uint32_t blocklen;
      uint8_t  code_cont;
      float    data[2]; /* .. and - possibly continues */
    } line_dash;
    struct {
      uint8_t  code;
      uint32_t space_slot;
      float    pad1;
      uint8_t  code_data;
      uint32_t data_len;
      uint32_t blocklen;
      uint8_t  code_cont;
      uint8_t  data[8]; /* .. and continues */
    } colorspace;
    struct
    {
      uint8_t  code;
      float    x;
      float    y;
      uint8_t  code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont;
      char     eid[8]; /* .. and continues */
    } texture;
    struct
    {
      uint8_t  code;
      uint32_t width;
      uint32_t height;
      uint8_t  code_cont0;
      uint16_t format;
      uint16_t pad0;
      uint32_t pad1;
      uint8_t  code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont1;
      char     eid[8]; /* .. and continues */
      // followed by - in variable offset code_Data, data_len, datablock_len, cont, pixeldata
    } define_texture;
    struct
    {
      uint8_t  code;
      float    pad;
      float    pad2;
      uint8_t  code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont;
      uint8_t  utf8[8]; /* .. and continues */
    } text_stroke;
    struct
    {
      uint8_t  code;
      float    pad;
      float    pad2;
      uint8_t  code_data;
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont;
      uint8_t  utf8[8]; /* .. and continues */
    } set_font;


    struct  // NYI - should be able to do old-style numerals, regular ligs, discretionary ligs
    {       //       the shaper shall look after current glyph, for matching utf8 and flags
            //       matching of 0 length utf8 maps to stylistic replacement.
      uint8_t  code;
      uint32_t glyph;
      uint32_t replacement;
      uint8_t  code_data;  /// < store which open-type flags activate it here
      uint32_t stringlen;
      uint32_t blocklen;
      uint8_t  code_cont;
      uint8_t  utf8[8]; /* .. and continues */
    } ligature;


    struct
    {
      uint8_t code;
      float model;
      float r;
      uint8_t pad1;
      float g;
      float b;
      uint8_t pad2;
      float a;
    } rgba;
    struct
    {
      uint8_t code;
      float model;
      float c;
      uint8_t pad1;
      float m;
      float y;
      uint8_t pad2;
      float k;
      float a;
    } cmyka;
    struct
    {
      uint8_t code;
      float model;
      float g;
      uint8_t pad1;
      float a;
    } graya;

    struct
    {
      uint8_t code;
      float model;
      float c0;
      uint8_t pad1;
      float c1;
      float c2;
      uint8_t pad2;
      float c3;
      float c4;
      uint8_t pad3;
      float c5;
      float c6;
      uint8_t pad4;
      float c7;
      float c8;
      uint8_t pad5;
      float c9;
      float c10;
    } set_color;
    struct
    {
      uint8_t code;
      float x;
      float y;
    } rel_move_to;
    struct
    {
      uint8_t code;
      float x;
      float y;
    } rel_line_to;
    struct
    {
      uint8_t code;
      float x;
      float y;
    } line_to;
    struct
    {
      uint8_t code;
      float cx1;
      float cy1;
      uint8_t pad0;
      float cx2;
      float cy2;
      uint8_t pad1;
      float x;
      float y;
    } rel_curve_to;
    struct
    {
      uint8_t code;
      float x;
      float y;
    } move_to;
    struct
    {
      uint8_t code;
      float cx1;
      float cy1;
      uint8_t pad0;
      float cx2;
      float cy2;
      uint8_t pad1;
      float x;
      float y;
    } curve_to;
    struct
    {
      uint8_t code;
      float x1;
      float y1;
      uint8_t pad0;
      float r1;
      float x2;
      uint8_t pad1;
      float y2;
      float r2;
    } radial_gradient;
    struct
    {
      uint8_t code;
      float x1;
      float y1;
      uint8_t pad0;
      float x2;
      float y2;
    } linear_gradient;
    struct
    {
      uint8_t code;
      float x;
      float y;
      uint8_t pad0;
      float start_angle;
      float cycles;
    } conic_gradient;
    struct
    {
      uint8_t code;
      float x;
      float y;
      uint8_t pad0;
      float width;
      float height;
      uint8_t pad1;
      float radius;
    } rectangle;
    struct {
      uint8_t code;
      float x;
      float y;
      uint8_t pad0;
      float width;
      float height;
    } view_box;

    struct
    {
      uint8_t code;
      uint16_t glyph_before;
      uint16_t glyph_after;
       int32_t amount;
    } kern;


    struct
    {
      uint8_t code;
      uint32_t glyph;
      uint32_t advance; // * 256
    } define_glyph;

    struct
    {
      uint8_t code;
      uint8_t rgba[4];
      uint16_t x;
      uint16_t y;
    } set_pixel;
    struct
    {
      uint8_t code;
      float cx;
      float cy;
      uint8_t pad0;
      float x;
      float y;
    } quad_to;
    struct
    {
      uint8_t code;
      float cx;
      float cy;
      uint8_t pad0;
      float x;
      float y;
    } rel_quad_to;
    struct
    {
      uint8_t code;
      float x;
      float y;
      uint8_t pad0;
      float radius;
      float angle1;
      uint8_t pad1;
      float angle2;
      float direction;
    }
    arc;
    struct
    {
      uint8_t code;
      float x1;
      float y1;
      uint8_t pad0;
      float x2;
      float y2;
      uint8_t pad1;
      float radius;
    }
    arc_to;
    /* some format specific generic accesors:  */
    struct
    {
      uint8_t code;
      float   x0;
      float   y0;
      uint8_t pad0;
      float   x1;
      float   y1;
      uint8_t pad1;
      float   x2;
      float   y2;
      uint8_t pad2;
      float   x3;
      float   y3;
      uint8_t pad3;
      float   x4;
      float   y4;
    } c;
    struct
    {
      uint8_t code;
      float   a0;
      float   a1;
      uint8_t pad0;
      float   a2;
      float   a3;
      uint8_t pad1;
      float   a4;
      float   a5;
      uint8_t pad2;
      float   a6;
      float   a7;
      uint8_t pad3;
      float   a8;
      float   a9;
    } f;
    struct
    {
      uint8_t  code;
      uint32_t a0;
      uint32_t a1;
      uint8_t  pad0;
      uint32_t a2;
      uint32_t a3;
      uint8_t  pad1;
      uint32_t a4;
      uint32_t a5;
      uint8_t  pad2;
      uint32_t a6;
      uint32_t a7;
      uint8_t  pad3;
      uint32_t a8;
      uint32_t a9;
    } u32;
    struct
    {
      uint8_t  code;
      uint64_t a0;
      uint8_t  pad0;
      uint64_t a1;
      uint8_t  pad1;
      uint64_t a2;
      uint8_t  pad2;
      uint64_t a3;
      uint8_t  pad3;
      uint64_t a4;
    } u64;
    struct
    {
      uint8_t code;
      int32_t a0;
      int32_t a1;
      uint8_t pad0;
      int32_t a2;
      int32_t a3;
      uint8_t pad1;
      int32_t a4;
      int32_t a5;
      uint8_t pad2;
      int32_t a6;
      int32_t a7;
      uint8_t pad3;
      int32_t a8;
      int32_t a9;
    } s32;
    struct
    {
      uint8_t code;
      int16_t a0;
      int16_t a1;
      int16_t a2;
      int16_t a3;
      uint8_t pad0;
      int16_t a4;
      int16_t a5;
      int16_t a6;
      int16_t a7;
      uint8_t pad1;
      int16_t a8;
      int16_t a9;
      int16_t a10;
      int16_t a11;
      uint8_t pad2;
      int16_t a12;
      int16_t a13;
      int16_t a14;
      int16_t a15;
      uint8_t pad3;
      int16_t a16;
      int16_t a17;
      int16_t a18;
      int16_t a19;
    } s16;
    struct
    {
      uint8_t code;
      uint16_t a0;
      uint16_t a1;
      uint16_t a2;
      uint16_t a3;
      uint8_t pad0;
      uint16_t a4;
      uint16_t a5;
      uint16_t a6;
      uint16_t a7;
      uint8_t pad1;
      uint16_t a8;
      uint16_t a9;
      uint16_t a10;
      uint16_t a11;
      uint8_t pad2;
      uint16_t a12;
      uint16_t a13;
      uint16_t a14;
      uint16_t a15;
      uint8_t pad3;
      uint16_t a16;
      uint16_t a17;
      uint16_t a18;
      uint16_t a19;
    } u16;
    struct
    {
      uint8_t code;
      uint8_t a0;
      uint8_t a1;
      uint8_t a2;
      uint8_t a3;
      uint8_t a4;
      uint8_t a5;
      uint8_t a6;
      uint8_t a7;
      uint8_t pad0;
      uint8_t a8;
      uint8_t a9;
      uint8_t a10;
      uint8_t a11;
      uint8_t a12;
      uint8_t a13;
      uint8_t a14;
      uint8_t a15;
      uint8_t pad1;
      uint8_t a16;
      uint8_t a17;
      uint8_t a18;
      uint8_t a19;
      uint8_t a20;
      uint8_t a21;
      uint8_t a22;
      uint8_t a23;
    } u8;
    struct
    {
      uint8_t code;
      int8_t a0;
      int8_t a1;
      int8_t a2;
      int8_t a3;
      int8_t a4;
      int8_t a5;
      int8_t a6;
      int8_t a7;
      uint8_t pad0;
      int8_t a8;
      int8_t a9;
      int8_t a10;
      int8_t a11;
      int8_t a12;
      int8_t a13;
      int8_t a14;
      int8_t a15;
      uint8_t pad1;
      int8_t a16;
      int8_t a17;
      int8_t a18;
      int8_t a19;
      int8_t a20;
      int8_t a21;
      int8_t a22;
      int8_t a23;
    } s8;
  };
  CtxEntry next_entry; // also pads size of CtxCommand slightly.
};
#pragma pack(pop)
#define ctx_arg_string()  ((char*)&entry[2].data.u8[0])

/* access macros for nth argument of a given type when packed into
 * an CtxEntry pointer in current code context
 */
#define ctx_arg_float(no) entry[(no)>>1].data.f[(no)&1]
#define ctx_arg_u64(no)   entry[(no)].data.u64[0]
#define ctx_arg_u32(no)   entry[(no)>>1].data.u32[(no)&1]
#define ctx_arg_s32(no)   entry[(no)>>1].data.s32[(no)&1]
#define ctx_arg_u16(no)   entry[(no)>>2].data.u16[(no)&3]
#define ctx_arg_s16(no)   entry[(no)>>2].data.s16[(no)&3]
#define ctx_arg_u8(no)    entry[(no)>>3].data.u8[(no)&7]
#define ctx_arg_s8(no)    entry[(no)>>3].data.s8[(no)&7]
#define ctx_arg_string()  ((char*)&entry[2].data.u8[0])
////////////////////////////////////////////////////////////////////

/*
 * removes any backend specific (SDL) clipboard integration and
 * use internal fallback if internal_clipboard is set to 1, currently
 * setting internal clipboard is irreversible.
 */
void ctx_internal_clipboard (Ctx *ctx, int internal_clipboard);

void ctx_wait_for_renderer (Ctx *ctx);


typedef enum CtxSubPixel
{
  CTX_SUBPIXEL_NONE = 0,
  CTX_SUBPIXEL_HRGB = 1,
  CTX_SUBPIXEL_HBGR = 2,
  CTX_SUBPIXEL_VRGB = 3,
  CTX_SUBPIXEL_VBGR = 4
} CtxSubPixel;

/* UTF8 utility functions:
 */
int ctx_utf8_strlen (const char *s);
int ctx_utf8_len (const unsigned char first_byte);
uint32_t ctx_utf8_to_unichar (const char *input);
int      ctx_unichar_to_utf8 (uint32_t  ch, uint8_t  *dest);
const char *ctx_utf8_skip (const char *s, int utf8_length);

int ctx_has_focus (Ctx *ctx);

int       ctx_get_major_version (void);
int       ctx_get_minor_version (void);
int       ctx_get_micro_version (void);

/* currently unused */
void      ctx_set_render_threads   (Ctx *ctx, int n_threads);
int       ctx_get_render_threads   (Ctx *ctx);

#if CTX_ASSERT==1
#define ctx_assert(a)  if(!(a)){fprintf(stderr,"%s:%i assertion failed\n", __FUNCTION__, __LINE__);  }
#else
#define ctx_assert(a)
#endif

#ifdef __cplusplus
}
#endif
#endif

#ifndef CTX_VERSION_STRING
#define CTX_VERSION_STRING "0.1.3"
#define CTX_VERSION_MAJOR 0
#define CTX_VERSION_MINOR 1
#define CTX_VERSION_MICRO 3
#endif
#ifndef __CTX_H__
#define __CTX_H__
/* definitions that determine which features are included and their settings,
 * for particular platforms - in particular microcontrollers ctx might need
 * tuning for different quality/performance/resource constraints.
 *
 * the way to configure ctx is to set these defines, before both including it
 * as a header and in the file where CTX_IMPLEMENTATION is set to include the
 * implementation for different featureset and runtime settings.
 *
 */


// babl included first causes babl support to be enabled
#ifndef CTX_BABL
#ifdef _BABL_H
#define CTX_BABL 1
#else
#define CTX_BABL 0
#endif
#endif

#if CTX_BABL
  #ifndef CTX_ENABLE_CM
    #define CTX_ENABLE_CM           1
  #endif
#else
  #ifndef CTX_ENABLE_CM
    #define CTX_ENABLE_CM           0
  #endif
#endif

// sdl included first causes sdl support to be enabled
#ifndef CTX_SDL
#ifdef SDL_h_
#define CTX_SDL 1
#else
#define CTX_SDL 0
#endif
#endif

#if CTX_SDL
#undef CTX_THREADS
#define CTX_THREADS 1
#endif

// fb and kms support has to be opted in to .. perhaps we could use
// defined from their includes as well? TODO
#ifndef CTX_FB
#define CTX_FB 0
#endif

#ifndef CTX_KMS
#define CTX_KMS 0
#endif


/* whether the font rendering happens in backend or front-end of API, the
 * option is used set to 0 by the tool that converts ttf fonts to ctx internal
 * representation - both should be possible so that this tool can be made
 * into a TTF/OTF font import at runtime (perhaps even with live subsetting).
 *
 * improving this feature and making it runtime selectable could also
 * be part of encoding all text as beziers upon pdf export
 */

#ifndef CTX_MAX_SCANLINES
#define CTX_MAX_SCANLINES 2048
#endif


/* subpixel-aa coordinates used in BITPACKing of drawlist
 *
 * powers of 2 is faster
 */
#ifndef CTX_SUBDIV
#define CTX_SUBDIV   8  //  max framebufer width 4095
//#define CTX_SUBDIV  10  //  max framebufer width 3250
//#define CTX_SUBDIV  16  //  max framebufer width 2047
//#define CTX_SUBDIV  24  //  max framebufer width 1350
//#define CTX_SUBDIV  32  //  max framebufer width 1023
#endif


// 8    12 68 40 24
// 16   12 68 40 24
/* scale-factor for font outlines prior to bit quantization by CTX_SUBDIV
 *
 * changing this also changes font file format - the value should be baked
 * into the ctxf files making them less dependent on the ctx used to
 * generate them
 */
#define CTX_BAKE_FONT_SIZE    160

/* pack some linetos/curvetos/movetos into denser drawlist instructions,
 * permitting more vectors to be stored in the same space, experimental
 * feature with added overhead.
 */
#ifndef CTX_BITPACK
#define CTX_BITPACK           1
#endif

#ifndef CTX_PARSER_FIXED_TEMP
#define CTX_PARSER_FIXED_TEMP 0
         // when 1  CTX_PARSER_MAXLEN is the fixed max stringlen
#endif   // and no allocations happens beyond creating the parser,
         // when 0 the scratchbuf for parsing is a separate dynamically
         // growing buffer, that maxes out at CTX_PARSER_MAXLEN
         //
#ifndef CTX_PARSER_MAXLEN
#if CTX_PARSER_FIXED_TEMP
#define CTX_PARSER_MAXLEN  1024*128        // This is the maximum texture/string size supported
#else
#define CTX_PARSER_MAXLEN  1024*1024*16    // 16mb
#endif
#endif

#ifndef CTX_RASTERIZER_ALLOW_DIRECT
#define CTX_RASTERIZER_ALLOW_DIRECT 1
#endif

#ifndef CTX_RASTERIZER_BEZIER_FIXED_POINT
#define CTX_RASTERIZER_BEZIER_FIXED_POINT 1
#endif

#ifndef CTX_FAST_FILL_RECT
#define CTX_FAST_FILL_RECT 1    /*  matters most for tiny rectangles where it shaves overhead, for larger rectangles
                                    a ~15-20% performance win can be seen. */
#endif

#ifndef CTX_FAST_STROKE_RECT
#define CTX_FAST_STROKE_RECT 1
#endif


#ifndef CTX_COMPOSITING_GROUPS
#define CTX_COMPOSITING_GROUPS   1
#endif

/* maximum nesting level of compositing groups
 */
#ifndef CTX_GROUP_MAX
#define CTX_GROUP_MAX             8
#endif

#ifndef CTX_ENABLE_CLIP
#define CTX_ENABLE_CLIP           1
#endif

/* use a 1bit clip buffer, saving RAM on microcontrollers, other rendering
 * will still be antialiased.
 */
#ifndef CTX_1BIT_CLIP
#define CTX_1BIT_CLIP             0
#endif


#ifndef CTX_ENABLE_SHADOW_BLUR
#define CTX_ENABLE_SHADOW_BLUR    0
#endif

// fudge geomtry slightly with smoother blend between edges,
// busting some SDF artifacts apparent in acute angles
#ifndef CTX_RASTERIZER_BLUR_FUDGE
#define CTX_RASTERIZER_BLUR_FUDGE 0
#endif

#ifndef CTX_GRADIENTS
#define CTX_GRADIENTS             1
#endif

#ifndef CTX_ALIGNED_STRUCTS
#define CTX_ALIGNED_STRUCTS       1
#endif

#ifndef CTX_GRADIENT_CACHE
#define CTX_GRADIENT_CACHE        1
#endif


#ifndef CTX_FONT_SHAPE_CACHE
#define CTX_FONT_SHAPE_CACHE      0
#endif

// size of per ctx context static temp helper buf
// for temporary shapings - not needing to incur
// an allocation
#ifndef CTX_SHAPE_GLYPHS
#define CTX_SHAPE_GLYPHS     32
#endif

#ifndef CTX_FONTS_FROM_FILE
#define CTX_FONTS_FROM_FILE  0
#endif

#ifndef CTX_GET_CONTENTS
#if CTX_FONTS_FROM_FILE
#define CTX_GET_CONTENTS    1
#else
#define CTX_GET_CONTENTS    0
#endif
#endif

#ifndef CTX_FORMATTER
#define CTX_FORMATTER       1
#endif

#ifndef CTX_PARSER
#define CTX_PARSER          1
#endif

#ifndef CTX_CURRENT_PATH
#define CTX_CURRENT_PATH    1
#endif

#ifndef CTX_VT
#define CTX_VT              0
#endif

/* when ctx_math is defined, which it is by default, we use ctx' own
 * implementations of math functions, instead of relying on math.h
 * the possible inlining gives us a slight speed-gain, and on
 * embedded platforms guarantees that we do not do double precision
 * math.
 */
#ifndef CTX_MATH
#define CTX_MATH            1  // use internal fast math for sqrt,sin,cos,atan2f etc.
#endif

#define ctx_log(fmt, ...)
//#define ctx_log(str, a...) fprintf(stderr, str, ##a)

/* the initial journal size - for both rasterizer
 * edgelist and drawlist.
 */
#ifndef CTX_MIN_JOURNAL_SIZE
#define CTX_MIN_JOURNAL_SIZE      512
#endif

/* The maximum size we permit the drawlist to grow to,
 * the memory used is this number * 9, where 9 is sizeof(CtxEntry)
 */
#ifndef CTX_MAX_JOURNAL_SIZE
//#define CTX_MAX_JOURNAL_SIZE   CTX_MIN_JOURNAL_SIZE
#define CTX_MAX_JOURNAL_SIZE 1024*1024*8
#endif

#ifndef CTX_DRAWLIST_STATIC
#define CTX_DRAWLIST_STATIC  0
#endif

#ifndef CTX_MIN_EDGE_LIST_SIZE
#define CTX_MIN_EDGE_LIST_SIZE   1024*4
#endif


// 3 5 or 15 - this is the AA used for worst-case scanlines; with crossings or edge start|ends
#ifndef CTX_RASTERIZER_AA
#define CTX_RASTERIZER_AA  5  // vertical-AA of CTX_ANTIALIAS_DEFAULT
#endif

/* The maximum complexity of a single path
 */
#ifndef CTX_MAX_EDGE_LIST_SIZE
#define CTX_MAX_EDGE_LIST_SIZE  CTX_MIN_EDGE_LIST_SIZE
#endif

#ifndef CTX_MAX_KEYDB
#define CTX_MAX_KEYDB 64 // number of entries in keydb
                         // entries are "copy-on-change" between states
#endif

#ifndef CTX_32BIT_SEGMENTS
#define CTX_32BIT_SEGMENTS 1  // without this clipping problems might
                              // occur when drawing far outside the viewport
                              // or with large translate amounts
                              // on micro controllers you most often will
                              // want this set to 0
#endif

/* whether we dither or not for gradients
 */
#ifndef CTX_DITHER
#define CTX_DITHER 0
#endif

/*  with 0 only source-over clear and copy will work, the API still
 *  through - but the backend is limited, for use to measure
 *  size and possibly in severely constrained ROMs.
 */
#ifndef CTX_BLENDING_AND_COMPOSITING
#define CTX_BLENDING_AND_COMPOSITING 1
#endif

/*  this forces the inlining of some performance
 *  critical paths.
 */
#ifndef CTX_FORCE_INLINES
#define CTX_FORCE_INLINES               1
#endif

/* create one-off inlined inner loop for normal blend mode (for floating point,
 * and grayscale for RGBA8 manual loops overrrides. Disabling this should speed
 * up compiles at penalty for the given formats.
 */
#ifndef CTX_INLINED_NORMAL     
#define CTX_INLINED_NORMAL      0
#endif

/*
 *  do not use manual RGBA8 code but rely on ctx inline templating
 */
#ifndef CTX_INLINED_NORMAL_RGBA8
#define CTX_INLINED_NORMAL_RGBA8  0
#endif

#undef CTX_RASTERIZER_SWITCH_DISPATCH
#ifndef CTX_RASTERIZER_SWITCH_DISPATCH
#define CTX_RASTERIZER_SWITCH_DISPATCH  1 // marginal improvement for some
                                          // modes, maybe get rid of this?
#endif

#ifndef CTX_U8_TO_FLOAT_LUT
#define CTX_U8_TO_FLOAT_LUT  0
#endif

#ifndef CTX_INLINED_GRADIENTS
#define CTX_INLINED_GRADIENTS   1
#endif

#ifndef CTX_BRAILLE_TEXT
#define CTX_BRAILLE_TEXT        0
#endif

/* Build code paths for grayscale rasterization, this makes clipping
 * faster.
 */
#ifndef CTX_NATIVE_GRAYA8
#define CTX_NATIVE_GRAYA8       0
#endif

/* enable CMYK rasterization targets
 */
#ifndef CTX_ENABLE_CMYK
#define CTX_ENABLE_CMYK         1
#endif

/* enable color management, slightly increases CtxColor struct size, should
 * be disabled for microcontrollers.
 */


#ifndef CTX_EVENTS
#define CTX_EVENTS              1
#endif

#ifndef CTX_MAX_DEVICES
#define CTX_MAX_DEVICES 16
#endif

#ifndef CTX_MAX_KEYBINDINGS
#define CTX_MAX_KEYBINDINGS 256
#endif


#ifndef CTX_PROTOCOL_U8_COLOR
#define CTX_PROTOCOL_U8_COLOR 0
#endif

#ifndef CTX_TERMINAL_EVENTS
#if CTX_EVENTS
#define CTX_TERMINAL_EVENTS 1
#else
#define CTX_TERMINAL_EVENTS 0
#endif
#endif

#ifndef CTX_LIMIT_FORMATS
#define CTX_LIMIT_FORMATS       0
#endif

#ifndef CTX_ENABLE_FLOAT
#define CTX_ENABLE_FLOAT        0
#endif

/* by default ctx includes all pixel formats, on microcontrollers
 * it can be useful to slim down code and runtime size by only
 * defining the used formats, set CTX_LIMIT_FORMATS to 1, and
 * manually add CTX_ENABLE_ flags for each of them.
 */
#if CTX_LIMIT_FORMATS
#if CTX_NATIVE_GRAYA8
#define CTX_ENABLE_GRAYA8               1
#define CTX_ENABLE_GRAY8                1
#endif
#else

#define CTX_ENABLE_GRAY1                1
#define CTX_ENABLE_GRAY2                1
#define CTX_ENABLE_GRAY4                1
#define CTX_ENABLE_GRAY8                1
#define CTX_ENABLE_GRAYA8               1
#define CTX_ENABLE_GRAYF                1
#define CTX_ENABLE_GRAYAF               1

#define CTX_ENABLE_RGB8                 1
#define CTX_ENABLE_RGBA8                1
#define CTX_ENABLE_BGRA8                1
#define CTX_ENABLE_BGR8                 1
#define CTX_ENABLE_RGB332               1
#define CTX_ENABLE_RGB565               1
#define CTX_ENABLE_RGB565_BYTESWAPPED   1
#define CTX_ENABLE_RGBAF                1
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT                1
#define CTX_ENABLE_YUV420               1

#if CTX_ENABLE_CMYK
#define CTX_ENABLE_CMYK8                1
#define CTX_ENABLE_CMYKA8               1
#define CTX_ENABLE_CMYKAF               1
#endif
#endif

#ifndef CTX_RGB565_ALPHA
#define CTX_RGB565_ALPHA                0   // when enabled pure purple is transparent,
                                            // for a ~15% overall performance hit
#endif

#ifndef CTX_RGB332_ALPHA
#define CTX_RGB332_ALPHA                0   // when enabled pure purple is transparent,
                                            // for a ~15% overall performance hit
#endif

#ifndef CTX_RESOLVED_FONTS
#define CTX_RESOLVED_FONTS 8   // how many font-strings to cache the resolution for in a static
                               // hash-table
#endif

/* by including ctx-font-regular.h, or ctx-font-mono.h the
 * built-in fonts using ctx drawlist encoding is enabled
 */
#ifndef CTX_NO_FONTS
#ifndef CTX_FONT_ENGINE_CTX
#define CTX_FONT_ENGINE_CTX        1
#endif
#endif

#ifndef CTX_ONE_FONT_ENGINE
#define CTX_ONE_FONT_ENGINE 0
#endif


#ifndef CTX_FONT_ENGINE_CTX_FS
#define CTX_FONT_ENGINE_CTX_FS 0
#endif

#ifdef HB_H
#ifndef CTX_HARFBUZZ
#define CTX_HARFBUZZ 1
#endif
#else
#ifndef CTX_HARFBUZZ
#define CTX_HARFBUZZ 0
#endif
#endif


#if CTX_HARFBUZZ
#ifndef CTX_FONT_ENGINE_HARFBUZZ
#define CTX_FONT_ENGINE_HARFBUZZ   1
#endif
#else
#define CTX_FONT_ENGINE_HARFBUZZ   0
#endif

#ifndef CTX_BABL
#ifdef _BABL_H
#define CTX_BABL 1
#else
#define CTX_BABL 0
#endif
#endif

#ifndef _BABL_H
#undef CTX_BABL
#define CTX_BABL 0
#endif

#ifndef CTX_ALWAYS_USE_NEAREST_FOR_SCALE1
#define CTX_ALWAYS_USE_NEAREST_FOR_SCALE1 0
#endif

/* include the bitpack packer, can be opted out of to decrease code size
 */
#ifndef CTX_BITPACK_PACKER
#define CTX_BITPACK_PACKER 0
#endif

/* enable RGBA8 intermediate format for
 *the indirectly implemented pixel-formats.
 */
#if CTX_ENABLE_GRAY1 | CTX_ENABLE_GRAY2 | CTX_ENABLE_GRAY4 | CTX_ENABLE_RGB565 | CTX_ENABLE_RGB565_BYTESWAPPED | CTX_ENABLE_RGB8 | CTX_ENABLE_RGB332

  #ifdef CTX_ENABLE_RGBA8
    #undef CTX_ENABLE_RGBA8
  #endif
  #define CTX_ENABLE_RGBA8  1
#endif

#ifdef CTX_ENABLE_CMYKF
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT 1
#endif

#ifdef CTX_ENABLE_GRAYF
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT 1
#endif

#ifdef CTX_ENABLE_GRAYAF
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT 1
#endif

#ifdef CTX_ENABLE_RGBAF
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT 1
#endif

#ifdef CTX_ENABLE_CMYKAF
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT 1
#endif

#ifdef CTX_ENABLE_CMYKF
#ifdef CTX_ENABLE_FLOAT
#undef CTX_ENABLE_FLOAT
#endif
#define CTX_ENABLE_FLOAT 1
#endif


/* enable cmykf which is cmyk intermediate format
 */
#ifdef CTX_ENABLE_CMYK8
#ifdef CTX_ENABLE_CMYKF
#undef CTX_ENABLE_CMYKF
#endif
#define CTX_ENABLE_CMYKF  1
#endif
#ifdef CTX_ENABLE_CMYKA8
#ifdef CTX_ENABLE_CMYKF
#undef CTX_ENABLE_CMYKF
#endif
#define CTX_ENABLE_CMYKF  1
#endif

#ifdef CTX_ENABLE_CMYKF8
#ifdef CTX_ENABLE_CMYK
#undef CTX_ENABLE_CMYK
#endif
#define CTX_ENABLE_CMYK   1
#endif

#define CTX_PI                              3.141592653589793f
#ifndef CTX_RASTERIZER_MAX_CIRCLE_SEGMENTS
#define CTX_RASTERIZER_MAX_CIRCLE_SEGMENTS  (128)
#endif

#ifndef CTX_MAX_FONTS
#define CTX_MAX_FONTS            32
#endif

#ifndef CTX_GLYPH_CACHE
#define CTX_GLYPH_CACHE 1
#endif

#ifndef CTX_GLYPH_CACHE_SIZE
#define CTX_GLYPH_CACHE_SIZE     128
#endif

#ifndef CTX_MAX_STATES
#define CTX_MAX_STATES           16
#endif

#ifndef CTX_MAX_EDGES
#define CTX_MAX_EDGES            255
#endif

#ifndef CTX_MAX_PENDING
#define CTX_MAX_PENDING          128
#endif

#ifndef CTX_MAX_TEXTURES
#define CTX_MAX_TEXTURES         32
#endif

#ifndef CTX_HASH_ROWS
#define CTX_HASH_ROWS            6
#endif
#ifndef CTX_HASH_COLS
#define CTX_HASH_COLS            5
#endif

#ifndef CTX_INLINE_FILL_RULE
#define CTX_INLINE_FILL_RULE 1
#endif

#ifndef CTX_MAX_THREADS
#define CTX_MAX_THREADS          8 // runtime is max of cores/2 and this
#endif

#ifndef CTX_FRAGMENT_SPECIALIZE
#define CTX_FRAGMENT_SPECIALIZE 1
#endif

#define CTX_RASTERIZER_EDGE_MULTIPLIER  2048
                                        // increasing this to 2048
                                        // removes artifacts in top half of res-diagram -
                                        // but reduces maximum available buffer width
#ifndef CTX_IMPLEMENTATION
#define CTX_IMPLEMENTATION 0
#else
#undef CTX_IMPLEMENTATION
#define CTX_IMPLEMENTATION 1
#endif

#ifndef CTX_MAX_SCANLINE_LENGTH
#define CTX_MAX_SCANLINE_LENGTH 4096
#endif


#ifndef CTX_MAX_CBS
#define CTX_MAX_CBS              64 // was 128 - each kb is kind of big
#endif

#ifndef static_OPAQUE // causes a CTX_MAX_SCANLINE_LENGTH
                          // buffer of 255 bytes to be part of
                          // rasterizer
#define static_OPAQUE 1
#endif

#ifdef CTX_RASTERIZER
#if CTX_RASTERIZER==0
#if CTX_SDL || CTX_FB || CTX_HEADLESS
#undef CTX_RASTERIZER
#define CTX_RASTERIZER 1
#endif
#else
#undef CTX_RASTERIZER
#define CTX_RASTERIZER 1
#endif
#endif

#if CTX_SDL || CTX_FB || CTX_HEADLESS
#if CTX_EVENTS
#undef CTX_EVENTS
#endif
#define CTX_EVENTS 1
#endif




#ifndef CTX_HEADLESS

#if CTX_FB || CTX_SDL || CTX_KMS
#define CTX_HEADLESS 1
#endif
#endif


#ifndef CTX_GRADIENT_CACHE_ELEMENTS
#define CTX_GRADIENT_CACHE_ELEMENTS 256
#endif

#ifndef CTX_PARSER_MAX_ARGS
#define CTX_PARSER_MAX_ARGS 20
#endif

#ifndef CTX_MAX_DASHES
#define CTX_MAX_DASHES CTX_PARSER_MAX_ARGS
#endif

#ifndef CTX_SCREENSHOT
#define CTX_SCREENSHOT 0
#endif

#ifndef CTX_ALSA
#define CTX_ALSA 0
#endif

#ifndef CTX_AUDIO
#define CTX_AUDIO 0
#endif

#if CTX_AUDIO==0
#if CTX_ALSA
#undef CTX_ALSA
#define CTX_ALSA 0
#endif
#endif

#ifndef CTX_CURL
#define CTX_CURL 0
#endif

#if ESP_PLATFORM
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#endif

#if CTX_THREADS
#if ESP_PLATFORM
#include <pthread.h>

#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 2, 0)
#include <esp_pthread.h>
#endif

#else
#include <pthread.h>
#endif
#define mtx_lock pthread_mutex_lock
#define mtx_unlock pthread_mutex_unlock
#define mtx_t pthread_mutex_t
#define cnd_t pthread_cond_t
#define mtx_plain NULL
#define mtx_init pthread_mutex_init
#define cnd_init(a) pthread_cond_init(a,NULL)
#define cnd_wait pthread_cond_wait
#define cnd_broadcast pthread_cond_broadcast
#define thrd_create(tid, tiled_render_fun, args) pthread_create(tid, NULL, tiled_render_fun, args)
#define thrd_t pthread_t
#else

#if PICO_BUILD
 
#include <pico/mutex.h>

#define mtx_t          mutex_t
#define mtx_plain      NULL
#define mtx_init(a,b)  mutex_init(a)
#define mtx_lock(a)    mutex_enter_blocking(a)
#define mtx_unlock(a)  mutex_exit(a)


#else

#define mtx_lock(a)
#define mtx_unlock(a)
#define mtx_t size_t
#define mtx_init(a,b)
#define mtx_plain 0

#endif

#define cnd_t size_t
#define cnd_init(a)
#define cnd_wait(a,b)
#define cnd_broadcast(c)
#define thrd_create(tid, tiled_render_fun, args) 0
#define thrd_t size_t

#endif

#ifndef CTX_SIMD_SUFFIX
#define CTX_SIMD_SUFFIX(symbol) symbol##_generic
#define CTX_SIMD_BUILD 0
#else


#define CTX_SIMD_BUILD 1
#ifdef CTX_COMPOSITE
#undef CTX_COMPOSITE
#define CTX_COMPOSITE 1
#endif

#endif


#if CTX_RASTERIZER
#ifndef CTX_COMPOSITE
#define CTX_COMPOSITE 1
#endif
#else
#ifndef CTX_COMPOSITE
#define CTX_COMPOSITE 0
#endif
#endif

#ifndef CTX_COMPOSITE
#define CTX_COMPOSITE 0
#endif

#ifndef CTX_MAX_GRADIENT_STOPS
#define CTX_MAX_GRADIENT_STOPS 16
#endif

#ifndef CTX_BRANCH_HINTS
#define CTX_BRANCH_HINTS  0
#endif

#ifdef EMSCRIPTEN
#define CTX_WASM 1
#else
#define CTX_WASM 0
#endif

#ifndef CTX_MAX_LISTEN_FDS
#define CTX_MAX_LISTEN_FDS 128 // becomes max clients..
#endif

#if CTX_WASM
#undef CTX_THREADS
#define CTX_THREADS 0
#undef CTX_HEADLESS
#define CTX_HEADLESS 0
#undef CTX_EVENTS
#define CTX_EVENTS 1
#undef CTX_PARSER
#define CTX_PARSER 1
#undef CTX_RASTERIZER
#define CTX_RASTERIZER 1
#endif

#ifndef CTX_PDF
#define CTX_PDF 0
#endif

#if CTX_IMAGE_WRITE

#if CTX_AUDIO==0
#define MINIZ_NO_INFLATE_APIS
#endif

#else

#if CTX_AUDIO==0
#define MINIZ_NO_DEFLATE_APIS
#define MINIZ_NO_INFLATE_APIS
#endif

#endif

#define MINIZ_NO_ARCHIVE_APIS
#define MINIZ_NO_STDIO


//#define uncompress tinf_uncompress
//#define Z_OK TINF_OK
//#define Z_BUF_ERROR TINF_BUF_ERROR
//#define Z_DATA_ERROR TINF_DATA_ERROR

#ifndef CTX_RAW_KB_EVENTS
#define CTX_RAW_KB_EVENTS 0
#endif


#ifndef CTX_BAREMETAL
#define CTX_BAREMETAL 0
#endif


#if CTX_IMPLEMENTATION
#ifndef SQUOZE_IMPLEMENTATION
#define SQUOZE_IMPLEMENTATION         1
#define SQUOZE_LIMIT_IMPLEMENTATIONS  1
#define SQUOZE_IMPLEMENTATION_32_UTF8 1
#define SQUOZE_USE_INTERN             0
#endif
#endif

#ifndef CTX_PTY
#define CTX_PTY 1
#endif

#ifndef CTX_STROKE_1PX   
#define CTX_STROKE_1PX    0   // XXX : these code paths can crash in fuzzing
#endif

#ifndef CTX_PICO
#define CTX_PICO 0
#endif


#ifndef CTX_GSTATE_PROTECT
#define CTX_GSTATE_PROTECT  1
#endif

// only applies with gcc not clang
#ifndef CTX_COMPOSITE_O3
#define CTX_COMPOSITE_O3 0
#endif

// only applies with gcc not clang
#ifndef CTX_COMPOSITE_O2
#define CTX_COMPOSITE_O2 0
#endif

// only applies with gcc not clang
#ifndef CTX_RASTERIZER_O3
#define CTX_RASTERIZER_O3 0
#endif

// only applies with gcc not clang
#ifndef CTX_RASTERIZER_O2
#define CTX_RASTERIZER_O2 0
#endif

#if CTX_KMS || CTX_FB
#undef CTX_RAW_KB_EVENTS
#define CTX_RAW_KB_EVENTS 1
#endif

#ifndef CTX_YUV_LUTS
#define  CTX_YUV_LUTS 0
#endif


#ifndef CTX_VT_STYLE_SIZE
#define CTX_VT_STYLE_SIZE   64
#endif

#ifndef CTX_ASSERT
#define CTX_ASSERT               0
#endif


#ifndef CTX_SCANBIN
#define CTX_SCANBIN 0
#endif

#ifndef CTX_LOAD_FILE
#define CTX_LOAD_FILE ___ctx_file_get_contents
#endif

#ifndef CTX_MAGIC
#define CTX_MAGIC 0
#endif

#ifndef CTX_CSS
#define CTX_CSS 0
#endif

#ifndef CTX_SVG_FREE_AGE
#define CTX_SVG_FREE_AGE 62
#endif


/* whether we keep a drawlist per terminal-tab, this causes more memory
 * usage, but should be faster with many tabs with graphical clients
 */
#ifndef CTX_VT_DRAWLIST
#define CTX_VT_DRAWLIST 0
#endif

/* when enabled, tabs that have the capability to launch sub-clients can do
 * so with an APC sequence
 */
#ifndef CTX_VT_LAUNCH
#define CTX_VT_LAUNCH 0
#endif


#ifndef CTX_VT_LOG
#define CTX_VT_LOG 0
#endif

#ifndef CTX_VT_SIXELS
#define CTX_VT_SIXELS 1
#endif

#ifndef CTX_VT_GFX
#define CTX_VT_GFX  1
#endif

#ifndef CTX_FB_KDSETMODE
#define CTX_FB_KDSETMODE 1
#endif

#ifndef CTX_TYPING_POINTER_IGNORE_MS
#define CTX_TYPING_POINTER_IGNORE_MS 700
#endif

#define CTX_FIX_SCALE 1024
#define CTX_FIX_SHIFT 10

#ifndef CTX_WIFI_NAME
#define CTX_WIFI_NAME     "test"
#endif
#ifndef CTX_WIFI_PASSWORD
#define CTX_WIFI_PASSWORD "testtesttest"
#endif

#ifndef assert
#define assert(a)
#endif

#ifndef CTX_NET
#define CTX_NET 0
#endif

#ifndef CTX_FONTGEN
#define CTX_FONTGEN 0
#endif

#if 0
#if CTX_FONT_ENGINE_HARFBUZZ==0
#undef CTX_FONTGEN
#define CTX_FONTGEN 0
#endif
#endif


#ifndef CTX_DECOMPRESSOR
#define CTX_DECOMPRESSOR 0
#endif

#ifndef CTX_COMPRESS
#define CTX_COMPRESS 0
#endif

#ifndef CTX_COMPRESS_NEEDLE_SIZE
#define CTX_COMPRESS_NEEDLE_SIZE 6
#endif

// compressing tiger.ctxc with only current frame reference
// 5 : 56760
// 6 : 55493
// 7 : 56188
// 8 : 58253

// smaller would be good for memory constrained
// devices where we still want this
#ifndef CTX_COMPRESS_HT_SIZE 
#define CTX_COMPRESS_HT_SIZE  (1024)
#endif

// same benchmark with tiger..
//16xxx - 55324
// 8192 - 55385
// 4096 - 55493
// 2048 - 55391
// 1024 - 55632
//  512 - 56269

#if CTX_FORMATTER==0
#undef CTX_NET
#define CTX_NET 0
#endif
#ifndef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE
#endif
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif

#ifndef CTX_STRING_H
#define CTX_STRING_H

typedef struct _CtxString CtxString;
struct _CtxString
{
  char *str;
  int   length;
  int   utf8_length;
  int   allocated_length;
  int   is_line;
};

CtxString   *ctx_string_new_with_size  (const char *initial, int initial_size);
CtxString   *ctx_string_new            (const char *initial);
CtxString   *ctx_string_new_printf (const char *format, ...);
char       *ctx_string_dissolve       (CtxString *string);
void        ctx_string_free           (CtxString *string, int freealloc);
const char *ctx_string_get            (CtxString *string);
uint32_t    ctx_string_get_unichar    (CtxString *string, int pos);
int         ctx_string_get_length     (CtxString *string);
int         ctx_string_get_utf8length (CtxString *string);
void        ctx_string_set            (CtxString *string, const char *new_string);
void        ctx_string_clear          (CtxString *string);
void        ctx_string_append_str     (CtxString *string, const char *str);
void        ctx_string_append_byte    (CtxString *string, char  val);
void        ctx_string_append_string  (CtxString *string, CtxString *string2);
void        ctx_string_append_unichar (CtxString *string, unsigned int unichar);
void        ctx_string_append_data    (CtxString *string, const char *data, int len);

void        ctx_string_pre_alloc       (CtxString *string, int size);
void        ctx_string_append_utf8char (CtxString *string, const char *str);
void        ctx_string_append_printf  (CtxString *string, const char *format, ...);
void        ctx_string_replace_utf8   (CtxString *string, int pos, const char *new_glyph);
void        ctx_string_insert_utf8    (CtxString *string, int pos, const char *new_glyph);

void        ctx_string_insert_unichar (CtxString *string, int pos, uint32_t unichar);
void        ctx_string_replace_unichar (CtxString *string, int pos, uint32_t unichar);
void        ctx_string_remove         (CtxString *string, int pos);
char       *ctx_strdup_printf         (const char *format, ...);
void        ctx_string_append_int     (CtxString *string, int val);
void        ctx_string_append_float   (CtxString *string, float val);

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#endif
#ifndef _CTX_INTERNAL_FONT_
#define _CTX_INTERNAL_FONT_

#ifndef CTX_FONT_ascii
/* glyph index: 
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi
  jklmnopqrstuvwxyz{|}~  */
static const struct __attribute__ ((packed)) {uint8_t code; uint32_t a; uint32_t b;}
ctx_font_ascii[]={
{15, 0x00000000, 0x000009b7},/* length:2487 CTX_SUBDIV:8 CTX_BAKE_FONT_SIZE:160 */
{'(', 0x00000010, 0x00000002},/* Roboto Regular*/
{32, 0x6f626f52, 0x52206f74},
{'e', 0x616c7567, 0x00000072},
{')', 0x00000010, 0x00000002},
{'(', 0x0000004b, 0x00000009},/* Apache Licence, Version 2.0
                                Copyright 2014 Christian Robertson - Apache 2*/
{32, 0x63617041, 0x4c206568},
{'i', 0x636e6563, 0x56202c65},
{'e', 0x6f697372, 0x2e32206e},
{'0', 0x706f430a, 0x67697279},
{'h', 0x30322074, 0x43203431},
{'h', 0x74736972, 0x206e6169},
{'R', 0x7265626f, 0x6e6f7374},
{32, 0x7041202d, 0x65686361},
{32, 0x00000032, 0x00000000},
{')', 0x0000004b, 0x00000009},
{'@', 0x00000020, 0x000027b0},/*                 x-advance: 39.687500 */
{'M', 0x00000000, 0x00000000},
{'[', 0x00540020, 0xfffffffb},/*kerning    T : -0.019531 */
{'@', 0x00000021, 0x00002940},/*        !        x-advance: 41.250000 */
{'M', 0x41e1a000, 0xc2e38000},
{'l', 0xbf820000, 0x42a34800},
{'4', 0x0000ff98, 0xfd73fff8},
{'l', 0x41728000, 0x00000000},
{'M', 0x41494000, 0xc0e88000},
{'8', 0xd111e400, 0xed32ed11},
{'8', 0x13320021, 0x2f111311},
{'8', 0x2eef1a00, 0x13ce13ef},
{'8', 0xedce00df, 0xd2efedef},
{'@', 0x00000022, 0x00003340},/*        "        x-advance: 51.250000 */
{'M', 0x41adc000, 0xc2dac000},
{'l', 0xc0160000, 0x41df2000},
{'l', 0xc10ac000, 0x00000000},
{'4', 0xfecc0000, 0x00000058},
{'l', 0x00000000, 0x412a0000},
{'M', 0x422b4000, 0xc2dac000},
{'l', 0xc0160000, 0x41df2000},
{'l', 0xc10ac000, 0x00000000},
{'l', 0x00000000, 0xc21a1000},
{'l', 0x41304000, 0x00000000},
{'l', 0x00000000, 0x412a0000},
{'[', 0x00220022, 0xfffffff3},/*kerning  " " : -0.050781 */
{'[', 0x00270022, 0xfffffff3},/*kerning  " ' : -0.050781 */
{'[', 0x00410022, 0xfffffff1},/*kerning  " A : -0.058594 */
{'[', 0x00610022, 0xfffffffa},/*kerning  " a : -0.023438 */
{'[', 0x00630022, 0xfffffff9},/*kerning  " c : -0.027344 */
{'[', 0x00640022, 0xfffffff9},/*kerning  " d : -0.027344 */
{'[', 0x00650022, 0xfffffff9},/*kerning  " e : -0.027344 */
{'[', 0x00670022, 0xfffffff9},/*kerning  " g : -0.027344 */
{'[', 0x006d0022, 0xfffffffe},/*kerning  " m : -0.007812 */
{'[', 0x006e0022, 0xfffffffe},/*kerning  " n : -0.007812 */
{'[', 0x006f0022, 0xfffffff9},/*kerning  " o : -0.027344 */
{'[', 0x00700022, 0xfffffffe},/*kerning  " p : -0.007812 */
{'[', 0x00710022, 0xfffffff9},/*kerning  " q : -0.027344 */
{'[', 0x00730022, 0xfffffff6},/*kerning  " s : -0.039062 */
{'[', 0x00770022, 0x00000001},/*kerning  " w : 0.003906 */
{'@', 0x00000023, 0x00006284},/*        #        x-advance: 98.515625 */
{'M', 0x42566000, 0x80000000},
{'l', 0x40c80000, 0xc2002000},
{'l', 0xc1a50000, 0x00000000},
{'l', 0xc0c80000, 0x42002000},
{'l', 0xc132c000, 0x80000000},
{'l', 0x40c80000, 0xc2002000},
{'l', 0xc1960000, 0x00000000},
{'l', 0x00000000, 0xc12c8000},
{'l', 0x41a6e000, 0x00000000},
{'l', 0x40aa0000, 0xc1dca000},
{'l', 0xc1a1e000, 0x00000000},
{'l', 0x00000000, 0xc12dc000},
{'l', 0x41b2c000, 0x00000000},
{'l', 0x40ca8000, 0xc2020000},
{'l', 0x41340000, 0x00000000},
{'l', 0xc0ca8000, 0x42020000},
{'l', 0x41a50000, 0x00000000},
{'l', 0x40ca8000, 0xc2020000},
{'l', 0x4132c000, 0x00000000},
{'l', 0xc0ca8000, 0x42020000},
{'l', 0x417dc000, 0x00000000},
{'l', 0x00000000, 0x412dc000},
{'l', 0xc18fc000, 0x00000000},
{'l', 0xc0ac8000, 0x41dca000},
{'l', 0x418c0000, 0x00000000},
{'l', 0x00000000, 0x412c8000},
{'4', 0x0000ff64, 0x0100ffce},
{'l', 0xc132c000, 0x80000000},
{'M', 0x42255000, 0xc22b4000},
{'l', 0x41a50000, 0x00000000},
{'l', 0x40ac8000, 0xc1dca000},
{'l', 0xc1a50000, 0x00000000},
{'l', 0xc0ac8000, 0x41dca000},
{'@', 0x00000024, 0x000059ec},/*        $        x-advance: 89.921875 */
{'M', 0x42a2d000, 0xc1eba000},
{'q', 0x00000000, 0x41598000},
{0, 0xc102a000, 0x41ab9000},
{'9', 0x003effbf, 0x004aff51},
{'4', 0x00770000, 0x0000ffa3},
{'l', 0x00000000, 0xc16d8000},
{'q', 0xc1408000, 0xbfa00000},
{0, 0xc1ac3000, 0xc112e000},
{'9', 0xffc1ffb5, 0xff33ffb5},
{'l', 0x41688000, 0x00000000},
{'q', 0x00000000, 0x41534000},
{0, 0x40e24000, 0x418ed000},
{'q', 0x40e24000, 0x4094c000},
{0, 0x416ba000, 0x4094c000},
{'q', 0x41278000, 0x00000000},
{0, 0x4181b000, 0xc09ec000},
{'8', 0x962dd92d, 0x9fd8c800},
{'q', 0xc0a3c000, 0xc0a3c000},
{0, 0xc18cf000, 0xc111a000},
{'q', 0xc16c4000, 0xc0960000},
{0, 0xc1b7c000, 0xc146c000},
{'q', 0xc1034000, 0xc0f78000},
{0, 0xc1034000, 0xc1aaa000},
{'q', 0x00000000, 0xc14f8000},
{0, 0x40f14000, 0xc1a87000},
{'9', 0xffc0003c, 0xffb300a3},
{'4', 0xff780000, 0x0000005d},
{'l', 0x00000000, 0x41898000},
{'q', 0x41520000, 0x3fdc0000},
{0, 0x41a37000, 0x412fa000},
{'9', 0x004a003a, 0x00ca003a},
{'l', 0xc1660000, 0x00000000},
{'q', 0x00000000, 0xc1278000},
{0, 0xc0a00000, 0xc189d000},
{'q', 0xc0a00000, 0xc0d84000},
{0, 0xc1660000, 0xc0d84000},
{'q', 0xc11d8000, 0x00000000},
{0, 0xc167e000, 0x40a14000},
{'8', 0x68db28db, 0x61243b00},
{'q', 0x40938000, 0x40988000},
{0, 0x419b5000, 0x411c4000},
{'q', 0x416ce000, 0x40a00000},
{0, 0x41b2c000, 0x41476000},
{'q', 0x40f14000, 0x40eec000},
{0, 0x40f14000, 0x41a5f000},
{'@', 0x00000025, 0x00007530},/*        %        x-advance: 117.187500 */
{'M', 0x41034000, 0xc2b7c000},
{'q', 0x00000000, 0xc11b0000},
{0, 0x40c80000, 0xc184d000},
{'q', 0x40c80000, 0xc0dd4000},
{0, 0x41884000, 0xc0dd4000},
{'q', 0x412f0000, 0x00000000},
{0, 0x41893000, 0x40dd4000},
{'9', 0x00370031, 0x00840031},
{'l', 0x00000000, 0x40c08000},
{'q', 0x00000000, 0x41188000},
{0, 0xc0c58000, 0x41839000},
{'q', 0xc0c58000, 0x40dd4000},
{0, 0xc1884000, 0x40dd4000},
{'q', 0xc12dc000, 0x00000000},
{0, 0xc1893000, 0xc0dd4000},
{'9', 0xffc9ffce, 0xff7dffce},
{'l', 0x00000000, 0xc0c08000},
{'M', 0x41988000, 0xc2abb800},
{'8', 0x4d182b00, 0x224b2218},
{'8', 0xde4a0032, 0xb318de18},
{'l', 0x00000000, 0xc0c08000},
{'8', 0xb2e8d500, 0xdeb5dee8},
{'8', 0x22b600ce, 0x4ee822e8},
{'l', 0x00000000, 0x40c08000},
{'M', 0x42b4f000, 0xc2c32800},
{'l', 0xc25e3000, 0x42b1d000},
{'4', 0xffd7ffbf, 0xfd3901bc},
{'l', 0x41020000, 0x40a50000},
{'M', 0x427e6000, 0xc1df2000},
{'q', 0x00000000, 0xc119c000},
{0, 0x40c80000, 0xc1843000},
{'q', 0x40c80000, 0xc0dd4000},
{0, 0x41884000, 0xc0dd4000},
{'q', 0x412f0000, 0x00000000},
{0, 0x41893000, 0x40dd4000},
{'9', 0x00370031, 0x00840031},
{'l', 0x00000000, 0x40c30000},
{'q', 0x00000000, 0x4119c000},
{0, 0xc0c58000, 0x41843000},
{'q', 0xc0c58000, 0x40dd4000},
{0, 0xc1884000, 0x40dd4000},
{'q', 0xc12f0000, 0x00000000},
{0, 0xc1898000, 0xc0dd4000},
{'9', 0xffc9ffce, 0xff7cffce},
{'l', 0x00000000, 0xc0c30000},
{'M', 0x4294e800, 0xc1ae6000},
{'8', 0x4e182b00, 0x224b2218},
{'8', 0xde4b0032, 0xb218de18},
{'l', 0x00000000, 0xc0c30000},
{'8', 0xb2e8d400, 0xdeb5dee8},
{'8', 0x22b600ce, 0x4ee822e8},
{'l', 0x00000000, 0x40c30000},
{'@', 0x00000026, 0x00006388},/*        &        x-advance: 99.531250 */
{'M', 0x42a32000, 0x80000000},
{'l', 0xc0f00000, 0xc10fc000},
{'q', 0xc0bb8000, 0x40a78000},
{0, 0xc15c0000, 0x40fc8000},
{'q', 0xc0fc8000, 0x402a0000},
{0, 0xc17b4000, 0x402a0000},
{'q', 0xc1884000, 0x00000000},
{0, 0xc1d70000, 0xc1110000},
{'q', 0xc11d8000, 0xc1110000},
{0, 0xc11d8000, 0xc1b90000},
{'q', 0x00000000, 0xc1228000},
{0, 0x40c44000, 0xc1893000},
{'q', 0x40c44000, 0xc0dfc000},
{0, 0x417e6000, 0xc15de000},
{'8', 0x97b6c8d2, 0x99e5cfe5},
{'q', 0x00000000, 0xc1548000},
{0, 0x40fa0000, 0xc1a37000},
{'q', 0x40fa0000, 0xc0e4c000},
{0, 0x41a5a000, 0xc0e4c000},
{'q', 0x41494000, 0x00000000},
{0, 0x419e7000, 0x40e4c000},
{'q', 0x40e74000, 0x40e4c000},
{0, 0x40e74000, 0x4186b000},
{'8', 0x6edf4100, 0x57a62ddf},
{'4', 0x0032ffbc, 0x00f200ca},
{'9', 0xffaf002a, 0xff4c002a},
{'l', 0x414f8000, 0x00000000},
{'9', 0x009f0000, 0x0108ffb4},
{'4', 0x009b0082, 0x0000ff76},
{'M', 0x41fd2000, 0xc2b06800},
{'9', 0x003a0000, 0x00960049},
{'l', 0x4105c000, 0xc0be0000},
{'8', 0xc93ce429, 0xb813e613},
{'8', 0xbde4dc00, 0xe2afe2e4},
{'8', 0x24ad00c9, 0x55e424e4},
{'M', 0x41b2c000, 0xc1f50000},
{'q', 0x00000000, 0x41048000},
{0, 0x40af0000, 0x4164c000},
{'q', 0x40af0000, 0x40c08000},
{0, 0x41866000, 0x40c08000},
{'9', 0x0000005c, 0xffbb00a8},
{'4', 0xfef7ff23, 0x0013ffe6},
{'8', 0x5bae31bd, 0x3df129f1},
{'@', 0x00000027, 0x00001bf8},/*        '        x-advance: 27.968750 */
{'M', 0x419ec000, 0xc2f00000},
{'l', 0x00000000, 0x41098000},
{'l', 0xbfd20000, 0x41e60000},
{'l', 0xc1214000, 0x00000000},
{'l', 0x3da00000, 0xc2156000},
{'l', 0x413a4000, 0x00000000},
{'[', 0x00220027, 0xfffffff3},/*kerning  ' " : -0.050781 */
{'[', 0x00270027, 0xfffffff3},/*kerning  ' ' : -0.050781 */
{'[', 0x00410027, 0xfffffff1},/*kerning  ' A : -0.058594 */
{'[', 0x00610027, 0xfffffffa},/*kerning  ' a : -0.023438 */
{'[', 0x00630027, 0xfffffff9},/*kerning  ' c : -0.027344 */
{'[', 0x00640027, 0xfffffff9},/*kerning  ' d : -0.027344 */
{'[', 0x00650027, 0xfffffff9},/*kerning  ' e : -0.027344 */
{'[', 0x00670027, 0xfffffff9},/*kerning  ' g : -0.027344 */
{'[', 0x006d0027, 0xfffffffe},/*kerning  ' m : -0.007812 */
{'[', 0x006e0027, 0xfffffffe},/*kerning  ' n : -0.007812 */
{'[', 0x006f0027, 0xfffffff9},/*kerning  ' o : -0.027344 */
{'[', 0x00700027, 0xfffffffe},/*kerning  ' p : -0.007812 */
{'[', 0x00710027, 0xfffffff9},/*kerning  ' q : -0.027344 */
{'[', 0x00730027, 0xfffffff6},/*kerning  ' s : -0.039062 */
{'[', 0x00770027, 0x00000001},/*kerning  ' w : 0.003906 */
{'@', 0x00000028, 0x000036c4},/*        (        x-advance: 54.765625 */
{'M', 0x41278000, 0xc2390000},
{'q', 0x00000000, 0xc1b54000},
{0, 0x40cf8000, 0xc21e7000},
{'q', 0x40cf8000, 0xc187a000},
{0, 0x41764000, 0xc1dd4000},
{'9', 0xffab0047, 0xff8a0082},
{'l', 0x40430000, 0x41188000},
{'q', 0xc1138000, 0x40de8000},
{0, 0xc1901000, 0x41c67000},
{'q', 0xc10ca000, 0x418ed000},
{0, 0xc10ca000, 0x4242d800},
{'q', 0x00000000, 0x41ed8000},
{0, 0x410ca000, 0x423ef000},
{'9', 0x00900046, 0x00cc0090},
{'l', 0xc0430000, 0x410c0000},
{'q', 0xc0ed8000, 0xc0820000},
{0, 0xc182a000, 0xc16c4000},
{'q', 0xc10e8000, 0xc12b4000},
{0, 0xc1764000, 0xc1dcf000},
{'q', 0xc0cf8000, 0xc1875000},
{0, 0xc0cf8000, 0xc2225800},
{'[', 0x00560028, 0x00000002},/*kerning  ( V : 0.007812 */
{'[', 0x00570028, 0x00000002},/*kerning  ( W : 0.007812 */
{'[', 0x00590028, 0x00000002},/*kerning  ( Y : 0.007812 */
{'@', 0x00000029, 0x000037b4},/*        )        x-advance: 55.703125 */
{'M', 0x42313000, 0xc235e000},
{'q', 0x00000000, 0x41b68000},
{0, 0xc0cf8000, 0x421f1000},
{'q', 0xc0cf8000, 0x4187a000},
{0, 0xc176e000, 0x41dd4000},
{'9', 0x0055ffb9, 0x0076ff7e},
{'l', 0xc0430000, 0xc10c0000},
{'q', 0x41124000, 0xc0de8000},
{0, 0x418fc000, 0xc1c9e000},
{'q', 0x410d4000, 0xc1924000},
{0, 0x410d4000, 0xc2449000},
{'q', 0x00000000, 0xc19e2000},
{0, 0xc08c0000, 0xc209f800},
{'q', 0xc08c0000, 0xc16ba000},
{0, 0xc12a0000, 0xc1c35000},
{'9', 0xffb3ffce, 0xff8fffa2},
{'l', 0x40430000, 0xc10d4000},
{'q', 0x40eb0000, 0x40848000},
{0, 0x41825000, 0x416d8000},
{'q', 0x410f2000, 0x412b4000},
{0, 0x4176e000, 0x41dcf000},
{'q', 0x40cf8000, 0x41875000},
{0, 0x40cf8000, 0x4221b800},
{'@', 0x0000002a, 0x000044e8},/*        *        x-advance: 68.906250 */
{'M', 0x41214000, 0xc25d4000},
{'l', 0x417b4000, 0xc1ac8000},
{'l', 0xc1bcc000, 0xc0e10000},
{'l', 0x406b0000, 0xc13b8000},
{'l', 0x41bcc000, 0x410ac000},
{'l', 0xbf340000, 0xc1d70000},
{'l', 0x413e0000, 0x00000000},
{'l', 0xbf480000, 0x41dac000},
{'l', 0x41ba4000, 0xc10ac000},
{'l', 0x40660000, 0x413f4000},
{'l', 0xc1bfe000, 0x40e38000},
{'l', 0x41764000, 0x41a96000},
{'l', 0xc11b0000, 0x40e88000},
{'l', 0xc1674000, 0xc1b40000},
{'l', 0xc1624000, 0x41afa000},
{'l', 0xc11c4000, 0xc0e38000},
{'@', 0x0000002b, 0x00005ac8},/*        +        x-advance: 90.781250 */
{'M', 0x42a82000, 0xc23db000},
{'l', 0xc1fdc000, 0x00000000},
{'l', 0x00000000, 0x42101000},
{'l', 0xc1674000, 0x00000000},
{'l', 0x00000000, 0xc2101000},
{'l', 0xc1fe6000, 0x00000000},
{'l', 0x00000000, 0xc1598000},
{'l', 0x41fe6000, 0x00000000},
{'l', 0x00000000, 0xc204d000},
{'l', 0x41674000, 0x00000000},
{'l', 0x00000000, 0x4204d000},
{'l', 0x41fdc000, 0x00000000},
{'l', 0x00000000, 0x41598000},
{'@', 0x0000002c, 0x00001f7c},/*        ,        x-advance: 31.484375 */
{'M', 0x41c12000, 0xc1898000},
{'l', 0x00000000, 0x413a4000},
{'q', 0x00000000, 0x40e38000},
{0, 0xc0660000, 0x4170a000},
{'9', 0x003fffe4, 0x0069ffb0},
{'l', 0xc1034000, 0xc0b68000},
{'9', 0xffad003c, 0xff55003d},
{'l', 0x00000000, 0xc14d0000},
{'l', 0x41624000, 0x00000000},
{'[', 0x0022002c, 0xffffffeb},/*kerning  , " : -0.082031 */
{'[', 0x0027002c, 0xffffffeb},/*kerning  , ' : -0.082031 */
{'@', 0x0000002d, 0x00002c38},/*        -        x-advance: 44.218750 */
{'M', 0x42246000, 0xc2593000},
{'l', 0x00000000, 0x413e0000},
{'l', 0xc2188000, 0x00000000},
{'l', 0x00000000, 0xc13e0000},
{'l', 0x42188000, 0x00000000},
{'@', 0x0000002e, 0x00002a30},/*        .        x-advance: 42.187500 */
{'M', 0x41340000, 0xc0f50000},
{'8', 0xcf12e300, 0xec35ec12},
{'8', 0x14350023, 0x31121412},
{'8', 0x30ee1c00, 0x14cb14ee},
{'8', 0xeccb00dd, 0xd0eeecee},
{'[', 0x0022002e, 0xffffffeb},/*kerning  . " : -0.082031 */
{'[', 0x0027002e, 0xffffffeb},/*kerning  . ' : -0.082031 */
{'@', 0x0000002f, 0x00004204},/*        /        x-advance: 66.015625 */
{'M', 0x42755000, 0xc2e38000},
{'l', 0xc23db000, 0x42f70800},
{'l', 0xc146c000, 0x00000000},
{'l', 0x423e0000, 0xc2f70800},
{'l', 0x41458000, 0x00000000},
{'[', 0x002f002f, 0xffffffe4},/*kerning  / / : -0.109375 */
{'@', 0x00000030, 0x000059ec},/*        0        x-advance: 89.921875 */
{'M', 0x42a1b800, 0xc2426000},
{'q', 0x00000000, 0x41dfc000},
{0, 0xc11a6000, 0x421c4000},
{'q', 0xc11a6000, 0x41318000},
{0, 0xc1d1b000, 0x41318000},
{'q', 0xc180c000, 0x00000000},
{0, 0xc1cf3000, 0xc12c8000},
{'9', 0xffaaffb2, 0xfed4ffb0},
{'l', 0x00000000, 0xc1992000},
{'q', 0x00000000, 0xc1df2000},
{0, 0x411c4000, 0xc21a8800},
{'q', 0x411c4000, 0xc12be000},
{0, 0x41d0c000, 0xc12be000},
{'q', 0x4182a000, 0x00000000},
{0, 0x41d02000, 0x4126e000},
{'9', 0x0053004d, 0x01290050},
{'l', 0x00000000, 0x41992000},
{'M', 0x4284a800, 0xc288b800},
{'q', 0x00000000, 0xc199c000},
{0, 0xc0af0000, 0xc1d98000},
{'q', 0xc0af0000, 0xc0ff0000},
{0, 0xc1802000, 0xc0ff0000},
{'q', 0xc1228000, 0x00000000},
{0, 0xc17aa000, 0x40f78000},
{'9', 0x003dffd4, 0x00d2ffd3},
{'l', 0x00000000, 0x41b9a000},
{'q', 0x00000000, 0x41988000},
{0, 0x40b2c000, 0x41dc0000},
{'q', 0x40b2c000, 0x41070000},
{0, 0x417e6000, 0x41070000},
{'q', 0x4128c000, 0x00000000},
{0, 0x417e6000, 0xc1052000},
{'q', 0x40ab4000, 0xc1052000},
{0, 0x40adc000, 0xc1d7f000},
{'l', 0x00000000, 0xc1b5e000},
{'@', 0x00000031, 0x000059ec},/*        1        x-advance: 89.921875 */
{'M', 0x4263d000, 0xc2e4c000},
{'l', 0x00000000, 0x42e4c000},
{'l', 0xc1674000, 0x80000000},
{'l', 0x00000000, 0xc2c0a800},
{'l', 0xc1e92000, 0x412a0000},
{'l', 0x00000000, 0xc150c000},
{'l', 0x42255000, 0xc17a0000},
{'l', 0x40110000, 0x00000000},
{'@', 0x00000032, 0x000059ec},/*        2        x-advance: 89.921875 */
{'M', 0x42a7f800, 0xc13e0000},
{'l', 0x00000000, 0x413e0000},
{'4', 0x0000fdad, 0xffad0000},
{'l', 0x421a6000, 0xc22be000},
{'q', 0x41188000, 0xc12c8000},
{0, 0x414da000, 0xc188e000},
{'q', 0x40548000, 0xc0ca8000},
{0, 0x40548000, 0xc14bc000},
{'q', 0x00000000, 0xc105c000},
{0, 0xc0a64000, 0xc164c000},
{'q', 0xc0a64000, 0xc0be0000},
{0, 0xc16a6000, 0xc0be0000},
{'q', 0xc1368000, 0x00000000},
{0, 0xc1884000, 0x40cf8000},
{'9', 0x0033ffd3, 0x0085ffd3},
{'l', 0xc1674000, 0x00000000},
{'q', 0x00000000, 0xc1660000},
{0, 0x41174000, 0xc1c58000},
{'q', 0x41174000, 0xc1250000},
{0, 0x41dd4000, 0xc1250000},
{'q', 0x4180c000, 0x00000000},
{0, 0x41c99000, 0x4105c000},
{'q', 0x4111a000, 0x4105c000},
{0, 0x4111a000, 0x41b04000},
{'q', 0x00000000, 0x41200000},
{0, 0xc0c58000, 0x41a0f000},
{'9', 0x0050ffcf, 0x009fff87},
{'l', 0xc1f3c000, 0x42043000},
{'l', 0x42642000, 0x00000000},
{'@', 0x00000033, 0x000059ec},/*        3        x-advance: 89.921875 */
{'M', 0x41f46000, 0xc2507000},
{'4', 0xffa10000, 0x00000055},
{'q', 0x4132c000, 0xbda00000},
{0, 0x41852000, 0xc0b40000},
{'q', 0x40af0000, 0xc0b18000},
{0, 0x40af0000, 0xc15d4000},
{'q', 0x00000000, 0xc1a00000},
{0, 0xc19ec000, 0xc1a00000},
{'q', 0xc1138000, 0x00000000},
{0, 0xc16ec000, 0x40a8c000},
{'9', 0x002affd3, 0x0071ffd3},
{'l', 0xc1674000, 0x00000000},
{'q', 0x00000000, 0xc150c000},
{0, 0x411a6000, 0xc1b18000},
{'q', 0x411a6000, 0xc1124000},
{0, 0x41cb7000, 0xc1124000},
{'q', 0x41764000, 0x00000000},
{0, 0x41c71000, 0x4102a000},
{'q', 0x4117e000, 0x4102a000},
{0, 0x4117e000, 0x41c03000},
{'8', 0x6cde3200, 0x599339de},
{'q', 0x41354000, 0x406b0000},
{0, 0x41778000, 0x41354000},
{'q', 0x40848000, 0x40f50000},
{0, 0x40848000, 0x41764000},
{'q', 0x00000000, 0x417f0000},
{0, 0xc1250000, 0x41c4e000},
{'q', 0xc1250000, 0x410ac000},
{0, 0xc1cda000, 0x410ac000},
{'q', 0xc16d8000, 0x00000000},
{0, 0xc1cbc000, 0xc103e000},
{'9', 0xffbfffab, 0xff45ffab},
{'l', 0x41674000, 0x00000000},
{'q', 0x00000000, 0x410fc000},
{0, 0x40ba4000, 0x41660000},
{'q', 0x40ba4000, 0x40ac8000},
{0, 0x417d2000, 0x40ac8000},
{'q', 0x411ec000, 0x00000000},
{0, 0x417b4000, 0xc0a78000},
{'q', 0x40b90000, 0xc0a78000},
{0, 0x40b90000, 0xc17dc000},
{'q', 0x00000000, 0xc12a0000},
{0, 0xc0d20000, 0xc17aa000},
{'q', 0xc0d20000, 0xc0a14000},
{0, 0xc18ca000, 0xc0a14000},
{'l', 0xc1250000, 0x00000000},
{'@', 0x00000034, 0x000059ec},/*        4        x-advance: 89.921875 */
{'M', 0x40848000, 0xc20bb000},
{'l', 0x424bc000, 0xc29da800},
{'l', 0x41764000, 0x00000000},
{'l', 0x00000000, 0x4296f000},
{'l', 0x417dc000, 0x00000000},
{'l', 0x00000000, 0x413e0000},
{'l', 0xc17dc000, 0x00000000},
{'l', 0x00000000, 0x41d34000},
{'l', 0xc1674000, 0x80000000},
{'4', 0xff2d0000, 0x0000fe61},
{'l', 0x00000000, 0xc1084000},
{'M', 0x41a46000, 0xc2192000},
{'l', 0x420de000, 0x00000000},
{'l', 0x00000000, 0xc25f7000},
{'l', 0xbfe60000, 0x404d0000},
{'l', 0xc206b000, 0x4252a000},
{'@', 0x00000035, 0x000059ec},/*        5        x-advance: 89.921875 */
{'M', 0x41dde000, 0xc2589000},
{'l', 0xc1390000, 0xc03e0000},
{'l', 0x40b68000, 0xc2629000},
{'l', 0x42697000, 0x00000000},
{'4', 0x006a0000, 0x0000fe90},
{'l', 0xc05c0000, 0x41f78000},
{'q', 0x41098000, 0xc09d8000},
{0, 0x4197e000, 0xc09d8000},
{'q', 0x417b4000, 0x00000000},
{0, 0x41c67000, 0x4125a000},
{'q', 0x4111a000, 0x4125a000},
{0, 0x4111a000, 0x41de3000},
{'q', 0x00000000, 0x4182a000},
{0, 0xc10e8000, 0x41d89000},
{'q', 0xc10e8000, 0x412be000},
{0, 0xc1d8e000, 0x412be000},
{'q', 0xc15d4000, 0x00000000},
{0, 0xc1bf4000, 0xc0f8c000},
{'9', 0xffc2ffb0, 0xff43ffa3},
{'l', 0x415c0000, 0x00000000},
{'q', 0x402f0000, 0x419ce000},
{0, 0x41ae6000, 0x419ce000},
{'q', 0x4123c000, 0x00000000},
{0, 0x417dc000, 0xc0de8000},
{'q', 0x40b40000, 0xc0de8000},
{0, 0x40b40000, 0xc196a000},
{'q', 0x00000000, 0xc12b4000},
{0, 0xc0bcc000, 0xc1901000},
{'q', 0xc0bcc000, 0xc0e9c000},
{0, 0xc186b000, 0xc0e9c000},
{'8', 0x0fa800c6, 0x2ac40fe2},
{'@', 0x00000036, 0x000059ec},/*        6        x-advance: 89.921875 */
{'M', 0x42a48800, 0xc2147000},
{'q', 0x00000000, 0x41816000},
{0, 0xc1106000, 0x41db6000},
{'q', 0xc1106000, 0x41340000},
{0, 0xc1d25000, 0x41340000},
{'q', 0xc1444000, 0x00000000},
{0, 0xc1a32000, 0xc0d0c000},
{'q', 0xc1020000, 0xc0d0c000},
{0, 0xc1426000, 0xc1848000},
{'9', 0xffb0ffe0, 0xff5cffe0},
{'l', 0x00000000, 0xc0d98000},
{'q', 0x00000000, 0xc1802000},
{0, 0x408fc000, 0xc1f78000},
{'q', 0x408fc000, 0xc16ec000},
{0, 0x41825000, 0xc1c3f000},
{'9', 0xffb4005e, 0xffb4010e},
{'4', 0x0000000a, 0x00620000},
{'q', 0xc1728000, 0x00000000},
{0, 0xc1bc7000, 0x40aa0000},
{'q', 0xc1066000, 0x40aa0000},
{0, 0xc1480000, 0x415ca000},
{'q', 0xc0834000, 0x4107a000},
{0, 0xc09ec000, 0x41915000},
{'q', 0x41110000, 0xc123c000},
{0, 0x41c3a000, 0xc123c000},
{'q', 0x41354000, 0x00000000},
{0, 0x41947000, 0x40af0000},
{'q', 0x40e74000, 0x40af0000},
{0, 0x412aa000, 0x4161a000},
{'9', 0x0045001b, 0x008f001b},
{'M', 0x41c76000, 0xc2269000},
{'q', 0x00000000, 0x41728000},
{0, 0x40d84000, 0x41b9a000},
{'q', 0x40d84000, 0x4100c000},
{0, 0x41746000, 0x4100c000},
{'q', 0x41200000, 0x00000000},
{0, 0x41782000, 0xc0e9c000},
{'q', 0x40b04000, 0xc0e9c000},
{0, 0x40b04000, 0xc195b000},
{'q', 0x00000000, 0xc1228000},
{0, 0xc0a28000, 0xc191a000},
{'q', 0xc0a28000, 0xc100c000},
{0, 0xc17a0000, 0xc100c000},
{'8', 0x249200c4, 0x58bc24cf},
{'l', 0x00000000, 0x40af0000},
{'@', 0x00000037, 0x000059ec},/*        7        x-advance: 89.921875 */
{'M', 0x42a5f000, 0xc2e38000},
{'l', 0x00000000, 0x41020000},
{'l', 0xc23c7000, 0x42d34000},
{'l', 0xc173c000, 0x80000000},
{'l', 0x423c2000, 0xc2cbc000},
{'l', 0xc2764000, 0x00000000},
{'l', 0x00000000, 0xc13e0000},
{'l', 0x4299c000, 0x00000000},
{'@', 0x00000038, 0x000059ec},/*        8        x-advance: 89.921875 */
{'M', 0x42a23000, 0xc1f64000},
{'q', 0x00000000, 0x417a0000},
{0, 0xc126e000, 0x41bfe000},
{'q', 0xc126e000, 0x4105c000},
{0, 0xc1cdf000, 0x4105c000},
{'q', 0xc1750000, 0x00000000},
{0, 0xc1cdf000, 0xc105c000},
{'q', 0xc126e000, 0xc105c000},
{0, 0xc126e000, 0xc1bfe000},
{'q', 0x00000000, 0xc1188000},
{0, 0x40a3c000, 0xc186b000},
{'8', 0xa86ec628, 0xada1e3c4},
{'q', 0xc08d4000, 0xc0d70000},
{0, 0xc08d4000, 0xc1714000},
{'q', 0x00000000, 0xc16ec000},
{0, 0x4117e000, 0xc1b86000},
{'q', 0x4117e000, 0xc1020000},
{0, 0x41c03000, 0xc1020000},
{'q', 0x4169c000, 0x00000000},
{0, 0x41c0d000, 0x41020000},
{'q', 0x4117e000, 0x41020000},
{0, 0x4117e000, 0x41b86000},
{'q', 0x00000000, 0x41070000},
{0, 0xc0910000, 0x4171e000},
{'q', 0xc0910000, 0x40d5c000},
{0, 0xc141c000, 0x4125a000},
{'q', 0x410d4000, 0x40700000},
{0, 0x41610000, 0x41318000},
{'9', 0x003a0029, 0x00860029},
{'M', 0x427ff000, 0xc2a7d000},
{'q', 0x00000000, 0xc1084000},
{0, 0xc0aa0000, 0xc1606000},
{'8', 0xd492d4d6, 0x2a9200bc},
{'q', 0xc0a78000, 0x40a8c000},
{0, 0xc0a78000, 0x41642000},
{'q', 0x00000000, 0x410d4000},
{0, 0x40a78000, 0x41624000},
{'8', 0x2a6e2a29, 0xd66e0044},
{'9', 0xffd6002a, 0xff8f002a},
{'M', 0x42852000, 0xc1f8c000},
{'q', 0x00000000, 0xc1188000},
{0, 0xc0c1c000, 0xc178c000},
{'q', 0xc0c1c000, 0xc0c08000},
{0, 0xc17be000, 0xc0c08000},
{'q', 0xc11ec000, 0x00000000},
{0, 0xc17be000, 0x40c08000},
{'q', 0xc0ba4000, 0x40c08000},
{0, 0xc0ba4000, 0x4178c000},
{'q', 0x00000000, 0x411d8000},
{0, 0x40ba4000, 0x41750000},
{'q', 0x40ba4000, 0x40af0000},
{0, 0x417e6000, 0x40af0000},
{'q', 0x41214000, 0x00000000},
{0, 0x417dc000, 0xc0af0000},
{'q', 0x40b90000, 0xc0af0000},
{0, 0x40b90000, 0xc1750000},
{'@', 0x00000039, 0x000059ec},/*        9        x-advance: 89.921875 */
{'M', 0x429ec000, 0xc2802000},
{'q', 0x00000000, 0x41318000},
{0, 0xbff50000, 0x41b31000},
{'q', 0xbff50000, 0x4134a000},
{0, 0xc0ed8000, 0x41a64000},
{'q', 0xc0b04000, 0x4117e000},
{0, 0xc1820000, 0x41746000},
{'9', 0x002effab, 0x002eff11},
{'l', 0x00000000, 0xc1444000},
{'q', 0x418a2000, 0x00000000},
{0, 0x41cd5000, 0xc0ac8000},
{'q', 0x41066000, 0xc0ac8000},
{0, 0x413b8000, 0xc161a000},
{'q', 0x40548000, 0xc10b6000},
{0, 0x406d8000, 0xc1947000},
{'8', 0x46aa2bdc, 0x1a921ace},
{'q', 0xc1340000, 0x00000000},
{0, 0xc1938000, 0xc0b40000},
{'q', 0xc0e60000, 0xc0b40000},
{0, 0xc12a0000, 0xc1656000},
{'q', 0xc05c0000, 0xc10b6000},
{0, 0xc05c0000, 0xc1901000},
{'q', 0x00000000, 0xc1820000},
{0, 0x410f2000, 0xc1de3000},
{'q', 0x410f2000, 0xc1386000},
{0, 0x41d2f000, 0xc1386000},
{'q', 0x414f8000, 0x00000000},
{0, 0x41a7d000, 0x40d70000},
{'q', 0x41002000, 0x40d70000},
{0, 0x413a4000, 0x418a2000},
{'9', 0x0054001d, 0x00b0001d},
{'l', 0x00000000, 0x40a78000},
{'M', 0x41b04000, 0xc2999800},
{'q', 0x00000000, 0x41228000},
{0, 0x40a3c000, 0x41938000},
{'q', 0x40a3c000, 0x41048000},
{0, 0x41782000, 0x41048000},
{'8', 0xdd6b003b, 0xa846dd30},
{'l', 0x00000000, 0xc0b68000},
{'q', 0x00000000, 0xc178c000},
{0, 0xc0d34000, 0xc1bea000},
{'q', 0xc0d34000, 0xc1048000},
{0, 0xc1746000, 0xc1048000},
{'q', 0xc1214000, 0x00000000},
{0, 0xc1796000, 0x40f3c000},
{'q', 0xc0b04000, 0x40f3c000},
{0, 0xc0b04000, 0x41979000},
{'@', 0x0000003a, 0x000026c0},/*        :        x-advance: 38.750000 */
{'M', 0x41264000, 0xc0f50000},
{'8', 0xcf12e300, 0xec35ec12},
{'8', 0x14350023, 0x31121412},
{'8', 0x30ee1c00, 0x14cb14ee},
{'8', 0xeccb00dd, 0xd0eeecee},
{'M', 0x41278000, 0xc2994800},
{'8', 0xcf12e300, 0xec35ec12},
{'8', 0x14350023, 0x31121412},
{'8', 0x30ee1c00, 0x14cb14ee},
{'8', 0xeccb00dd, 0xd0eeecee},
{'@', 0x0000003b, 0x000021d4},/*        ;        x-advance: 33.828125 */
{'M', 0x41098000, 0xc2994800},
{'8', 0xcf12e300, 0xec35ec12},
{'8', 0x14350023, 0x31121412},
{'8', 0x30ee1c00, 0x14cb14ee},
{'8', 0xeccb00dd, 0xd0eeecee},
{'M', 0x41c8a000, 0xc1898000},
{'l', 0x00000000, 0x413a4000},
{'q', 0x00000000, 0x40e38000},
{0, 0xc0660000, 0x4170a000},
{'9', 0x003fffe4, 0x0069ffb0},
{'l', 0xc1034000, 0xc0b68000},
{'9', 0xffad003c, 0xff55003d},
{'l', 0x00000000, 0xc14d0000},
{'l', 0x41624000, 0x00000000},
{'@', 0x0000003c, 0x00005154},/*        <        x-advance: 81.328125 */
{'M', 0x428b1000, 0xc1750000},
{'l', 0xc27fa000, 0xc1ece000},
{'l', 0x00000000, 0xc1354000},
{'l', 0x427fa000, 0xc1ec4000},
{'l', 0x00000000, 0x41750000},
{'l', 0xc2430000, 0x41a0a000},
{'l', 0x42430000, 0x419e2000},
{'l', 0x00000000, 0x41750000},
{'@', 0x0000003d, 0x000057d0},/*        =        x-advance: 87.812500 */
{'M', 0x429a1000, 0xc2985800},
{'l', 0x00000000, 0x41494000},
{'4', 0x0000fdf7, 0xff9c0000},
{'l', 0x42825000, 0x00000000},
{'M', 0x429a1000, 0xc22f0000},
{'l', 0x00000000, 0x41494000},
{'l', 0xc2825000, 0x00000000},
{'l', 0x00000000, 0xc1494000},
{'l', 0x42825000, 0x00000000},
{'@', 0x0000003e, 0x000053ac},/*        >        x-advance: 83.671875 */
{'M', 0x4128c000, 0xc2abe000},
{'l', 0x42857000, 0x41ec4000},
{'l', 0x00000000, 0x41368000},
{'l', 0xc2857000, 0x41ece000},
{'l', 0x00000000, 0xc16ec000},
{'l', 0x424ee000, 0xc1a46000},
{'l', 0xc24ee000, 0xc1a14000},
{'l', 0x00000000, 0xc16ec000},
{'@', 0x0000003f, 0x00004ba0},/*        ?        x-advance: 75.625000 */
{'M', 0x4229b000, 0xc2002000},
{'l', 0xc1688000, 0x00000000},
{'q', 0x3da00000, 0xc1354000},
{0, 0x40480000, 0xc187a000},
{'8', 0x9753d318, 0xaf4ad529},
{'8', 0x9a20da20, 0x9bdec000},
{'8', 0xdb9ddbde, 0x1d9e00c9},
{'9', 0x001dffd5, 0x005effd5},
{'l', 0xc1674000, 0x00000000},
{'q', 0x3e200000, 0xc1534000},
{0, 0x4116a000, 0xc1a5a000},
{'q', 0x41142000, 0xc0f00000},
{0, 0x41b63000, 0xc0f00000},
{'q', 0x416ec000, 0x00000000},
{0, 0x41b8b000, 0x40ff0000},
{'q', 0x4102a000, 0x40ff0000},
{0, 0x4102a000, 0x41adc000},
{'q', 0x00000000, 0x41278000},
{0, 0xc0c58000, 0x41965000},
{'q', 0xc0c58000, 0x41052000},
{0, 0xc1570000, 0x4170a000},
{'9', 0x0035ffc6, 0x009effc6},
{'M', 0x41da2000, 0xc0e88000},
{'8', 0xd111e400, 0xed32ed11},
{'8', 0x13330021, 0x2f111311},
{'8', 0x2eef1a00, 0x13cd13ef},
{'8', 0xedce00df, 0xd2efedef},
{'@', 0x00000040, 0x00008fac},/*        @        x-advance: 143.671875 */
{'M', 0x42c5a800, 0x41e38000},
{'q', 0xc0af0000, 0x40610000},
{0, 0xc15a2000, 0x40a78000},
{'q', 0xc102a000, 0x3fdc0000},
{0, 0xc176e000, 0x3fdc0000},
{'q', 0xc1ed8000, 0x00000000},
{0, 0xc2379800, 0xc19c9000},
{'q', 0xc181b000, 0xc19c9000},
{0, 0xc16ce000, 0xc254a800},
{'q', 0x3f700000, 0xc1ab4000},
{0, 0x41156000, 0xc218f800},
{'q', 0x41066000, 0xc186b000},
{0, 0x41b86000, 0xc1d43000},
{'q', 0x416a6000, 0xc11b0000},
{0, 0x42090800, 0xc11b0000},
{'q', 0x41f0a000, 0x00000000},
{0, 0x4236a800, 0x419ce000},
{'q', 0x41796000, 0x419ce000},
{0, 0x41642000, 0x42539000},
{'q', 0xbec80000, 0x4119c000},
{0, 0xc0688000, 0x41988000},
{'q', 0xc04f8000, 0x41174000},
{0, 0xc1228000, 0x417aa000},
{'q', 0xc0dd4000, 0x40c6c000},
{0, 0xc1915000, 0x40c6c000},
{'q', 0xc16b0000, 0x00000000},
{0, 0xc1960000, 0xc1548000},
{'q', 0xc1070000, 0x41548000},
{0, 0xc1a78000, 0x41548000},
{'q', 0xc137c000, 0x00000000},
{0, 0xc187a000, 0xc1174000},
{'q', 0xc0af0000, 0xc1174000},
{0, 0xc0820000, 0xc1c6c000},
{'q', 0x3fe60000, 0xc1a46000},
{0, 0x413c2000, 0xc2027800},
{'q', 0x411f6000, 0xc1412000},
{0, 0x41b09000, 0xc1412000},
{'8', 0x136a0043, 0x2e491326},
{'l', 0xc07f0000, 0x422d2000},
{'q', 0xbf820000, 0x41368000},
{0, 0x40250000, 0x416c4000},
{'q', 0x40660000, 0x40570000},
{0, 0x40ed8000, 0x40570000},
{'q', 0x41174000, 0x00000000},
{0, 0x41692000, 0xc1138000},
{'q', 0x40a3c000, 0xc1138000},
{0, 0x40b54000, 0xc1b36000},
{'q', 0x3faa0000, 0xc1e92000},
{0, 0xc12d2000, 0xc236d000},
{'q', 0xc1426000, 0xc1848000},
{0, 0xc21d5800, 0xc1848000},
{'q', 0xc1c4e000, 0x00000000},
{0, 0xc21ce000, 0x418e8000},
{'q', 0xc169c000, 0x418e8000},
{0, 0xc17c8000, 0x4239a000},
{'q', 0xbfb40000, 0x41e9c000},
{0, 0x413ae000, 0x42386000},
{'q', 0x41516000, 0x41870000},
{0, 0x42180800, 0x41870000},
{'8', 0xf36f0037, 0xdd5ef338},
{'l', 0x403e0000, 0x410e8000},
{'M', 0x425d9000, 0xc202a000},
{'q', 0xbf820000, 0x41304000},
{0, 0x40098000, 0x41884000},
{'8', 0x30503019, 0xe444001f},
{'9', 0xffe40024, 0xffa1003d},
{'4', 0xfffb0000, 0xfec7001c},
{'q', 0xc08c0000, 0xc0110000},
{0, 0xc1160000, 0xc0110000},
{'q', 0xc1084000, 0x00000000},
{0, 0xc16ce000, 0x410c0000},
{'q', 0xc0c94000, 0x410c0000},
{0, 0xc0fb4000, 0x41cee000},
{'@', 0x00000041, 0x00006860},/*        A        x-advance: 104.375000 */
{'M', 0x40110000, 0x80000000},
{'l', 0x422d7000, 0xc2e38000},
{'l', 0x41534000, 0x00000000},
{'l', 0x422e1000, 0x42e38000},
{'l', 0xc1778000, 0x80000000},
{'l', 0xc12dc000, 0xc1ee2000},
{'4', 0x0000fe84, 0x00eeffaa},
{'l', 0xc1764000, 0x80000000},
{'M', 0x4203e000, 0xc2287000},
{'l', 0x421a6000, 0x00000000},
{'l', 0xc19a6000, 0xc2543000},
{'l', 0xc19a6000, 0x42543000},
{'[', 0x00220041, 0xfffffff1},/*kerning  A " : -0.058594 */
{'[', 0x00270041, 0xfffffff1},/*kerning  A ' : -0.058594 */
{'[', 0x003f0041, 0xfffffff9},/*kerning  A ? : -0.027344 */
{'[', 0x00430041, 0xffffffff},/*kerning  A C : -0.003906 */
{'[', 0x00470041, 0xffffffff},/*kerning  A G : -0.003906 */
{'[', 0x004f0041, 0xffffffff},/*kerning  A O : -0.003906 */
{'[', 0x00510041, 0xffffffff},/*kerning  A Q : -0.003906 */
{'[', 0x00540041, 0xfffffff0},/*kerning  A T : -0.062500 */
{'[', 0x00550041, 0xfffffffe},/*kerning  A U : -0.007812 */
{'[', 0x00560041, 0xfffffff5},/*kerning  A V : -0.042969 */
{'[', 0x00570041, 0xfffffff8},/*kerning  A W : -0.031250 */
{'[', 0x00590041, 0xfffffff5},/*kerning  A Y : -0.042969 */
{'[', 0x006f0041, 0xffffffff},/*kerning  A o : -0.003906 */
{'[', 0x00740041, 0xfffffffe},/*kerning  A t : -0.007812 */
{'[', 0x00750041, 0xffffffff},/*kerning  A u : -0.003906 */
{'[', 0x00760041, 0xfffffffa},/*kerning  A v : -0.023438 */
{'[', 0x00770041, 0xfffffffc},/*kerning  A w : -0.015625 */
{'[', 0x00790041, 0xfffffffa},/*kerning  A y : -0.023438 */
{'[', 0x007a0041, 0x00000001},/*kerning  A z : 0.003906 */
{'@', 0x00000042, 0x000063b0},/*        B        x-advance: 99.687500 */
{'M', 0x42b54000, 0xc2034000},
{'q', 0x00000000, 0x417f0000},
{0, 0xc1246000, 0x41c30000},
{'9', 0x0043ffae, 0x0043ff26},
{'4', 0x0000fec2, 0xfc720000},
{'l', 0x42151000, 0x00000000},
{'q', 0x418c0000, 0x00000000},
{0, 0x41da7000, 0x40e74000},
{'q', 0x411ce000, 0x40e74000},
{0, 0x411ce000, 0x41b8b000},
{'q', 0x00000000, 0x40fc8000},
{0, 0xc08fc000, 0x41606000},
{'q', 0xc08fc000, 0x40c44000},
{0, 0xc144e000, 0x4117e000},
{'q', 0x4119c000, 0x402a0000},
{0, 0x416ba000, 0x41214000},
{'9', 0x003b0028, 0x00880028},
{'M', 0x41e24000, 0xc2cad000},
{'4', 0x01200000, 0x000000b5},
{'q', 0x411b0000, 0x00000000},
{0, 0x417a0000, 0xc09b0000},
{'q', 0x40be0000, 0xc09b0000},
{0, 0x40be0000, 0xc1570000},
{'9', 0xff750000, 0xff72ff58},
{'l', 0xc1b90000, 0x00000000},
{'M', 0x42974000, 0xc202a000},
{'q', 0x00000000, 0xc1188000},
{0, 0xc0a64000, 0xc170a000},
{'9', 0xffd4ffd7, 0xffd4ff7b},
{'4', 0x0000ff35, 0x01470000},
{'l', 0x41c62000, 0x00000000},
{'q', 0x412b4000, 0x00000000},
{0, 0x41852000, 0xc0b04000},
{'q', 0x40be0000, 0xc0b04000},
{0, 0x40be0000, 0xc16e2000},
{'[', 0x00540042, 0xfffffffd},/*kerning  B T : -0.011719 */
{'[', 0x00560042, 0xfffffffd},/*kerning  B V : -0.011719 */
{'[', 0x00590042, 0xfffffff9},/*kerning  B Y : -0.027344 */
{'@', 0x00000043, 0x00006824},/*        C        x-advance: 104.140625 */
{'M', 0x42a3c000, 0xc210b000},
{'l', 0x41700000, 0x00000000},
{'q', 0xbfdc0000, 0x41816000},
{0, 0xc1430000, 0x41d7a000},
{'q', 0xc1278000, 0x412c8000},
{0, 0xc1f78000, 0x412c8000},
{'q', 0xc19ec000, 0x00000000},
{0, 0xc1fff000, 0xc162e000},
{'9', 0xff8fff9f, 0xfed3ff9d},
{'l', 0x00000000, 0xc1430000},
{'q', 0x00000000, 0xc1bf4000},
{0, 0x4144e000, 0xc2197000},
{'q', 0x4144e000, 0xc1674000},
{0, 0x42059800, 0xc1674000},
{'q', 0x419a6000, 0x00000000},
{0, 0x41ed8000, 0x412a0000},
{'9', 0x00550053, 0x00db0060},
{'l', 0xc1700000, 0x00000000},
{'q', 0xbfdc0000, 0xc13e0000},
{0, 0xc0f50000, 0xc1965000},
{'q', 0xc0be0000, 0xc0dd4000},
{0, 0xc1992000, 0xc0dd4000},
{'q', 0xc1714000, 0x00000000},
{0, 0xc1b72000, 0x41318000},
{'9', 0x0058ffc2, 0x00e9ffc2},
{'l', 0x00000000, 0x4137c000},
{'q', 0x00000000, 0x41866000},
{0, 0x40e38000, 0x41e51000},
{'q', 0x40e38000, 0x413d6000},
{0, 0x41b22000, 0x413d6000},
{'q', 0x41660000, 0x00000000},
{0, 0x41a23000, 0xc0d70000},
{'q', 0x40bcc000, 0xc0d70000},
{0, 0x40fb4000, 0xc1960000},
{'[', 0x00290043, 0xfffffffd},/*kerning  C ) : -0.011719 */
{'[', 0x00540043, 0xfffffffd},/*kerning  C T : -0.011719 */
{'[', 0x005d0043, 0xffffffff},/*kerning  C ] : -0.003906 */
{'[', 0x007d0043, 0xfffffffe},/*kerning  C } : -0.007812 */
{'@', 0x00000044, 0x00006900},/*        D        x-advance: 105.000000 */
{'M', 0x41534000, 0x80000000},
{'4', 0xfc720000, 0x00000101},
{'q', 0x41b36000, 0x00000000},
{0, 0x42112800, 0x4166a000},
{'9', 0x0073006e, 0x0138006e},
{'l', 0x00000000, 0x40d98000},
{'q', 0x00000000, 0x41c58000},
{0, 0xc15f2000, 0x421c4000},
{'9', 0x0073ff91, 0x0073fed4},
{'l', 0xc1f64000, 0x80000000},
{'M', 0x41e24000, 0xc2cad000},
{'4', 0x02c90000, 0x0000007d},
{'q', 0x4191a000, 0x00000000},
{0, 0x41db6000, 0xc1340000},
{'9', 0xffa60049, 0xff110049},
{'l', 0x00000000, 0xc0de8000},
{'q', 0x00000000, 0xc19ce000},
{0, 0xc1138000, 0xc1f28000},
{'q', 0xc1138000, 0xc12b4000},
{0, 0xc1d02000, 0xc12b4000},
{'l', 0xc188e000, 0x00000000},
{'[', 0x002c0044, 0xfffffff3},/*kerning  D , : -0.050781 */
{'[', 0x002e0044, 0xfffffff3},/*kerning  D . : -0.050781 */
{'[', 0x00410044, 0xfffffffe},/*kerning  D A : -0.007812 */
{'[', 0x00540044, 0xfffffffd},/*kerning  D T : -0.011719 */
{'[', 0x00560044, 0xfffffffe},/*kerning  D V : -0.007812 */
{'[', 0x00580044, 0xfffffffe},/*kerning  D X : -0.007812 */
{'[', 0x00590044, 0xfffffffb},/*kerning  D Y : -0.019531 */
{'[', 0x005a0044, 0xfffffffe},/*kerning  D Z : -0.007812 */
{'@', 0x00000045, 0x00005af0},/*        E        x-advance: 90.937500 */
{'M', 0x41534000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x428ef800, 0x00000000},
{'l', 0x00000000, 0x41458000},
{'l', 0xc261a000, 0x00000000},
{'l', 0x00000000, 0x42124000},
{'l', 0x4244e000, 0x00000000},
{'l', 0x00000000, 0x41444000},
{'l', 0xc244e000, 0x00000000},
{'l', 0x00000000, 0x42214000},
{'l', 0x4264c000, 0x00000000},
{'l', 0x00000000, 0x41444000},
{'l', 0xc2908800, 0x80000000},
{'[', 0x00540045, 0x00000002},/*kerning  E T : 0.007812 */
{'[', 0x00630045, 0xfffffffe},/*kerning  E c : -0.007812 */
{'[', 0x00640045, 0xfffffffe},/*kerning  E d : -0.007812 */
{'[', 0x00650045, 0xfffffffe},/*kerning  E e : -0.007812 */
{'[', 0x00660045, 0xfffffffe},/*kerning  E f : -0.007812 */
{'[', 0x00670045, 0xfffffffe},/*kerning  E g : -0.007812 */
{'[', 0x006f0045, 0xfffffffe},/*kerning  E o : -0.007812 */
{'[', 0x00710045, 0xfffffffe},/*kerning  E q : -0.007812 */
{'[', 0x00750045, 0xfffffffe},/*kerning  E u : -0.007812 */
{'[', 0x00760045, 0xfffffffd},/*kerning  E v : -0.011719 */
{'[', 0x00770045, 0xfffffffe},/*kerning  E w : -0.007812 */
{'[', 0x00790045, 0xfffffffd},/*kerning  E y : -0.011719 */
{'@', 0x00000046, 0x00005870},/*        F        x-advance: 88.437500 */
{'M', 0x41534000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x428cf000, 0x00000000},
{'l', 0x00000000, 0x41458000},
{'l', 0xc25d9000, 0x00000000},
{'l', 0x00000000, 0x421b5000},
{'l', 0x423ea000, 0x00000000},
{'l', 0x00000000, 0x41458000},
{'l', 0xc23ea000, 0x00000000},
{'l', 0x00000000, 0x4248f000},
{'l', 0xc1714000, 0x80000000},
{'[', 0x002c0046, 0xffffffe3},/*kerning  F , : -0.113281 */
{'[', 0x002e0046, 0xffffffe3},/*kerning  F . : -0.113281 */
{'[', 0x00410046, 0xffffffeb},/*kerning  F A : -0.082031 */
{'[', 0x004a0046, 0xffffffdf},/*kerning  F J : -0.128906 */
{'[', 0x00540046, 0x00000002},/*kerning  F T : 0.007812 */
{'[', 0x00610046, 0xfffffffc},/*kerning  F a : -0.015625 */
{'[', 0x00630046, 0xfffffffe},/*kerning  F c : -0.007812 */
{'[', 0x00640046, 0xfffffffe},/*kerning  F d : -0.007812 */
{'[', 0x00650046, 0xfffffffe},/*kerning  F e : -0.007812 */
{'[', 0x00670046, 0xfffffffe},/*kerning  F g : -0.007812 */
{'[', 0x006f0046, 0xfffffffe},/*kerning  F o : -0.007812 */
{'[', 0x00710046, 0xfffffffe},/*kerning  F q : -0.007812 */
{'[', 0x00720046, 0xfffffffd},/*kerning  F r : -0.011719 */
{'[', 0x00750046, 0xfffffffe},/*kerning  F u : -0.007812 */
{'[', 0x00760046, 0xfffffffd},/*kerning  F v : -0.011719 */
{'[', 0x00790046, 0xfffffffd},/*kerning  F y : -0.011719 */
{'@', 0x00000047, 0x00006cfc},/*        G        x-advance: 108.984375 */
{'M', 0x42c28800, 0xc2629000},
{'l', 0x00000000, 0x42269000},
{'q', 0xc04d0000, 0x40960000},
{0, 0xc1430000, 0x412a0000},
{'q', 0xc10fc000, 0x40be0000},
{0, 0xc1e06000, 0x40be0000},
{'q', 0xc1a64000, 0x00000000},
{0, 0xc2089000, 0xc1642000},
{'9', 0xff8eff96, 0xfec2ff96},
{'l', 0x00000000, 0xc10d4000},
{'q', 0x00000000, 0xc1cb2000},
{0, 0x413e0000, 0xc21ec000},
{'q', 0x413e0000, 0xc164c000},
{0, 0x4207a000, 0xc164c000},
{'q', 0x419c4000, 0x00000000},
{0, 0x41ed3000, 0x411d8000},
{'9', 0x004e0050, 0x00c80062},
{'l', 0xc1714000, 0x00000000},
{'q', 0xbfc80000, 0xc1138000},
{0, 0xc0f64000, 0xc17dc000},
{'q', 0xc0c44000, 0xc0d48000},
{0, 0xc1997000, 0xc0d48000},
{'q', 0xc17b4000, 0x00000000},
{0, 0xc1b90000, 0x4130e000},
{'9', 0x0058ffc5, 0x00f0ffc4},
{'l', 0x00000000, 0x41160000},
{'q', 0x00000000, 0x419d8000},
{0, 0x410e8000, 0x41f5f000},
{'q', 0x410e8000, 0x4130e000},
{0, 0x41bc2000, 0x4130e000},
{'q', 0x4141c000, 0x00000000},
{0, 0x418c0000, 0xc0368000},
{'9', 0xffea002b, 0xffd5003d},
{'l', 0x00000000, 0xc1cbc000},
{'l', 0xc1d2a000, 0x00000000},
{'l', 0x00000000, 0xc1430000},
{'l', 0x42255000, 0x00000000},
{'@', 0x00000048, 0x00007224},/*        H        x-advance: 114.140625 */
{'M', 0x42ab4000, 0x80000000},
{'l', 0x00000000, 0xc2525000},
{'l', 0xc2656000, 0x00000000},
{'l', 0x00000000, 0x42525000},
{'l', 0xc1714000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x41714000, 0x00000000},
{'l', 0x00000000, 0x4243a000},
{'l', 0x42656000, 0x00000000},
{'l', 0x00000000, 0xc243a000},
{'l', 0x41700000, 0x00000000},
{'l', 0x00000000, 0x42e38000},
{'l', 0xc1700000, 0x80000000},
{'[', 0x00410048, 0x00000002},/*kerning  H A : 0.007812 */
{'[', 0x00540048, 0xfffffffd},/*kerning  H T : -0.011719 */
{'[', 0x00580048, 0x00000002},/*kerning  H X : 0.007812 */
{'[', 0x00590048, 0xfffffffd},/*kerning  H Y : -0.011719 */
{'@', 0x00000049, 0x00002b84},/*        I        x-advance: 43.515625 */
{'M', 0x41eb0000, 0xc2e38000},
{'l', 0x00000000, 0x42e38000},
{'l', 0xc1714000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x41714000, 0x00000000},
{'[', 0x00410049, 0x00000002},/*kerning  I A : 0.007812 */
{'[', 0x00540049, 0xfffffffd},/*kerning  I T : -0.011719 */
{'[', 0x00580049, 0x00000002},/*kerning  I X : 0.007812 */
{'[', 0x00590049, 0xfffffffd},/*kerning  I Y : -0.011719 */
{'@', 0x0000004a, 0x00005848},/*        J        x-advance: 88.281250 */
{'M', 0x4273c000, 0xc2e38000},
{'4', 0x00000078, 0x02840000},
{'q', 0x00000000, 0x41870000},
{0, 0xc121e000, 0x41ce9000},
{'q', 0xc121e000, 0x410f2000},
{0, 0xc1cdf000, 0x410f2000},
{'q', 0xc17b4000, 0x00000000},
{0, 0xc1ce9000, 0xc1020000},
{'9', 0xffbfffb0, 0xff39ffb0},
{'l', 0x41714000, 0x00000000},
{'q', 0x00000000, 0x412c8000},
{0, 0x40ba4000, 0x417c8000},
{'q', 0x40ba4000, 0x40a00000},
{0, 0x4170a000, 0x40a00000},
{'q', 0x410e8000, 0x00000000},
{0, 0x416e2000, 0xc0b68000},
{'q', 0x40bf4000, 0xc0b68000},
{0, 0x40bf4000, 0xc1866000},
{'l', 0x00000000, 0xc2a11800},
{'[', 0x0041004a, 0xfffffffe},/*kerning  J A : -0.007812 */
{'@', 0x0000004b, 0x00006464},/*        K        x-advance: 100.390625 */
{'M', 0x42a4d800, 0x80000000},
{'l', 0xc220f000, 0xc253e000},
{'l', 0xc15e8000, 0x41674000},
{'l', 0x00000000, 0x421a1000},
{'l', 0xc1714000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x41714000, 0x00000000},
{'l', 0x00000000, 0x42606000},
{'l', 0x424a3000, 0xc2606000},
{'l', 0x41910000, 0x00000000},
{'l', 0xc232c000, 0x4248f000},
{'l', 0x42408000, 0x427e1000},
{'l', 0xc18fc000, 0x80000000},
{'[', 0x002d004b, 0xfffffff8},/*kerning  K - : -0.031250 */
{'[', 0x0043004b, 0xfffffffd},/*kerning  K C : -0.011719 */
{'[', 0x0047004b, 0xfffffffd},/*kerning  K G : -0.011719 */
{'[', 0x004f004b, 0xfffffffd},/*kerning  K O : -0.011719 */
{'[', 0x0051004b, 0xfffffffd},/*kerning  K Q : -0.011719 */
{'[', 0x0063004b, 0xfffffffd},/*kerning  K c : -0.011719 */
{'[', 0x0064004b, 0xfffffffd},/*kerning  K d : -0.011719 */
{'[', 0x0065004b, 0xfffffffd},/*kerning  K e : -0.011719 */
{'[', 0x0067004b, 0xfffffffd},/*kerning  K g : -0.011719 */
{'[', 0x006d004b, 0xfffffffe},/*kerning  K m : -0.007812 */
{'[', 0x006e004b, 0xfffffffe},/*kerning  K n : -0.007812 */
{'[', 0x006f004b, 0xfffffffd},/*kerning  K o : -0.011719 */
{'[', 0x0070004b, 0xfffffffe},/*kerning  K p : -0.007812 */
{'[', 0x0071004b, 0xfffffffd},/*kerning  K q : -0.011719 */
{'[', 0x0075004b, 0xfffffffe},/*kerning  K u : -0.007812 */
{'[', 0x0076004b, 0xfffffffb},/*kerning  K v : -0.019531 */
{'[', 0x0077004b, 0xfffffff8},/*kerning  K w : -0.031250 */
{'[', 0x0079004b, 0xfffffffb},/*kerning  K y : -0.019531 */
{'@', 0x0000004c, 0x0000562c},/*        L        x-advance: 86.171875 */
{'M', 0x42a46000, 0xc1444000},
{'l', 0x00000000, 0x41444000},
{'l', 0xc289f800, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x41714000, 0x00000000},
{'l', 0x00000000, 0x42caf800},
{'l', 0x4257a000, 0x00000000},
{'[', 0x0022004c, 0xffffffd6},/*kerning  L " : -0.164062 */
{'[', 0x0027004c, 0xffffffd6},/*kerning  L ' : -0.164062 */
{'[', 0x0041004c, 0x00000002},/*kerning  L A : 0.007812 */
{'[', 0x0043004c, 0xfffffff8},/*kerning  L C : -0.031250 */
{'[', 0x0047004c, 0xfffffff8},/*kerning  L G : -0.031250 */
{'[', 0x004f004c, 0xfffffff8},/*kerning  L O : -0.031250 */
{'[', 0x0051004c, 0xfffffff8},/*kerning  L Q : -0.031250 */
{'[', 0x0054004c, 0xffffffdd},/*kerning  L T : -0.136719 */
{'[', 0x0055004c, 0xfffffffa},/*kerning  L U : -0.023438 */
{'[', 0x0056004c, 0xffffffea},/*kerning  L V : -0.085938 */
{'[', 0x0057004c, 0xffffffee},/*kerning  L W : -0.070312 */
{'[', 0x0059004c, 0xffffffe2},/*kerning  L Y : -0.117188 */
{'[', 0x0075004c, 0xfffffffb},/*kerning  L u : -0.019531 */
{'[', 0x0076004c, 0xfffffff0},/*kerning  L v : -0.062500 */
{'[', 0x0077004c, 0xfffffff5},/*kerning  L w : -0.042969 */
{'[', 0x0079004c, 0xfffffff0},/*kerning  L y : -0.062500 */
{'@', 0x0000004d, 0x00008bb0},/*        M        x-advance: 139.687500 */
{'M', 0x428bb000, 0xc1a82000},
{'l', 0x4214c000, 0xc2b97800},
{'l', 0x419b0000, 0x00000000},
{'l', 0x00000000, 0x42e38000},
{'l', 0xc1700000, 0x80000000},
{'l', 0x00000000, 0xc2318000},
{'l', 0x3fbe0000, 0xc23e5000},
{'l', 0xc215b000, 0x42b7e800},
{'l', 0xc1368000, 0x80000000},
{'l', 0xc2156000, 0xc2b83800},
{'l', 0x3fbe0000, 0x423ef000},
{'l', 0x00000000, 0x42318000},
{'l', 0xc1700000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x419b0000, 0x00000000},
{'l', 0x42151000, 0x42b97800},
{'[', 0x0041004d, 0x00000002},/*kerning  M A : 0.007812 */
{'[', 0x0054004d, 0xfffffffd},/*kerning  M T : -0.011719 */
{'[', 0x0058004d, 0x00000002},/*kerning  M X : 0.007812 */
{'[', 0x0059004d, 0xfffffffd},/*kerning  M Y : -0.011719 */
{'@', 0x0000004e, 0x00007224},/*        N        x-advance: 114.140625 */
{'M', 0x42c96800, 0xc2e38000},
{'l', 0x00000000, 0x42e38000},
{'l', 0xc1728000, 0x80000000},
{'l', 0xc2651000, 0xc2af7800},
{'l', 0x00000000, 0x42af7800},
{'l', 0xc1714000, 0x80000000},
{'l', 0x00000000, 0xc2e38000},
{'l', 0x41714000, 0x00000000},
{'l', 0x42660000, 0x42aff000},
{'l', 0x00000000, 0xc2aff000},
{'l', 0x416ec000, 0x00000000},
{'[', 0x0041004e, 0x00000002},/*kerning  N A : 0.007812 */
{'[', 0x0054004e, 0xfffffffd},/*kerning  N T : -0.011719 */
{'[', 0x0058004e, 0x00000002},/*kerning  N X : 0.007812 */
{'[', 0x0059004e, 0xfffffffd},/*kerning  N Y : -0.011719 */
{'@', 0x0000004f, 0x00006e14},/*        O        x-advance: 110.078125 */
{'M', 0x42c99000, 0xc2552000},
{'q', 0x00000000, 0x41cd0000},
{0, 0xc146c000, 0x4220f000},
{'q', 0xc146c000, 0x4169c000},
{0, 0xc204d000, 0x4169c000},
{'q', 0xc1a1e000, 0x00000000},
{0, 0xc2043000, 0xc169c000},
{'9', 0xff8cff9a, 0xfebfff9a},
{'l', 0x00000000, 0xc0e60000},
{'q', 0x00000000, 0xc1cc6000},
{0, 0x414bc000, 0xc220c800},
{'q', 0x414bc000, 0xc16a6000},
{0, 0x4203e000, 0xc16a6000},
{'q', 0x41a50000, 0x00000000},
{0, 0x42045800, 0x4166a000},
{'9', 0x00730063, 0x013b0065},
{'l', 0x00000000, 0x41020000},
{'M', 0x42abb800, 0xc2728000},
{'q', 0x00000000, 0xc1a28000},
{0, 0xc1020000, 0xc1f8c000},
{'q', 0xc1020000, 0xc12c8000},
{0, 0xc1b5e000, 0xc12c8000},
{'q', 0xc15fc000, 0x00000000},
{0, 0xc1b31000, 0x412c8000},
{'9', 0x0056ffbd, 0x00f8ffbd},
{'l', 0x00000000, 0x40eb0000},
{'q', 0x00000000, 0x41a3c000},
{0, 0x4107a000, 0x41fa5000},
{'q', 0x4107a000, 0x412d2000},
{0, 0x41b3b000, 0x412d2000},
{'q', 0x416b0000, 0x00000000},
{0, 0x41b59000, 0xc12d2000},
{'q', 0x41002000, 0xc12d2000},
{0, 0x41002000, 0xc1fa5000},
{'l', 0x00000000, 0xc0eb0000},
{'[', 0x002c004f, 0xfffffff3},/*kerning  O , : -0.050781 */
{'[', 0x002e004f, 0xfffffff3},/*kerning  O . : -0.050781 */
{'[', 0x0041004f, 0xfffffffe},/*kerning  O A : -0.007812 */
{'[', 0x0054004f, 0xfffffffd},/*kerning  O T : -0.011719 */
{'[', 0x0056004f, 0xfffffffe},/*kerning  O V : -0.007812 */
{'[', 0x0058004f, 0xfffffffe},/*kerning  O X : -0.007812 */
{'[', 0x0059004f, 0xfffffffb},/*kerning  O Y : -0.019531 */
{'[', 0x005a004f, 0xfffffffe},/*kerning  O Z : -0.007812 */
{'@', 0x00000050, 0x000064f0},/*        P        x-advance: 100.937500 */
{'M', 0x41e24000, 0xc2327000},
{'l', 0x00000000, 0x42327000},
{'4', 0x0000ff88, 0xfc720000},
{'l', 0x4227d000, 0x00000000},
{'q', 0x419b0000, 0x00000000},
{0, 0x41ed3000, 0x411c4000},
{'q', 0x41246000, 0x411c4000},
{0, 0x41246000, 0x41c76000},
{'q', 0x00000000, 0x4183e000},
{0, 0xc1246000, 0x41cbc000},
{'9', 0x0047ffae, 0x0047ff13},
{'l', 0xc1d70000, 0x00000000},
{'M', 0x41e24000, 0xc2cad000},
{'4', 0x01640000, 0x000000d7},
{'q', 0x41548000, 0x00000000},
{0, 0x41988000, 0xc0c58000},
{'q', 0x40b90000, 0xc0c58000},
{0, 0x40b90000, 0xc17dc000},
{'q', 0x00000000, 0xc10c0000},
{0, 0xc0b90000, 0xc17a0000},
{'q', 0xc0b90000, 0xc0dc0000},
{0, 0xc1988000, 0xc0dc0000},
{'l', 0xc1d70000, 0x00000000},
{'[', 0x002c0050, 0xffffffd7},/*kerning  P , : -0.160156 */
{'[', 0x002e0050, 0xffffffd7},/*kerning  P . : -0.160156 */
{'[', 0x00410050, 0xffffffef},/*kerning  P A : -0.066406 */
{'[', 0x004a0050, 0xffffffe7},/*kerning  P J : -0.097656 */
{'[', 0x00580050, 0xfffffffd},/*kerning  P X : -0.011719 */
{'[', 0x005a0050, 0xfffffffd},/*kerning  P Z : -0.011719 */
{'[', 0x00610050, 0xffffffff},/*kerning  P a : -0.003906 */
{'[', 0x00630050, 0xffffffff},/*kerning  P c : -0.003906 */
{'[', 0x00640050, 0xffffffff},/*kerning  P d : -0.003906 */
{'[', 0x00650050, 0xffffffff},/*kerning  P e : -0.003906 */
{'[', 0x00670050, 0xffffffff},/*kerning  P g : -0.003906 */
{'[', 0x006f0050, 0xffffffff},/*kerning  P o : -0.003906 */
{'[', 0x00710050, 0xffffffff},/*kerning  P q : -0.003906 */
{'[', 0x00740050, 0x00000001},/*kerning  P t : 0.003906 */
{'[', 0x00760050, 0x00000001},/*kerning  P v : 0.003906 */
{'[', 0x00790050, 0x00000001},/*kerning  P y : 0.003906 */
{'@', 0x00000051, 0x00006e14},/*        Q        x-advance: 110.078125 */
{'M', 0x42c8f000, 0x411d8000},
{'4', 0x004bffaf, 0xff68ff41},
{'q', 0xc0b40000, 0x3fb40000},
{0, 0xc13e0000, 0x3fb40000},
{'q', 0xc1a1e000, 0x00000000},
{0, 0xc2043000, 0xc169c000},
{'9', 0xff8cff9a, 0xfebfff9a},
{'l', 0x00000000, 0xc0e60000},
{'q', 0x00000000, 0xc1cc6000},
{0, 0x414bc000, 0xc220c800},
{'q', 0x414bc000, 0xc16a6000},
{0, 0x4203e000, 0xc16a6000},
{'q', 0x41a50000, 0x00000000},
{0, 0x42045800, 0x4166a000},
{'9', 0x00730063, 0x013b0065},
{'l', 0x00000000, 0x41020000},
{'q', 0x00000000, 0x41834000},
{0, 0xc0a78000, 0x41e33000},
{'9', 0x005fffd7, 0x0095ff8c},
{'l', 0x41a1e000, 0x41802000},
{'M', 0x42aa5000, 0xc2728000},
{'q', 0x00000000, 0xc1a28000},
{0, 0xc1020000, 0xc1f8c000},
{'q', 0xc1020000, 0xc12c8000},
{0, 0xc1b5e000, 0xc12c8000},
{'q', 0xc15fc000, 0x00000000},
{0, 0xc1b31000, 0x412c8000},
{'9', 0x0056ffbd, 0x00f8ffbd},
{'l', 0x00000000, 0x40eb0000},
{'q', 0x00000000, 0x41a3c000},
{0, 0x4107a000, 0x41fa5000},
{'q', 0x4107a000, 0x412d2000},
{0, 0x41b3b000, 0x412d2000},
{'q', 0x416b0000, 0x00000000},
{0, 0x41b59000, 0xc12d2000},
{'q', 0x41002000, 0xc12d2000},
{0, 0x41002000, 0xc1fa5000},
{'l', 0x00000000, 0xc0eb0000},
{'[', 0x00540051, 0xfffffffb},/*kerning  Q T : -0.019531 */
{'[', 0x00560051, 0xfffffffd},/*kerning  Q V : -0.011719 */
{'[', 0x00570051, 0xfffffffe},/*kerning  Q W : -0.007812 */
{'[', 0x00590051, 0xfffffffc},/*kerning  Q Y : -0.015625 */
{'@', 0x00000052, 0x00006298},/*        R        x-advance: 98.593750 */
{'M', 0x429f6000, 0x80000000},
{'l', 0xc1c58000, 0xc2386000},
{'l', 0xc1d5c000, 0x00000000},
{'l', 0x00000000, 0x42386000},
{'4', 0x0000ff88, 0xfc720000},
{'l', 0x4216a000, 0x00000000},
{'q', 0x41992000, 0x00000000},
{0, 0x41ebf000, 0x410c0000},
{'q', 0x4125a000, 0x410c0000},
{0, 0x4125a000, 0x41cb2000},
{'q', 0x00000000, 0x412a0000},
{0, 0xc0b7c000, 0x41947000},
{'9', 0x003fffd3, 0x005eff81},
{'4', 0x018200d5, 0x00070000},
{'l', 0xc180c000, 0x80000000},
{'M', 0x41e24000, 0xc2cad000},
{'4', 0x01580000, 0x000000b8},
{'q', 0x4141c000, 0x00000000},
{0, 0x4191f000, 0xc0c6c000},
{'q', 0x40c44000, 0xc0c6c000},
{0, 0x40c44000, 0xc170a000},
{'q', 0x00000000, 0xc11d8000},
{0, 0xc0bcc000, 0xc17d2000},
{'q', 0xc0bcc000, 0xc0bf4000},
{0, 0xc1979000, 0xc0bf4000},
{'l', 0xc1b4a000, 0x00000000},
{'[', 0x00540052, 0xfffffff6},/*kerning  R T : -0.039062 */
{'[', 0x00560052, 0xfffffffe},/*kerning  R V : -0.007812 */
{'[', 0x00590052, 0xfffffffa},/*kerning  R Y : -0.023438 */
{'@', 0x00000053, 0x00005f00},/*        S        x-advance: 95.000000 */
{'M', 0x4293a800, 0xc1e60000},
{'q', 0x00000000, 0xc0fa0000},
{0, 0xc0a8c000, 0xc1480000},
{'q', 0xc0a8c000, 0xc0960000},
{0, 0xc1b13000, 0xc11a6000},
{'q', 0xc1870000, 0xc09ec000},
{0, 0xc1d57000, 0xc14a8000},
{'q', 0xc11ce000, 0xc0f64000},
{0, 0xc11ce000, 0xc1a69000},
{'q', 0x00000000, 0xc1548000},
{0, 0x41296000, 0xc1b0e000},
{'q', 0x41296000, 0xc10d4000},
{0, 0x41e0b000, 0xc10d4000},
{'q', 0x4199c000, 0x00000000},
{0, 0x41ed3000, 0x4128c000},
{'9', 0x00540053, 0x00be0053},
{'l', 0xc1700000, 0x00000000},
{'q', 0x00000000, 0xc1188000},
{0, 0xc0c58000, 0xc17c8000},
{'q', 0xc0c58000, 0xc0c80000},
{0, 0xc1974000, 0xc0c80000},
{'q', 0xc1408000, 0x00000000},
{0, 0xc18e8000, 0x40a8c000},
{'8', 0x69d22ad2, 0x5e313800},
{'q', 0x40c44000, 0x40974000},
{0, 0x419fb000, 0x410a2000},
{'q', 0x419e2000, 0x40b18000},
{0, 0x41e6a000, 0x415b6000},
{'q', 0x41110000, 0x4102a000},
{0, 0x41110000, 0x41ab9000},
{'q', 0x00000000, 0x415e8000},
{0, 0xc12dc000, 0x41b18000},
{'q', 0xc12dc000, 0x41048000},
{0, 0xc1e6a000, 0x41048000},
{'q', 0xc1278000, 0x00000000},
{0, 0xc1a2d000, 0xc07a0000},
{'q', 0xc11e2000, 0xc07a0000},
{0, 0xc1820000, 0xc139a000},
{'9', 0xffc3ffce, 0xff68ffce},
{'l', 0x41700000, 0x00000000},
{'q', 0x00000000, 0x413a4000},
{0, 0x41084000, 0x4187a000},
{'q', 0x41084000, 0x40aa0000},
{0, 0x419ba000, 0x40aa0000},
{'q', 0x413cc000, 0x00000000},
{0, 0x41915000, 0xc09c4000},
{'q', 0x40cbc000, 0xc09c4000},
{0, 0x40cbc000, 0xc152a000},
{'@', 0x00000054, 0x00005f78},/*        T        x-advance: 95.468750 */
{'M', 0x407a0000, 0xc2cad000},
{'l', 0x00000000, 0xc1458000},
{'l', 0x42afc800, 0x00000000},
{'l', 0x00000000, 0x41458000},
{'l', 0xc2124000, 0x00000000},
{'l', 0x00000000, 0x42cad000},
{'l', 0xc16d8000, 0x80000000},
{'l', 0x00000000, 0xc2cad000},
{'l', 0xc211f000, 0x00000000},
{'[', 0x00200054, 0xfffffffb},/*kerning  T   : -0.019531 */
{'[', 0x002c0054, 0xffffffe5},/*kerning  T , : -0.105469 */
{'[', 0x002d0054, 0xffffffe3},/*kerning  T - : -0.113281 */
{'[', 0x002e0054, 0xffffffe5},/*kerning  T . : -0.105469 */
{'[', 0x00410054, 0xfffffff6},/*kerning  T A : -0.039062 */
{'[', 0x00430054, 0xfffffffd},/*kerning  T C : -0.011719 */
{'[', 0x00470054, 0xfffffffd},/*kerning  T G : -0.011719 */
{'[', 0x004a0054, 0xffffffe2},/*kerning  T J : -0.117188 */
{'[', 0x004f0054, 0xfffffffd},/*kerning  T O : -0.011719 */
{'[', 0x00510054, 0xfffffffd},/*kerning  T Q : -0.011719 */
{'[', 0x00530054, 0xfffffffe},/*kerning  T S : -0.007812 */
{'[', 0x00540054, 0x00000002},/*kerning  T T : 0.007812 */
{'[', 0x00560054, 0x00000002},/*kerning  T V : 0.007812 */
{'[', 0x00570054, 0x00000001},/*kerning  T W : 0.003906 */
{'[', 0x00590054, 0x00000002},/*kerning  T Y : 0.007812 */
{'[', 0x00610054, 0xfffffff2},/*kerning  T a : -0.054688 */
{'[', 0x00630054, 0xfffffff4},/*kerning  T c : -0.046875 */
{'[', 0x00640054, 0xfffffff4},/*kerning  T d : -0.046875 */
{'[', 0x00650054, 0xfffffff4},/*kerning  T e : -0.046875 */
{'[', 0x00670054, 0xfffffff4},/*kerning  T g : -0.046875 */
{'[', 0x006d0054, 0xfffffff3},/*kerning  T m : -0.050781 */
{'[', 0x006e0054, 0xfffffff3},/*kerning  T n : -0.050781 */
{'[', 0x006f0054, 0xfffffff4},/*kerning  T o : -0.046875 */
{'[', 0x00700054, 0xfffffff3},/*kerning  T p : -0.050781 */
{'[', 0x00710054, 0xfffffff4},/*kerning  T q : -0.046875 */
{'[', 0x00720054, 0xfffffff7},/*kerning  T r : -0.035156 */
{'[', 0x00730054, 0xfffffff2},/*kerning  T s : -0.054688 */
{'[', 0x00750054, 0xfffffff4},/*kerning  T u : -0.046875 */
{'[', 0x00760054, 0xfffffff7},/*kerning  T v : -0.035156 */
{'[', 0x00770054, 0xfffffff9},/*kerning  T w : -0.027344 */
{'[', 0x00780054, 0xfffffff7},/*kerning  T x : -0.035156 */
{'[', 0x00790054, 0xfffffff7},/*kerning  T y : -0.035156 */
{'[', 0x007a0054, 0xfffffff9},/*kerning  T z : -0.027344 */
{'@', 0x00000055, 0x000067c0},/*        U        x-advance: 103.750000 */
{'M', 0x429c9000, 0xc2e38000},
{'4', 0x00000078, 0x02670000},
{'q', 0x00000000, 0x4199c000},
{0, 0xc1458000, 0x41e65000},
{'q', 0xc1458000, 0x41192000},
{0, 0xc1e74000, 0x41192000},
{'q', 0xc18b6000, 0x00000000},
{0, 0xc1ea1000, 0xc1192000},
{'9', 0xffb4ffa2, 0xff1affa2},
{'4', 0xfd990000, 0x00000077},
{'l', 0x00000000, 0x4299e800},
{'q', 0x00000000, 0x4155c000},
{0, 0x40e74000, 0x419dd000},
{'q', 0x40e74000, 0x40cbc000},
{0, 0x41979000, 0x40cbc000},
{'q', 0x413e0000, 0x00000000},
{0, 0x41988000, 0xc0cbc000},
{'q', 0x40e60000, 0xc0cbc000},
{0, 0x40e60000, 0xc19dd000},
{'l', 0x00000000, 0xc299e800},
{'[', 0x00410055, 0xfffffffe},/*kerning  U A : -0.007812 */
{'@', 0x00000056, 0x000065e0},/*        V        x-advance: 101.875000 */
{'M', 0x42c78800, 0xc2e38000},
{'l', 0xc2287000, 0x42e38000},
{'l', 0xc155c000, 0x80000000},
{'l', 0xc2282000, 0xc2e38000},
{'l', 0x4182a000, 0x00000000},
{'l', 0x42011000, 0x42bb8000},
{'l', 0x42025000, 0xc2bb8000},
{'l', 0x4182a000, 0x00000000},
{'[', 0x00290056, 0x00000002},/*kerning  V ) : 0.007812 */
{'[', 0x002c0056, 0xffffffe4},/*kerning  V , : -0.109375 */
{'[', 0x002d0056, 0xfffffffc},/*kerning  V - : -0.015625 */
{'[', 0x002e0056, 0xffffffe4},/*kerning  V . : -0.109375 */
{'[', 0x00410056, 0xfffffff7},/*kerning  V A : -0.035156 */
{'[', 0x00430056, 0xffffffff},/*kerning  V C : -0.003906 */
{'[', 0x00470056, 0xffffffff},/*kerning  V G : -0.003906 */
{'[', 0x004f0056, 0xffffffff},/*kerning  V O : -0.003906 */
{'[', 0x00510056, 0xffffffff},/*kerning  V Q : -0.003906 */
{'[', 0x005d0056, 0x00000002},/*kerning  V ] : 0.007812 */
{'[', 0x00610056, 0xfffffffb},/*kerning  V a : -0.019531 */
{'[', 0x00630056, 0xfffffffb},/*kerning  V c : -0.019531 */
{'[', 0x00640056, 0xfffffffb},/*kerning  V d : -0.019531 */
{'[', 0x00650056, 0xfffffffb},/*kerning  V e : -0.019531 */
{'[', 0x00670056, 0xfffffffb},/*kerning  V g : -0.019531 */
{'[', 0x006f0056, 0xfffffffb},/*kerning  V o : -0.019531 */
{'[', 0x00710056, 0xfffffffb},/*kerning  V q : -0.019531 */
{'[', 0x00720056, 0xfffffffd},/*kerning  V r : -0.011719 */
{'[', 0x00750056, 0xfffffffd},/*kerning  V u : -0.011719 */
{'[', 0x00760056, 0xffffffff},/*kerning  V v : -0.003906 */
{'[', 0x00790056, 0xffffffff},/*kerning  V y : -0.003906 */
{'[', 0x007d0056, 0x00000002},/*kerning  V } : 0.007812 */
{'@', 0x00000057, 0x00008df4},/*        W        x-advance: 141.953125 */
{'M', 0x430a8400, 0xc2e38000},
{'l', 0xc1dc0000, 0x42e38000},
{'l', 0xc15ac000, 0x80000000},
{'l', 0xc1bb8000, 0xc2a5c800},
{'l', 0xbfe60000, 0xc10ac000},
{'l', 0xbfe60000, 0x410ac000},
{'l', 0xc1c26000, 0x42a5c800},
{'l', 0xc15ac000, 0x80000000},
{'l', 0xc1dca000, 0xc2e38000},
{'l', 0x41700000, 0x00000000},
{'l', 0x418fc000, 0x429ba000},
{'l', 0x40110000, 0x41714000},
{'l', 0x40480000, 0xc1584000},
{'l', 0x41b4a000, 0xc29ec000},
{'l', 0x41494000, 0x00000000},
{'l', 0x41afa000, 0x429ec000},
{'l', 0x404d0000, 0x415d4000},
{'l', 0x401b0000, 0xc1778000},
{'l', 0x418ca000, 0xc29b7800},
{'l', 0x41714000, 0x00000000},
{'[', 0x00290057, 0x00000001},/*kerning  W ) : 0.003906 */
{'[', 0x002c0057, 0xfffffff1},/*kerning  W , : -0.058594 */
{'[', 0x002d0057, 0xfffffff9},/*kerning  W - : -0.027344 */
{'[', 0x002e0057, 0xfffffff1},/*kerning  W . : -0.058594 */
{'[', 0x00410057, 0xfffffffb},/*kerning  W A : -0.019531 */
{'[', 0x00540057, 0x00000001},/*kerning  W T : 0.003906 */
{'[', 0x005d0057, 0x00000001},/*kerning  W ] : 0.003906 */
{'[', 0x00610057, 0xfffffffc},/*kerning  W a : -0.015625 */
{'[', 0x00630057, 0xfffffffd},/*kerning  W c : -0.011719 */
{'[', 0x00640057, 0xfffffffd},/*kerning  W d : -0.011719 */
{'[', 0x00650057, 0xfffffffd},/*kerning  W e : -0.011719 */
{'[', 0x00670057, 0xfffffffd},/*kerning  W g : -0.011719 */
{'[', 0x006f0057, 0xfffffffd},/*kerning  W o : -0.011719 */
{'[', 0x00710057, 0xfffffffd},/*kerning  W q : -0.011719 */
{'[', 0x00720057, 0xfffffffe},/*kerning  W r : -0.007812 */
{'[', 0x00750057, 0xfffffffe},/*kerning  W u : -0.007812 */
{'[', 0x007d0057, 0x00000001},/*kerning  W } : 0.003906 */
{'@', 0x00000058, 0x00006450},/*        X        x-advance: 100.312500 */
{'M', 0x41b7c000, 0xc2e38000},
{'l', 0x41dac000, 0x422e6000},
{'l', 0x41dac000, 0xc22e6000},
{'l', 0x418ca000, 0x00000000},
{'l', 0xc20fc000, 0x42615000},
{'l', 0x42133000, 0x4265b000},
{'l', 0xc18de000, 0x80000000},
{'l', 0xc1e06000, 0xc231d000},
{'l', 0xc1e06000, 0x4231d000},
{'l', 0xc18de000, 0x80000000},
{'l', 0x42133000, 0xc265b000},
{'l', 0xc20fc000, 0xc2615000},
{'l', 0x418ca000, 0x00000000},
{'[', 0x002d0058, 0xfffffffb},/*kerning  X - : -0.019531 */
{'[', 0x00430058, 0xfffffffd},/*kerning  X C : -0.011719 */
{'[', 0x00470058, 0xfffffffd},/*kerning  X G : -0.011719 */
{'[', 0x004f0058, 0xfffffffd},/*kerning  X O : -0.011719 */
{'[', 0x00510058, 0xfffffffd},/*kerning  X Q : -0.011719 */
{'[', 0x00560058, 0x00000001},/*kerning  X V : 0.003906 */
{'[', 0x00630058, 0xfffffffd},/*kerning  X c : -0.011719 */
{'[', 0x00640058, 0xfffffffd},/*kerning  X d : -0.011719 */
{'[', 0x00650058, 0xfffffffd},/*kerning  X e : -0.011719 */
{'[', 0x00670058, 0xfffffffd},/*kerning  X g : -0.011719 */
{'[', 0x006f0058, 0xfffffffe},/*kerning  X o : -0.007812 */
{'[', 0x00710058, 0xfffffffd},/*kerning  X q : -0.011719 */
{'[', 0x00750058, 0xfffffffe},/*kerning  X u : -0.007812 */
{'[', 0x00760058, 0xfffffffd},/*kerning  X v : -0.011719 */
{'[', 0x00790058, 0xfffffffd},/*kerning  X y : -0.011719 */
{'@', 0x00000059, 0x00006018},/*        Y        x-advance: 96.093750 */
{'M', 0x41938000, 0xc2e38000},
{'l', 0x41ec4000, 0x42647000},
{'l', 0x41ece000, 0xc2647000},
{'l', 0x4188e000, 0x00000000},
{'l', 0xc21ce000, 0x428e8000},
{'l', 0x00000000, 0x422a0000},
{'l', 0xc1714000, 0x80000000},
{'l', 0x00000000, 0xc22a0000},
{'l', 0xc21ce000, 0xc28e8000},
{'l', 0x418a2000, 0x00000000},
{'[', 0x00260059, 0xfffffffd},/*kerning  Y & : -0.011719 */
{'[', 0x00290059, 0x00000002},/*kerning  Y ) : 0.007812 */
{'[', 0x002a0059, 0xfffffffa},/*kerning  Y * : -0.023438 */
{'[', 0x002c0059, 0xffffffe6},/*kerning  Y , : -0.101562 */
{'[', 0x002d0059, 0xfffffffa},/*kerning  Y - : -0.023438 */
{'[', 0x002e0059, 0xffffffe6},/*kerning  Y . : -0.101562 */
{'[', 0x00410059, 0xfffffff5},/*kerning  Y A : -0.042969 */
{'[', 0x00430059, 0xfffffffd},/*kerning  Y C : -0.011719 */
{'[', 0x00470059, 0xfffffffd},/*kerning  Y G : -0.011719 */
{'[', 0x004a0059, 0xfffffff4},/*kerning  Y J : -0.046875 */
{'[', 0x004f0059, 0xfffffffd},/*kerning  Y O : -0.011719 */
{'[', 0x00510059, 0xfffffffd},/*kerning  Y Q : -0.011719 */
{'[', 0x00530059, 0xfffffffe},/*kerning  Y S : -0.007812 */
{'[', 0x00540059, 0x00000002},/*kerning  Y T : 0.007812 */
{'[', 0x00550059, 0xfffffff4},/*kerning  Y U : -0.046875 */
{'[', 0x00560059, 0x00000002},/*kerning  Y V : 0.007812 */
{'[', 0x00570059, 0x00000002},/*kerning  Y W : 0.007812 */
{'[', 0x00580059, 0x00000001},/*kerning  Y X : 0.003906 */
{'[', 0x00590059, 0x00000002},/*kerning  Y Y : 0.007812 */
{'[', 0x005d0059, 0x00000002},/*kerning  Y ] : 0.007812 */
{'[', 0x00610059, 0xfffffff7},/*kerning  Y a : -0.035156 */
{'[', 0x00630059, 0xfffffff8},/*kerning  Y c : -0.031250 */
{'[', 0x00640059, 0xfffffff8},/*kerning  Y d : -0.031250 */
{'[', 0x00650059, 0xfffffff8},/*kerning  Y e : -0.031250 */
{'[', 0x00660059, 0xfffffffe},/*kerning  Y f : -0.007812 */
{'[', 0x00670059, 0xfffffff8},/*kerning  Y g : -0.031250 */
{'[', 0x006d0059, 0xfffffffb},/*kerning  Y m : -0.019531 */
{'[', 0x006e0059, 0xfffffffb},/*kerning  Y n : -0.019531 */
{'[', 0x006f0059, 0xfffffff8},/*kerning  Y o : -0.031250 */
{'[', 0x00700059, 0xfffffffb},/*kerning  Y p : -0.019531 */
{'[', 0x00710059, 0xfffffff8},/*kerning  Y q : -0.031250 */
{'[', 0x00720059, 0xfffffffb},/*kerning  Y r : -0.019531 */
{'[', 0x00730059, 0xfffffff9},/*kerning  Y s : -0.027344 */
{'[', 0x00740059, 0xfffffffe},/*kerning  Y t : -0.007812 */
{'[', 0x00750059, 0xfffffffc},/*kerning  Y u : -0.015625 */
{'[', 0x00760059, 0xfffffffe},/*kerning  Y v : -0.007812 */
{'[', 0x00780059, 0xfffffffe},/*kerning  Y x : -0.007812 */
{'[', 0x00790059, 0xfffffffe},/*kerning  Y y : -0.007812 */
{'[', 0x007a0059, 0xfffffffd},/*kerning  Y z : -0.011719 */
{'[', 0x007d0059, 0x00000002},/*kerning  Y } : 0.007812 */
{'@', 0x0000005a, 0x00005fdc},/*        Z        x-advance: 95.859375 */
{'M', 0x40fa0000, 0xc2cad000},
{'l', 0x00000000, 0xc1458000},
{'l', 0x429e7000, 0x00000000},
{'l', 0x00000000, 0x412f0000},
{'l', 0xc27a0000, 0x42b51800},
{'l', 0x42820000, 0x00000000},
{'l', 0x00000000, 0x41444000},
{'l', 0xc2a57800, 0x80000000},
{'l', 0x00000000, 0xc1340000},
{'l', 0x42796000, 0xc2b45000},
{'l', 0xc2755000, 0x00000000},
{'[', 0x0041005a, 0x00000001},/*kerning  Z A : 0.003906 */
{'[', 0x0043005a, 0xfffffffd},/*kerning  Z C : -0.011719 */
{'[', 0x0047005a, 0xfffffffd},/*kerning  Z G : -0.011719 */
{'[', 0x004f005a, 0xfffffffd},/*kerning  Z O : -0.011719 */
{'[', 0x0051005a, 0xfffffffd},/*kerning  Z Q : -0.011719 */
{'[', 0x0063005a, 0xfffffffe},/*kerning  Z c : -0.007812 */
{'[', 0x0064005a, 0xfffffffe},/*kerning  Z d : -0.007812 */
{'[', 0x0065005a, 0xfffffffe},/*kerning  Z e : -0.007812 */
{'[', 0x0067005a, 0xfffffffe},/*kerning  Z g : -0.007812 */
{'[', 0x006f005a, 0xfffffffe},/*kerning  Z o : -0.007812 */
{'[', 0x0071005a, 0xfffffffe},/*kerning  Z q : -0.007812 */
{'[', 0x0075005a, 0xfffffffe},/*kerning  Z u : -0.007812 */
{'[', 0x0076005a, 0xfffffffd},/*kerning  Z v : -0.011719 */
{'[', 0x0077005a, 0xfffffffd},/*kerning  Z w : -0.011719 */
{'[', 0x0079005a, 0xfffffffd},/*kerning  Z y : -0.011719 */
{'@', 0x0000005b, 0x00002a6c},/*        [        x-advance: 42.421875 */
{'M', 0x42237000, 0xc3020000},
{'l', 0x00000000, 0x413e0000},
{'l', 0xc16ec000, 0x00000000},
{'l', 0x00000000, 0x4302a000},
{'l', 0x416ec000, 0x00000000},
{'l', 0x00000000, 0x413e0000},
{'l', 0xc1eb0000, 0x00000000},
{'l', 0x00000000, 0xc31a6000},
{'l', 0x41eb0000, 0x00000000},
{'[', 0x004a005b, 0xfffffffe},/*kerning  [ J : -0.007812 */
{'[', 0x0055005b, 0xfffffffe},/*kerning  [ U : -0.007812 */
{'@', 0x0000005c, 0x000041b4},/*       \         x-advance: 65.703125 */
{'M', 0x424ad000, 0x411c4000},
{'l', 0xc23e0000, 0xc2f70800},
{'l', 0x415c0000, 0x00000000},
{'l', 0x423e0000, 0x42f70800},
{'l', 0xc15c0000, 0x00000000},
{'@', 0x0000005d, 0x00002a6c},/*        ]        x-advance: 42.421875 */
{'M', 0x3f480000, 0xc2ec4000},
{'l', 0x00000000, 0xc13e0000},
{'l', 0x41ec4000, 0x00000000},
{'l', 0x00000000, 0x431a6000},
{'l', 0xc1ec4000, 0x00000000},
{'l', 0x00000000, 0xc13e0000},
{'l', 0x41700000, 0x00000000},
{'l', 0x00000000, 0xc302a000},
{'l', 0xc1700000, 0x00000000},
{'@', 0x0000005e, 0x000042e0},/*        ^        x-advance: 66.875000 */
{'M', 0x40a00000, 0xc263d000},
{'l', 0x41bae000, 0xc2633000},
{'l', 0x41200000, 0x00000000},
{'l', 0x41ba4000, 0x42633000},
{'l', 0xc1570000, 0x00000000},
{'l', 0xc16d8000, 0xc216f000},
{'l', 0xc16ec000, 0x4216f000},
{'l', 0xc1570000, 0x00000000},
{'@', 0x0000005f, 0x00004830},/*        _        x-advance: 72.187500 */
{'M', 0x428fe800, 0x80000000},
{'l', 0x00000000, 0x413e0000},
{'l', 0xc28f4800, 0x00000000},
{'l', 0x00000000, 0xc13e0000},
{'l', 0x428f4800, 0x80000000},
{'@', 0x00000060, 0x00003174},/*        `        x-advance: 49.453125 */
{'M', 0x41afa000, 0xc2f00000},
{'l', 0x41714000, 0x41b7c000},
{'l', 0xc146c000, 0x00000000},
{'l', 0xc1a14000, 0xc1b7c000},
{'l', 0x418c0000, 0x00000000},
{'@', 0x00000061, 0x00005708},/*        a        x-advance: 87.031250 */
{'M', 0x427cd000, 0x80000000},
{'8', 0xb9f0e8f5, 0x3baf22e0},
{'q', 0xc0c30000, 0x40458000},
{0, 0xc15e8000, 0x40458000},
{'q', 0xc14f8000, 0x00000000},
{0, 0xc1a64000, 0xc0e88000},
{'q', 0xc0fa0000, 0xc0e88000},
{0, 0xc0fa0000, 0xc18e8000},
{'q', 0x00000000, 0xc1598000},
{0, 0x41250000, 0xc1a55000},
{'9', 0xffc80052, 0xffc800dd},
{'4', 0x00000072, 0xffcb0000},
{'8', 0xa1ddc400, 0xdd96dddd},
{'8', 0x209700bf, 0x4ad820d8},
{'l', 0xc1674000, 0x00000000},
{'q', 0x00000000, 0xc1110000},
{0, 0x41124000, 0xc1884000},
{'q', 0x41124000, 0xc0ff0000},
{0, 0x41c3a000, 0xc0ff0000},
{'q', 0x415c0000, 0x00000000},
{0, 0x41b4a000, 0x40e10000},
{'9', 0x00380046, 0x00aa0046},
{'l', 0x00000000, 0x4217e000},
{'9', 0x005d0000, 0x00940017},
{'4', 0x000a0000, 0x0000ff88},
{'M', 0x421ce000, 0xc1318000},
{'8', 0xe16c003e, 0xbb40e12d},
{'4', 0xff750000, 0x0000ff95},
{'q', 0xc1c30000, 0x3ef00000},
{0, 0xc1c30000, 0x417a0000},
{'8', 0x51203000, 0x21602120},
{'[', 0x00220061, 0xfffffff8},/*kerning  a " : -0.031250 */
{'[', 0x00270061, 0xfffffff8},/*kerning  a ' : -0.031250 */
{'[', 0x00760061, 0xffffffff},/*kerning  a v : -0.003906 */
{'[', 0x00790061, 0xffffffff},/*kerning  a y : -0.003906 */
{'@', 0x00000062, 0x000059d8},/*        b        x-advance: 89.843750 */
{'M', 0x42a52800, 0xc2255000},
{'q', 0x00000000, 0x41942000},
{0, 0xc1098000, 0x41f5a000},
{'q', 0xc1098000, 0x41430000},
{0, 0xc1c26000, 0x41430000},
{'9', 0x0000ff80, 0xffa6ff3b},
{'l', 0xbf480000, 0x411c4000},
{'l', 0xc1548000, 0x80000000},
{'4', 0xfc400000, 0x00000074},
{'l', 0x00000000, 0x42327000},
{'q', 0x41098000, 0xc12b4000},
{0, 0x41c08000, 0xc12b4000},
{'q', 0x417f0000, 0x00000000},
{0, 0x41c3f000, 0x413e0000},
{'9', 0x005f0044, 0x00fa0044},
{'l', 0x00000000, 0x3fd20000},
{'M', 0x4237c000, 0xc293d000},
{'8', 0x1e9a00c1, 0x4ac31ed9},
{'l', 0x00000000, 0x42133000},
{'8', 0x4b3e2d16, 0x1e661e28},
{'q', 0x413b8000, 0x00000000},
{0, 0x4186b000, 0xc1106000},
{'9', 0xffb80028, 0xff540028},
{'l', 0x00000000, 0xbfd20000},
{'q', 0x00000000, 0xc1494000},
{0, 0xc09c4000, 0xc1ae1000},
{'q', 0xc09c4000, 0xc112e000},
{0, 0xc189d000, 0xc112e000},
{'[', 0x00220062, 0xfffffffd},/*kerning  b " : -0.011719 */
{'[', 0x00270062, 0xfffffffd},/*kerning  b ' : -0.011719 */
{'[', 0x00760062, 0xffffffff},/*kerning  b v : -0.003906 */
{'[', 0x00780062, 0xffffffff},/*kerning  b x : -0.003906 */
{'[', 0x00790062, 0xffffffff},/*kerning  b y : -0.003906 */
{'[', 0x007a0062, 0xffffffff},/*kerning  b z : -0.003906 */
{'@', 0x00000063, 0x000053c0},/*        c        x-advance: 83.750000 */
{'M', 0x42336000, 0xc1250000},
{'8', 0xdc6c003d, 0xa232dc2e},
{'l', 0x415c0000, 0x00000000},
{'q', 0xbf0c0000, 0x41354000},
{0, 0xc1264000, 0x419e7000},
{'q', 0xc11d8000, 0x4107a000},
{0, 0xc1ba4000, 0x4107a000},
{'q', 0xc1988000, 0x00000000},
{0, 0xc1e29000, 0xc1494000},
{'9', 0xff9cffb6, 0xff14ffb6},
{'l', 0x00000000, 0xc0520000},
{'q', 0x00000000, 0xc1884000},
{0, 0x41142000, 0xc1ece000},
{'q', 0x41142000, 0xc1494000},
{0, 0x41e29000, 0xc1494000},
{'q', 0x416d8000, 0x00000000},
{0, 0x41bfe000, 0x410ca000},
{'9', 0x00460049, 0x00ae004d},
{'l', 0xc15c0000, 0x00000000},
{'q', 0xbf0c0000, 0xc0fa0000},
{0, 0xc0bcc000, 0xc1548000},
{'q', 0xc0ab4000, 0xc0af0000},
{0, 0xc1606000, 0xc0af0000},
{'8', 0x249100b9, 0x5bc824d8},
{'9', 0x0037fff0, 0x0072fff0},
{'l', 0x00000000, 0x40520000},
{'q', 0x00000000, 0x40ed8000},
{0, 0x40020000, 0x41660000},
{'q', 0x40020000, 0x40de8000},
{0, 0x40e24000, 0x41372000},
{'q', 0x40a14000, 0x408fc000},
{0, 0x41606000, 0x408fc000},
{'[', 0x00220063, 0xffffffff},/*kerning  c " : -0.003906 */
{'[', 0x00270063, 0xffffffff},/*kerning  c ' : -0.003906 */
{'@', 0x00000064, 0x00005a3c},/*        d        x-advance: 90.234375 */
{'M', 0x42831800, 0x80000000},
{'l', 0xbf340000, 0xc1110000},
{'q', 0xc10ac000, 0x412a0000},
{0, 0xc1c12000, 0x412a0000},
{'q', 0xc16d8000, 0x00000000},
{0, 0xc1bfe000, 0xc1408000},
{'9', 0xffa0ffb7, 0xff0fffb6},
{'l', 0x00000000, 0xc0110000},
{'q', 0x00000000, 0xc19b0000},
{0, 0x4112e000, 0xc1fa0000},
{'q', 0x4112e000, 0xc13e0000},
{0, 0x41c21000, 0xc13e0000},
{'9', 0x00000077, 0x005000bb},
{'l', 0x00000000, 0xc22fa000},
{'4', 0x00000074, 0x03c00000},
{'l', 0xc1548000, 0x80000000},
{'M', 0x41afa000, 0xc2255000},
{'q', 0x00000000, 0x41494000},
{0, 0x40aa0000, 0x41acd000},
{'q', 0x40aa0000, 0x41106000},
{0, 0x41884000, 0x41106000},
{'9', 0x0000006b, 0xff9e00a0},
{'l', 0x00000000, 0xc21ba000},
{'q', 0xc0cf8000, 0xc1408000},
{0, 0xc19ec000, 0xc1408000},
{'q', 0xc13cc000, 0x00000000},
{0, 0xc1893000, 0x4112e000},
{'q', 0xc0ab4000, 0x4112e000},
{0, 0xc0ab4000, 0x41ae1000},
{'l', 0x00000000, 0x3fd20000},
{'@', 0x00000065, 0x000054d8},/*        e        x-advance: 84.843750 */
{'M', 0x429bc800, 0xc16c4000},
{'q', 0xc0848000, 0x40c80000},
{0, 0xc13b8000, 0x4134a000},
{'q', 0xc0f28000, 0x40a14000},
{0, 0xc1a0a000, 0x40a14000},
{'q', 0xc18d4000, 0x00000000},
{0, 0xc1e1f000, 0xc137c000},
{'9', 0xffa5ffac, 0xff15ffac},
{'l', 0x00000000, 0xc0520000},
{'q', 0x00000000, 0xc15d4000},
{0, 0x40a8c000, 0xc1bc7000},
{'q', 0x40a8c000, 0xc11ba000},
{0, 0x415b6000, 0xc16d8000},
{'q', 0x41070000, 0xc0a3c000},
{0, 0x418fc000, 0xc0a3c000},
{'q', 0x41910000, 0x00000000},
{0, 0x41d39000, 0x413d6000},
{'9', 0x005e0042, 0x00ec0042},
{'4', 0x00330000, 0x0000fe37},
{'q', 0x3ea00000, 0x413a4000},
{0, 0x40dd4000, 0x419e7000},
{'q', 0x40d34000, 0x4102a000},
{0, 0x41915000, 0x4102a000},
{'8', 0xe767003d, 0xbe4ae72a},
{'l', 0x410c0000, 0x40de8000},
{'M', 0x4230e000, 0xc2947000},
{'q', 0xc1098000, 0x00000000},
{0, 0xc1688000, 0x40c80000},
{'9', 0x0032ffd1, 0x008fffc5},
{'4', 0x00000152, 0xfff80000},
{'q', 0xbf0c0000, 0xc1070000},
{0, 0xc09c4000, 0xc17c8000},
{'q', 0xc08ac000, 0xc0eb0000},
{0, 0xc176e000, 0xc0eb0000},
{'[', 0x00220065, 0xffffffff},/*kerning  e " : -0.003906 */
{'[', 0x00270065, 0xffffffff},/*kerning  e ' : -0.003906 */
{'[', 0x00760065, 0xffffffff},/*kerning  e v : -0.003906 */
{'[', 0x00790065, 0xffffffff},/*kerning  e y : -0.003906 */
{'@', 0x00000066, 0x000037a0},/*        f        x-advance: 55.625000 */
{'M', 0x424a3000, 0xc292e000},
{'l', 0xc18fc000, 0x00000000},
{'l', 0x00000000, 0x4292e000},
{'l', 0xc1674000, 0x80000000},
{'l', 0x00000000, 0xc292e000},
{'0', 0xa8000096, 0xb500006a},
{'q', 0x3e200000, 0xc1570000},
{0, 0x40f14000, 0xc1a46000},
{'q', 0x40ec4000, 0xc0e38000},
{0, 0x41a19000, 0xc0e38000},
{'9', 0x00000026, 0x000a0050},
{'l', 0xbf480000, 0x413cc000},
{'q', 0xc0520000, 0xbf340000},
{0, 0xc0fa0000, 0xbf340000},
{'9', 0x0000ff8d, 0x007bff8b},
{'l', 0x00000000, 0x41160000},
{'l', 0x418fc000, 0x00000000},
{'l', 0x00000000, 0x41318000},
{'[', 0x00220066, 0x00000002},/*kerning  f " : 0.007812 */
{'[', 0x00270066, 0x00000002},/*kerning  f ' : 0.007812 */
{'[', 0x00290066, 0x00000002},/*kerning  f ) : 0.007812 */
{'[', 0x005d0066, 0x00000002},/*kerning  f ] : 0.007812 */
{'[', 0x00630066, 0xfffffffd},/*kerning  f c : -0.011719 */
{'[', 0x00640066, 0xfffffffd},/*kerning  f d : -0.011719 */
{'[', 0x00650066, 0xfffffffd},/*kerning  f e : -0.011719 */
{'[', 0x00670066, 0xfffffffd},/*kerning  f g : -0.011719 */
{'[', 0x00710066, 0xfffffffd},/*kerning  f q : -0.011719 */
{'[', 0x007d0066, 0x00000002},/*kerning  f } : 0.007812 */
{'@', 0x00000067, 0x000059d8},/*        g        x-advance: 89.843750 */
{'M', 0x422c8000, 0x42057000},
{'q', 0xc0d20000, 0x00000000},
{0, 0xc180c000, 0xc04d0000},
{'9', 0xffe7ffb4, 0xffa5ff87},
{'l', 0x40f28000, 0xc1098000},
{'q', 0x41160000, 0x41368000},
{0, 0x41b54000, 0x41368000},
{'q', 0x4123c000, 0x00000000},
{0, 0x4182a000, 0xc0b7c000},
{'9', 0xffd30030, 0xff7a0030},
{'l', 0x00000000, 0xc0ed8000},
{'q', 0xc1098000, 0x41214000},
{0, 0xc1bd6000, 0x41214000},
{'q', 0xc173c000, 0x00000000},
{0, 0xc1c1c000, 0xc1430000},
{'9', 0xff9fffb9, 0xff0bffb9},
{'l', 0x00000000, 0xbfd20000},
{'q', 0x00000000, 0xc19b0000},
{0, 0x410f2000, 0xc1fa0000},
{'q', 0x410f2000, 0xc13e0000},
{0, 0x41c35000, 0xc13e0000},
{'9', 0x0000007c, 0x005700c1},
{'4', 0xffb50005, 0x00000069},
{'l', 0x00000000, 0x42a57800},
{'q', 0x00000000, 0x41866000},
{0, 0xc1200000, 0x41cfd000},
{'9', 0x0049ffb0, 0x0049ff32},
{'M', 0x41b04000, 0xc2255000},
{'q', 0x00000000, 0x41494000},
{0, 0x40a8c000, 0x41acd000},
{'q', 0x40a8c000, 0x41106000},
{0, 0x4187f000, 0x41106000},
{'9', 0x0000006e, 0xff9c00a1},
{'l', 0x00000000, 0xc21a1000},
{'8', 0xbbc4d7eb, 0xe59de5da},
{'q', 0xc13cc000, 0x00000000},
{0, 0xc188e000, 0x4112e000},
{'q', 0xc0aa0000, 0x4112e000},
{0, 0xc0aa0000, 0x41ae1000},
{'l', 0x00000000, 0x3fd20000},
{'@', 0x00000068, 0x00005820},/*        h        x-advance: 88.125000 */
{'M', 0x42386000, 0xc293d000},
{'8', 0x1e9e00c9, 0x4ebe1ed6},
{'l', 0x00000000, 0x42719000},
{'l', 0xc1674000, 0x80000000},
{'4', 0xfc400000, 0x00000073},
{'l', 0x00000000, 0x42363000},
{'q', 0x4119c000, 0xc13a4000},
{0, 0x41c76000, 0xc13a4000},
{'q', 0x4146c000, 0x00000000},
{0, 0x419dd000, 0x40de8000},
{'9', 0x0037003a, 0x00ba003b},
{'4', 0x01be0000, 0x0000ff8c},
{'l', 0x00000000, 0xc25e3000},
{'q', 0x00000000, 0xc11ec000},
{0, 0xc08ac000, 0xc1624000},
{'q', 0xc08ac000, 0xc0870000},
{0, 0xc148a000, 0xc0870000},
{'[', 0x00220068, 0xfffffff3},/*kerning  h " : -0.050781 */
{'[', 0x00270068, 0xfffffff3},/*kerning  h ' : -0.050781 */
{'@', 0x00000069, 0x000026e8},/*        i        x-advance: 38.906250 */
{'M', 0x41318000, 0xc2d5e800},
{'8', 0xd111e400, 0xed32ed11},
{'8', 0x13320021, 0x2f111311},
{'8', 0x2def1a00, 0x13ce13ef},
{'8', 0xedce00df, 0xd3efedef},
{'M', 0x41d5c000, 0xc2a91000},
{'l', 0x00000000, 0x42a91000},
{'l', 0xc1688000, 0x80000000},
{'l', 0x00000000, 0xc2a91000},
{'l', 0x41688000, 0x00000000},
{'@', 0x0000006a, 0x00002648},/*        j        x-advance: 38.281250 */
{'M', 0x411ec000, 0xc2d5e800},
{'8', 0xd111e400, 0xed32ed11},
{'8', 0x13330021, 0x2f111311},
{'8', 0x2def1a00, 0x13cd13ef},
{'8', 0xedce00df, 0xd3efedef},
{'M', 0x41368000, 0xc2a91000},
{'4', 0x00000074, 0x02f40000},
{'q', 0x00000000, 0x41c08000},
{0, 0xc1b0e000, 0x41c08000},
{'9', 0x0000ffda, 0xfff6ffb9},
{'l', 0x3da00000, 0xc13a4000},
{'8', 0x05350517, 0xaa4e004c},
{'l', 0x00000000, 0xc2bf1800},
{'@', 0x0000006b, 0x00005118},/*        k        x-advance: 81.093750 */
{'M', 0x427ff000, 0x80000000},
{'l', 0xc1ea6000, 0xc21ce000},
{'l', 0xc1124000, 0x41174000},
{'l', 0x00000000, 0x41ee2000},
{'l', 0xc1688000, 0x80000000},
{'l', 0x00000000, 0xc2f00000},
{'l', 0x41688000, 0x00000000},
{'l', 0x00000000, 0x42910000},
{'l', 0x40f78000, 0xc1138000},
{'l', 0x41d20000, 0xc1de8000},
{'l', 0x418d4000, 0x00000000},
{'l', 0xc203e000, 0x420cf000},
{'l', 0x42133000, 0x42453000},
{'l', 0xc1884000, 0x80000000},
{'[', 0x0063006b, 0xfffffffe},/*kerning  k c : -0.007812 */
{'[', 0x0064006b, 0xfffffffe},/*kerning  k d : -0.007812 */
{'[', 0x0065006b, 0xfffffffe},/*kerning  k e : -0.007812 */
{'[', 0x0067006b, 0xfffffffe},/*kerning  k g : -0.007812 */
{'[', 0x0071006b, 0xfffffffe},/*kerning  k q : -0.007812 */
{'@', 0x0000006c, 0x000026e8},/*        l        x-advance: 38.906250 */
{'M', 0x41d5c000, 0xc2f00000},
{'l', 0x00000000, 0x42f00000},
{'l', 0xc1688000, 0x80000000},
{'l', 0x00000000, 0xc2f00000},
{'l', 0x41688000, 0x00000000},
{'@', 0x0000006d, 0x00008c50},/*        m        x-advance: 140.312500 */
{'M', 0x42336000, 0xc293d000},
{'9', 0x0000ff8f, 0x005fff65},
{'l', 0x00000000, 0x4277d000},
{'l', 0xc1688000, 0x80000000},
{'4', 0xfd5c0000, 0x0000006e},
{'l', 0x3ec80000, 0x41138000},
{'q', 0x41124000, 0xc12c8000},
{0, 0x41c80000, 0xc12c8000},
{'q', 0x41020000, 0x00000000},
{0, 0x4167e000, 0x404f8000},
{'8', 0x524d1932, 0xb257d021},
{'q', 0x40d84000, 0xc0700000},
{0, 0x417e6000, 0xc0700000},
{'q', 0x41598000, 0x00000000},
{0, 0x41a7d000, 0x40e88000},
{'9', 0x003a003b, 0x00ba003b},
{'4', 0x01bc0000, 0x0000ff8c},
{'l', 0x00000000, 0xc25ed000},
{'q', 0x00000000, 0xc12a0000},
{0, 0xc09c4000, 0xc166a000},
{'8', 0xe297e2d9, 0x299200ba},
{'9', 0x0029ffd8, 0x0064ffd2},
{'4', 0x01c00000, 0x0000ff8d},
{'l', 0x00000000, 0xc25e8000},
{'q', 0x00000000, 0xc11ec000},
{0, 0xc09d8000, 0xc161a000},
{'q', 0xc09d8000, 0xc085c000},
{0, 0xc1520000, 0xc085c000},
{'[', 0x0022006d, 0xfffffff3},/*kerning  m " : -0.050781 */
{'[', 0x0027006d, 0xfffffff3},/*kerning  m ' : -0.050781 */
{'@', 0x0000006e, 0x0000585c},/*        n        x-advance: 88.359375 */
{'M', 0x42386000, 0xc293d000},
{'8', 0x1e9e00c9, 0x4ebe1ed6},
{'l', 0x00000000, 0x42719000},
{'l', 0xc1674000, 0x80000000},
{'4', 0xfd5c0000, 0x0000006d},
{'l', 0x3ef00000, 0x4128c000},
{'q', 0x4119c000, 0xc141c000},
{0, 0x41c9e000, 0xc141c000},
{'q', 0x4146c000, 0x00000000},
{0, 0x419dd000, 0x40de8000},
{'9', 0x0037003a, 0x00ba003b},
{'4', 0x01be0000, 0x0000ff8c},
{'l', 0x00000000, 0xc25e3000},
{'q', 0x00000000, 0xc11ec000},
{0, 0xc08ac000, 0xc1624000},
{'q', 0xc08ac000, 0xc0870000},
{0, 0xc148a000, 0xc0870000},
{'[', 0x0022006e, 0xfffffff3},/*kerning  n " : -0.050781 */
{'[', 0x0027006e, 0xfffffff3},/*kerning  n ' : -0.050781 */
{'@', 0x0000006f, 0x00005b40},/*        o        x-advance: 91.250000 */
{'M', 0x40e60000, 0xc22c8000},
{'q', 0x00000000, 0xc192e000},
{0, 0x41250000, 0xc1f55000},
{'q', 0x41250000, 0xc144e000},
{0, 0x41e06000, 0xc144e000},
{'q', 0x418de000, 0x00000000},
{0, 0x41e06000, 0x41412000},
{'9', 0x00600052, 0x00f00054},
{'l', 0x00000000, 0x40250000},
{'q', 0x00000000, 0x4192e000},
{0, 0xc125a000, 0x41f50000},
{'q', 0xc125a000, 0x41444000},
{0, 0xc1e0b000, 0x41444000},
{'q', 0xc18e8000, 0x00000000},
{0, 0xc1e15000, 0xc1444000},
{'9', 0xff9effae, 0xff0bffae},
{'l', 0x00000000, 0xbfe60000},
{'M', 0x41ad2000, 0xc2255000},
{'q', 0x00000000, 0x41494000},
{0, 0x40bf4000, 0x41ae6000},
{'q', 0x40bf4000, 0x41138000},
{0, 0x4190b000, 0x41138000},
{'q', 0x413cc000, 0x00000000},
{0, 0x418e8000, 0xc111a000},
{'9', 0xffb80030, 0xff530030},
{'l', 0x00000000, 0xc0020000},
{'q', 0x00000000, 0xc146c000},
{0, 0xc0c08000, 0xc1ae1000},
{'q', 0xc0c08000, 0xc1156000},
{0, 0xc1906000, 0xc1156000},
{'q', 0xc13f4000, 0x00000000},
{0, 0xc18f7000, 0x41156000},
{'q', 0xc0bf4000, 0x41156000},
{0, 0xc0bf4000, 0x41ae1000},
{'l', 0x00000000, 0x3fe60000},
{'[', 0x0022006f, 0xffffffef},/*kerning  o " : -0.066406 */
{'[', 0x0027006f, 0xffffffef},/*kerning  o ' : -0.066406 */
{'[', 0x0076006f, 0xffffffff},/*kerning  o v : -0.003906 */
{'[', 0x0078006f, 0xfffffffe},/*kerning  o x : -0.007812 */
{'[', 0x0079006f, 0xffffffff},/*kerning  o y : -0.003906 */
{'[', 0x007a006f, 0xfffffffe},/*kerning  o z : -0.007812 */
{'@', 0x00000070, 0x000059d8},/*        p        x-advance: 89.843750 */
{'M', 0x42467000, 0x3fc80000},
{'9', 0x0000ff87, 0xffb2ff3f},
{'l', 0x00000000, 0x4222d000},
{'l', 0xc1688000, 0x00000000},
{'4', 0xfc580000, 0x0000006a},
{'l', 0x3f340000, 0x4114c000},
{'q', 0x410e8000, 0xc12dc000},
{0, 0x41c3a000, 0xc12dc000},
{'q', 0x41802000, 0x00000000},
{0, 0x41c44000, 0x413e0000},
{'9', 0x005f0044, 0x00fa0044},
{'l', 0x00000000, 0x3fd20000},
{'q', 0x00000000, 0x41942000},
{0, 0xc108e000, 0x41f5a000},
{'9', 0x0061ffbc, 0x0061ff3e},
{'M', 0x4234a000, 0xc293d000},
{'9', 0x0000ff97, 0x005dff63},
{'l', 0x00000000, 0x4221e000},
{'q', 0x40d48000, 0x4137c000},
{0, 0x419ec000, 0x4137c000},
{'q', 0x413b8000, 0x00000000},
{0, 0x41893000, 0xc1138000},
{'9', 0xffb7002b, 0xff52002b},
{'l', 0x00000000, 0xbfd20000},
{'q', 0x00000000, 0xc1494000},
{0, 0xc0adc000, 0xc1ae1000},
{'q', 0xc0adc000, 0xc112e000},
{0, 0xc18a7000, 0xc112e000},
{'[', 0x00220070, 0xfffffffd},/*kerning  p " : -0.011719 */
{'[', 0x00270070, 0xfffffffd},/*kerning  p ' : -0.011719 */
{'[', 0x00760070, 0xffffffff},/*kerning  p v : -0.003906 */
{'[', 0x00780070, 0xffffffff},/*kerning  p x : -0.003906 */
{'[', 0x00790070, 0xffffffff},/*kerning  p y : -0.003906 */
{'[', 0x007a0070, 0xffffffff},/*kerning  p z : -0.003906 */
{'@', 0x00000071, 0x00005af0},/*        q        x-advance: 90.937500 */
{'M', 0x429d8000, 0xc2a91000},
{'4', 0x03a80000, 0x0000ff8c},
{'l', 0x00000000, 0xc2214000},
{'q', 0xc10ac000, 0x41160000},
{0, 0xc1ba4000, 0x41160000},
{'q', 0xc17a0000, 0x00000000},
{0, 0xc1c49000, 0xc1430000},
{'9', 0xff9fffb9, 0xff0bffb9},
{'l', 0x00000000, 0xbfd20000},
{'q', 0x00000000, 0xc19b0000},
{0, 0x410e8000, 0xc1fa0000},
{'q', 0x410e8000, 0xc13e0000},
{0, 0x41c62000, 0xc13e0000},
{'9', 0x00000078, 0x005000be},
{'4', 0xffbc0005, 0x0000006a},
{'M', 0x41afa000, 0xc2255000},
{'q', 0x00000000, 0x41494000},
{0, 0x40adc000, 0x41ae6000},
{'q', 0x40adc000, 0x41138000},
{0, 0x41893000, 0x41138000},
{'9', 0x00000067, 0xffa6009d},
{'l', 0x00000000, 0xc225f000},
{'q', 0xc0d98000, 0xc1318000},
{0, 0xc19c4000, 0xc1318000},
{'q', 0xc13e0000, 0x00000000},
{0, 0xc18a7000, 0x41156000},
{'q', 0xc0adc000, 0x41156000},
{0, 0xc0adc000, 0x41aff000},
{'l', 0x00000000, 0x3fc80000},
{'@', 0x00000072, 0x00003638},/*        r        x-advance: 54.218750 */
{'M', 0x42331000, 0xc2906000},
{'9', 0x0000ff8f, 0x0061ff66},
{'l', 0x00000000, 0x42700000},
{'l', 0xc1674000, 0x80000000},
{'4', 0xfd5c0000, 0x00000070},
{'l', 0x3ea00000, 0x411b0000},
{'q', 0x40de8000, 0xc1340000},
{0, 0x41a0a000, 0xc1340000},
{'9', 0x00000020, 0x00080033},
{'l', 0xbda00000, 0x41570000},
{'q', 0xc04d0000, 0xbf200000},
{0, 0xc0e10000, 0xbf200000},
{'[', 0x00220072, 0x00000002},/*kerning  r " : 0.007812 */
{'[', 0x00270072, 0x00000002},/*kerning  r ' : 0.007812 */
{'[', 0x002c0072, 0xfffffff1},/*kerning  r , : -0.058594 */
{'[', 0x002e0072, 0xfffffff1},/*kerning  r . : -0.058594 */
{'[', 0x00610072, 0xfffffffb},/*kerning  r a : -0.019531 */
{'[', 0x00630072, 0xfffffffe},/*kerning  r c : -0.007812 */
{'[', 0x00640072, 0xfffffffe},/*kerning  r d : -0.007812 */
{'[', 0x00650072, 0xfffffffe},/*kerning  r e : -0.007812 */
{'[', 0x00660072, 0x00000001},/*kerning  r f : 0.003906 */
{'[', 0x00670072, 0xfffffffe},/*kerning  r g : -0.007812 */
{'[', 0x006f0072, 0xfffffffe},/*kerning  r o : -0.007812 */
{'[', 0x00710072, 0xfffffffe},/*kerning  r q : -0.007812 */
{'[', 0x00740072, 0x00000006},/*kerning  r t : 0.023438 */
{'[', 0x00760072, 0x00000002},/*kerning  r v : 0.007812 */
{'[', 0x00770072, 0x00000002},/*kerning  r w : 0.007812 */
{'[', 0x00790072, 0x00000002},/*kerning  r y : 0.007812 */
{'@', 0x00000073, 0x00005294},/*        s        x-advance: 82.578125 */
{'M', 0x4270f000, 0xc1b36000},
{'q', 0x00000000, 0xc0938000},
{0, 0xc0598000, 0xc1052000},
{'q', 0xc0598000, 0xc06d8000},
{0, 0xc17aa000, 0xc0c6c000},
{'q', 0xc1624000, 0xc0390000},
{0, 0xc1b40000, 0xc1066000},
{'q', 0xc105c000, 0xc0b04000},
{0, 0xc105c000, 0xc1807000},
{'q', 0x00000000, 0xc1200000},
{0, 0x4108e000, 0xc18ac000},
{'q', 0x4108e000, 0xc0eb0000},
{0, 0x41b63000, 0xc0eb0000},
{'q', 0x41728000, 0x00000000},
{0, 0x41bd6000, 0x40f78000},
{'9', 0x003d0044, 0x00950044},
{'l', 0xc1674000, 0x00000000},
{'8', 0xb1dcd700, 0xdb97dbdc},
{'8', 0x1f9900b9, 0x44e11fe1},
{'q', 0x00000000, 0x40938000},
{0, 0x40688000, 0x40eec000},
{'q', 0x40688000, 0x40368000},
{0, 0x4176e000, 0x40b04000},
{'q', 0x4178c000, 0x40610000},
{0, 0x41b95000, 0x41138000},
{'q', 0x40f3c000, 0x40b68000},
{0, 0x40f3c000, 0x4180c000},
{'q', 0x00000000, 0x4132c000},
{0, 0xc10f2000, 0x41910000},
{'q', 0xc10f2000, 0x40de8000},
{0, 0xc1bdb000, 0x40de8000},
{'q', 0xc1866000, 0x00000000},
{0, 0xc1cda000, 0xc1098000},
{'9', 0xffbcffb9, 0xff68ffb9},
{'l', 0x41688000, 0x00000000},
{'8', 0x63374703, 0x1b691b33},
{'8', 0xe56c0046, 0xbb25e525},
{'@', 0x00000074, 0x00003458},/*        t        x-advance: 52.343750 */
{'M', 0x423b3000, 0x80000000},
{'8', 0x0ca70cd9, 0xd99200c0},
{'9', 0xffd9ffd3, 0xff73ffd3},
{'l', 0x00000000, 0xc251b000},
{'l', 0xc1778000, 0x00000000},
{'l', 0x00000000, 0xc1318000},
{'l', 0x41778000, 0x00000000},
{'l', 0x00000000, 0xc1a46000},
{'l', 0x41674000, 0x00000000},
{'l', 0x00000000, 0x41a46000},
{'l', 0x417c8000, 0x00000000},
{'4', 0x00580000, 0x0000ff82},
{'l', 0x00000000, 0x42520000},
{'8', 0x42163300, 0x0e330e16},
{'q', 0x402f0000, 0x00000000},
{0, 0x40d98000, 0xbf700000},
{'l', 0x3da00000, 0x413cc000},
{'[', 0x006f0074, 0xfffffffe},/*kerning  t o : -0.007812 */
{'@', 0x00000075, 0x00005834},/*        u        x-advance: 88.203125 */
{'M', 0x427dc000, 0x80000000},
{'l', 0xbea00000, 0xc105c000},
{'q', 0xc1048000, 0x411ec000},
{0, 0xc1c58000, 0x411ec000},
{'q', 0xc146c000, 0x00000000},
{0, 0xc1a0a000, 0xc0eb0000},
{'9', 0xffc6ffc3, 0xff3fffc3},
{'4', 0xfe4c0000, 0x00000073},
{'l', 0x00000000, 0x425ac000},
{'q', 0x00000000, 0x41368000},
{0, 0x4099c000, 0x41746000},
{'q', 0x4099c000, 0x40778000},
{0, 0x412be000, 0x40778000},
{'9', 0x00000082, 0xff9e00b0},
{'l', 0x00000000, 0xc2764000},
{'l', 0x41688000, 0x00000000},
{'l', 0x00000000, 0x42a91000},
{'l', 0xc15d4000, 0x80000000},
{'@', 0x00000076, 0x00004d80},/*        v        x-advance: 77.500000 */
{'M', 0x42953800, 0xc2a91000},
{'l', 0xc1f32000, 0x42a91000},
{'l', 0xc1304000, 0x80000000},
{'l', 0xc1f50000, 0xc2a91000},
{'l', 0x416d8000, 0x00000000},
{'l', 0x41abe000, 0x42818800},
{'l', 0x41a78000, 0xc2818800},
{'l', 0x416c4000, 0x00000000},
{'[', 0x00220076, 0x00000001},/*kerning  v " : 0.003906 */
{'[', 0x00270076, 0x00000001},/*kerning  v ' : 0.003906 */
{'[', 0x002c0076, 0xfffffff3},/*kerning  v , : -0.050781 */
{'[', 0x002e0076, 0xfffffff3},/*kerning  v . : -0.050781 */
{'[', 0x00610076, 0xffffffff},/*kerning  v a : -0.003906 */
{'[', 0x00630076, 0xffffffff},/*kerning  v c : -0.003906 */
{'[', 0x00640076, 0xffffffff},/*kerning  v d : -0.003906 */
{'[', 0x00650076, 0xffffffff},/*kerning  v e : -0.003906 */
{'[', 0x00660076, 0x00000001},/*kerning  v f : 0.003906 */
{'[', 0x00670076, 0xffffffff},/*kerning  v g : -0.003906 */
{'[', 0x006f0076, 0xffffffff},/*kerning  v o : -0.003906 */
{'[', 0x00710076, 0xffffffff},/*kerning  v q : -0.003906 */
{'@', 0x00000077, 0x0000783c},/*        w        x-advance: 120.234375 */
{'M', 0x42e8f800, 0xc2a91000},
{'l', 0xc1c44000, 0x42a91000},
{'l', 0xc13b8000, 0x80000000},
{'l', 0xc1a46000, 0xc27ff000},
{'l', 0xc1a00000, 0x427ff000},
{'l', 0xc13cc000, 0x80000000},
{'l', 0xc1c44000, 0xc2a91000},
{'l', 0x41674000, 0x00000000},
{'l', 0x41852000, 0x427c8000},
{'l', 0x419d8000, 0xc27c8000},
{'l', 0x413a4000, 0x00000000},
{'l', 0x41a00000, 0x4280e800},
{'l', 0x4182a000, 0xc280e800},
{'l', 0x41660000, 0x00000000},
{'[', 0x002c0077, 0xfffffff1},/*kerning  w , : -0.058594 */
{'[', 0x002e0077, 0xfffffff1},/*kerning  w . : -0.058594 */
{'@', 0x00000078, 0x00004f60},/*        x        x-advance: 79.375000 */
{'M', 0x41a64000, 0xc2a91000},
{'l', 0x41942000, 0x41f64000},
{'l', 0x41960000, 0xc1f64000},
{'l', 0x4187a000, 0x00000000},
{'l', 0xc1dd4000, 0x4226e000},
{'l', 0x41e42000, 0x422b4000},
{'l', 0xc185c000, 0x80000000},
{'l', 0xc19c4000, 0xc1fdc000},
{'l', 0xc19c4000, 0x41fdc000},
{'l', 0xc1866000, 0x80000000},
{'l', 0x41e38000, 0xc22b4000},
{'l', 0xc1dca000, 0xc226e000},
{'l', 0x41852000, 0x00000000},
{'[', 0x00630078, 0xfffffffe},/*kerning  x c : -0.007812 */
{'[', 0x00640078, 0xfffffffe},/*kerning  x d : -0.007812 */
{'[', 0x00650078, 0xfffffffe},/*kerning  x e : -0.007812 */
{'[', 0x00670078, 0xfffffffe},/*kerning  x g : -0.007812 */
{'[', 0x006f0078, 0xfffffffe},/*kerning  x o : -0.007812 */
{'[', 0x00710078, 0xfffffffe},/*kerning  x q : -0.007812 */
{'@', 0x00000079, 0x00004bb4},/*        y        x-advance: 75.703125 */
{'M', 0x421f6000, 0x4150c000},
{'9', 0x009effc4, 0x00a8ff4b},
{'l', 0xc01b0000, 0x3da00000},
{'9', 0x0000ffdc, 0xfff6ffbf},
{'4', 0xffa30000, 0x0002001f},
{'8', 0xe85b003a, 0xaa36e821},
{'l', 0x40480000, 0xc1098000},
{'l', 0xc1f14000, 0xc2a73000},
{'l', 0x417c8000, 0x00000000},
{'l', 0x41a96000, 0x427d2000},
{'l', 0x419ce000, 0xc27d2000},
{'l', 0x41778000, 0x00000000},
{'l', 0xc207a000, 0x42c32800},
{'[', 0x00220079, 0x00000001},/*kerning  y " : 0.003906 */
{'[', 0x00270079, 0x00000001},/*kerning  y ' : 0.003906 */
{'[', 0x002c0079, 0xfffffff3},/*kerning  y , : -0.050781 */
{'[', 0x002e0079, 0xfffffff3},/*kerning  y . : -0.050781 */
{'[', 0x00610079, 0xffffffff},/*kerning  y a : -0.003906 */
{'[', 0x00630079, 0xffffffff},/*kerning  y c : -0.003906 */
{'[', 0x00640079, 0xffffffff},/*kerning  y d : -0.003906 */
{'[', 0x00650079, 0xffffffff},/*kerning  y e : -0.003906 */
{'[', 0x00660079, 0x00000001},/*kerning  y f : 0.003906 */
{'[', 0x00670079, 0xffffffff},/*kerning  y g : -0.003906 */
{'[', 0x006f0079, 0xffffffff},/*kerning  y o : -0.003906 */
{'[', 0x00710079, 0xffffffff},/*kerning  y q : -0.003906 */
{'@', 0x0000007a, 0x00004f60},/*        z        x-advance: 79.375000 */
{'M', 0x40f28000, 0xc2912800},
{'l', 0x00000000, 0xc13f4000},
{'l', 0x42804800, 0x00000000},
{'l', 0x00000000, 0x4123c000},
{'l', 0xc23c2000, 0x4279b000},
{'l', 0x42453000, 0x00000000},
{'l', 0x00000000, 0x413e0000},
{'l', 0xc2861000, 0x80000000},
{'l', 0x00000000, 0xc12a0000},
{'l', 0x423a4000, 0xc277d000},
{'l', 0xc237c000, 0x00000000},
{'[', 0x0063007a, 0xfffffffe},/*kerning  z c : -0.007812 */
{'[', 0x0064007a, 0xfffffffe},/*kerning  z d : -0.007812 */
{'[', 0x0065007a, 0xfffffffe},/*kerning  z e : -0.007812 */
{'[', 0x0067007a, 0xfffffffe},/*kerning  z g : -0.007812 */
{'[', 0x006f007a, 0xfffffffe},/*kerning  z o : -0.007812 */
{'[', 0x0071007a, 0xfffffffe},/*kerning  z q : -0.007812 */
{'@', 0x0000007b, 0x00003624},/*        {        x-advance: 54.140625 */
{'M', 0x40a00000, 0xc229b000},
{'l', 0x00000000, 0xc1354000},
{'9', 0x00000084, 0xff690084},
{'l', 0x00000000, 0xc17c8000},
{'q', 0x00000000, 0xc1458000},
{0, 0x40be0000, 0xc1b09000},
{'9', 0xffb3002f, 0xff8e00af},
{'l', 0x40430000, 0x410e8000},
{'q', 0xc114c000, 0x40390000},
{0, 0xc14d0000, 0x4125a000},
{'9', 0x003bffe4, 0x0088ffe4},
{'l', 0x00000000, 0x41778000},
{'q', 0x00000000, 0x418f2000},
{0, 0xc150c000, 0x41c76000},
{'9', 0x00370068, 0x00c80068},
{'l', 0x00000000, 0x41750000},
{'q', 0x00000000, 0x4119c000},
{0, 0x40610000, 0x41884000},
{'9', 0x003b001c, 0x00520066},
{'l', 0xc0430000, 0x410fc000},
{'q', 0xc17f0000, 0xc0910000},
{0, 0xc1af0000, 0xc164c000},
{'9', 0xffb2ffd1, 0xff50ffd1},
{'l', 0x00000000, 0xc17a0000},
{'q', 0x00000000, 0xc1988000},
{0, 0xc1848000, 0xc1988000},
{'[', 0x004a007b, 0xfffffffe},/*kerning  { J : -0.007812 */
{'[', 0x0055007b, 0xfffffffe},/*kerning  { U : -0.007812 */
{'@', 0x0000007c, 0x00002710},/*        |        x-advance: 39.062500 */
{'M', 0x41cb2000, 0xc2e38000},
{'l', 0x00000000, 0x4306d800},
{'l', 0xc13a4000, 0x00000000},
{'l', 0x00000000, 0xc306d800},
{'l', 0x413a4000, 0x00000000},
{'@', 0x0000007d, 0x00003624},/*        }        x-advance: 54.140625 */
{'M', 0x4243f000, 0xc2570000},
{'l', 0x00000000, 0x41354000},
{'9', 0x0000ff7c, 0x0097ff7c},
{'l', 0x00000000, 0x417c8000},
{'q', 0x00000000, 0x41444000},
{0, 0xc0bcc000, 0x41b04000},
{'9', 0x004effd1, 0x0072ff51},
{'l', 0xc0430000, 0xc10fc000},
{'q', 0x41138000, 0xc0390000},
{0, 0x414c6000, 0xc1250000},
{'9', 0xffc5001c, 0xff78001c},
{'l', 0x00000000, 0xc178c000},
{'q', 0x00000000, 0xc192e000},
{0, 0x41638000, 0xc1c62000},
{'9', 0xffcdff8f, 0xff3aff8f},
{'l', 0x00000000, 0xc178c000},
{'q', 0x00000000, 0xc119c000},
{0, 0xc0610000, 0xc1889000},
{'9', 0xffc5ffe4, 0xffaeff9a},
{'l', 0x40430000, 0xc10e8000},
{'q', 0x41802000, 0x40910000},
{0, 0x41af5000, 0x41642000},
{'9', 0x004d002f, 0x00b0002f},
{'l', 0x00000000, 0x417f0000},
{'q', 0x00000000, 0x41960000},
{0, 0x41848000, 0x41960000},
{'@', 0x0000007e, 0x00006cd4},/*        ~        x-advance: 108.828125 */
{'M', 0x42ad9800, 0xc272d000},
{'l', 0x413e0000, 0xbda00000},
{'q', 0x00000000, 0x41408000},
{0, 0xc0e24000, 0x41a55000},
{'q', 0xc0e24000, 0x410a2000},
{0, 0xc191f000, 0x410a2000},
{'8', 0xeba100ca, 0xc0a6ebd7},
{'8', 0xd3c6e3e1, 0xf0c6f0e6},
{'8', 0x21b600d1, 0x5ce621e6},
{'l', 0xc1494000, 0x3e200000},
{'q', 0x00000000, 0xc1444000},
{0, 0x40e24000, 0xc1a3c000},
{'q', 0x40e24000, 0xc1034000},
{0, 0x41915000, 0xc1034000},
{'8', 0x165f0035, 0x3f591629},
{'8', 0x3446292f, 0x0a300a16},
{'8', 0xdc4d0030, 0xa11ddc1d},
};
#define ctx_font_ascii_name "Roboto Regular"
#endif
#endif //_CTX_INTERNAL_FONT_
#ifndef __CTX_LIST__
#define __CTX_LIST__

#include <stdlib.h>

#ifndef CTX_EXTERNAL_MALLOC
static inline void *ctx_realloc (void *mem, size_t old_size, size_t new_size)
{
  if (old_size){};
  return (void*)realloc (mem, new_size);
}

static inline void *ctx_malloc (size_t size)
{
  return (void*)malloc (size);
}

static inline void ctx_free (void *mem)
{
  free (mem);
}

static inline void *ctx_calloc (size_t size, size_t count)
{
  return calloc (size, count);
}

#endif

/* The whole ctx_list implementation is in the header and will be inlined
 * wherever it is used.
 */
struct _CtxList {
  void *data;
  CtxList *next;
  void (*freefunc)(void *data, void *freefunc_data);
  void *freefunc_data;
};

static inline void ctx_list_prepend_full (CtxList **list, void *data,
    void (*freefunc)(void *data, void *freefunc_data),
    void *freefunc_data)
{
  CtxList *new_= (CtxList*)ctx_calloc (1, sizeof (CtxList));
  new_->next = *list;
  new_->data=data;
  new_->freefunc=freefunc;
  new_->freefunc_data = freefunc_data;
  *list = new_;
}

static inline int ctx_list_length (CtxList *list)
{
  int length = 0;
  CtxList *l;
  for (l = list; l; l = l->next, length++);
  return length;
}

static inline void ctx_list_prepend (CtxList **list, void *data)
{
  CtxList *new_ = (CtxList*) ctx_calloc (1, sizeof (CtxList));
  new_->next= *list;
  new_->data=data;
  *list = new_;
}

static inline CtxList *ctx_list_nth (CtxList *list, int no)
{
  while (no-- && list)
    { list = list->next; }
  return list;
}

static inline void *ctx_list_nth_data (CtxList *list, int no)
{
  CtxList *l = ctx_list_nth (list, no);
  if (l)
    return l->data;
  return NULL;
}


static inline void
ctx_list_insert_before (CtxList **list, CtxList *sibling,
                       void *data)
{
  if (*list == NULL || *list == sibling)
    {
      ctx_list_prepend (list, data);
    }
  else
    {
      CtxList *prev = NULL;
      for (CtxList *l = *list; l; l=l->next)
        {
          if (l == sibling)
            { break; }
          prev = l;
        }
      if (prev)
        {
          CtxList *new_ = (CtxList*)ctx_calloc (1, sizeof (CtxList));
          new_->next = sibling;
          new_->data = data;
          prev->next=new_;
        }
    }
}

static inline void ctx_list_remove_link (CtxList **list, CtxList *link)
{
  CtxList *iter, *prev = NULL;
  if ((*list) == link)
    {
      prev = (*list)->next;
      *list = prev;
      link->next = NULL;
      return;
    }
  for (iter = *list; iter; iter = iter->next)
    if (iter == link)
      {
        if (prev)
          prev->next = iter->next;
        link->next = NULL;
        return;
      }
    else
      prev = iter;
}

static inline void ctx_list_remove (CtxList **list, void *data)
{
  CtxList *iter, *prev = NULL;
  if ((*list)->data == data)
    {
      if ((*list)->freefunc)
        (*list)->freefunc ((*list)->data, (*list)->freefunc_data);
      prev = (*list)->next;
      ctx_free (*list);
      *list = prev;
      return;
    }
  for (iter = *list; iter; iter = iter->next)
    if (iter->data == data)
      {
        if (iter->freefunc)
          iter->freefunc (iter->data, iter->freefunc_data);
        prev->next = iter->next;
        ctx_free (iter);
        break;
      }
    else
      prev = iter;
}

static inline void ctx_list_free (CtxList **list)
{
  while (*list)
    ctx_list_remove (list, (*list)->data);
}

static inline void
ctx_list_reverse (CtxList **list)
{
  CtxList *new_ = NULL;
  CtxList *l;
  for (l = *list; l; l=l->next)
    ctx_list_prepend (&new_, l->data);
  ctx_list_free (list);
  *list = new_;
}

static inline void *ctx_list_last (CtxList *list)
{
  if (list)
    {
      CtxList *last;
      for (last = list; last->next; last=last->next);
      return last->data;
    }
  return NULL;
}

static inline void ctx_list_concat (CtxList **list, CtxList *list_b)
{
  if (*list)
    {
      CtxList *last;
      for (last = *list; last->next; last=last->next);
      last->next = list_b;
      return;
    }
  *list = list_b;
}

static inline void ctx_list_append_full (CtxList **list, void *data,
    void (*freefunc)(void *data, void *freefunc_data),
    void *freefunc_data)
{
  CtxList *new_ = (CtxList*) ctx_calloc (1, sizeof (CtxList));
  new_->data=data;
  new_->freefunc = freefunc;
  new_->freefunc_data = freefunc_data;
  ctx_list_concat (list, new_);
}

static inline void ctx_list_append (CtxList **list, void *data)
{
  ctx_list_append_full (list, data, NULL, NULL);
}

static inline void
ctx_list_insert_at (CtxList **list,
                    int       no,
                    void     *data)
{
  if (*list == NULL || no == 0)
    {
      ctx_list_prepend (list, data);
    }
  else
    {
      int pos = 0;
      CtxList *prev = NULL;
      CtxList *sibling = NULL;
      for (CtxList *l = *list; l && pos < no; l=l->next)
        {
          prev = sibling;
          sibling = l;
          pos ++;
        }
      if (prev)
        {
          CtxList *new_ = (CtxList*)ctx_calloc (1, sizeof (CtxList));
          new_->next = sibling;
          new_->data = data;
          prev->next=new_;
          return;
        }
      ctx_list_append (list, data);
    }
}

static CtxList*
ctx_list_merge_sorted (CtxList* list1,
                       CtxList* list2,
    int(*compare)(const void *a, const void *b, void *userdata), void *userdata
)
{
  if (list1 == NULL)
     return(list2);
  else if (list2==NULL)
     return(list1);

  if (compare (list1->data, list2->data, userdata) >= 0)
  {
    list1->next = ctx_list_merge_sorted (list1->next,list2, compare, userdata);
    /*list1->next->prev = list1;
      list1->prev = NULL;*/
    return list1;
  }
  else
  {
    list2->next = ctx_list_merge_sorted (list1,list2->next, compare, userdata);
    /*list2->next->prev = list2;
      list2->prev = NULL;*/
    return list2;
  }
}

static void
ctx_list_split_half (CtxList*  head,
                     CtxList** list1,
                     CtxList** list2)
{
  CtxList* fast;
  CtxList* slow;
  if (head==NULL || head->next==NULL)
  {
    *list1 = head;
    *list2 = NULL;
  }
  else
  {
    slow = head;
    fast = head->next;

    while (fast != NULL)
    {
      fast = fast->next;
      if (fast != NULL)
      {
        slow = slow->next;
        fast = fast->next;
      }
    }

    *list1 = head;
    *list2 = slow->next;
    slow->next = NULL;
  }
}

static inline void ctx_list_sort (CtxList **head,
    int(*compare)(const void *a, const void *b, void *userdata),
    void *userdata)
{
  CtxList* list1;
  CtxList* list2;

  /* Base case -- length 0 or 1 */
  if ((*head == NULL) || ((*head)->next == NULL))
  {
    return;
  }

  ctx_list_split_half (*head, &list1, &list2);
  ctx_list_sort (&list1, compare, userdata);
  ctx_list_sort (&list2, compare, userdata);
  *head = ctx_list_merge_sorted (list1, list2, compare, userdata);
}

static inline void ctx_list_insert_sorted (CtxList **list,
                                           void     *item,
    int(*compare)(const void *a, const void *b, void *userdata),
                                           void     *userdata)
{
  ctx_list_prepend (list, item);
  ctx_list_sort (list, compare, userdata);
}


static inline CtxList *ctx_list_find_custom (CtxList *list,
                                         void    *needle,
                                         int(*compare)(const void *a, const void *b, void *userdata),
                                         void *userdata)
{
  CtxList *l;
  for (l = list; l; l = l->next)
  {
    if (compare (l->data, needle, userdata) == 0)
      return l;
  }
  return NULL;
}

#endif
 /* Copyright (C) 2020 Øyvind Kolås <pippin@gimp.org>
 */

#if CTX_FORMATTER||CTX_AUDIO

/* returns the maximum string length including terminating \0 */
int ctx_a85enc_len (int input_length);
int ctx_a85enc (const void *srcp, char *dst, int count);


#endif

#if CTX_PARSER

int ctx_a85dec (const char *src, char *dst, int count);
int ctx_a85len (const char *src, int count);
#endif
#ifndef __CTX_EXTRA_H
#define __CTX_EXTRA_H

#if CTX_FORCE_INLINES
#define CTX_INLINE inline __attribute__((always_inline))
#else
#define CTX_INLINE inline
#endif

void ctx_wait_for_renderer (Ctx *ctx);

#define CTX_CLAMP(val,min,max) ((val)<(min)?(min):(val)>(max)?(max):(val))
//static CTX_INLINE int   ctx_mini (const int a, const int b)     { if (a < b) return a; return b; }
//static CTX_INLINE int   ctx_maxi (const int a, const int b)     { if (a > b) return a; return b; }
static CTX_INLINE int   ctx_mini (const int a, const int b)     {
return (a<b)*a+(a>=b)*b;
        //if (a < b) return a; return b; 
}
static CTX_INLINE int   ctx_maxi (const int a, const int b)     {
return (a>b)*a+(a<=b)*b;
        //if (a > b) return a; return b; 
}
static CTX_INLINE float ctx_minf (const float a, const float b) { if (a < b) return a; return b; }
static CTX_INLINE float ctx_maxf (const float a, const float b) { if (a > b) return a; return b; }
static CTX_INLINE float ctx_clampf (const float v, const float min, const float max) {
       return CTX_CLAMP(v,min,max);
}


typedef enum CtxOutputmode
{
  CTX_OUTPUT_MODE_QUARTER,
  CTX_OUTPUT_MODE_BRAILLE,
  CTX_OUTPUT_MODE_SIXELS,
  CTX_OUTPUT_MODE_GRAYS,
  CTX_OUTPUT_MODE_CTX,
  CTX_OUTPUT_MODE_CTX_COMPACT,
  CTX_OUTPUT_MODE_CTX_FILE,
  CTX_OUTPUT_MODE_CTX_COMPACT_FILE,
  CTX_OUTPUT_MODE_UI
} CtxOutputmode;

static CTX_INLINE float ctx_pow2 (const float a) { return a * a; }
#if CTX_MATH

static CTX_INLINE float
ctx_fabsf (const float x)
{
  union
  {
    float f;
    uint32_t i;
  } u = { x };
  u.i &= 0x7fffffff;
  return u.f;
}

static CTX_INLINE float
ctx_invsqrtf (const float x)
{
  union
  {
    float f;
    uint32_t i;
  } u = { x };
  u.i = 0x5f3759df - (u.i >> 1);
  u.f *= (1.5f - 0.5f * x * u.f * u.f);
  u.f *= (1.5f - 0.5f * x * u.f * u.f); //repeating Newton-Raphson step for higher precision
  return u.f;
}


CTX_INLINE static float ctx_sqrtf (const float a)
{
  return 1.0f/ctx_invsqrtf (a);
}

CTX_INLINE static float ctx_hypotf (const float a, const float b)
{
  return ctx_sqrtf (ctx_pow2 (a)+ctx_pow2 (b) );
}

CTX_INLINE static float
ctx_sinf (float x)
{
  if (x < -CTX_PI * 2)
    {
      x = -x;
      long ix = (long)(x / (CTX_PI * 2));
      x = x - ix * CTX_PI * 2;
      x = -x;
    }
  if (x < -CTX_PI * 1000)
  {
    x = -0.5f;
  }
  if (x > CTX_PI * 1000)
  {
    // really large numbers tend to cause practically inifinite
    // loops since the > CTX_PI * 2 seemingly fails
    x = 0.5f;
  }
  if (x > CTX_PI * 2)
    { 
      long ix = (long)(x / (CTX_PI * 2));
      x = x - (ix * CTX_PI * 2);
    }
  while (x < -CTX_PI)
    { x += CTX_PI * 2; }
  while (x > CTX_PI)
    { x -= CTX_PI * 2; }

  /* source : http://mooooo.ooo/chebyshev-sine-approximation/ */
  const float coeffs[]=
  {
    -0.10132118f,           // x
      0.0066208798f,         // x^3
      -0.00017350505f,        // x^5
      0.0000025222919f,      // x^7
      -0.000000023317787f,    // x^9
      0.00000000013291342f
    }; // x^11
  float x2 = x*x;
  float p11 = coeffs[5];
  float p9  = p11*x2 + coeffs[4];
  float p7  = p9*x2  + coeffs[3];
  float p5  = p7*x2  + coeffs[2];
  float p3  = p5*x2  + coeffs[1];
  float p1  = p3*x2  + coeffs[0];
  return (x - CTX_PI + 0.00000008742278f) *
         (x + CTX_PI - 0.00000008742278f) * p1 * x;
}

static CTX_INLINE float ctx_atan2f (const float y, const float x)
{
  float atan, z;
  if ( x == 0.0f )
    {
      if ( y > 0.0f )
        { return CTX_PI/2; }
      if ( y == 0.0f )
        { return 0.0f; }
      return -CTX_PI/2;
    }
  z = y/x;
  if ( ctx_fabsf ( z ) < 1.0f )
    {
      atan = z/ (1.0f + 0.28f*z*z);
      if (x < 0.0f)
        {
          if ( y < 0.0f )
            { return atan - CTX_PI; }
          return atan + CTX_PI;
        }
    }
  else
    {
      atan = CTX_PI/2 - z/ (z*z + 0.28f);
      if ( y < 0.0f ) { return atan - CTX_PI; }
    }
  return atan;
}


static CTX_INLINE float ctx_atanf (const float a)
{
  return ctx_atan2f (a, 1.0f);
}

static CTX_INLINE float ctx_asinf (const float x)
{
  return ctx_atanf ( x * ctx_invsqrtf (1.0f-ctx_pow2 (x) ));
}

static CTX_INLINE float ctx_acosf (const float x)
{
  return ctx_atanf ( ctx_sqrtf (1.0f-ctx_pow2 (x) ) / (x) );
}

CTX_INLINE static float ctx_cosf (const float a)
{
  return ctx_sinf ( (a) + CTX_PI/2.0f);
}

static CTX_INLINE float ctx_tanf (const float a)
{
  return (ctx_cosf (a) / ctx_sinf (a) );
}
static CTX_INLINE float
ctx_floorf (const float x)
{
  return (int)x; // XXX
}
static CTX_INLINE float
ctx_expf (const float x)
{
  union { uint32_t i; float f; } v =
    {  (uint32_t)( (1 << 23) * (x + 183.1395965f)) };
  return v.f;
}

/* define more trig based on having sqrt, sin and atan2 */

#else
#if !__COSMOPOLITAN__
#include <math.h>
#endif
static CTX_INLINE float ctx_fabsf (const float x)           { return fabsf (x); }
static CTX_INLINE float ctx_floorf (const float x)          { return floorf (x); }
static CTX_INLINE float ctx_asinf (const float x)           { return asinf (x); }
static CTX_INLINE float ctx_sinf (const float x)            { return sinf (x); }
static CTX_INLINE float ctx_atan2f (const float y, float x) { return atan2f (y, x); }
static CTX_INLINE float ctx_hypotf (const float a, float b) { return hypotf (a, b); }
static CTX_INLINE float ctx_acosf (const float a)           { return acosf (a); }
static CTX_INLINE float ctx_cosf (const float a)            { return cosf (a); }
static CTX_INLINE float ctx_tanf (const float a)            { return tanf (a); }
static CTX_INLINE float ctx_expf (const float p)            { return expf (p); }
static CTX_INLINE float ctx_sqrtf (const float a)           { return sqrtf (a); }
static CTX_INLINE float ctx_atanf (const float a)           { return atanf (a); }
#endif

static CTX_INLINE float
ctx_invsqrtf_fast (const float x)
{
  union
  {
    float f;
    uint32_t i;
  } u = { x };
  u.i = 0x5f3759df - (u.i >> 1);
  return u.f;
}
CTX_INLINE static float ctx_sqrtf_fast (const float a)
{
  return 1.0f/ctx_invsqrtf_fast (a);
}
CTX_INLINE static float ctx_hypotf_fast (const float a, const float b)
{
  return ctx_sqrtf_fast (ctx_pow2 (a)+ctx_pow2 (b) );
}


static CTX_INLINE float ctx_atan2f_rest (
  const float x, const float y_recip)
{
  float atan, z = x * y_recip;
  if ( ctx_fabsf ( z ) < 1.0f )
    {
      atan = z/ (1.0f + 0.28f*z*z);
      if (y_recip < 0.0f)
        {
          if ( x < 0.0f )
            { return atan - CTX_PI; }
          return atan + CTX_PI;
        }
    }
  else
    {
      atan = CTX_PI/2 - z/ (z*z + 0.28f);
      if ( x < 0.0f ) { return atan - CTX_PI; }
    }
  return atan;
}


static inline float _ctx_parse_float (const char *str, char **endptr)
{
  return strtof (str, endptr); /* XXX: , vs . problem in some locales */
}

const char *ctx_get_string (Ctx *ctx, uint32_t hash);
void ctx_set_string (Ctx *ctx, uint32_t hash, const char *value);
void ctx_set_blob (Ctx *ctx, uint32_t hash, const void*value, int length);
typedef struct _CtxColor CtxColor;

void
ctx_matrix_translate (CtxMatrix *matrix, float x, float y);


void ctx_get_matrix (Ctx *ctx, CtxMatrix *matrix);
void ctx_set_matrix (Ctx *ctx, CtxMatrix *matrix);
int _ctx_is_rasterizer (Ctx *ctx);

int ctx_color (Ctx *ctx, const char *string);
typedef struct _CtxState CtxState;
CtxColor *ctx_color_new (void);
CtxState *ctx_get_state (Ctx *ctx);
void ctx_color_get_rgba (CtxState *state, CtxColor *color, float *out);
void ctx_color_set_rgba (CtxState *state, CtxColor *color, float r, float g, float b, float a);
void ctx_color_free (CtxColor *color);
void ctx_set_color (Ctx *ctx, uint32_t hash, CtxColor *color);
int  ctx_get_color (Ctx *ctx, uint32_t hash, CtxColor *color);
int  ctx_color_set_from_string (Ctx *ctx, CtxColor *color, const char *string);

int ctx_color_is_transparent (CtxColor *color);

void ctx_user_to_device          (Ctx *ctx, float *x, float *y);
void ctx_user_to_device_distance (Ctx *ctx, float *x, float *y);


void ctx_device_to_user          (Ctx *ctx, float *x, float *y);
void ctx_device_to_user_distance (Ctx *ctx, float *x, float *y);

int ctx_is_set_now (Ctx *ctx, uint32_t hash);
void ctx_set_size (Ctx *ctx, int width, int height);

static inline float ctx_matrix_get_scale (CtxMatrix *matrix)
{
   return ctx_maxf (ctx_maxf (ctx_fabsf (matrix->m[0][0]),
                         ctx_fabsf (matrix->m[0][1]) ),
               ctx_maxf (ctx_fabsf (matrix->m[1][0]),
                         ctx_fabsf (matrix->m[1][1]) ) );
}

#if CTX_GET_CONTENTS
int
_ctx_file_get_contents (const char     *path,
                        unsigned char **contents,
                        long           *length);
#endif

#if CTX_BABL
void ctx_rasterizer_colorspace_babl (CtxState      *state,
                                     CtxColorSpace  space_slot,
                                     const Babl    *space);
#endif
void ctx_rasterizer_colorspace_icc (CtxState            *state,
                                    CtxColorSpace        space_slot,
                                    const unsigned char *icc_data,
                                    int                  icc_length);


CtxBuffer *ctx_buffer_new_bare (void);

void ctx_buffer_set_data (CtxBuffer *buffer,
                          void *data, int width, int height,
                          int stride,
                          CtxPixelFormat pixel_format,
                          void (*freefunc) (void *pixels, void *user_data),
                          void *user_data);

int ctx_textureclock (Ctx *ctx);


void ctx_list_backends(void);
int ctx_pixel_format_ebpp (CtxPixelFormat format);

#endif
#if 0
#if !__COSMOPOLITAN__
#include <stdarg.h>
#include <unistd.h>
#include <math.h>

#endif
#include "ctx.h"
#endif

/* An immediate mode toolkit for ctx, ctx expects to receive full frames of
 * data to draw and by keeping knowledge of the contents of the previous frame
 * avoid re-drawing unchanged areas of the display.
 *
 * 
 * TODO/BUGS:
 *   - more than one scroll per panel
 *   - horizontal scroll
 */

typedef struct _Css      Css;
typedef struct _CssPanel CssPanel;


extern int _css_key_bindings_active;
Css *css_new        (Ctx *ctx);
void css_destroy    (Css *itk);
void css_reset      (Css *itk);

CssPanel *css_panel_start (Css *itk, const char *title, int x, int y, int width, int height);
void      css_panel_end   (Css *itk);

void css_newline    (Css *itk);
void css_seperator  (Css *itk);
void css_titlebar   (Css *itk, const char *label);

void css_label      (Css *itk, const char *label);
void css_labelf     (Css *itk, const char *format, ...);


int  css_toggle     (Css *itk, const char *label, int in_val);

int  css_button     (Css *itk, const char *label);

/* this is already modernized - it is the same as css_toggle but gets rendered
 * differently
 */
int  css_radio      (Css *itk, const char *label, int set);


/* needs tweaking / expander2 it should return the state of the expander */
int  css_expander   (Css *itk, const char *label, int *val);

/* return newly set value if ant change */
int  css_choice     (Css *itk, const char *label, int in_val);
void css_choice_add (Css *itk, int value, const char *label);
void css_set_focus_no (Css *itk, int pos);

int  css_control_no (Css *itk);


/*
 * returns NULL if value is unchanged or a newly allocated string
 * when entry has been changed.
 *
 */
char *css_entry (Css *itk,
                 const char *label,
                 const char *fallback,
                 const char *val);



/* returns the new value - if it has changed due to interaction
 */
float css_slider    (Css *itk, const char *label, float value, double min, double max, double step);

/* these are utilities to keep some code a little bit shorter
 */
void css_slider_int   (Css *itk, const char *label, int *val, int min, int max, int step);
void css_slider_float (Css *itk, const char *label, float *val, float min, float max, float step);
void css_slider_uint8 (Css *itk, const char *label, uint8_t *val, uint8_t min, uint8_t max, uint8_t step);

/*  returns 1 when the value has been changed
 *
 *  this expects a string to write to maxlen is length including
 *  room for terminating \0
 *
 *  return 1 when the value has been changed
 */
int css_entry_str_len (Css        *itk,
                       const char *label,
                       const char *fallback,
                       char       *val,
                       int         maxlen);

/* to be called on focus changes that might take focus away from
 * edited css_entry
 */
void css_entry_commit (Css *itk);
void css_lost_focus (Css *itk);

/* return new value if changed */


//void css_choice_add (Css *itk, int value, const char *label);
void        css_done          (Css *itk);
void        css_style_color   (Ctx *ctx, const char *name);
//void      css_style_color2  (Css *itk, const char *klass, const char*attr);
void        css_style_bg      (Css *itk, const char *klass);
void        css_style_fg      (Css *itk, const char *klass);
const char *css_style_string  (const char *name);
float       css_style_float   (char *name);
float       css_em            (Css *itk);

Ctx        *css_ctx            (Css *itk);
float       css_x              (Css *itk);
float       css_y              (Css *itk);
void        css_set_x          (Css *itk, float x);
void        css_set_y          (Css *itk, float y);
void        css_set_xy         (Css *itk, float x, float y);
void        css_set_edge_left  (Css *itk, float edge);
void        css_set_edge_right (Css *itk, float edge);
void        css_set_edge_top   (Css *itk, float edge);
void        css_set_edge_bottom(Css *itk, float edge);
float       css_wrap_width     (Css *itk);
float       css_height         (Css *itk);
void        css_set_height     (Css *itk, float height);
float       css_edge_left      (Css *itk);
float       css_edge_right     (Css *itk);
float       css_edge_top       (Css *itk);
float       css_edge_bottom    (Css *itk);
void        css_set_wrap_width (Css *itk, float wwidth);

/* runs until ctx_exit itk->ctx) is called */
void        css_run_ui         (Css *itk, int (*ui_fun)(Css *itk, void *data), void *ui_data);
void        css_set_font_size  (Css *itk, float font_size);

void        css_set_scale       (Css *itk, float scale);
float       css_scale           (Css *itk);
float       css_rel_ver_advance (Css *itk);

int         css_focus_no         (Css *itk);
int         css_is_editing_entry (Css *itk);

/*
   A helper function that does css_run_ui on a ctx context that is both created
   and destroyed, this helps keep small programs tiny.

   void css_main (int (*ui_fun)(Css *itk, void *data), void *ui_data)
   {
     Ctx *ctx = ctx_new (-1, -1, NULL);
     Css *itk = css_new (ctx);
     css_run_ui (itk, ui_fun, ui_data);
     css_destroy (itk);
     ctx_destroy (ctx);
    }
 */

void css_main         (int (*ui_fun)(Css *itk, void *data), void *ui_data);
void css_key_bindings (Css *itk);

typedef struct _CtxControl CtxControl;
CtxControl *css_focused_control (Css *itk);
CtxControl *css_find_control    (Css *itk, int no);
CtxControl *css_add_control     (Css *itk,
                                 int type,
                                 const char *label,
                                 float x, float y,
                                 float width, float height);
void css_set_flag               (Css *itk, int flag, int on);


void css_panels_reset_scroll    (Css *itk);

void css_ctx_settings (Css *itk);
void css_css_settings (Css *itk);
void css_key_quit (CtxEvent *event, void *userdata, void *userdata2);

enum {
  UI_SLIDER = 1,
  UI_EXPANDER,
  UI_TOGGLE,
  UI_LABEL,
  UI_TITLEBAR,
  UI_BUTTON,
  UI_CHOICE,
  UI_ENTRY,
  UI_MENU,
  UI_SEPARATOR,
  UI_RADIO
};

enum {
  CSS_FLAG_SHOW_LABEL = (1<<0),
  CSS_FLAG_ACTIVE     = (1<<1),
  CSS_FLAG_CANCEL_ON_LOST_FOCUS = (1<<2),
  CSS_FLAG_DEFAULT    = (CSS_FLAG_SHOW_LABEL|CSS_FLAG_ACTIVE)
};
 // XXX : commit or cancel entry on focus change
 //


struct _CssPanel{
  int   x;
  int   y;
  int   width;
  int   height;
  int   expanded;
  int   max_y;
  float scroll_start_y;
  float scroll;

  int   do_scroll_jump;
  const char *title;
};

typedef struct CssPal{
  char id;
  uint8_t r;
  uint8_t g;
  uint8_t b;
  uint8_t a;
} CssPal;

struct _CtxControl{
  int no;
  int ref_count;
  uint64_t flags;
  int type; /* this should be a pointer to the vfuncs/class struct
               instead - along with one optional instance data per control */
  char *label;
  void *id; /* possibly unique identifier */

  float x;
  float y;
  float width;
  float height;
  void *val;

  float value;

  char *entry_value;

  char *fallback;
  float min;
  float max;
  float step;
};


float css_panel_scroll (Css *itk);
void css_panel_set_scroll (Css *itk, float scroll);

typedef struct _Css          Css;
typedef struct _CtxStyle     CtxStyle;

void css_start            (Css *mrg, const char *class_name, void *id_ptr);
void css_start_with_style (Css *mrg,
                           const char *style_id,
                           void       *id_ptr,
                           const char *style);

void css_start_with_stylef (Css *mrg, const char *style_id, void *id_ptr,
                            const char *format, ...);
void css_xml_render (Css *mrg,
                     char *uri_base,
                     void (*link_cb) (CtxEvent *event, void *href, void *link_data),
                     void *link_data,
                     void *(finalize)(void *listen_data, void *listen_data2, void *finalize_data),
                     void *finalize_data,
                     char *html_);

void
css_printf (Css *mrg, const char *format, ...);

void css_print_xml (Css *mrg, const char *xml);

void
css_printf_xml (Css *mrg, const char *format, ...);

void
css_print_xml (Css *mrg, const char *utf8);

// returns width added horizontally
float css_addstr (Css *mrg, const char *string, int utf8_length);

void ctx_stylesheet_add (Css *mrg, const char *css, const char *uri_base,
                         int priority, char **error);
CtxStyle *ctx_style (Css *mrg);

void css_end (Css *mrg, CtxFloatRectangle *ret_rect);

int
mrg_get_contents (Css         *mrg,
                  const char  *referer,
                  const char  *input_uri,
                  char       **contents,
                  long        *length);

int css_xml_extent (Css *mrg, uint8_t *contents, float *width, float *height, float *vb_x, float *vb_y, float *vb_width, float *vb_height);
#ifndef __CTX_CONSTANTS
#define __CTX_CONSTANTS
#define SQZ_a 195u // "a"
#define SQZ_absolute 1840437120u // "absolute"
#define SQZ_action 3696112672u // "action"
#define SQZ_addStop 220908742u // "addStop"
#define SQZ_aelig 1120987016u // "aelig"
#define SQZ_alias 2034413622u // "alias"
#define SQZ_all_scroll 1118648896u // "all-scroll"
#define SQZ_alpha 4000549904u // "alpha"
#define SQZ_alphabetic 2966120946u // "alphabetic"
#define SQZ_amp 7368131u // "amp"
#define SQZ_apos 1936683203u // "apos"
#define SQZ_aqua 1635086787u // "aqua"
#define SQZ_arc 6517443u // "arc"
#define SQZ_arcTo 3982854812u // "arcTo"
#define SQZ_aring 855903140u // "aring"
#define SQZ_auto 1869903299u // "auto"
#define SQZ_background 1071035380u // "background"
#define SQZ_background_color 609802584u // "background-color"
#define SQZ_beginPath 120180698u // "beginPath"
#define SQZ_bevel 761062270u // "bevel"
#define SQZ_bidi_override 29328268u // "bidi-override"
#define SQZ_black 271321868u // "black"
#define SQZ_blend 316843154u // "blend"
#define SQZ_blendMode 644815934u // "blendMode"
#define SQZ_blending 3694082958u // "blending"
#define SQZ_blink 2515894180u // "blink"
#define SQZ_block 2220858820u // "block"
#define SQZ_blue 1702194373u // "blue"
#define SQZ_bold 1684828101u // "bold"
#define SQZ_bolder 2370434142u // "bolder"
#define SQZ_border 1170187232u // "border"
#define SQZ_border_bottom 3975273498u // "border-bottom"
#define SQZ_border_bottom_color 3186075110u // "border-bottom-color"
#define SQZ_border_bottom_width 1124387196u // "border-bottom-width"
#define SQZ_border_box 1245790092u // "border-box"
#define SQZ_border_color 541811290u // "border-color"
#define SQZ_border_left 2975583868u // "border-left"
#define SQZ_border_left_color 3331269224u // "border-left-color"
#define SQZ_border_left_width 3310378862u // "border-left-width"
#define SQZ_border_right 4045413762u // "border-right"
#define SQZ_border_right_color 243329524u // "border-right-color"
#define SQZ_border_right_width 1360128814u // "border-right-width"
#define SQZ_border_top 1801458758u // "border-top"
#define SQZ_border_top_color 3407512826u // "border-top-color"
#define SQZ_border_top_width 4176048594u // "border-top-width"
#define SQZ_border_width 3642950774u // "border-width"
#define SQZ_both 1752461253u // "both"
#define SQZ_bottom 1302706776u // "bottom"
#define SQZ_box_sizing 3965777366u // "box-sizing"
#define SQZ_br 29381u // "br"
#define SQZ_bull 1819047365u // "bull"
#define SQZ_butt 1953789381u // "butt"
#define SQZ_c 199u // "c"
#define SQZ_cap 7365063u // "cap"
#define SQZ_cedil 1951672802u // "cedil"
#define SQZ_cell 1819043271u // "cell"
#define SQZ_cent 1953392071u // "cent"
#define SQZ_center 1006603526u // "center"
#define SQZ_circle 196442712u // "circle"
#define SQZ_class 680581762u // "class"
#define SQZ_clear 1094071360u // "clear"
#define SQZ_clip 1885957319u // "clip"
#define SQZ_closePath 3537486488u // "closePath"
#define SQZ_cmyk 1803120071u // "cmyk"
#define SQZ_cmykS 3263315852u // "cmykS"
#define SQZ_cmykSpace 2366647638u // "cmykSpace"
#define SQZ_cmyka 3355381580u // "cmyka"
#define SQZ_cmykaS 3917993734u // "cmykaS"
#define SQZ_col_resize 2272161114u // "col-resize"
#define SQZ_colgroup 4270888898u // "colgroup"
#define SQZ_color 4231809138u // "color"
#define SQZ_colorSpace 4246256736u // "colorSpace"
#define SQZ_compositingMode 3764262848u // "compositingMode"
#define SQZ_conicGradient 1669326832u // "conicGradient"
#define SQZ_context_menu 434478918u // "context-menu"
#define SQZ_copy 2037411783u // "copy"
#define SQZ_crosshair 4030082594u // "crosshair"
#define SQZ_curren 3230040072u // "curren"
#define SQZ_currentColor 3452186816u // "currentColor"
#define SQZ_cursor 4212479966u // "cursor"
#define SQZ_cursor_wait 1647783762u // "cursor-wait"
#define SQZ_curveTo 48499966u // "curveTo"
#define SQZ_cx 30919u // "cx"
#define SQZ_cy 31175u // "cy"
#define SQZ_cyan 1851881927u // "cyan"
#define SQZ_d 201u // "d"
#define SQZ_darken 2939689930u // "darken"
#define SQZ_dd 25801u // "dd"
#define SQZ_default 2280700682u // "default"
#define SQZ_defineFont 813704086u // "defineFont"
#define SQZ_defineGlyph 1628031142u // "defineGlyph"
#define SQZ_defineTexture 4030922434u // "defineTexture"
#define SQZ_defs 1936090569u // "defs"
#define SQZ_deg 6776265u // "deg"
#define SQZ_destinationAtop 1605909240u // "destinationAtop"
#define SQZ_destinationIn 4096489814u // "destinationIn"
#define SQZ_destinationOut 1966109282u // "destinationOut"
#define SQZ_destinationOver 507903672u // "destinationOver"
#define SQZ_deviceCMYK 3879736092u // "deviceCMYK"
#define SQZ_deviceRGB 911778270u // "deviceRGB"
#define SQZ_difference 3137481792u // "difference"
#define SQZ_direction 626501720u // "direction"
#define SQZ_display 512467722u // "display"
#define SQZ_div 7760329u // "div"
#define SQZ_dotted 1961166438u // "dotted"
#define SQZ_drgb 1650946761u // "drgb"
#define SQZ_drgbS 179784888u // "drgbS"
#define SQZ_drgbSpace 1000873868u // "drgbSpace"
#define SQZ_drgba 465014226u // "drgba"
#define SQZ_drgbaS 2465325300u // "drgbaS"
#define SQZ_dt 29897u // "dt"
#define SQZ_e_resize 3569673796u // "e-resize"
#define SQZ_ellipse 3790670476u // "ellipse"
#define SQZ_embed 3279610738u // "embed"
#define SQZ_end 6581963u // "end"
#define SQZ_endFrame 2645960260u // "endFrame"
#define SQZ_endGroup 2864376370u // "endGroup"
#define SQZ_euro 1869772235u // "euro"
#define SQZ_evenOdd 3373267632u // "evenOdd"
#define SQZ_evenodd 1852152574u // "evenodd"
#define SQZ_ew_resize 2458267842u // "ew-resize"
#define SQZ_extend 2652659078u // "extend"
#define SQZ_feather 4162344430u // "feather"
#define SQZ_file 1701603789u // "file"
#define SQZ_fill 1819044301u // "fill"
#define SQZ_fillRect 3070816944u // "fillRect"
#define SQZ_fillRule 2262201016u // "fillRule"
#define SQZ_fill_color 2350805940u // "fill-color"
#define SQZ_fill_rule 1151472398u // "fill-rule"
#define SQZ_first_child 439258010u // "first-child"
#define SQZ_fixed 778407114u // "fixed"
#define SQZ_float 2455282620u // "float"
#define SQZ_flow_root 518738066u // "flow-root"
#define SQZ_font 1953394637u // "font"
#define SQZ_fontSize 2620910512u // "fontSize"
#define SQZ_font_family 2798191102u // "font-family"
#define SQZ_font_size 3477901146u // "font-size"
#define SQZ_font_style 2628706306u // "font-style"
#define SQZ_font_weight 1197895732u // "font-weight"
#define SQZ_fr 29389u // "fr"
#define SQZ_fuchsia 439362132u // "fuchsia"
#define SQZ_fx 30925u // "fx"
#define SQZ_fy 31181u // "fy"
#define SQZ_g 207u // "g"
#define SQZ_globalAlpha 3833809790u // "globalAlpha"
#define SQZ_glyph 1308254186u // "glyph"
#define SQZ_gradientAddStop 2831884664u // "gradientAddStop"
#define SQZ_gradientTransform 1288938878u // "gradientTransform"
#define SQZ_gradientUnits 2968072588u // "gradientUnits"
#define SQZ_gray 2036429519u // "gray"
#define SQZ_grayS 417614710u // "grayS"
#define SQZ_graya 2560443068u // "graya"
#define SQZ_grayaS 2408801086u // "grayaS"
#define SQZ_green 1517032782u // "green"
#define SQZ_gt 29903u // "gt"
#define SQZ_hanging 72134188u // "hanging"
#define SQZ_head 1684104657u // "head"
#define SQZ_height 3762298230u // "height"
#define SQZ_hellip 4254915686u // "hellip"
#define SQZ_help 1886152145u // "help"
#define SQZ_hidden 2737189728u // "hidden"
#define SQZ_horLineTo 2754532u // "horLineTo"
#define SQZ_hr 29393u // "hr"
#define SQZ_href 1717924561u // "href"
#define SQZ_html 1819112657u // "html"
#define SQZ_http 1886680273u // "http"
#define SQZ_hue 6649297u // "hue"
#define SQZ_id 25811u // "id"
#define SQZ_identity 4029142280u // "identity"
#define SQZ_ideographic 3361616408u // "ideographic"
#define SQZ_iexcl 2255292952u // "iexcl"
#define SQZ_imageSmoothing 3109175850u // "imageSmoothing"
#define SQZ_img 6778323u // "img"
#define SQZ_inline_block 3464466506u // "inline-block"
#define SQZ_input 3954510188u // "input"
#define SQZ_inset 3128333578u // "inset"
#define SQZ_italic 396886224u // "italic"
#define SQZ_join 1852403669u // "join"
#define SQZ_justify 233888506u // "justify"
#define SQZ_kerningPair 2079485344u // "kerningPair"
#define SQZ_lab 6447577u // "lab"
#define SQZ_labS 1398956505u // "labS"
#define SQZ_laba 1633837529u // "laba"
#define SQZ_labaS 4170772618u // "labaS"
#define SQZ_laquo 64667100u // "laquo"
#define SQZ_lch 6841305u // "lch"
#define SQZ_lchS 1399350233u // "lchS"
#define SQZ_lcha 1634231257u // "lcha"
#define SQZ_lchaS 2598918966u // "lchaS"
#define SQZ_left 1952867801u // "left"
#define SQZ_letter_spacing 1326564462u // "letter-spacing"
#define SQZ_li 27097u // "li"
#define SQZ_lighten 2693650260u // "lighten"
#define SQZ_lime 1701669337u // "lime"
#define SQZ_line 1701734873u // "line"
#define SQZ_lineCap 3957741450u // "lineCap"
#define SQZ_lineDash 2886130602u // "lineDash"
#define SQZ_lineDashOffset 1904302200u // "lineDashOffset"
#define SQZ_lineHeight 1698077880u // "lineHeight"
#define SQZ_lineJoin 3891781172u // "lineJoin"
#define SQZ_lineTo 3077153258u // "lineTo"
#define SQZ_lineWidth 3851910782u // "lineWidth"
#define SQZ_line_height 3733591786u // "line-height"
#define SQZ_line_width 1869007654u // "line-width"
#define SQZ_linearGradient 905023680u // "linearGradient"
#define SQZ_linethrough 34244248u // "linethrough"
#define SQZ_link 1802398169u // "link"
#define SQZ_list_item 2339943222u // "list-item"
#define SQZ_lower 697158190u // "lower"
#define SQZ_lowerBottom 4240938844u // "lowerBottom"
#define SQZ_lt 29913u // "lt"
#define SQZ_ltr 7501017u // "ltr"
#define SQZ_magenta 578523642u // "magenta"
#define SQZ_margin 2593567380u // "margin"
#define SQZ_margin_bottom 2905482030u // "margin-bottom"
#define SQZ_margin_left 1656714300u // "margin-left"
#define SQZ_margin_right 3017942990u // "margin-right"
#define SQZ_margin_top 625296560u // "margin-top"
#define SQZ_maroon 3386542482u // "maroon"
#define SQZ_max_height 129479668u // "max-height"
#define SQZ_max_width 713333008u // "max-width"
#define SQZ_maximize 4009606768u // "maximize"
#define SQZ_mdash 2043309408u // "mdash"
#define SQZ_meta 1635018203u // "meta"
#define SQZ_middle 2223770148u // "middle"
#define SQZ_middot 435157574u // "middot"
#define SQZ_min_height 3589941308u // "min-height"
#define SQZ_min_width 570636676u // "min-width"
#define SQZ_miter 886459200u // "miter"
#define SQZ_miterLimit 1856773288u // "miterLimit"
#define SQZ_move 1702260699u // "move"
#define SQZ_moveTo 3083476356u // "moveTo"
#define SQZ_multiply 3976122014u // "multiply"
#define SQZ_n_resize 202450980u // "n-resize"
#define SQZ_navy 2037801437u // "navy"
#define SQZ_nbsp 1886610141u // "nbsp"
#define SQZ_ne_resize 2436514350u // "ne-resize"
#define SQZ_nesw_resize 366763636u // "nesw-resize"
#define SQZ_newPage 2687321890u // "newPage"
#define SQZ_newPath 4208019970u // "newPath"
#define SQZ_newState 3121230612u // "newState"
#define SQZ_no_drop 890688824u // "no-drop"
#define SQZ_none 1701736413u // "none"
#define SQZ_nonzero 2746451764u // "nonzero"
#define SQZ_normal 1883425054u // "normal"
#define SQZ_not_allowed 224860282u // "not-allowed"
#define SQZ_nowrap 3884678112u // "nowrap"
#define SQZ_ns_resize 1753032392u // "ns-resize"
#define SQZ_nw_resize 3642132534u // "nw-resize"
#define SQZ_oblique 2262696070u // "oblique"
#define SQZ_offset 1396589030u // "offset"
#define SQZ_olive 3415799870u // "olive"
#define SQZ_omega 1147793334u // "omega"
#define SQZ_opacity 2184299270u // "opacity"
#define SQZ_option 537535526u // "option"
#define SQZ_ordm 1835299551u // "ordm"
#define SQZ_oslash 1567583338u // "oslash"
#define SQZ_overflow 3253908870u // "overflow"
#define SQZ_overline 2037328102u // "overline"
#define SQZ_p 225u // "p"
#define SQZ_padding 2806228288u // "padding"
#define SQZ_padding_bottom 2393940612u // "padding-bottom"
#define SQZ_padding_left 2955272020u // "padding-left"
#define SQZ_padding_right 4039401684u // "padding-right"
#define SQZ_padding_top 439515192u // "padding-top"
#define SQZ_paint 1082699806u // "paint"
#define SQZ_para 1634886113u // "para"
#define SQZ_path 1752457697u // "path"
#define SQZ_phi 6908129u // "phi"
#define SQZ_plusmn 279695816u // "plusmn"
#define SQZ_pointer 132752978u // "pointer"
#define SQZ_polygon 1804794854u // "polygon"
#define SQZ_polyline 845479076u // "polyline"
#define SQZ_position 3883240572u // "position"
#define SQZ_pound 363756384u // "pound"
#define SQZ_pre 6648545u // "pre"
#define SQZ_pre_line 4122418998u // "pre-line"
#define SQZ_pre_wrap 837003298u // "pre-wrap"
#define SQZ_preserve 1666261276u // "preserve"
#define SQZ_print_symbols 669612738u // "print-symbols"
#define SQZ_progress 2815872894u // "progress"
#define SQZ_purple 3066163412u // "purple"
#define SQZ_quadTo 3205866160u // "quadTo"
#define SQZ_quot 1953461731u // "quot"
#define SQZ_r 229u // "r"
#define SQZ_radialGradient 83850682u // "radialGradient"
#define SQZ_raise 2772216630u // "raise"
#define SQZ_raiseTop 1913256554u // "raiseTop"
#define SQZ_raquo 3261968210u // "raquo"
#define SQZ_rect 1952671205u // "rect"
#define SQZ_rectangle 1861211308u // "rectangle"
#define SQZ_red 6579685u // "red"
#define SQZ_reg 6776293u // "reg"
#define SQZ_rel 7103973u // "rel"
#define SQZ_relArcTo 4253296276u // "relArcTo"
#define SQZ_relCurveTo 2548821600u // "relCurveTo"
#define SQZ_relHorLineTo 3243288302u // "relHorLineTo"
#define SQZ_relLineTo 1630005260u // "relLineTo"
#define SQZ_relMoveTo 429673596u // "relMoveTo"
#define SQZ_relQuadTo 2362773920u // "relQuadTo"
#define SQZ_relSmoothTo 1725151068u // "relSmoothTo"
#define SQZ_relSmoothqTo 2960208730u // "relSmoothqTo"
#define SQZ_relVerLineTo 1112835164u // "relVerLineTo"
#define SQZ_relative 979899102u // "relative"
#define SQZ_resetPath 2864022032u // "resetPath"
#define SQZ_restore 1405984258u // "restore"
#define SQZ_reverse 2464792996u // "reverse"
#define SQZ_rgb 6449125u // "rgb"
#define SQZ_rgbS 1398958053u // "rgbS"
#define SQZ_rgbSpace 1625332122u // "rgbSpace"
#define SQZ_rgba 1633839077u // "rgba"
#define SQZ_rgbaS 4158357036u // "rgbaS"
#define SQZ_right 1751820526u // "right"
#define SQZ_rotate 1488065704u // "rotate"
#define SQZ_round 3173447652u // "round"
#define SQZ_roundRectangle 3273785582u // "roundRectangle"
#define SQZ_row_resize 702013530u // "row-resize"
#define SQZ_rtl 7107813u // "rtl"
#define SQZ_rx 30949u // "rx"
#define SQZ_ry 31205u // "ry"
#define SQZ_s_resize 125328402u // "s-resize"
#define SQZ_save 1702257127u // "save"
#define SQZ_scale 2647970994u // "scale"
#define SQZ_screen 3670530854u // "screen"
#define SQZ_scroll 3099410214u // "scroll"
#define SQZ_se_resize 315956726u // "se-resize"
#define SQZ_sect 1952671207u // "sect"
#define SQZ_setFontSize 231476456u // "setFontSize"
#define SQZ_setLineCap 174619460u // "setLineCap"
#define SQZ_setLineJoin 4048631422u // "setLineJoin"
#define SQZ_setLineWidth 3926586244u // "setLineWidth"
#define SQZ_shadowBlur 3889925774u // "shadowBlur"
#define SQZ_shadowColor 291132682u // "shadowColor"
#define SQZ_shadowOffsetX 1630263752u // "shadowOffsetX"
#define SQZ_shadowOffsetY 89733304u // "shadowOffsetY"
#define SQZ_shy 7956711u // "shy"
#define SQZ_silver 2643959904u // "silver"
#define SQZ_smoothQuadTo 954100048u // "smoothQuadTo"
#define SQZ_smoothTo 174420282u // "smoothTo"
#define SQZ_solid 2770487110u // "solid"
#define SQZ_sourceAtop 864901378u // "sourceAtop"
#define SQZ_sourceIn 1369048320u // "sourceIn"
#define SQZ_sourceOut 1938332472u // "sourceOut"
#define SQZ_sourceOver 134897678u // "sourceOver"
#define SQZ_sourceTransform 1611809620u // "sourceTransform"
#define SQZ_spreadMethod 3574032566u // "spreadMethod"
#define SQZ_square 239664392u // "square"
#define SQZ_src 6517479u // "src"
#define SQZ_start 4080984002u // "start"
#define SQZ_startFrame 2128007688u // "startFrame"
#define SQZ_startGroup 4085444064u // "startGroup"
#define SQZ_static 3471421972u // "static"
#define SQZ_stop 1886352615u // "stop"
#define SQZ_stop_color 1175890462u // "stop-color"
#define SQZ_stop_opacity 250359768u // "stop-opacity"
#define SQZ_stroke 1444212908u // "stroke"
#define SQZ_strokePos 888669104u // "strokePos"
#define SQZ_strokeRect 1131907664u // "strokeRect"
#define SQZ_strokeSource 2685374474u // "strokeSource"
#define SQZ_stroke_color 1804158464u // "stroke-color"
#define SQZ_stroke_linecap 535668102u // "stroke-linecap"
#define SQZ_stroke_linejoin 1888005366u // "stroke-linejoin"
#define SQZ_stroke_miterlimit 1499817720u // "stroke-miterlimit"
#define SQZ_stroke_width 2655701078u // "stroke-width"
#define SQZ_style 3511288852u // "style"
#define SQZ_sub 6452711u // "sub"
#define SQZ_sup1 829453799u // "sup1"
#define SQZ_sup2 846231015u // "sup2"
#define SQZ_sup3 863008231u // "sup3"
#define SQZ_super 532067904u // "super"
#define SQZ_svg 6780647u // "svg"
#define SQZ_sw_resize 2121684268u // "sw-resize"
#define SQZ_syntax_highlight 1534043236u // "syntax-highlight"
#define SQZ_tab_size 945510526u // "tab-size"
#define SQZ_table 2705307032u // "table"
#define SQZ_tbody 3472781808u // "tbody"
#define SQZ_td 25833u // "td"
#define SQZ_teal 1818322409u // "teal"
#define SQZ_text 1954047465u // "text"
#define SQZ_textAlign 3594701278u // "textAlign"
#define SQZ_textBaseline 1453773018u // "textBaseline"
#define SQZ_textDirection 1179776176u // "textDirection"
#define SQZ_text_align 519203916u // "text-align"
#define SQZ_text_anchor 2618811808u // "text-anchor"
#define SQZ_text_decoration 2191990606u // "text-decoration"
#define SQZ_text_indent 1164860048u // "text-indent"
#define SQZ_text_stroke 3855125514u // "text-stroke"
#define SQZ_text_stroke_color 357760164u // "text-stroke-color"
#define SQZ_text_stroke_width 376828216u // "text-stroke-width"
#define SQZ_texture 785032878u // "texture"
#define SQZ_tfoot 3061216442u // "tfoot"
#define SQZ_th 26857u // "th"
#define SQZ_thead 460193516u // "thead"
#define SQZ_title 300059882u // "title"
#define SQZ_top 7368681u // "top"
#define SQZ_tr 29417u // "tr"
#define SQZ_trade 3023660122u // "trade"
#define SQZ_transform 3615253204u // "transform"
#define SQZ_translate 1137670376u // "translate"
#define SQZ_transparent 1911736550u // "transparent"
#define SQZ_true 1702195945u // "true"
#define SQZ_ui 27115u // "ui"
#define SQZ_underline 4021545710u // "underline"
#define SQZ_unicode_bidi 185934494u // "unicode-bidi"
#define SQZ_unmaximize 3435737582u // "unmaximize"
#define SQZ_userCMYK 622108702u // "userCMYK"
#define SQZ_userRGB 4035904520u // "userRGB"
#define SQZ_verLineTo 1200482574u // "verLineTo"
#define SQZ_version 3945712782u // "version"
#define SQZ_vertical_align 3047242218u // "vertical-align"
#define SQZ_vertical_text 580215056u // "vertical-text"
#define SQZ_viewBox 1582737754u // "viewBox"
#define SQZ_viewbox 816983354u // "viewbox"
#define SQZ_visibility 4182119682u // "visibility"
#define SQZ_visible 2712656970u // "visible"
#define SQZ_w_resize 505786646u // "w-resize"
#define SQZ_white 518020662u // "white"
#define SQZ_white_space 2063040106u // "white-space"
#define SQZ_width 3799171678u // "width"
#define SQZ_winding 2304820652u // "winding"
#define SQZ_word_spacing 2779764612u // "word-spacing"
#define SQZ_wrapLeft 3331521568u // "wrapLeft"
#define SQZ_wrapRight 1810250152u // "wrapRight"
#define SQZ_x 241u // "x"
#define SQZ_x1 12785u // "x1"
#define SQZ_x2 13041u // "x2"
#define SQZ_xor 7499761u // "xor"
#define SQZ_y 243u // "y"
#define SQZ_y1 12787u // "y1"
#define SQZ_y2 13043u // "y2"
#define SQZ_yellow 490403164u // "yellow"
#define SQZ_yen 7235059u // "yen"
#define SQZ_yes 7562739u // "yes"
#define SQZ_z_index 448175280u // "z-index"
#define SQZ_zoom_in 2458604508u // "zoom-in"
#define SQZ_zoom_out 3603903986u // "zoom-out"
#endif

#ifndef __CTX_LIBC_H
#define __CTX_LIBC_H

#if !__COSMOPOLITAN__
#include <stddef.h>
#endif

static inline void ctx_strcpy (char *dst, const char *src)
{
  int i = 0;
  for (i = 0; src[i]; i++)
    { dst[i] = src[i]; }
  dst[i] = 0;
}

static inline char *_ctx_strchr (const char *haystack, char needle)
{
  const char *p = haystack;
  while (*p && *p != needle)
    {
      p++;
    }
  if (*p == needle)
    { return (char *) p; }
  return NULL;
}
static inline char *ctx_strchr (const char *haystack, char needle)
{
  return _ctx_strchr (haystack, needle);
}

static inline int ctx_strcmp (const char *a, const char *b)
{
  int i;
  for (i = 0; a[i] && b[i]; a++, b++)
    if (a[0] != b[0])
      { return 1; }
  if (a[0] == 0 && b[0] == 0) { return 0; }
  return 1;
}

static inline int ctx_strncmp (const char *a, const char *b, size_t n)
{
  size_t i;
  for (i = 0; a[i] && b[i] && i < n; a++, b++)
    if (a[0] != b[0])
      { return 1; }
  if (i >=n) return 1;
  return 0;
}

static inline int ctx_strlen (const char *s)
{
  int len = 0;
  for (; *s; s++) { len++; }
  return len;
}

static inline char *ctx_strstr (const char *h, const char *n)
{
  int needle_len = ctx_strlen (n);
  if (n[0]==0)
    { return (char *) h; }
  while (*h)
    {
      if (!ctx_strncmp (h, n, needle_len) )
        { return (char *) h; }
      h++;
    }
  return NULL;
}

static inline char *ctx_strdup (const char *str)
{
  int len = ctx_strlen (str);
  char *ret = (char*)ctx_malloc (len + 1);
  memcpy (ret, str, len);
  ret[len]=0;
  return ret;
}

static inline int ctx_atoi (const char *str)
{
  int ret = 0;
  int sign = 1;
  int pos = 0;
  if (str[0]=='-'){
    sign = -1;
    pos ++;
  }
  while(str[pos] >= '0' && str[pos] <= '9')
  {
    int digit = str[pos] - '0';
    ret = ret * 10 + digit;
    pos++;
  }
  return ret * sign;
}

#endif
#ifndef CTX_AUDIO_H
#define CTX_AUDIO_H

#if !__COSMOPOLITAN__
#include <stdint.h>
#endif

/* This enum should be kept in sync with the corresponding mmm enum.
 */
typedef enum {
  CTX_F32,
  CTX_F32S,
  CTX_S16,
  CTX_S16S
} CtxPCM;

void   ctx_pcm_set_format        (Ctx *ctx, CtxPCM format);
CtxPCM ctx_pcm_get_format        (Ctx *ctx);
int    ctx_pcm_get_sample_rate   (Ctx *ctx);
void   ctx_pcm_set_sample_rate   (Ctx *ctx, int sample_rate);
int    ctx_pcm_get_frame_chunk   (Ctx *ctx);
int    ctx_pcm_get_queued        (Ctx *ctx);
float  ctx_pcm_get_queued_length (Ctx *ctx);
int    ctx_pcm_queue             (Ctx *ctx, const int8_t *data, int frames);

#endif
/* Copyright (c) 2021-2022 Øyvind Kolås <pippin@gimp.org>

  Fast cache-miss eliminating unicode strings for C.

  All features are optional:
    optimized 32bit 52bit 62bit and 64bit squoze encodings in UTF5+ and/or UTF-8
    string interning and APIS (for only getting the core squoze reference
                               implementation)
      both utf8, unichar and printf for core APIs
      embedding of strings (only for debug/profiling)
      reference counting
      embedded length

  License to be determined, the core implementation the snippet for
  squoze64_utf8 on https://squoz.org/ is ISC licensed



*/
#if 0
Minimal usage example:

#define SQUOZE_IMPLEMENTATION
#include "squoze.h"

int main (int argc, char **argv)
{:q
  char temp[10];
  Sqz *string = NULL;
  
  sqz_set (&string, "hello");


}

#endif

#ifndef SQUOZE_H
#define SQUOZE_H

#include <stdint.h>
#include <stddef.h>

// configuration of internal squoze, these
// are values that must be set before both header
// and implementation uses of squoze.h the values only
// impact the string interning implementation and not
// the low-level APIs


#ifndef SQUOZE_INTERN_DIRECT_STRING     // when 1 the pointers returned are
#define SQUOZE_INTERN_DIRECT_STRING  1  // directly string pointers
                                        // when 0 the struct of the per entry
                                        // allocation is returned, for integration
                                        // with garbage collectors that scan
                                        // for pointers 0 is preferable.
#endif

#ifndef SQUOZE_ID_BITS         // number of bits to use for interning API
#define SQUOZE_ID_BITS 64      // 32 52 62 or 64
#endif

#ifndef SQUOZE_ID_UTF5         // use UTF5+ as the embed encoding
#define SQUOZE_ID_UTF5 0       // if not set then UTF8 is used
#endif

#ifndef SQUOZE_ID_MURMUR       // use murmurhash and no embedding
#define SQUOZE_ID_MURMUR 0     //
#endif

#ifndef SQUOZE_REF_COUNTING    // build the refcounting support, adds
#define SQUOZE_REF_COUNTING 0  // per-interned-string overhead
#endif

#ifndef SQUOZE_STORE_LENGTH    // store byte-lengths as part of
#define SQUOZE_STORE_LENGTH 1  // per-interned-string data
#endif

#ifndef SQUOZE_USE_INTERN      // enable interning hash-table
#define SQUOZE_USE_INTERN 1    // without this only a single
                               // core implementation can be built
			       //
/*  XXX - you should not need to tweak anything below here,
 *        though the tweaks are available for tinkering
 *        and debugging.
 */
#ifndef SQUOZE_REF_SANITY
#define SQUOZE_REF_SANITY      0 // report consistency errors and use more RAM
#endif

#ifndef SQUOZE_CLOBBER_ON_FREE
#define SQUOZE_CLOBBER_ON_FREE 0
  // clobber strings when freeing, not a full leak report
  // but better to always glitch than silently succeding or failing
#endif

#ifndef SQUOZE_INITIAL_POOL_SIZE
#define SQUOZE_INITIAL_POOL_SIZE   (1<<8)  // initial hash-table capacity
#endif

#ifndef SQUOZE_USE_BUILTIN_CLZ
#define SQUOZE_USE_BUILTIN_CLZ  1 // use builtin for determining highest bit in unicode char
#endif

#ifndef SQUOZE_UTF8_MANUAL_UNROLL
#define SQUOZE_UTF8_MANUAL_UNROLL 1 // use manually unrolled UTF8 code
#endif

#ifndef SQUOZE_LIMIT_IMPLEMENTATIONS
#define SQUOZE_LIMIT_IMPLEMENTATIONS 0
#endif

#ifndef SQUOZE_IMPLEMENTATION_32_UTF8
#define SQUOZE_IMPLEMENTATION_32_UTF8 (!SQUOZE_LIMIT_IMPLEMENTATIONS)
#endif
#ifndef SQUOZE_IMPLEMENTATION_32_UTF5
#define SQUOZE_IMPLEMENTATION_32_UTF5 (!SQUOZE_LIMIT_IMPLEMENTATIONS)
#endif
#ifndef SQUOZE_IMPLEMENTATION_52_UTF5
#define SQUOZE_IMPLEMENTATION_52_UTF5 (!SQUOZE_LIMIT_IMPLEMENTATIONS)
#endif
#ifndef SQUOZE_IMPLEMENTATION_62_UTF5
#define SQUOZE_IMPLEMENTATION_62_UTF5 (!SQUOZE_LIMIT_IMPLEMENTATIONS)
#endif
#ifndef SQUOZE_IMPLEMENTATION_64_UTF8
#define SQUOZE_IMPLEMENTATION_64_UTF8 (!SQUOZE_LIMIT_IMPLEMENTATIONS)
#endif
#endif

#if SQUOZE_USE_INTERN

#if SQUOZE_ID_BITS==32
typedef uint32_t sqz_id_t;
#else
typedef uint64_t sqz_id_t;
#endif


typedef struct _Sqz      Sqz;      /* handle representing a squozed string  */


/* create a new string that is the concatenation of a and b
 */
Sqz         *sqz_utf8             (const char *str);
static const char  *sqz_decode           (Sqz *squozed, char *temp);


int          sqz_length           (Sqz *squozed);
sqz_id_t     sqz_id               (Sqz *squozed);
uint32_t     sqz_unichar_at       (Sqz *a, int pos);
int          sqz_strcmp           (Sqz *a, Sqz *b);
inline int   sqz_equal            (Sqz *a, Sqz *b) { return a == b; }
void         sqz_unset            (Sqz **a);


Sqz         *sqz_cat              (Sqz *a, Sqz *b);
Sqz         *sqz_substring        (Sqz *a, int pos, int length);

void         sqz_insert           (Sqz **a, int pos, Sqz *b);
void         sqz_set              (Sqz **a, Sqz *b);
void         sqz_erase            (Sqz **a, int pos, int length);

#include <stdarg.h>
Sqz         *sqz_printf           (const char *format, ...);
Sqz         *sqz_printf_va_list   (const char *format, va_list list);
Sqz         *sqz_unichar          (uint32_t unichar);
Sqz         *sqz_double           (double value);
Sqz         *sqz_int              (int value);

/* the following is APIs mostly implemented in terms of the above */

int          sqz_has_prefix       (Sqz *a, Sqz *prefix);
int          sqz_has_suffix       (Sqz *a, Sqz *suffix);

void         sqz_insert_double    (Sqz **a, int pos, double value);
void         sqz_insert_int       (Sqz **a, int pos, int value);


void         sqz_insert_unichar   (Sqz **a, int pos, uint32_t unichar);
void         sqz_replace_unichar  (Sqz **a, int pos, int length, uint32_t unichar);
void         sqz_append_unichar   (Sqz **a, uint32_t unichar);
void         sqz_append_utf8      (Sqz **a, const char *utf8);
int          sqz_has_prefix_utf8  (Sqz  *a, const char *utf8);
int          sqz_has_suffix_utf8  (Sqz  *a, const char *utf8);
void         sqz_insert_utf8      (Sqz **a, int pos, const char *utf8);
void         sqz_set_utf8         (Sqz **a, const char *utf8);
void         sqz_replace_utf8     (Sqz **a, int pos, int length, const char *utf8);
void         sqz_set_printf       (Sqz **a, const char *format, ...);
void         sqz_append_printf    (Sqz **a, const char *format, ...);
void         sqz_insert_printf    (Sqz **a, int pos, const char *format, ...);
void         sqz_replace_printf   (Sqz **a, int pos, int length, const char *format, ...);
/* increase reference count of string */
Sqz         *sqz_ref              (Sqz *squozed);
Sqz         *sqz_dup              (Sqz *squozed);
/* decrement reference count of string */
void         sqz_unref            (Sqz *squozed);
typedef struct _SqzPool  SqzPool;  /* a pool for grouping allocated strings */


/* create a new string pool, with fallback to another pool -
 * or NULL for fallback to default pool, takes a reference on fallback.
 */
SqzPool    *sqz_pool_new          (SqzPool *fallback);

/* increase reference count of pool
 */
void         sqz_pool_ref         (SqzPool *pool);

/* decrease reference point of pool, when matching _new() + _ref() calls
 * the pool is destoryed.
 */
void         sqz_pool_unref       (SqzPool *pool);

/* add a string to a squoze pool
 */
Sqz         *sqz_pool_add         (SqzPool *pool, const char *str);

Sqz *sqz_concat (Sqz *a, Sqz *b);

/* Report stats on interned strings 
 */
void sqz_pool_mem_stats (SqzPool *pool,
                         size_t     *size,
                         size_t     *slack,
                         size_t     *intern_alloc);

/* empty all pools
 */
void sqz_cleanup (void);

#endif


#if SQUOZE_IMPLEMENTATION_32_UTF5 || \
    SQUOZE_IMPLEMENTATION_52_UTF5 || \
    SQUOZE_IMPLEMENTATION_62_UTF5
#define SQUOZE_USE_UTF5 1
#else
#define SQUOZE_USE_UTF5 0
#endif


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if SQUOZE_IMPLEMENTATION_32_UTF5
uint32_t     squoze32_utf5        (const char *utf8, size_t len);
const char  *squoze32_utf5_decode (uint32_t    id,   char *dest);
#endif

#if SQUOZE_IMPLEMENTATION_32_UTF8
static uint32_t     squoze32_utf8        (const char *utf8, size_t len);
static const char  *squoze32_utf8_decode (uint32_t    id,   char *dest);
#endif

#if SQUOZE_IMPLEMENTATION_52_UTF5
uint64_t     squoze52_utf5        (const char *utf8, size_t len);
const char  *squoze52_utf5_decode (uint64_t    id,   char *dest);
#endif

#if SQUOZE_IMPLEMENTATION_62_UTF5
uint64_t     squoze62_utf5        (const char *utf8, size_t len);
const char  *squoze62_utf5_decode (uint64_t    id,   char *dest);
#endif

#if SQUOZE_IMPLEMENTATION_64_UTF8
uint64_t     squoze64_utf8        (const char *utf8, size_t len);
const char  *squoze62_utf8_decode (uint64_t    id,   char *dest);
#endif

#endif

#ifdef SQUOZE_IMPLEMENTATION

static inline uint32_t MurmurOAAT32 (const char * key, int len)
{
  size_t h = 3323198485ul;
  for (int i = 0;i < len;i++) {
    h ^= key[i];
    h *= 0x5bd1e995;
    h &= 0xffffffff;
    h ^= h >> 15;
  }
  return h;
}

static inline uint64_t MurmurOAAT64 ( const char * key, int len)
{
  uint64_t h = 525201411107845655ull;
  for (int i = 0;i < len;i++) {
    h ^= key[i];
    h *= 0x5bd1e9955bd1e995;
    h ^= h >> 47;
  }
  return h;
}

#if SQUOZE_USE_UTF5 // YYY

// TODO:  UTF5+ should operate directly on bits instead of
//        going via bytes
static inline void squoze5_encode (const char *input, int inlen,
                                   char *output, int *r_outlen,
                                   int   permit_squeezed,
                                   int   escape_endzero);
static void squoze_decode_utf5_bytes (int is_utf5, 
                                      const unsigned char *input, int inlen,
                                      char *output, int *r_outlen);
static inline size_t squoze5_encode_int (const char *input, int inlen,
                                         int maxlen, int *overflow,
                                         int escape_endzero);

#endif


/* this should have the same behavior as the bitwidth and encoding
 * specific implementations
 */
static inline uint64_t squoze_encode_id (int squoze_dim, int utf5, const char *stf8, size_t len)
{
  int length = len;
  uint64_t id = 0;
#if SQUOZE_USE_UTF5
  if (utf5)
  {
    int max_quintets = squoze_dim / 5;
    if (length <= max_quintets)
    {
      int overflow = 0;
      id = squoze5_encode_int (stf8, length, max_quintets, &overflow, 1);
      if (!overflow)
        return id;
    }
    id = 0;
    id = MurmurOAAT32(stf8, length);
    id &= ~1;
  }
  else
#endif
  {
    const uint8_t *utf8 = (const uint8_t*)stf8;
    if (squoze_dim > 32)
      squoze_dim = 64;
    int bytes_dim = squoze_dim / 8;
  
    uint8_t first_byte = ((uint8_t*)utf8)[0];
    if (first_byte<128
        && first_byte != 11
        && (length <= bytes_dim))
    {
      id = utf8[0] * 2 + 1;
      for (int i = 1; i < length; i++)
        id += ((uint64_t)utf8[i]<<(8*(i)));
    }
    else if (length <= bytes_dim-1)
    {
      id = 23;
      for (int i = 0; i < length; i++)
        id += ((uint64_t)utf8[i]<<(8*(i+1)));
    }
    else
    {
      id = MurmurOAAT32(stf8, len);
      id &= ~1;  // make even - intern marker
    }
  }
  return id;
}

#ifdef __CTX_H__ // override with ctx variants if included from ctx
#define strdup ctx_strdup
#define strstr ctx_strstr
#endif


#if SQUOZE_IMPLEMENTATION_32_UTF5
uint32_t squoze32_utf5 (const char *utf8, size_t len)
{
  return squoze_encode_id (32, 1, utf8, len);
}
#endif

#if SQUOZE_IMPLEMENTATION_52_UTF5
uint64_t squoze52_utf5 (const char *utf8, size_t len)
{
  return squoze_encode_id (52, 1, utf8, len);
}
#endif

#if SQUOZE_IMPLEMENTATION_62_UTF5
uint64_t squoze62_utf5 (const char *utf8, size_t len)
{
  return squoze_encode_id (62, 1, utf8, len);
}
#endif

static inline uint64_t squoze_utf8 (size_t bytes_dim, const char *stf8, size_t length)
{
  uint64_t id;
  const uint8_t *utf8 = (const uint8_t*)stf8;

  uint8_t first_byte = ((uint8_t*)utf8)[0];
  if (   first_byte < 128
      && first_byte != 11
      && (length <= bytes_dim))
  {
      switch (length)
      {
#if SQUOZE_UTF8_MANUAL_UNROLL
        case 0: id = 1;
                break;
        case 1: id = utf8[0] * 2 + 1;
                break;
        case 2: id = utf8[0] * 2 + 1 + (utf8[1] << (8*1));
                break;
        case 3: id = utf8[0] * 2 + 1 + (utf8[1] << (8*1))
                                     + (utf8[2] << (8*2));
                break;
        case 4: id = utf8[0] * 2 + 1 + (utf8[1] << (8*1))
                                     + (utf8[2] << (8*2))
                                     + (utf8[3] << (8*3));
                break;
        case 5: id = utf8[0] * 2 + 1 + ((uint64_t)utf8[1] << (8*1))
                                     + ((uint64_t)utf8[2] << (8*2))
                                     + ((uint64_t)utf8[3] << (8*3))
                                     + ((uint64_t)utf8[4] << (8*4));
                break;
        case 6: id = utf8[0] * 2 + 1 + ((uint64_t)utf8[1] << (8*1))
                                     + ((uint64_t)utf8[2] << (8*2))
                                     + ((uint64_t)utf8[3] << (8*3))
                                     + ((uint64_t)utf8[4] << (8*4))
                                     + ((uint64_t)utf8[5] << (8*5));
                break;
        case 7: id = utf8[0] * 2 + 1 + ((uint64_t)utf8[1] << (8*1))
                                     + ((uint64_t)utf8[2] << (8*2))
                                     + ((uint64_t)utf8[3] << (8*3))
                                     + ((uint64_t)utf8[4] << (8*4))
                                     + ((uint64_t)utf8[5] << (8*5))
                                     + ((uint64_t)utf8[6] << (8*6));
                break;
        case 8: id = utf8[0] * 2 + 1 + ((uint64_t)utf8[1] << (8*1))
                                     + ((uint64_t)utf8[2] << (8*2))
                                     + ((uint64_t)utf8[3] << (8*3))
                                     + ((uint64_t)utf8[4] << (8*4))
                                     + ((uint64_t)utf8[5] << (8*5))
                                     + ((uint64_t)utf8[6] << (8*6))
                                     + ((uint64_t)utf8[7] << (8*7));
                break;
#endif
        default:
          id = utf8[0] * 2 + 1;
          for (unsigned int i = 1; i < length; i++)
            id += ((uint64_t)utf8[i]<<(8*(i)));
      }
    return id;
  }
  else if (length <= bytes_dim-1)
  {
      switch (length)
      {
#if SQUOZE_UTF8_MANUAL_UNROLL
        case 0: id = 23;
          break;
        case 1: id = 23 + (utf8[0] << (8*1));
          break;
        case 2: id = 23 + (utf8[0] << (8*1))
                        + (utf8[1] << (8*2));
          break;
        case 3: id = 23 + (utf8[0] << (8*1))
                        + (utf8[1] << (8*2))
                        + (utf8[2] << (8*3));
          break;
        case 4: id = 23 + ((uint64_t)utf8[0] << (8*1))
                        + ((uint64_t)utf8[1] << (8*2))
                        + ((uint64_t)utf8[2] << (8*3))
                        + ((uint64_t)utf8[3] << (8*4));
          break;
        case 5: id = 23 + ((uint64_t)utf8[0] << (8*1))
                        + ((uint64_t)utf8[1] << (8*2))
                        + ((uint64_t)utf8[2] << (8*3))
                        + ((uint64_t)utf8[3] << (8*4))
                        + ((uint64_t)utf8[4] << (8*5));
          break;
        case 6: id = 23 + ((uint64_t)utf8[0] << (8*1))
                        + ((uint64_t)utf8[1] << (8*2))
                        + ((uint64_t)utf8[2] << (8*3))
                        + ((uint64_t)utf8[3] << (8*4))
                        + ((uint64_t)utf8[4] << (8*5))
                        + ((uint64_t)utf8[5] << (8*6));
          break;
        case 7: id = 23 + ((uint64_t)utf8[0] << (8*1))
                        + ((uint64_t)utf8[1] << (8*2))
                        + ((uint64_t)utf8[2] << (8*3))
                        + ((uint64_t)utf8[3] << (8*4))
                        + ((uint64_t)utf8[4] << (8*5))
                        + ((uint64_t)utf8[5] << (8*6))
                        + ((uint64_t)utf8[6] << (8*7));
          break;
#endif
        default:
          id = 23;
          for (unsigned int i = 0; i < length; i++)
            id += ((uint64_t)utf8[i]<<(8*(i+1)));
      }
    return id;
  }

  id = MurmurOAAT32(stf8, length);
  id &= ~1;  // make even - intern marker
  return id;
}

#if SQUOZE_IMPLEMENTATION_64_UTF8
uint64_t squoze64_utf8 (const char *stf8, size_t length)
{
  return squoze_utf8 (8, stf8, length);
}
#endif

#if SQUOZE_IMPLEMENTATION_32_UTF8
static uint32_t squoze32_utf8 (const char *stf8, size_t length)
{
  uint32_t id;
  const uint8_t *utf8 = (const uint8_t*)stf8;
  size_t bytes_dim = 4;

  uint8_t first_byte = ((uint8_t*)utf8)[0];
  if (first_byte    < 128
      && first_byte != 11
      && (length <= bytes_dim))
  {
      switch (length)
      {
#if SQUOZE_UTF8_MANUAL_UNROLL
        case 0: id = 1;
                break;
        case 1: id = utf8[0] * 2 + 1;
                break;
        case 2: id = utf8[0] * 2 + 1 + (utf8[1] << (8*1));
                break;
        case 3: id = utf8[0] * 2 + 1 + (utf8[1] << (8*1))
                                     + (utf8[2] << (8*2));
                break;
        case 4: id = utf8[0] * 2 + 1 + (utf8[1] << (8*1))
                                     + (utf8[2] << (8*2))
                                     + (utf8[3] << (8*3));
                break;
#endif
        default:
          id = utf8[0] * 2 + 1;
          for (unsigned int i = 1; i < length; i++)
            id += ((uint32_t)utf8[i]<<(8*(i)));
      }
    return id;
  }
  else if (length <= bytes_dim-1)
  {
      switch (length)
      {
#if SQUOZE_UTF8_MANUAL_UNROLL
        case 0: id = 23;
          break;
        case 1: id = 23 + (utf8[0] << (8*1));
          break;
        case 2: id = 23 + (utf8[0] << (8*1))
                        + (utf8[1] << (8*2));
          break;
        case 3: id = 23 + (utf8[0] << (8*1))
                        + (utf8[1] << (8*2))
                        + (utf8[2] << (8*3));
          break;
#endif
        default:
          id = 23;
          for (unsigned int i = 0; i < length; i++)
            id += ((uint32_t)utf8[i]<<(8*(i+1)));
      }
    return id;
  }

  id = MurmurOAAT32(stf8, length);
  id &= ~1;  // make even - intern marker
  return id;
}
#endif


static const char *squoze_id_decode_r (int squoze_dim, uint64_t hash, char *ret, int retlen, int is_utf5)
{
#if SQUOZE_USE_UTF5
  if (is_utf5)
  {
    int is_utf5       = (hash & 2)!=0;
    uint8_t utf5[20]=""; // we newer go really high since there isnt room
                          // in the integers
    uint64_t tmp = hash;
    int len = 0;
    tmp /= 4;
    utf5[len]=0;
    while (tmp > 0)
    {
      utf5[len++] = tmp & 31;
      tmp /= 32;
    }
    utf5[len]=0;
    squoze_decode_utf5_bytes (is_utf5, utf5, len, ret, &retlen);
    return ret;
  }
  else
#endif
  {
    if (squoze_dim == 32)
    {
      if ((hash & 0xff) == 23)
      {
         memcpy (ret, ((char*)&hash)+1, 3);
         ret[3] = 0;
      }
      else
      {
        memcpy (ret, &hash, 4);
        ((unsigned char*)ret)[0]/=2;
        ret[4] = 0;
      }
    }
    else
    {
      if ((hash & 0xff) == 23)
      {
        memcpy (ret, ((char*)&hash)+1, 7);
        ret[7] = 0;
      }
      else
      {
        memcpy (ret, &hash, 8);
        ((unsigned char*)ret)[0]/=2;
        ret[8] = 0;
      }
    }
    return ret;
  }
}

static const char *squoze_id_decode (int squoze_dim, uint64_t id, int is_utf5, char *dest);
static const char *squoze_id_decode (int squoze_dim, uint64_t id, int is_utf5, char *dest)
{
  if (id == 0 || ((id & 1) == 0)) {dest[0]=0;return NULL; }
  else if (id == 3) { dest[0]=0;return NULL;}
  squoze_id_decode_r (squoze_dim, id, dest, 16, is_utf5);
  return dest;
}

#if SQUOZE_IMPLEMENTATION_32_UTF5
const char *squoze32_utf5_decode (uint32_t id, char *dest)
{
  return squoze_id_decode (32, id, 1, dest);
}
#endif

#if SQUOZE_IMPLEMENTATION_52_UTF5
const char *squoze52_utf5_decode (uint64_t id, char *dest)
{
  return squoze_id_decode (52, id, 1, dest);
}
#endif

#if SQUOZE_IMPLEMENTATION_62_UTF5
const char *squoze62_utf5_decode (uint64_t id, char *dest)
{
  return squoze_id_decode (62, id, 1, dest);
}
#endif

#if SQUOZE_IMPLEMENTATION_64_UTF8
static const char *squoze64_utf8_decode (uint64_t id, char *dest)
{
  return squoze_id_decode (64, id, 0, dest);
}
#endif

#if SQUOZE_IMPLEMENTATION_32_UTF8
static const char *squoze32_utf8_decode (uint32_t id, char *dest)
{
  return squoze_id_decode (32, id, 0, dest);
}
#endif

static inline uint32_t
squoze_utf8_to_unichar (const char *input)
{
  const uint8_t *utf8 = (const uint8_t *) input;
  uint8_t c = utf8[0];
  if ( (c & 0x80) == 0)
    { return c; }
  else if ( (c & 0xE0) == 0xC0)
    return ( (utf8[0] & 0x1F) << 6) |
           (utf8[1] & 0x3F);
  else if ( (c & 0xF0) == 0xE0)
    return ( (utf8[0] & 0xF)  << 12) |
           ( (utf8[1] & 0x3F) << 6) |
           (utf8[2] & 0x3F);
  else if ( (c & 0xF8) == 0xF0)
    return ( (utf8[0] & 0x7)  << 18) |
           ( (utf8[1] & 0x3F) << 12) |
           ( (utf8[2] & 0x3F) << 6) |
           (utf8[3] & 0x3F);
  else if ( (c & 0xFC) == 0xF8)
    return ( (utf8[0] & 0x3)  << 24) |
           ( (utf8[1] & 0x3F) << 18) |
           ( (utf8[2] & 0x3F) << 12) |
           ( (utf8[3] & 0x3F) << 6) |
           (utf8[4] & 0x3F);
  else if ( (c & 0xFE) == 0xFC)
    return ( (utf8[0] & 0x1)  << 30) |
           ( (utf8[1] & 0x3F) << 24) |
           ( (utf8[2] & 0x3F) << 18) |
           ( (utf8[3] & 0x3F) << 12) |
           ( (utf8[4] & 0x3F) << 6) |
           (utf8[5] & 0x3F);
  return 0;
}
static inline int
squoze_unichar_to_utf8 (uint32_t  ch,
                      uint8_t  *dest)
{
  /* http://www.cprogramming.com/tutorial/utf8.c  */
  /*  Basic UTF-8 manipulation routines
    by Jeff Bezanson
    placed in the public domain Fall 2005 ... */
  if (ch < 0x80)
    {
      dest[0] = (char) ch;
      return 1;
    }
  if (ch < 0x800)
    {
      dest[0] = (ch>>6) | 0xC0;
      dest[1] = (ch & 0x3F) | 0x80;
      return 2;
    }
  if (ch < 0x10000)
    {
      dest[0] = (ch>>12) | 0xE0;
      dest[1] = ( (ch>>6) & 0x3F) | 0x80;
      dest[2] = (ch & 0x3F) | 0x80;
      return 3;
    }
  if (ch < 0x110000)
    {
      dest[0] = (ch>>18) | 0xF0;
      dest[1] = ( (ch>>12) & 0x3F) | 0x80;
      dest[2] = ( (ch>>6) & 0x3F) | 0x80;
      dest[3] = (ch & 0x3F) | 0x80;
      return 4;
    }
  return 0;
}

static inline int squoze_utf8_strlen (const char *s)
{
  int count;
  if (!s)
    { return 0; }
  for (count = 0; *s; s++)
    if ( (*s & 0xC0) != 0x80)
      { count++; }
  return count;
}

static inline int
squoze_utf8_len (const unsigned char first_byte)
{
  if      ( (first_byte & 0x80) == 0)
    { return 1; }
  else if ( (first_byte & 0xE0) == 0xC0)
    { return 2; }
  else if ( (first_byte & 0xF0) == 0xE0)
    { return 3; }
  else if ( (first_byte & 0xF8) == 0xF0)
    { return 4; }
  return 1;
}



/*  data structures and implementation for string interning, potentially
 *  with both ref-counting and pools of strings.
 */
#if SQUOZE_USE_INTERN

struct _Sqz {
#if SQUOZE_REF_COUNTING
    int32_t       ref_count; // set to magic value for ROM strings?
                             // and store pointer in string data?
#endif
#if SQUOZE_STORE_LENGTH
    int32_t       length;
#endif
    sqz_id_t      hash;
    char          string[];
};


static inline uint64_t sqz_pool_encode     (SqzPool *pool, const char *utf8, size_t len, Sqz **interned_ref);

struct _SqzPool
{
  int32_t     ref_count;
  SqzPool    *fallback;
  Sqz       **hashtable;
  int         count;
  int         size;
  SqzPool    *next;
};

static SqzPool global_pool = {0, NULL, NULL, 0, 0, NULL};

static SqzPool *sqz_pools = NULL;

static int sqz_pool_find (SqzPool *pool, uint64_t hash, int length, const uint8_t *bytes)
{
  if (pool->size == 0)
    return -1;
  int pos = (hash/2) & (pool->size-1);
  if (!pool->hashtable[pos])
    return -1;
  while (pool->hashtable[pos]->hash != hash
#if SQUOZE_STORE_LENGTH
         || pool->hashtable[pos]->length != length
#endif
         || strcmp (pool->hashtable[pos]->string, (char*)bytes)
         )
  {
    pos++;
    pos &= (pool->size-1);
    if (!pool->hashtable[pos])
      return -1;
  }
  return pos;
}
static int sqz_pool_add_entry (SqzPool *pool, Sqz *str)
{
  if (pool->count + 1 >= pool->size / 2)
  {
     Sqz **old = pool->hashtable;
     int old_size = pool->size;
     if (old_size == 0)
       pool->size = SQUOZE_INITIAL_POOL_SIZE;
     else
       pool->size *= 2;
     pool->hashtable = (Sqz**)calloc (pool->size, sizeof (void*));
     if (old)
     {
       for (int i = 0; i < old_size; i++)
         if (old[i])
           sqz_pool_add_entry (pool, old[i]);
       free (old);
     }
  }
  pool->count++;

  int pos = (str->hash/2) & (pool->size-1);
  while (pool->hashtable[pos])
  {
    pos++;
    pos &= (pool->size-1);
  }
  pool->hashtable[pos]=str;
  return pos;
}

#if SQUOZE_REF_SANITY
static int sqz_pool_remove (SqzPool *pool, Sqz *squozed, int do_free)
{
  Sqz *str = squozed;
  int no = sqz_pool_find (pool, str->hash, strlen (str->string), (uint8_t*)str->string);
  if (no < 0)
    return 0;
  if (do_free)
    free (str);
#ifdef assert
  assert (pool->hashtable[no] == squozed);
#endif
  pool->hashtable[no]=0;
  
  // check if there is another one to promote now
  for (int i = no+1; pool->hashtable[i]; i = (i+1)&(pool->size-1))
  {
    if ((pool->hashtable[i]->hash & (pool->size-1)) == (unsigned)no)
    {
      Sqz *for_upgrade = pool->hashtable[i];
      sqz_pool_remove (pool, for_upgrade, 0);
      sqz_pool_add_entry (pool, for_upgrade);
      break;
    }
  }
  return 1;
}
#endif

static Sqz *sqz_lookup (SqzPool *pool, sqz_id_t id, int length, const uint8_t *bytes)
{
  int pos = sqz_pool_find (pool, id, length, bytes);
  if (pos >= 0)
    return pool->hashtable[pos];
  if (pool->fallback)
    return sqz_lookup (pool->fallback, id, length, bytes);
  return NULL;
}

void sqz_pool_mem_stats (SqzPool *pool,
                         size_t     *size,
                            size_t     *slack,
                            size_t     *intern_alloc)
{
  if (!pool) pool = &global_pool;
  if (size)
  {
    *size = sizeof (SqzPool) + pool->size * sizeof (void*);
  }
  if (slack)
  {
    *slack = (pool->size - pool->count) * sizeof (void*);
  }

  if (intern_alloc)
  {
    size_t sum = 0;
    for (int i = 0; i < pool->size; i++)
    {
      if (pool->hashtable[i])
      {
        Sqz *squoze = pool->hashtable[i];
        sum += strlen (squoze->string) + 1 + sizeof (Sqz);
      }
    }
    *intern_alloc = sum;
  }
}

 // we do 32bit also for 64bit - we want the same predetermined hashes to match
static inline Sqz *_sqz_pool_add (SqzPool *pool, const char *str)
{
  if (!pool) pool = &global_pool;
  Sqz *interned = NULL;
  uint64_t hash = sqz_pool_encode (pool, str, strlen (str), &interned);

  if (interned)
  {
#ifdef assert
    assert ((((size_t)interned)&0x1)==0);
#endif
#if SQUOZE_DIRECT_STRING
    return interned+1;
#else
    return interned;
#endif
  }
  else
    return (Sqz*)((size_t)hash);
}

Sqz *sqz_pool_add (SqzPool *pool, const char *str)
{
  return _sqz_pool_add (pool, str);
}

Sqz *sqz_utf8(const char *str)
{
  return _sqz_pool_add (NULL, str);
}

// encodes utf8 to a squoze id of squoze_dim bits - if interned_ret is provided overflowed ids
// are interned and a new interned squoze is returned.
static uint64_t sqz_pool_encode (SqzPool *pool, const char *utf8, size_t len, Sqz **interned_ref)
{
#if   SQUOZE_ID_BITS==32 && SQUOZE_ID_MURMUR
   uint64_t hash = MurmurOAAT32(utf8, len) & ~1;
#elif  SQUOZE_ID_BITS==32 && SQUOZE_ID_UTF5
   uint64_t hash = squoze32_utf5 (utf8, len);
#elif SQUOZE_ID_BITS==32 && SQUOZE_ID_UTF8
   uint64_t hash = squoze32_utf8 (utf8, len);
#elif SQUOZE_ID_BITS==62 && SQUOZE_ID_UTF5
   uint64_t hash = squoze62_utf5 (utf8, len);
#elif SQUOZE_ID_BITS==52 && SQUOZE_ID_UTF5
   uint64_t hash = squoze52_utf5 (utf8, len);
#elif SQUOZE_ID_BITS==64 && SQUOZE_ID_UTF8
   uint64_t hash = squoze64_utf8 (utf8, len);
#else
   uint64_t hash = squoze_encode_id (SQUOZE_ID_BITS, SQUOZE_ID_UTF5, utf8, len);
#endif

  if (!interned_ref)
    return hash;
  if (pool == NULL) pool = &global_pool;
  if ((hash & 1)==0)
  {
    Sqz *str = sqz_lookup (pool, hash, len, (const uint8_t*)utf8);
    if (str)
    {
#if SQUOZE_REF_COUNTING
      str->ref_count++;
#endif
      if (interned_ref) *interned_ref = str + SQUOZE_INTERN_DIRECT_STRING;
      return hash; 
    }

    {
      Sqz *entry = (Sqz*)calloc (len + 1 + sizeof(Sqz), 1);
      entry->hash = hash;
#if SQUOZE_STORE_LENGTH
      entry->length = len;
#endif
      strcpy (entry->string, utf8);
      if (interned_ref) *interned_ref = entry + SQUOZE_INTERN_DIRECT_STRING;
      sqz_pool_add_entry (pool, entry);
    }
  }
  return hash;
}

static inline int sqz_is_interned (Sqz *squozed)
{
  return ((((size_t)(squozed))&1) == 0);
}

static inline int sqz_is_embedded (Sqz *squozed)
{
  return !sqz_is_interned (squozed);
}

/* returns either the string or temp with the decode
 * embedded string decoded
 */
static const char *sqz_decode (Sqz *squozed, char *temp)
{
  if (!squozed) return NULL;
  if (sqz_is_embedded (squozed))
  {
#if   SQUOZE_ID_BITS==32 && SQUOZE_ID_UTF5
    return squoze32_utf5_decode ((size_t)squozed, temp);
#elif SQUOZE_ID_BITS==32 && SQUOZE_ID_UTF8
    return squoze32_utf8_decode ((size_t)squozed, temp);
#elif SQUOZE_ID_BITS==52 && SQUOZE_ID_UTF5
    return squoze52_utf5_decode ((size_t)squozed, temp);
#elif SQUOZE_ID_BITS==62 && SQUOZE_ID_UTF5
    return squoze62_utf5_decode ((size_t)squozed, temp);
#elif SQUOZE_ID_BITS==64 && SQUOZE_ID_UTF8
    return squoze64_utf8_decode ((size_t)squozed, temp);
#else
    return squoze_id_decode (SQUOZE_ID_BITS,
                             ((size_t)squozed),
                             SQUOZE_ID_UTF5,
                             temp);
#endif
  }
  else
  {
#if SQUOZE_INTERN_DIRECT_STRING
    return (char*)squozed;
#else
    return squozed->string;
#endif
  }
}

Sqz *sqz_ref (Sqz *squozed)
{
#if SQUOZE_REF_COUNTING
  if (sqz_is_interned (squozed))
  {
     (squozed-SQUOZE_INTERN_DIRECT_STRING)->ref_count ++;
  }
#endif
  return squozed;
}
Sqz *sqz_dup (Sqz *squozed)
{
  return sqz_ref (squozed);
}

void sqz_unref (Sqz *squozed)
{
#if SQUOZE_REF_COUNTING
  if (sqz_is_interned (squozed))
  {
#if SQUOZE_INTERN_DIRECT_STRING
      squozed--;
#endif
      if (squozed->ref_count <= 0)
      {
#if SQUOZE_CLOBBER_ON_FREE
        squozed->string[-squozed->ref_count]='#';
#endif
#if SQUOZE_REF_SANITY
        if (squozed->ref_count < 0)
          fprintf (stderr, "double unref for \"%s\"\n", squozed->string);
        squozed->ref_count--;
#else
        SqzPool *pool = &global_pool;
        if (sqz_pool_remove (pool, squozed, 1))
        {
          return;
        }
        pool = sqz_pools;
        if (pool)
        do {
          if (sqz_pool_remove (pool, squozed, 1))
          {
            return;
          }
          pool = pool->next;
        } while (pool);
#endif
      }
      else
      {
        squozed->ref_count--;
      }
  }
#endif
}

int sqz_has_prefix (Sqz *a, Sqz *prefix)
{
  char tmp_a[16];
  char tmp_prefix[16];
  const char *a_str = sqz_decode (a, tmp_a);
  const char *prefix_str = sqz_decode (prefix, tmp_prefix);
  return !strncmp (a_str, prefix_str, strlen (prefix_str));
}

int sqz_has_prefix_utf8 (Sqz *a, const char *utf8)
{
  Sqz *b = sqz_utf8 (utf8);
  int ret = sqz_has_prefix (a, b);
  sqz_unref (b);
  return ret;
}

int sqz_has_suffix_utf8 (Sqz *a, const char *utf8)
{
  Sqz *b = sqz_utf8 (utf8);
  int ret = sqz_has_suffix (a, b);
  sqz_unref (b);
  return ret;
}

int sqz_has_suffix (Sqz *a, Sqz *suffix)
{
  char        tmp_a[16];
  const char *a_str = sqz_decode (a, tmp_a);
  int         a_len = strlen (a_str);
  char        tmp_suffix[16];
  const char *suffix_str = sqz_decode (suffix, tmp_suffix);
  int         suffix_len = strlen (suffix_str);
  
  if (a_len < suffix_len)
    return 0;
  return strcmp (a_str + a_len - suffix_len, suffix_str);
}


static void _sqz_prepend (Sqz **squoze, Sqz *head)
{
  if (!squoze) return;
  Sqz *combined = sqz_cat (head, *squoze);
  sqz_unref (*squoze);
  *squoze=combined;
}

static void _sqz_append (Sqz **squoze, Sqz *tail)
{
  if (!squoze) return;
  Sqz *combined = sqz_cat (*squoze, tail);
  sqz_unref (*squoze);
  *squoze=combined;
}

Sqz *sqz_substring (Sqz *a, int pos, int length)
{
  int src_length = sqz_length (a);
  if (pos > src_length)
    return sqz_utf8 ("");
  if (pos < 0)
    pos = src_length + pos + 1;
  char tmp[16];
  const char *src = sqz_decode (a, tmp);
  char *end;
  int allocated = 0;

  char *copy;
  if (src_length < 256)
  {
    copy = alloca (strlen (src) + 1);
    strcpy (copy, src);
  }
  else
  {
    copy  = strdup (src);
    allocated = 1;
  }
  char *p = copy;
  int i;
  for (i = 0; i < pos; i++)
    p += squoze_utf8_len (*p);
  end = p;
  for (i = 0; i < length && *end; i++)
    end += squoze_utf8_len (*end);
  *end = 0;

  Sqz *ret = sqz_utf8 (p);
  if (allocated)
    free (copy);
  return ret;
}

void sqz_erase (Sqz **a, int pos, int length)
{
  if (!a) return;
  if (!*a) return;

  if (length < 1)
    return;
  if (pos < 0)
  {
    pos = sqz_length (*a) + pos;
  }

  Sqz *pre  = sqz_substring (*a, 0, pos);
  Sqz *post = sqz_substring (*a, pos+length, 10000);
  sqz_unref (*a);
  *a = sqz_cat (pre, post);
  sqz_unref (pre);
  sqz_unref (post);
}

void sqz_insert (Sqz **a, int pos, Sqz *b)
{
  if (pos == 0)
  {
    _sqz_prepend (a, b);
    return;
  }
  if (pos == -1)
  {
    _sqz_append (a, b);
    return;
  }
  if (!a) return;
  if (!*a) return;
  if (pos < 0)
  {
    pos = sqz_length (*a) + pos + 1;
  }
  Sqz *pre  = sqz_substring (*a, 0, pos);
  Sqz *post = sqz_substring (*a, pos, 10000);
  sqz_unref (*a);

  *a = sqz_cat (pre, b);
  _sqz_append (a, post);
  sqz_unref (pre);
  sqz_unref (post);
}

void sqz_insert_utf8 (Sqz **a, int pos, const char *utf8)
{
  Sqz *b = sqz_utf8 (utf8);
  sqz_insert (a, pos, b);
  sqz_unref (b);
}

Sqz *sqz_unichar (uint32_t unichar)
{
  char temp[5];
  temp[squoze_unichar_to_utf8 (unichar, (uint8_t*)temp)]=0;
  return sqz_utf8 (temp);
}

Sqz *sqz_int (int value)
{
  char temp[40];
  sprintf (temp, "%i", value);
  if (strchr (temp, ','))
    *strchr (temp, ',')='.';
  return sqz_utf8 (temp);
}

Sqz *sqz_double (double value)
{
  char temp[40];
  sprintf (temp, "%f", value);
  if (strchr (temp, ','))
    *strchr (temp, ',')='.';
  return sqz_utf8 (temp);
}

void sqz_insert_unichar (Sqz **a, int pos, uint32_t unichar)
{
  Sqz *b = sqz_unichar (unichar);
  sqz_insert (a, pos, b);
  sqz_unref (b);
}

void sqz_insert_double (Sqz **a, int pos, double value)
{
  Sqz *b = sqz_double (value);
  sqz_insert (a, pos, b);
  sqz_unref (b);
}

void sqz_insert_int (Sqz **a, int pos, int value)
{
  Sqz *b = sqz_int (value);
  sqz_insert (a, pos, b);
  sqz_unref (b);
}

uint32_t sqz_unichar_at (Sqz *a, int pos)
{
  char tmp[16];
  const char *str = sqz_decode (a, tmp);
  const char *p = str;
  int i;
  if (pos < 0)
  {
    pos = sqz_length (a) + pos;
  }
  for (i = 0; i < pos; i++)
    p += squoze_utf8_len (*p);
  return squoze_utf8_to_unichar (p);
}

void sqz_replace (Sqz **a, int pos, int length, Sqz *b)
{
  sqz_erase (a, pos, length);
  sqz_insert (a, pos, b);
}

void sqz_replace_unichar  (Sqz **a, int pos, int length, uint32_t unichar)
{
  Sqz *b = sqz_unichar (unichar);
  sqz_erase (a, pos, length);
  sqz_insert (a, pos, b);
  sqz_unref (b);
}

void sqz_replace_utf8  (Sqz **a, int pos, int length, const char *utf8)
{
  sqz_erase (a, pos, length);
  sqz_insert_utf8 (a, pos, utf8);
}

void sqz_append_utf8 (Sqz **a, const char *utf8)
{
  sqz_insert_utf8 (a, -1, utf8);
}

void sqz_append_unichar (Sqz **a, uint32_t unichar)
{
  sqz_insert_unichar (a, -1, unichar);
}

#define SQZ_EXPAND_PRINTF \
  va_list ap; \
  size_t needed; \
  char *buffer; \
  va_start (ap, format); \
  needed = vsnprintf (NULL, 0, format, ap) + 1; \
  if (needed < 256) \
    buffer = alloca (needed);\
  else\
    buffer = malloc (needed);\
  va_end (ap);\
  va_start (ap, format);\
  vsnprintf (buffer, needed, format, ap);\
  va_end (ap);\
  Sqz *b = sqz_utf8 (buffer);\
  if (needed >= 256)\
    free (buffer);

Sqz      *sqz_printf (const char *format, ...)
{
  SQZ_EXPAND_PRINTF;
  return b;
}

void sqz_insert_printf (Sqz **a, int pos, const char *format, ...)
{
  SQZ_EXPAND_PRINTF;
  sqz_insert (a, pos, b);
  sqz_unref (b);
}

void sqz_replace_printf (Sqz **a, int pos, int length, const char *format, ...)
{
  SQZ_EXPAND_PRINTF;
  sqz_replace (a, pos, length, b);
  sqz_unref (b);
}

void sqz_append_printf (Sqz **a, const char *format, ...)
{
  SQZ_EXPAND_PRINTF;
  sqz_insert (a, -1, b);
  sqz_unref (b);
}

int sqz_strcmp (Sqz *a, Sqz *b)
{
  if (a == b) return 0;
  char tmp_a[16];
  char tmp_b[16];
  return strcmp (sqz_decode (a, tmp_a), sqz_decode (b, tmp_b));
}

static void _sqz_steal (Sqz **a, Sqz *b)
{
  if (*a)
    sqz_unref (*a);
  *a = b;
}

void sqz_set (Sqz **a, Sqz *b)
{
  if (*a)
    sqz_unref (*a);
  *a = sqz_ref (b);
}

void sqz_set_utf8 (Sqz **a, const char *str)
{
  _sqz_steal (a, sqz_utf8 (str));
}

void sqz_set_printf (Sqz **a, const char *format, ...)
{
  SQZ_EXPAND_PRINTF;
  _sqz_steal (a, b);
}

void sqz_unset (Sqz **a)
{
  if (*a == NULL) return;
  sqz_unref (*a);
  *a = NULL;
}

sqz_id_t sqz_id (Sqz *squozed)
{
  if (!squozed) return 0;
  if (sqz_is_embedded (squozed))
    return ((size_t)(squozed));
  else
  {
#if SQUOZE_INTERN_DIRECT_STRING
    squozed--;
#endif
    return squozed->hash;
  }
}

int sqz_length (Sqz *squozed)
{
  char buf[15];
  if (!squozed) return 0;
  return squoze_utf8_strlen(sqz_decode (squozed, buf));
}

// XXX : not used - remove it, and be unicode native?
int sqz_byte_length (Sqz *squozed)
{
  char buf[15];
  if (!squozed) return 0;
#if 0
  return strlen(sqz_decode (squozed, buf));
#else
  if (sqz_is_embedded (squozed))
  {
    sqz_decode (squozed, buf);
    return strlen (buf);
  }
  else
  {
#if SQUOZE_INTERN_DIRECT_STRING
    squozed--;
#endif
#if SQUOZE_STORE_LENGTH
    return squozed->length;
#endif
    return strlen (squozed->string);
  }
#endif
  return 0;
}

Sqz *sqz_cat (Sqz *a, Sqz *b)
{
  char buf_a[16];
  char buf_b[16];
  const char *str_a = sqz_decode (a, buf_a);
  const char *str_b = sqz_decode (b, buf_b);
  int len_a = strlen (str_a);
  int len_b = strlen (str_b);
  if (len_a + len_b < 128)
  {
    char temp[128];
    temp[0]=0;
    strcpy (temp, str_a);
    if (str_b)
      strcpy (&temp[strlen(temp)], str_b);
    return sqz_utf8 (temp);
  }
  else
  {
    char *temp = malloc (len_a + len_b + 1);
    temp[0]=0;
    strcpy (temp, str_a);
    if (str_b)
      strcpy (&temp[strlen(temp)], str_b);
    Sqz *ret = sqz_utf8 (temp);
    free (temp);
    return ret;
  }
}


SqzPool *sqz_pool_new     (SqzPool *fallback)
{
  SqzPool *pool = (SqzPool*)calloc (sizeof (SqzPool), 1);
  pool->fallback = fallback;
  pool->next = sqz_pools;
  sqz_pools = pool;
  if (fallback)
    sqz_pool_ref (fallback);
  return pool;
}

void sqz_pool_ref (SqzPool *pool)
{
  if (!pool) return;
  pool->ref_count--;
}

static void sqz_pool_destroy (SqzPool *pool)
{
#if 0
    fprintf (stderr, "destorying pool: size:%i count:%i embedded:%i\n",
       pool->size, pool->count, pool->count_embedded);
#endif
    for (int i = 0; i < pool->size; i++)
    {
      if (pool->hashtable[i])
        free (pool->hashtable[i]);
      pool->hashtable[i] = 0;
    }
    if (pool->fallback)
      sqz_pool_unref (pool->fallback);

    if (pool == sqz_pools)
    {
       sqz_pools = pool->next;
    }
    else
    {
      SqzPool *prev = NULL;
      SqzPool *iter = sqz_pools;
      while (iter && iter != pool)
      {
         prev = iter;
         iter = iter->next;
      }
      if (prev) // XXX not needed
        prev->next = pool->next;
    }
    pool->size = 0;
    pool->count = 0;
    if (pool->hashtable)
      free (pool->hashtable);
    pool->hashtable = NULL;

    // XXX report non unreffed items based on config
}

void sqz_pool_unref (SqzPool *pool)
{
  if (!pool) return;
  if (pool->ref_count == 0)
  {
    sqz_pool_destroy (pool);
    free (pool);
  }
  else
  {
    pool->ref_count--;
  }
}

void
sqz_cleanup (void)
{
  sqz_pool_destroy (&global_pool);
  // also destory other known pools
  // XXX : when debugging report leaked pools
}
#endif

// UTF5 implementation

#if SQUOZE_USE_UTF5

// extra value meaning in UTF5 mode
#define SQUOZE_ENTER_SQUEEZE    16

// value meanings in squeeze mode
#define SQUOZE_SPACE            0
#define SQUOZE_DEC_OFFSET_A     27
#define SQUOZE_INC_OFFSET_A     28
#define SQUOZE_DEC_OFFSET_B     29
#define SQUOZE_INC_OFFSET_B     30
#define SQUOZE_ENTER_UTF5       31


static inline uint32_t squoze_utf8_to_unichar (const char *input);
static inline int      squoze_unichar_to_utf8 (uint32_t  ch, uint8_t  *dest);
static inline int      squoze_utf8_len        (const unsigned char first_byte);
static inline int      squoze_utf8_strlen     (const char *s);


/* returns the base-offset of the segment this unichar belongs to,
 *
 * segments are 26 items long and are offset so that 'a'-'z' is
 * one segment.
 */
#define SQUOZE_JUMP_STRIDE      26
#define SQUOZE_JUMP_OFFSET      19
static inline int squoze_new_offset (uint32_t unichar)
{
  uint32_t ret = unichar - (unichar % SQUOZE_JUMP_STRIDE) + SQUOZE_JUMP_OFFSET;
  if (ret > unichar) ret -= SQUOZE_JUMP_STRIDE;
  return ret;
}

static inline int squoze_needed_jump (uint32_t off, uint32_t unicha)
{
  int count = 0;
  int unichar = unicha;
  int offset = off;

  if (unichar == 32) // space is always in range
    return 0;

  /* TODO: replace this with direct computation of values instead of loop */
  while (unichar < offset)
  {
    offset -= SQUOZE_JUMP_STRIDE;
    count --;
  }
  if (count)
    return count;

  return (unichar - offset) / SQUOZE_JUMP_STRIDE;
}


static inline int
squoze_utf5_length (uint32_t unichar)
{
  if (unichar == 0)
    return 1;
#if SQUOZE_USE_BUILTIN_CLZ
  return __builtin_clz(unichar)/4+1;
#else
  int nibbles = 1;
  while (unichar)
  {
    nibbles ++;
    unichar /= 16;
  }
  return nibbles;
#endif
}

typedef struct EncodeUtf5 {
  int      is_utf5;
  int      offset;
  int      length;
  void    *write_data;
  uint32_t current;
} EncodeUtf5;

static inline int squoze_compute_cost_utf5 (int offset, int val, int utf5_length, int next_val, int next_utf5_length)
{
  int cost = 0; 
  cost += utf5_length;
  if (next_val)
  {
    cost += next_utf5_length;
  }
  return cost;
}

static inline int squoze_compute_cost_squeezed (int offset, int val, int needed_jump, int next_val, int next_utf5_length)
{
  int cost = 0;
  if (needed_jump == 0)
  {
    cost += 1;
  }
  else if (needed_jump >= -2 && needed_jump <= 2)
  {
    cost += 2;
    offset += SQUOZE_JUMP_STRIDE * needed_jump;
  }
  else if (needed_jump >= -10 && needed_jump <= 10)
  {
    cost += 3;
    offset += SQUOZE_JUMP_STRIDE * needed_jump;
  }
  else
  {
    cost += 100; // very expensive, makes the other choice win
  }

  if (next_val)
  {
    int change_cost = 1 + squoze_utf5_length (next_val);
    int no_change_cost = 0;
    needed_jump = squoze_needed_jump (offset, next_val);

    if (needed_jump == 0)
    {
      no_change_cost += 1;
    }
    else if (needed_jump >= -2 && needed_jump <= 2)
    {
      no_change_cost += 2;
    }
    else if (needed_jump >= -10 && needed_jump <= 10)
    {
      no_change_cost += 3;
      offset += SQUOZE_JUMP_STRIDE * needed_jump;
    }
    else
    {
      no_change_cost = change_cost;
    }
    if (change_cost < no_change_cost)
      cost += change_cost;
    else
      cost += no_change_cost;
  }

  return cost;
}

static inline void squoze5_encode (const char *input, int inlen,
                                   char *output, int *r_outlen,
                                   int   permit_squeezed,
                                   int   escape_endzero)
{
  int offset  = 97;//squoze_new_offset('a');
  int is_utf5 = 1;
  int len     = 0;

  int first_len;
  int next_val = squoze_utf8_to_unichar (&input[0]);
  int next_utf5_length = squoze_utf5_length (next_val);
  for (int i = 0; i < inlen; i+= first_len)
  {
    int val = next_val;
    int utf5_length = next_utf5_length;
    int needed_jump = squoze_needed_jump (offset, val);
    first_len = squoze_utf8_len (input[i]);
    if (i + first_len < inlen)
    {
      next_val = squoze_utf8_to_unichar (&input[i+first_len]);
      next_utf5_length = squoze_utf5_length (next_val);
    }

    if (is_utf5)
    {
      int change_cost    = squoze_compute_cost_squeezed (offset, val, needed_jump, next_val, next_utf5_length);
      int no_change_cost = squoze_compute_cost_utf5 (offset, val, utf5_length, next_val, next_utf5_length);
  
      if (i != 0)          /* ignore cost of initial 'G' */
        change_cost += 1;

      if (permit_squeezed && change_cost <= no_change_cost)
      {
        output[len++] = SQUOZE_ENTER_SQUEEZE;
        is_utf5 = 0;
      }
    }
    else
    {
      int change_cost    = 1 + squoze_compute_cost_utf5 (offset, val, utf5_length, next_val, next_utf5_length);
      int no_change_cost = squoze_compute_cost_squeezed (offset, val, needed_jump, next_val, next_utf5_length);

      if (change_cost < no_change_cost)
      {
        output[len++] = SQUOZE_ENTER_UTF5;
        is_utf5 = 1;
      }
    }

    if (!is_utf5)
    {
      if (needed_jump)
      {
        if (needed_jump >= -2 && needed_jump <= 2)
        {
          switch (needed_jump)
          {
            case -1: output[len++] = SQUOZE_DEC_OFFSET_B; break;
            case  1: output[len++] = SQUOZE_INC_OFFSET_B; break;
            case -2: output[len++] = SQUOZE_DEC_OFFSET_A; break;
            case  2: output[len++] = SQUOZE_INC_OFFSET_A; break;
          }
          offset += SQUOZE_JUMP_STRIDE * needed_jump;
        }
        else if (needed_jump >= -10 && needed_jump <= 10) {
              int encoded_val;
              if (needed_jump < -2)
                encoded_val = 5 - needed_jump;
              else
                encoded_val = needed_jump - 3;

              output[len++] = (encoded_val / 4) + SQUOZE_DEC_OFFSET_A;
              output[len++] = (encoded_val % 4) + SQUOZE_DEC_OFFSET_A;

              offset += SQUOZE_JUMP_STRIDE * needed_jump;
        }
        else
        {
#ifdef assert
          assert(0); // should not be reached
#endif
          output[len++] = SQUOZE_ENTER_UTF5;
          is_utf5 = 1;
        }
      }
    }

    if (is_utf5)
    {
      offset = squoze_new_offset (val);
      int quintet_no = 0;
      uint8_t temp[12]={0,};

      while (val)
      {
        int oval = val % 16;
        int hi = 16;
        if (val / 16)
          hi = 0;
        temp[quintet_no++] = oval + hi;
        val /= 16;
      }
      for (int i = 0; i < quintet_no; i++)
        output[len++] = temp[quintet_no-1-i];
    }
    else 
    {
      output[len++] = (val == ' ')?SQUOZE_SPACE:val-offset+1;
    }
  }

  if (escape_endzero && len && output[len-1]==0)
  {
    if (is_utf5)
      output[len++] = 16;
    else
      output[len++] = SQUOZE_ENTER_UTF5;
  }
  output[len]=0;
  if (r_outlen)
    *r_outlen = len;
}

/* squoze_encode_int:
 * @input utf8 input data
 * @inlen length of @input in bytes
 * @maxlen maximum number of quintets to encode
 * @overflow pointer to int that gets set to 1 if we overflow
 * @permit_squeezed 
 *
 */
static inline size_t squoze5_encode_int (const char *input, int inlen,
                                         int maxlen, int *overflow,
                                         int escape_endzero)
{
  size_t ret  = 0;
  int offset  = 97;//squoze_new_offset('a');
  int is_utf5 = 1;
  int len     = 0;

  int start_utf5 = 1;
  int gotzero = 0;

#define ADD_QUINTET(q) \
  do { \
    if (len + inlen-i > maxlen) {\
      *overflow = 1;\
      return 0;\
    }\
    ret |= ((size_t)(q))<<(5*len++); gotzero = (q==0);\
  } while (0)

  int first_len;
  int next_val = squoze_utf8_to_unichar (&input[0]);
  int next_utf5_length = squoze_utf5_length (next_val);
  int i = 0;
  for (int i = 0; i < inlen; i+= first_len)
  {
    int val         = next_val;
    int utf5_length = squoze_utf5_length (val);
    int needed_jump = squoze_needed_jump (offset, val);
    first_len = squoze_utf8_len (input[i]);
    if (i + first_len < inlen)
    {
      next_val         = squoze_utf8_to_unichar (&input[i+first_len]);
      next_utf5_length = squoze_utf5_length (next_val);
    }
    else
    {
      next_val = 0;
      next_utf5_length = 0;
    }

    if (is_utf5)
    {
      int change_cost    = squoze_compute_cost_squeezed (offset, val, needed_jump, next_val, next_utf5_length);
      int no_change_cost = squoze_compute_cost_utf5 (offset, val, utf5_length, next_val, next_utf5_length);
  
      if (i != 0)          /* ignore cost of initial 'G' */
        change_cost += 1;

      if (change_cost <= no_change_cost)
      {
        if (i != 0)
        { 
          ADD_QUINTET(SQUOZE_ENTER_SQUEEZE);
        }
        else
          start_utf5 = 0;

        is_utf5 = 0;
      }
    }
    else
    {
      int change_cost    = 1 + squoze_compute_cost_utf5 (offset, val, utf5_length, next_val, next_utf5_length);
      int no_change_cost = squoze_compute_cost_squeezed (offset, val, needed_jump, next_val, next_utf5_length);

      if (change_cost < no_change_cost)
      {
        ADD_QUINTET(SQUOZE_ENTER_UTF5);
        is_utf5 = 1;
      }
    }

    if (!is_utf5)
    {
      if (needed_jump)
      {
        if (needed_jump >= -2 && needed_jump <= 2)
        {
          switch (needed_jump)
          {
            case -1: ADD_QUINTET(SQUOZE_DEC_OFFSET_B); break;
            case  1: ADD_QUINTET(SQUOZE_INC_OFFSET_B); break;
            case -2: ADD_QUINTET(SQUOZE_DEC_OFFSET_A); break;
            case  2: ADD_QUINTET(SQUOZE_INC_OFFSET_A); break;
          }
          offset += SQUOZE_JUMP_STRIDE * needed_jump;
        }
        else if (needed_jump >= -10 && needed_jump <= 10) {
              int encoded_val;
              if (needed_jump < -2)
                encoded_val = 5 - needed_jump;
              else
                encoded_val = needed_jump - 3;

              ADD_QUINTET ((encoded_val/4) + SQUOZE_DEC_OFFSET_A);
              ADD_QUINTET ((encoded_val%4) + SQUOZE_DEC_OFFSET_A);

              offset += SQUOZE_JUMP_STRIDE * needed_jump;
        }
        else
        {
#ifdef assert
          assert(0); // should not be reached
#endif
          ADD_QUINTET (SQUOZE_ENTER_UTF5);
          is_utf5 = 1;
        }
      }
    }

    if (is_utf5)
    {
      offset = squoze_new_offset (val);
      int quintet_no = 0;
      uint8_t temp[12]={0,};

      while (val)
      {
        temp[quintet_no++] = (val&0xf) + (val/16)?0:16;
        val /= 16;
      }
      for (int j = 0; j < quintet_no; j++)
        ADD_QUINTET(temp[quintet_no-1-j]);
    }
    else 
    {
      ADD_QUINTET((val == ' ')?SQUOZE_SPACE:val-offset+1);
    }
  }

#if 1
  if (escape_endzero && len && gotzero)
  {
    // do a mode-change after 0 to avoid 0 being interpreted
    // as end of quintets
    ADD_QUINTET(is_utf5?16:SQUOZE_ENTER_UTF5);
  }
#endif

#undef ADD_QUINTET

  return (ret<<2) | ((start_utf5*2)|1);
}

typedef struct SquozeUtf5Dec {
  int       is_utf5;
  int       offset;
  void     *write_data;
  uint32_t  current;
  void    (*append_unichar) (uint32_t unichar, void *write_data);
  int       jumped_amount;
  int       jump_mode;
} SquozeUtf5Dec;

typedef struct SquozeUtf5DecDefaultData {
  uint8_t *buf;
  int      length;
} SquozeUtf5DecDefaultData;

static void squoze_decode_utf5_append_unichar_as_utf8 (uint32_t unichar, void *write_data)
{
  SquozeUtf5DecDefaultData *data = (SquozeUtf5DecDefaultData*)write_data;
  int length = squoze_unichar_to_utf8 (unichar, &data->buf[data->length]);
  data->buf[data->length += length] = 0;
}

static void squoze_decode_jump (SquozeUtf5Dec *dec, uint8_t in)
{
  dec->offset -= SQUOZE_JUMP_STRIDE * dec->jumped_amount;
  int jump_len = (dec->jump_mode - SQUOZE_DEC_OFFSET_A) * 4 +
                 (in - SQUOZE_DEC_OFFSET_A);
  if (jump_len > 7)
    jump_len = 5 - jump_len;
  else
    jump_len += 3;
  dec->offset += jump_len * SQUOZE_JUMP_STRIDE;
  dec->jumped_amount = 0;
}

static void squoze_decode_utf5 (SquozeUtf5Dec *dec, uint8_t in)
{
  if (dec->is_utf5)
  {
    if (in >= 16)
    {
      if (dec->current)
      {
        dec->offset = squoze_new_offset (dec->current);
        dec->append_unichar (dec->current, dec->write_data);
        dec->current = 0;
      }
    }
    if (in == SQUOZE_ENTER_SQUEEZE)
    {
      if (dec->current)
      {
        dec->offset = squoze_new_offset (dec->current);
        dec->append_unichar (dec->current, dec->write_data);
        dec->current = 0;
      }
      dec->is_utf5 = 0;
    }
    else
    {
      dec->current = dec->current * 16 + (in % 16);
    }
  }
  else
  {
    if (dec->jumped_amount)
    {
      switch (in)
      {
        case SQUOZE_DEC_OFFSET_A:
        case SQUOZE_DEC_OFFSET_B:
        case SQUOZE_INC_OFFSET_A:
        case SQUOZE_INC_OFFSET_B:
          squoze_decode_jump (dec, in);
          break;
        default:
          dec->append_unichar (dec->offset + (in - 1), dec->write_data);
          dec->jumped_amount = 0;
          dec->jump_mode = 0;
          break;
      }
    }
    else
    {
      switch (in)
      {
        case SQUOZE_ENTER_UTF5:
          dec->is_utf5 = 1;
          dec->jumped_amount = 0;
          dec->jump_mode = 0;
          break;
        case SQUOZE_SPACE: 
          dec->append_unichar (' ', dec->write_data);
          dec->jumped_amount = 0;
          dec->jump_mode = 0;
          break;
        case SQUOZE_DEC_OFFSET_A:
          dec->jumped_amount = -2;
          dec->jump_mode = in;
          dec->offset += dec->jumped_amount * SQUOZE_JUMP_STRIDE;
          break;
        case SQUOZE_INC_OFFSET_A:
          dec->jumped_amount = 2;
          dec->jump_mode = in;
          dec->offset += dec->jumped_amount * SQUOZE_JUMP_STRIDE;
          break;
        case SQUOZE_DEC_OFFSET_B:
          dec->jumped_amount = -1;
          dec->jump_mode = in;
          dec->offset += dec->jumped_amount * SQUOZE_JUMP_STRIDE;
          break;
        case SQUOZE_INC_OFFSET_B:
          dec->jumped_amount = 1;
          dec->jump_mode = in;
          dec->offset += dec->jumped_amount * SQUOZE_JUMP_STRIDE;
          break;
        default:
          dec->append_unichar (dec->offset + (in - 1), dec->write_data);
          dec->jumped_amount = 0;
          dec->jump_mode = 0;
      }
    }
  }
}

static void squoze_decode_utf5_bytes (int is_utf5, 
                                      const unsigned char *input, int inlen,
                                      char *output, int *r_outlen)
{
  SquozeUtf5DecDefaultData append_data = {(unsigned char*)output, 0};
  SquozeUtf5Dec dec = {is_utf5,
                     97,//squoze_new_offset('a'),
                     &append_data,
                     0,
                     squoze_decode_utf5_append_unichar_as_utf8,
                     0, 0
                    };
  for (int i = 0; i < inlen; i++)
    squoze_decode_utf5 (&dec, input[i]);
  if (dec.current)
    dec.append_unichar (dec.current, dec.write_data);
  if (r_outlen)
    *r_outlen = append_data.length;
}
#endif

#endif

#if CTX_IMPLEMENTATION || CTX_SIMD_BUILD


#ifndef MINIZ_EXPORT
#define MINIZ_EXPORT
#endif
/* miniz.c 3.0.0 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateReset/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/
#pragma once



/* Defines to completely disable specific portions of miniz.c: 
   If all macros here are defined the only functionality remaining will be CRC-32 and adler-32. */

/* Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O. */
/*#define MINIZ_NO_STDIO */

/* If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or */
/* get/set file times, and the C run-time funcs that get/set times won't be called. */
/* The current downside is the times written to your archives will be from 1979. */
/*#define MINIZ_NO_TIME */

/* Define MINIZ_NO_DEFLATE_APIS to disable all compression API's. */
/*#define MINIZ_NO_DEFLATE_APIS */

/* Define MINIZ_NO_INFLATE_APIS to disable all decompression API's. */
/*#define MINIZ_NO_INFLATE_APIS */

/* Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_APIS */

/* Define MINIZ_NO_ARCHIVE_WRITING_APIS to disable all writing related ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_WRITING_APIS */

/* Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's. */
/*#define MINIZ_NO_ZLIB_APIS */

/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib. */
/*#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

/* Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc. 
   Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
   callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
   functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work. */
/*#define MINIZ_NO_MALLOC */

#ifdef MINIZ_NO_INFLATE_APIS
#define MINIZ_NO_ARCHIVE_APIS
#endif

#ifdef MINIZ_NO_DEFLATE_APIS
#define MINIZ_NO_ARCHIVE_WRITING_APIS
#endif

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
/* TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux */
#define MINIZ_NO_TIME
#endif

#include <stddef.h>

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
#include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
/* MINIZ_X86_OR_X64_CPU is only used to help set the below macros. */
#define MINIZ_X86_OR_X64_CPU 1
#else
#define MINIZ_X86_OR_X64_CPU 0
#endif

/* Set MINIZ_LITTLE_ENDIAN only if not set */
#if !defined(MINIZ_LITTLE_ENDIAN)
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)

#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
/* Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian. */
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#else

#if MINIZ_X86_OR_X64_CPU
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#endif
#endif

/* Using unaligned loads and stores causes errors when using UBSan */
#if defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES only if not set */
#if !defined(MINIZ_USE_UNALIGNED_LOADS_AND_STORES)
#if MINIZ_X86_OR_X64_CPU
/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses. */
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#define MINIZ_UNALIGNED_USE_MEMCPY
#else
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
/* Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions). */
#define MINIZ_HAS_64BIT_REGISTERS 1
#else
#define MINIZ_HAS_64BIT_REGISTERS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API Definitions. */

/* For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits! */
typedef unsigned long mz_ulong;

/* mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap. */
MINIZ_EXPORT void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
/* mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
/* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

/* Compression strategies. */
enum
{
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};

/* Method */
#define MZ_DEFLATED 8

/* Heap allocation callbacks.
Note that mz_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long. */
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);

/* Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. */
enum
{
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};

#define MZ_VERSION "11.0.0"
#define MZ_VERNUM 0xB000
#define MZ_VER_MAJOR 11
#define MZ_VER_MINOR 0
#define MZ_VER_REVISION 0
#define MZ_VER_SUBREVISION 0

#ifndef MINIZ_NO_ZLIB_APIS

/* Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). */
enum
{
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};

/* Return status codes. MZ_PARAM_ERROR is non-standard. */
enum
{
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};

/* Window bits */
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

/* Compression/decompression stream struct. */
typedef struct mz_stream_s
{
    const unsigned char *next_in; /* pointer to next byte to read */
    unsigned int avail_in;        /* number of bytes available at next_in */
    mz_ulong total_in;            /* total number of bytes consumed so far */

    unsigned char *next_out; /* pointer to next byte to write */
    unsigned int avail_out;  /* number of bytes that can be written to next_out */
    mz_ulong total_out;      /* total number of bytes produced so far */

    char *msg;                       /* error msg (unused) */
    struct mz_internal_state *state; /* internal state, allocated by zalloc/zfree */

    mz_alloc_func zalloc; /* optional heap allocation function (defaults to malloc) */
    mz_free_func zfree;   /* optional heap free function (defaults to free) */
    void *opaque;         /* heap alloc function user pointer */

    int data_type;     /* data_type (unused) */
    mz_ulong adler;    /* adler32 of the source or uncompressed data */
    mz_ulong reserved; /* not used */
} mz_stream;

typedef mz_stream *mz_streamp;

/* Returns the version string of miniz.c. */
MINIZ_EXPORT const char *mz_version(void);

#ifndef MINIZ_NO_DEFLATE_APIS

/* mz_deflateInit() initializes a compressor with default options: */
/* Parameters: */
/*  pStream must point to an initialized mz_stream struct. */
/*  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. */
/*  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio. */
/*  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
/*  MZ_PARAM_ERROR if the input parameters are bogus. */
/*  MZ_MEM_ERROR on out of memory. */
MINIZ_EXPORT int mz_deflateInit(mz_streamp pStream, int level);

/* mz_deflateInit2() is like mz_deflate(), except with more control: */
/* Additional parameters: */
/*   method must be MZ_DEFLATED */
/*   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) */
/*   mem_level must be between [1, 9] (it's checked but ignored by miniz.c) */
MINIZ_EXPORT int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */
MINIZ_EXPORT int mz_deflateReset(mz_streamp pStream);

/* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. */
/* Return values: */
/*   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full). */
/*   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) */
MINIZ_EXPORT int mz_deflate(mz_streamp pStream, int flush);

/* mz_deflateEnd() deinitializes a compressor: */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
MINIZ_EXPORT int mz_deflateEnd(mz_streamp pStream);

/* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */
MINIZ_EXPORT mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

/* Single-call compression functions mz_compress() and mz_compress2(): */
/* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */
MINIZ_EXPORT int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

/* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */
MINIZ_EXPORT mz_ulong mz_compressBound(mz_ulong source_len);

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

/* Initializes a decompressor. */
MINIZ_EXPORT int mz_inflateInit(mz_streamp pStream);

/* mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: */
/* window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). */
MINIZ_EXPORT int mz_inflateInit2(mz_streamp pStream, int window_bits);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). */
MINIZ_EXPORT int mz_inflateReset(mz_streamp pStream);

/* Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. */
/*   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). */
/*   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. */
/* Return values: */
/*   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full. */
/*   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_DATA_ERROR if the deflate stream is invalid. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again */
/*   with more input data, or with more room in the output buffer (except when using single call decompression, described above). */
MINIZ_EXPORT int mz_inflate(mz_streamp pStream, int flush);

/* Deinitializes a decompressor. */
MINIZ_EXPORT int mz_inflateEnd(mz_streamp pStream);

/* Single-call decompression. */
/* Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. */
MINIZ_EXPORT int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len);
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

/* Returns a string description of the specified error code, or NULL if the error code is invalid. */
MINIZ_EXPORT const char *mz_error(int err);

/* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */
/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef mz_ulong uLong;
typedef Byte Bytef;
typedef uInt uIntf;
typedef char charf;
typedef int intf;
typedef void *voidpf;
typedef uLong uLongf;
typedef void *voidp;
typedef void *const voidpc;
#define Z_NULL 0
#define Z_NO_FLUSH MZ_NO_FLUSH
#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
#define Z_FULL_FLUSH MZ_FULL_FLUSH
#define Z_FINISH MZ_FINISH
#define Z_BLOCK MZ_BLOCK
#define Z_OK MZ_OK
#define Z_STREAM_END MZ_STREAM_END
#define Z_NEED_DICT MZ_NEED_DICT
#define Z_ERRNO MZ_ERRNO
#define Z_STREAM_ERROR MZ_STREAM_ERROR
#define Z_DATA_ERROR MZ_DATA_ERROR
#define Z_MEM_ERROR MZ_MEM_ERROR
#define Z_BUF_ERROR MZ_BUF_ERROR
#define Z_VERSION_ERROR MZ_VERSION_ERROR
#define Z_PARAM_ERROR MZ_PARAM_ERROR
#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
#define Z_BEST_SPEED MZ_BEST_SPEED
#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
#define Z_FILTERED MZ_FILTERED
#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
#define Z_RLE MZ_RLE
#define Z_FIXED MZ_FIXED
#define Z_DEFLATED MZ_DEFLATED
#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
#define alloc_func mz_alloc_func
#define free_func mz_free_func
#define internal_state mz_internal_state
#define z_stream mz_stream

#ifndef MINIZ_NO_DEFLATE_APIS
#define deflateInit mz_deflateInit
#define deflateInit2 mz_deflateInit2
#define deflateReset mz_deflateReset
#define deflate mz_deflate
#define deflateEnd mz_deflateEnd
#define deflateBound mz_deflateBound
#define compress mz_compress
#define compress2 mz_compress2
#define compressBound mz_compressBound
#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS
#define inflateInit mz_inflateInit
#define inflateInit2 mz_inflateInit2
#define inflateReset mz_inflateReset
#define inflate mz_inflate
#define inflateEnd mz_inflateEnd
#define uncompress mz_uncompress
#define uncompress2 mz_uncompress2
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

#define crc32 mz_crc32
#define adler32 mz_adler32
#define MAX_WBITS 15
#define MAX_MEM_LEVEL 9
#define zError mz_error
#define ZLIB_VERSION MZ_VERSION
#define ZLIB_VERNUM MZ_VERNUM
#define ZLIB_VER_MAJOR MZ_VER_MAJOR
#define ZLIB_VER_MINOR MZ_VER_MINOR
#define ZLIB_VER_REVISION MZ_VER_REVISION
#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
#define zlibVersion mz_version
#define zlib_version mz_version()
#endif /* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

#endif /* MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif





#pragma once
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>



/* ------------------- Types and macros */
typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef int64_t mz_int64;
typedef uint64_t mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

/* Works around MSVC's spammy "warning C4127: conditional expression is constant" message. */
#ifdef _MSC_VER
#define MZ_MACRO_END while (0, 0)
#else
#define MZ_MACRO_END while (0)
#endif

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <stdio.h>
#define MZ_FILE FILE
#endif /* #ifdef MINIZ_NO_STDIO */

#ifdef MINIZ_NO_TIME
typedef struct mz_dummy_time_t_tag
{
    mz_uint32 m_dummy1;
    mz_uint32 m_dummy2;
} mz_dummy_time_t;
#define MZ_TIME_T mz_dummy_time_t
#else
#define MZ_TIME_T time_t
#endif

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
#define MZ_MALLOC(x) NULL
#define MZ_FREE(x) (void)x, ((void)0)
#define MZ_REALLOC(p, x) NULL
#else
#define MZ_MALLOC(x) malloc(x)
#define MZ_FREE(x) free(x)
#define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
#define MZ_CLEAR_ARR(obj) memset((obj), 0, sizeof(obj))
#define MZ_CLEAR_PTR(obj) memset((obj), 0, sizeof(*obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
#define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
#define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#define MZ_READ_LE64(p) (((mz_uint64)MZ_READ_LE32(p)) | (((mz_uint64)MZ_READ_LE32((const mz_uint8 *)(p) + sizeof(mz_uint32))) << 32U))

#ifdef _MSC_VER
#define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
#define MZ_FORCEINLINE __inline__ __attribute__((__always_inline__))
#else
#define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size);
extern MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address);
extern MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size);

#define MZ_UINT16_MAX (0xFFFFU)
#define MZ_UINT32_MAX (0xFFFFFFFFU)

#ifdef __cplusplus
}
#endif
 #pragma once


#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* ------------------- Low-level Compression API Definitions */

/* Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently). */
#define TDEFL_LESS_MEMORY 0

/* tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search): */
/* TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). */
enum
{
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};

/* TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data. */
/* TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). */
/* TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. */
/* TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). */
/* TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) */
/* TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled. */
/* TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. */
/* TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. */
/* The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). */
enum
{
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};

/* High level compression functions: */
/* tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of source block to compress. */
/*  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression. */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must free() the returned block when it's no longer needed. */
MINIZ_EXPORT void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */
/* Returns 0 on failure. */
MINIZ_EXPORT size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* Compresses an image to a compressed PNG file in memory. */
/* On entry: */
/*  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. */
/*  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. */
/*  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL */
/*  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pLen_out will be set to the size of the PNG image file. */
/*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. */
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

/* Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time. */
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);

/* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */
MINIZ_EXPORT mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

enum
{
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};

/* TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes). */
#if TDEFL_LESS_MEMORY
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 12,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#else
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#endif

/* The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions. */
typedef enum {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
} tdefl_status;

/* Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums */
typedef enum {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
} tdefl_flush;

/* tdefl's compression state structure. */
typedef struct
{
    tdefl_put_buf_func_ptr m_pPut_buf_func;
    void *m_pPut_buf_user;
    mz_uint m_flags, m_max_probes[2];
    int m_greedy_parsing;
    mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
    mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
    mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
    mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
    tdefl_status m_prev_return_status;
    const void *m_pIn_buf;
    void *m_pOut_buf;
    size_t *m_pIn_buf_size, *m_pOut_buf_size;
    tdefl_flush m_flush;
    const mz_uint8 *m_pSrc;
    size_t m_src_buf_left, m_out_buf_ofs;
    mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
    mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
    mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
    mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
    mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

/* Initializes the compressor. */
/* There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory. */
/* pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. */
/* If pBut_buf_func is NULL the user should always call the tdefl_compress() API. */
/* flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) */
MINIZ_EXPORT tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

/* Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. */
MINIZ_EXPORT tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

/* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */
/* tdefl_compress_buffer() always consumes the entire input buffer. */
MINIZ_EXPORT tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

MINIZ_EXPORT tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
MINIZ_EXPORT mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

/* Create tdefl_compress() flags given zlib-style compression parameters. */
/* level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) */
/* window_bits may be -15 (raw deflate) or 15 (zlib) */
/* strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED */
MINIZ_EXPORT mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor structure in C so that */
/* non-C language bindings to tdefl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tdefl_compressor *tdefl_compressor_alloc(void);
MINIZ_EXPORT void tdefl_compressor_free(tdefl_compressor *pComp);
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
 #pragma once

/* ------------------- Low-level Decompression API Definitions */

#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* Decompression flags used by tinfl_decompress(). */
/* TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream. */
/* TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. */
/* TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). */
/* TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. */
enum
{
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};

/* High level decompression functions: */
/* tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. */
/* On return: */
/*  Function returns a pointer to the decompressed data, or NULL on failure. */
/*  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must call mz_free() on the returned block when it's no longer needed. */
MINIZ_EXPORT void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */
/* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
MINIZ_EXPORT size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */
/* Returns 1 on success or 0 on failure. */
typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
MINIZ_EXPORT int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;

#ifndef MINIZ_NO_MALLOC
/* Allocate the tinfl_decompressor structure in C so that */
/* non-C language bindings to tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tinfl_decompressor *tinfl_decompressor_alloc(void);
MINIZ_EXPORT void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
#endif

/* Max size of LZ dictionary. */
#define TINFL_LZ_DICT_SIZE 32768

/* Return status. */
typedef enum {
    /* This flags indicates the inflator needs 1 or more input bytes to make forward progress, but the caller is indicating that no more are available. The compressed data */
    /* is probably corrupted. If you call the inflator again with more bytes it'll try to continue processing the input but this is a BAD sign (either the data is corrupted or you called it incorrectly). */
    /* If you call it again with no input you'll just get TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS again. */
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,

    /* This flag indicates that one or more of the input parameters was obviously bogus. (You can try calling it again, but if you get this error the calling code is wrong.) */
    TINFL_STATUS_BAD_PARAM = -3,

    /* This flags indicate the inflator is finished but the adler32 check of the uncompressed data didn't match. If you call it again it'll return TINFL_STATUS_DONE. */
    TINFL_STATUS_ADLER32_MISMATCH = -2,

    /* This flags indicate the inflator has somehow failed (bad code, corrupted input, etc.). If you call it again without resetting via tinfl_init() it it'll just keep on returning the same status failure code. */
    TINFL_STATUS_FAILED = -1,

    /* Any status code less than TINFL_STATUS_DONE must indicate a failure. */

    /* This flag indicates the inflator has returned every byte of uncompressed data that it can, has consumed every byte that it needed, has successfully reached the end of the deflate stream, and */
    /* if zlib headers and adler32 checking enabled that it has successfully checked the uncompressed data's adler32. If you call it again you'll just get TINFL_STATUS_DONE over and over again. */
    TINFL_STATUS_DONE = 0,

    /* This flag indicates the inflator MUST have more input data (even 1 byte) before it can make any more forward progress, or you need to clear the TINFL_FLAG_HAS_MORE_INPUT */
    /* flag on the next call if you don't have any more source data. If the source data was somehow corrupted it's also possible (but unlikely) for the inflator to keep on demanding input to */
    /* proceed, so be sure to properly set the TINFL_FLAG_HAS_MORE_INPUT flag. */
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,

    /* This flag indicates the inflator definitely has 1 or more bytes of uncompressed data available, but it cannot write this data into the output buffer. */
    /* Note if the source compressed data was corrupted it's possible for the inflator to return a lot of uncompressed data to the caller. I've been assuming you know how much uncompressed data to expect */
    /* (either exact or worst case) and will stop calling the inflator and fail after receiving too much. In pure streaming scenarios where you have no idea how many bytes to expect this may not be possible */
    /* so I may need to add some code to address this. */
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

/* Initializes the decompressor to its initial state. */
#define tinfl_init(r)     \
    do                    \
    {                     \
        (r)->m_state = 0; \
    }                     \
    MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

/* Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. */
/* This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. */
MINIZ_EXPORT tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

/* Internal/private bits follow. */
enum
{
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

#if MINIZ_HAS_64BIT_REGISTERS
#define TINFL_USE_64BIT_BITBUF 1
#else
#define TINFL_USE_64BIT_BITBUF 0
#endif

#if TINFL_USE_64BIT_BITBUF
typedef mz_uint64 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (64)
#else
typedef mz_uint32 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag
{
    mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
    tinfl_bit_buf_t m_bit_buf;
    size_t m_dist_from_out_buf_start;
    mz_int16 m_look_up[TINFL_MAX_HUFF_TABLES][TINFL_FAST_LOOKUP_SIZE];
    mz_int16 m_tree_0[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
    mz_int16 m_tree_1[TINFL_MAX_HUFF_SYMBOLS_1 * 2];
    mz_int16 m_tree_2[TINFL_MAX_HUFF_SYMBOLS_2 * 2];
    mz_uint8 m_code_size_0[TINFL_MAX_HUFF_SYMBOLS_0];
    mz_uint8 m_code_size_1[TINFL_MAX_HUFF_SYMBOLS_1];
    mz_uint8 m_code_size_2[TINFL_MAX_HUFF_SYMBOLS_2];
    mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/
 
#pragma once


/* ------------------- ZIP archive reading/writing */

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

enum
{
    /* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */
    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
};

typedef struct
{
    /* Central directory file index. */
    mz_uint32 m_file_index;

    /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
    mz_uint64 m_central_dir_ofs;

    /* These fields are copied directly from the zip's central dir. */
    mz_uint16 m_version_made_by;
    mz_uint16 m_version_needed;
    mz_uint16 m_bit_flag;
    mz_uint16 m_method;

    /* CRC-32 of uncompressed data. */
    mz_uint32 m_crc32;

    /* File's compressed size. */
    mz_uint64 m_comp_size;

    /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
    mz_uint64 m_uncomp_size;

    /* Zip internal and external file attributes. */
    mz_uint16 m_internal_attr;
    mz_uint32 m_external_attr;

    /* Entry's local header file offset in bytes. */
    mz_uint64 m_local_header_ofs;

    /* Size of comment in bytes. */
    mz_uint32 m_comment_size;

    /* MZ_TRUE if the entry appears to be a directory. */
    mz_bool m_is_directory;

    /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
    mz_bool m_is_encrypted;

    /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
    mz_bool m_is_supported;

    /* Filename. If string ends in '/' it's a subdirectory entry. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];

    /* Comment field. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];

#ifdef MINIZ_NO_TIME
    MZ_TIME_T m_padding;
#else
    MZ_TIME_T m_time;
#endif
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum {
    MZ_ZIP_MODE_INVALID = 0,
    MZ_ZIP_MODE_READING = 1,
    MZ_ZIP_MODE_WRITING = 2,
    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef enum {
    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000,
    /*After adding a compressed file, seek back
    to local file header and set the correct sizes*/
    MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE = 0x20000
} mz_zip_flags;

typedef enum {
    MZ_ZIP_TYPE_INVALID = 0,
    MZ_ZIP_TYPE_USER,
    MZ_ZIP_TYPE_MEMORY,
    MZ_ZIP_TYPE_HEAP,
    MZ_ZIP_TYPE_FILE,
    MZ_ZIP_TYPE_CFILE,
    MZ_ZIP_TOTAL_TYPES
} mz_zip_type;

/* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */
typedef enum {
    MZ_ZIP_NO_ERROR = 0,
    MZ_ZIP_UNDEFINED_ERROR,
    MZ_ZIP_TOO_MANY_FILES,
    MZ_ZIP_FILE_TOO_LARGE,
    MZ_ZIP_UNSUPPORTED_METHOD,
    MZ_ZIP_UNSUPPORTED_ENCRYPTION,
    MZ_ZIP_UNSUPPORTED_FEATURE,
    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
    MZ_ZIP_NOT_AN_ARCHIVE,
    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
    MZ_ZIP_UNSUPPORTED_MULTIDISK,
    MZ_ZIP_DECOMPRESSION_FAILED,
    MZ_ZIP_COMPRESSION_FAILED,
    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
    MZ_ZIP_CRC_CHECK_FAILED,
    MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
    MZ_ZIP_ALLOC_FAILED,
    MZ_ZIP_FILE_OPEN_FAILED,
    MZ_ZIP_FILE_CREATE_FAILED,
    MZ_ZIP_FILE_WRITE_FAILED,
    MZ_ZIP_FILE_READ_FAILED,
    MZ_ZIP_FILE_CLOSE_FAILED,
    MZ_ZIP_FILE_SEEK_FAILED,
    MZ_ZIP_FILE_STAT_FAILED,
    MZ_ZIP_INVALID_PARAMETER,
    MZ_ZIP_INVALID_FILENAME,
    MZ_ZIP_BUF_TOO_SMALL,
    MZ_ZIP_INTERNAL_ERROR,
    MZ_ZIP_FILE_NOT_FOUND,
    MZ_ZIP_ARCHIVE_TOO_LARGE,
    MZ_ZIP_VALIDATION_FAILED,
    MZ_ZIP_WRITE_CALLBACK_FAILED,
    MZ_ZIP_TOTAL_ERRORS
} mz_zip_error;

typedef struct
{
    mz_uint64 m_archive_size;
    mz_uint64 m_central_directory_file_ofs;

    /* We only support up to UINT32_MAX files in zip64 mode. */
    mz_uint32 m_total_files;
    mz_zip_mode m_zip_mode;
    mz_zip_type m_zip_type;
    mz_zip_error m_last_error;

    mz_uint64 m_file_offset_alignment;

    mz_alloc_func m_pAlloc;
    mz_free_func m_pFree;
    mz_realloc_func m_pRealloc;
    void *m_pAlloc_opaque;

    mz_file_read_func m_pRead;
    mz_file_write_func m_pWrite;
    mz_file_needs_keepalive m_pNeeds_keepalive;
    void *m_pIO_opaque;

    mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef struct
{
    mz_zip_archive *pZip;
    mz_uint flags;

    int status;

    mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    void *pWrite_buf;

    size_t out_blk_remain;

    tinfl_decompressor inflator;

#ifdef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint padding;
#else
    mz_uint file_crc32;
#endif

} mz_zip_reader_extract_iter_state;

/* -------- ZIP reading */

/* Inits a ZIP archive reader. */
/* These functions read and validate the archive's central directory. */
MINIZ_EXPORT mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
/* Read a archive from a disk file. */
/* file_start_ofs is the file offset where the archive actually begins, or 0. */
/* actual_archive_size is the true total size of the archive, which may be smaller than the file's actual size on disk. If zero the entire file is treated as the archive. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
MINIZ_EXPORT mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);

/* Read an archive from an already opened FILE, beginning at the current file position. */
/* The archive is assumed to be archive_size bytes long. If archive_size is 0, then the entire rest of the file is assumed to contain the archive. */
/* The FILE will NOT be closed when mz_zip_reader_end() is called. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
#endif

/* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */
MINIZ_EXPORT mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

/* -------- ZIP reading or writing */

/* Clears a mz_zip_archive struct to all zeros. */
/* Important: This must be done before passing the struct to any mz_zip functions. */
MINIZ_EXPORT void mz_zip_zero_struct(mz_zip_archive *pZip);

MINIZ_EXPORT mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);

/* Returns the total number of files in the archive. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

MINIZ_EXPORT mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
MINIZ_EXPORT mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
MINIZ_EXPORT MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);

/* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */
MINIZ_EXPORT size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);

/* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */
/* Note that the m_last_error functionality is not thread safe. */
MINIZ_EXPORT mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
MINIZ_EXPORT mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT const char *mz_zip_get_error_string(mz_zip_error mz_err);

/* MZ_TRUE if the archive file entry is a directory entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the file is encrypted/strong encrypted. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);

/* Retrieves the filename of an archive file entry. */
/* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

/* Attempts to locates a file in the archive's central directory. */
/* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
/* Returns -1 if the file cannot be found. */
MINIZ_EXPORT int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);

/* Returns detailed information about an archive file entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

/* MZ_TRUE if the file is in zip64 format. */
/* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */
MINIZ_EXPORT mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);

/* Returns the total central directory size in bytes. */
/* The current max supported size is <= MZ_UINT32_MAX. */
MINIZ_EXPORT size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);

/* Extracts a archive file to a memory buffer using no memory allocation. */
/* There must be at least enough room on the stack to store the inflator's state (~34KB or so). */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

/* Extracts a archive file to a memory buffer. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

/* Extracts a archive file to a dynamically allocated heap buffer. */
/* The memory will be allocated via the mz_zip_archive's alloc/realloc functions. */
/* Returns NULL and sets the last error on failure. */
MINIZ_EXPORT void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

/* Extracts a archive file using a callback function to output the file's data. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

/* Extract a file iteratively */
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
MINIZ_EXPORT size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState);

#ifndef MINIZ_NO_STDIO
/* Extracts a archive file to a disk file and sets its last accessed and modified times. */
/* This function only extracts files, not archive directory records. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);

/* Extracts a archive file starting at the current position in the destination FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
#endif

#if 0
/* TODO */
	typedef void *mz_zip_streaming_extract_state_ptr;
	mz_zip_streaming_extract_state_ptr mz_zip_streaming_extract_begin(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
	mz_uint64 mz_zip_streaming_extract_get_size(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_uint64 mz_zip_streaming_extract_get_cur_ofs(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_bool mz_zip_streaming_extract_seek(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, mz_uint64 new_ofs);
	size_t mz_zip_streaming_extract_read(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, void *pBuf, size_t buf_size);
	mz_bool mz_zip_streaming_extract_end(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
#endif

/* This function compares the archive's local headers, the optional local zip64 extended information block, and the optional descriptor following the compressed data vs. the data in the central directory. */
/* It also validates that each file can be successfully uncompressed unless the MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY is specified. */
MINIZ_EXPORT mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

/* Validates an entire archive by calling mz_zip_validate_file() on each file. */
MINIZ_EXPORT mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags);

/* Misc utils/helpers, valid for ZIP reading or writing */
MINIZ_EXPORT mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr);
#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr);
#endif

/* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */
MINIZ_EXPORT mz_bool mz_zip_end(mz_zip_archive *pZip);

/* -------- ZIP writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

/* Inits a ZIP archive writer. */
/*Set pZip->m_pWrite (and pZip->m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/
/*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/
MINIZ_EXPORT mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
MINIZ_EXPORT mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
#endif

/* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */
/* For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called. */
/* For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it). */
/* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL. */
/* Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before */
/* the archive is finalized the file's central directory will be hosed. */
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);

/* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */
/* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */
/* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                              mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                 const char *user_extra_data_central, mz_uint user_extra_data_central_len);

/* Adds the contents of a file to an archive. This function also records the disk file's modified time into the archive. */
/* File data is supplied via a read callback function. User mz_zip_writer_add_(c)file to add a file directly.*/
MINIZ_EXPORT mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size,
	const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
	const char *user_extra_data_central, mz_uint user_extra_data_central_len);


#ifndef MINIZ_NO_STDIO
/* Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size,
                                const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                const char *user_extra_data_central, mz_uint user_extra_data_central_len);
#endif

/* Adds a file to an archive by fully cloning the data from another archive. */
/* This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index);

/* Finalizes the archive by writing the central directory records followed by the end of central directory record. */
/* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */
/* An archive must be manually finalized by calling this function for it to be valid. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);

/* Finalizes a heap archive, returning a pointer to the heap block and its size. */
/* The heap block will be allocated using the mz_zip_archive's alloc/realloc callbacks. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);

/* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */
/* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */
MINIZ_EXPORT mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

/* -------- Misc. high-level helper functions: */

/* mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive. */
/* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
/* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);

#ifndef MINIZ_NO_STDIO
/* Reads a single file from an archive into a heap block. */
/* If pComment is not NULL, only the file with the specified comment will be extracted. */
/* Returns NULL on failure. */
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
#endif

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifdef __cplusplus
}
#endif

#endif /* MINIZ_NO_ARCHIVE_APIS */
#ifndef __CTX_CLIENTS_H
#define __CTX_CLIENTS_H



struct _CtxClient {
  VT    *vt;        // or NULL when thread

  long       rev;

  CtxList *events;  // we could use this queue also for vt

  Ctx     *ctx;
  char    *title;
  int      x;
  int      y;
  int      width;
  int      height;
  float    opacity;
  CtxClientFlags flags;
#if 0
  int      shaded;
  int      iconified;
  int      maximized;
  int      resizable;
#endif
  int      unmaximized_x;
  int      unmaximized_y;
  int      unmaximized_width;
  int      unmaximized_height;
  int      do_quit;
  long     drawn_rev;
  int      id;
  int      internal; // render a settings window rather than a vt

#if CTX_THREADS
  thrd_t tid;     // and only split code path in processing?
                    // -- why?
#endif
  void (*start_routine)(Ctx *ctx, void *user_data);
  void    *user_data;
  CtxClientFinalize finalize;
  Ctx     *sub_ctx;
  CtxList *ctx_events;


  /* we want to keep variation at the end */
#if CTX_THREADS
  mtx_t    mtx;
#endif
#if CTX_VT_DRAWLIST
  Ctx     *recording;
#endif
};


void ctx_client_lock (CtxClient *client);
void ctx_client_unlock (CtxClient *client);
void ctx_set_focus_cb (Ctx *ctx, void(*focus_cb)(Ctx *ctx, int id, void *user_data), void *user_data);

#endif

#if CTX_IMPLEMENTATION|CTX_COMPOSITE

#ifndef __CTX_INTERNAL_H
#define __CTX_INTERNAL_H

#if !__COSMOPOLITAN__
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <math.h>
#endif


#if CTX_BRANCH_HINTS
#define CTX_LIKELY(x)      __builtin_expect(!!(x), 1)
#define CTX_UNLIKELY(x)    __builtin_expect(!!(x), 0)
#else
#define CTX_LIKELY(x)      (x)
#define CTX_UNLIKELY(x)    (x)
#endif


#define CTX_FULL_AA 15

typedef struct _CtxRasterizer CtxRasterizer;
typedef struct _CtxGState     CtxGState;
//typedef struct _CtxState      CtxState;

typedef struct _CtxSource CtxSource;

typedef enum
{
  CTX_EDGE             = 0, 
  CTX_EDGE_FLIPPED     = 1,
  CTX_NEW_EDGE         = 2,
  CTX_CLOSE_EDGE       = 3
} CtxRasterizerCode;


#define CTX_VALID_RGBA_U8     (1<<0)
#define CTX_VALID_RGBA_DEVICE (1<<1)
#if CTX_ENABLE_CM
#define CTX_VALID_RGBA        (1<<2)
#endif
#if CTX_ENABLE_CMYK
#define CTX_VALID_CMYKA       (1<<3)
#define CTX_VALID_DCMYKA      (1<<4)
#endif
#define CTX_VALID_GRAYA       (1<<5)
#define CTX_VALID_GRAYA_U8    (1<<6)
#define CTX_VALID_LABA        ((1<<7) | CTX_VALID_GRAYA)

struct _CtxColor
{
  uint8_t magic; // for colors used in keydb, set to a non valid start of
                 // string value.
  uint8_t rgba[4];
  uint8_t l_u8;
  uint8_t original; // the bitmask of the originally set color
  uint8_t valid;    // bitmask of which members contain valid
  // values, gets denser populated as more
  // formats are requested from a set color.
  float   device_red;
  float   device_green;
  float   device_blue;
  float   alpha;
  float   l;        // luminance and gray
#if CTX_ENABLE_LAB  // NYI
  float   a;
  float   b;
#endif
#if CTX_ENABLE_CMYK
  float   device_cyan;
  float   device_magenta;
  float   device_yellow;
  float   device_key;
  float   cyan;
  float   magenta;
  float   yellow;
  float   key;
#endif

#if CTX_ENABLE_CM
  float   red;
  float   green;
  float   blue;
#if CTX_BABL
  const Babl *space; // gets copied from state when color is declared
#else
  void   *space; // gets copied from state when color is declared, 
#endif
#endif
};

typedef struct _CtxGradientStop CtxGradientStop;

struct _CtxGradientStop
{
  CtxColor color;
  float   pos;
};


enum _CtxSourceType
{
  CTX_SOURCE_COLOR,
  CTX_SOURCE_NONE = 1,
  CTX_SOURCE_TEXTURE,
  CTX_SOURCE_LINEAR_GRADIENT,
  CTX_SOURCE_RADIAL_GRADIENT,
  CTX_SOURCE_CONIC_GRADIENT,
  CTX_SOURCE_INHERIT_FILL
};

typedef enum _CtxSourceType CtxSourceType;

typedef struct _CtxPixelFormatInfo CtxPixelFormatInfo;

struct _CtxBuffer
{
  void               *data;
  int                 width;
  int                 height;
  int                 stride;
  int                 frame;      // last frame used in, everything > 3 can be removed,
                                  // as clients wont rely on it.
  char               *eid;        // might be NULL, when not - should be unique for pixel contents
  const CtxPixelFormatInfo *format;
  void (*freefunc) (void *pixels, void *user_data);
  void               *user_data;

#if CTX_ENABLE_CM
#if CTX_BABL
  const Babl *space;
#else
  void       *space; 
#endif
#endif
#if CTX_ENABLE_CM
  CtxBuffer          *color_managed; /* only valid for one render target, cache
                                        for a specific space
                                        */
#endif
};



typedef struct _CtxGradient CtxGradient;
struct _CtxGradient
{
  CtxGradientStop stops[CTX_MAX_GRADIENT_STOPS];
  int n_stops;
};

struct _CtxSource
{
  int type;
  CtxMatrix  set_transform;
  CtxMatrix  transform;
  uint32_t   pad;
  union
  {
    CtxColor color;
    struct
    {
      uint8_t rgba[4]; // shares data with set color
      uint8_t pad;
      CtxBuffer *buffer;
    } texture;
    struct
    {
      float x0;
      float y0;
      float x1;
      float y1;
      float length;
      float dx_scaled;
      float dy_scaled;
      float start_scaled;
    } linear_gradient;
    struct
    {
      float x;
      float y;
      float start_angle;
      float cycles;
    } conic_gradient;
    struct
    {
      float x0;
      float y0;
      float r0;
      float x1;
      float y1;
      float r1;
      float rdelta;
    } radial_gradient;
  };
};


typedef struct _Ctx16f16Matrix     Ctx16f16Matrix;
struct
  _Ctx16f16Matrix
{
#if CTX_32BIT_SEGMENTS
  int64_t m[3][3];  // forcing higher precision easily, the extra
                    // memory cost is minuscle
#else
  int32_t m[3][3];
#endif
};


struct _CtxGState
{
#if CTX_32BIT_SEGMENTS
  uint32_t      keydb_pos;
  uint32_t      stringpool_pos;
#else
  uint16_t      keydb_pos;      // this limits these
  uint16_t      stringpool_pos; // 
#endif

  CtxMatrix     transform;
  Ctx16f16Matrix  prepped_transform;
  CtxSource     source_stroke;
  CtxSource     source_fill;
  float         global_alpha_f;

  float         line_width;
  float         line_dash_offset;
  float         stroke_pos;
  float         feather;
  float         miter_limit;
  float         font_size;
#if CTX_ENABLE_SHADOW_BLUR
  float         shadow_blur;
  float         shadow_offset_x;
  float         shadow_offset_y;
#endif
  unsigned int  transform_type:3;
  unsigned int        clipped:1;
  CtxColorModel    color_model:8;
  /* bitfield-pack small state-parts */
  CtxLineCap          line_cap:2;
  CtxLineJoin        line_join:2;
  CtxFillRule        fill_rule:1;
  unsigned int image_smoothing:1;
  unsigned int            font:6;
  unsigned int            bold:1;
  unsigned int          italic:1;

  uint8_t       global_alpha_u8;
  int16_t       clip_min_x;
  int16_t       clip_min_y;
  int16_t       clip_max_x;
  int16_t       clip_max_y;
  int           n_dashes;

#if CTX_ENABLE_CM
#if CTX_BABL
  const Babl   *device_space;
  const Babl   *texture_space;
  const Babl   *rgb_space;       
  const Babl   *cmyk_space;

  const Babl   *fish_rgbaf_user_to_device;
  const Babl   *fish_rgbaf_texture_to_device;
  const Babl   *fish_rgbaf_device_to_user;

#else
  void         *device_space;
  void         *texture_space;
  void         *rgb_space;       
  void         *cmyk_space;
  void         *fish_rgbaf_user_to_device; // dummy padding
  void         *fish_rgbaf_texture_to_device; // dummy padding
  void         *fish_rgbaf_device_to_user; // dummy padding
#endif
#endif
  CtxCompositingMode  compositing_mode; // bitfield refs lead to
  CtxBlend                  blend_mode; // non-vectorization
  CtxExtend                 extend;
  long  tolerance_fixed;
  float tolerance;
  float dashes[CTX_MAX_DASHES]; // XXX moving dashes 
                                //  to state storage,. will
                                //  allow it to be larger,
                                //  free up memory, and
                                //  make save/restore faster
};

typedef enum
{
  CTX_TRANSFORMATION_NONE         = 0,
  CTX_TRANSFORMATION_SCREEN_SPACE = 1,
  CTX_TRANSFORMATION_RELATIVE     = 2,
#if CTX_BITPACK
  CTX_TRANSFORMATION_BITPACK      = 4,
#endif
  CTX_TRANSFORMATION_STORE_CLEAR  = 16,
} CtxTransformation;

#define CTX_DRAWLIST_DOESNT_OWN_ENTRIES   64
#define CTX_DRAWLIST_EDGE_LIST            128
#define CTX_DRAWLIST_CURRENT_PATH         512
// BITPACK

struct _CtxDrawlist
{
  CtxEntry     *entries;
  unsigned int  count;
  int           size;
  uint32_t      flags;
};

// the keydb consists of keys set to floating point values,
// that might also be interpreted as integers for enums.
//
// the hash
typedef struct _CtxKeyDbEntry CtxKeyDbEntry;
struct _CtxKeyDbEntry
{
  uint32_t key;
  float value;
  //union { float f[1]; uint8_t u8[4]; }value;
};

struct _CtxState
{
  int  has_moved;
  unsigned int  has_clipped:1;
  int8_t        source; // used for the single-shifting to stroking
                // 0  = fill
                // 1  = start_stroke
                // 2  = in_stroke
                //
                //   if we're at in_stroke at start of a source definition
                //   we do filling
  int16_t       gstate_no;

  float         x;
  float         y;
  float         first_x;
  float         first_y;
  int           ink_min_x;
  int           ink_min_y;
  int           ink_max_x;
  int           ink_max_y;
#if CTX_GSTATE_PROTECT
  int           gstate_waterlevel;
#endif
  CtxGState     gstate;
#if CTX_GRADIENTS
  CtxGradient   gradient; /* we keep only one gradient,
                             this goes icky with multiple
                             restores - it should really be part of
                             graphics state..
                             XXX, with the stringpool gradients
                             can be stored there.
                           */
#endif
  CtxKeyDbEntry keydb[CTX_MAX_KEYDB];
  CtxGState     gstate_stack[CTX_MAX_STATES];//at end, so can be made dynamic
  char         *stringpool;
  int           stringpool_size;
};


typedef struct _CtxFont       CtxFont;
typedef struct _CtxFontEngine CtxFontEngine;

struct _CtxFontEngine
{
  int   (*glyph)       (CtxFont *font, Ctx *ctx, int glyphid, int stroke);
  float (*glyph_width) (CtxFont *font, Ctx *ctx, int glyphid);
  float (*glyph_kern)  (CtxFont *font, Ctx *ctx, uint32_t glyphA, uint32_t unicharB);

  // return -1 for not found or 0 or positive number for found glyph
  int   (*glyph_lookup)  (CtxFont *font, Ctx *ctx, uint32_t unichar);
  void  (*unload) (CtxFont *font);
  const char *(*get_name)    (CtxFont *font);
  void (*get_vmetrics) (CtxFont *font, float *ascent, float *descent, float *linegap);
};

#if CTX_FONT_ENGINE_HARFBUZZ
#include <hb.h>
#include <hb-ot.h>
#endif

#pragma pack(push,1)
struct _CtxFont
{
#if CTX_ONE_FONT_ENGINE==0
  CtxFontEngine *engine;
#endif
  union
  {
    struct
    {
      const char *name;
      CtxEntry *data;
      int free_data;
    } ctx;
#if CTX_FONT_ENGINE_CTX_FS
    struct
    {
      const char *name;
      char *path;
    } ctx_fs;
#endif
#if CTX_FONT_ENGINE_HARFBUZZ
    struct
    {
      const char *name;
      char *path;
      hb_blob_t *blob;
      hb_face_t *face;
      hb_font_t *font;
      hb_draw_funcs_t *draw_funcs;
#if HB_VERSION_MAJOR >= 7
      hb_paint_funcs_t *paint_funcs;
#endif
      double scale;
    } hb;
#endif

#if 0
    struct { int start; int end; int gw; int gh; const uint8_t *data;} monobitmap;
#endif
  };
#if CTX_ONE_FONT_ENGINE==0
  int     font_no;
  uint8_t type:4; // 0 ctx    1 stb    2 monobitmap 3 fs 4 hb
  char   *path;
  uint8_t monospaced:1;
#endif
  uint8_t has_fligs:1;
};
#pragma pack(pop)

enum _CtxIteratorFlag
{
  CTX_ITERATOR_FLAT           = 0,
  CTX_ITERATOR_EXPAND_BITPACK = 2,
  CTX_ITERATOR_DEFAULTS       = CTX_ITERATOR_EXPAND_BITPACK
};
typedef enum _CtxIteratorFlag CtxIteratorFlag;


struct _CtxIterator
{
  int              pos;
  int              first_run;
  CtxDrawlist *drawlist;
  int              end_pos;
  int              flags;

  int              bitpack_pos;
  int              bitpack_length;     // if non 0 bitpack is active
  CtxEntry         bitpack_command[6]; // the command returned to the
  // user if unpacking is needed.
};

#if CTX_EVENTS 

// include list implementation - since it already is a header+inline online
// implementation?

typedef struct CtxItemCb {
  CtxEventType types;
  CtxCb        cb;
  void*        data1;
  void*        data2;

  void (*finalize) (void *data1, void *data2, void *finalize_data);
  void  *finalize_data;

} CtxItemCb;



typedef struct CtxItem {
  CtxMatrix inv_matrix;  /* for event coordinate transforms */

  /* bounding box */
  float          x0;
  float          y0;
  float          x1;
  float          y1;

  void *path;
  double          path_hash;

  CtxCursor       cursor; /* if 0 then UNSET and no cursor change is requested
                           */

  CtxEventType   types;   /* all cb's ored together */
  CtxItemCb cb[CTX_MAX_CBS];
  int       cb_count;
  int       ref_count;
} CtxItem;


typedef struct CtxBinding {
  char *nick;
  char *command;
  char *label;
  CtxCb cb;
  void *cb_data;
  CtxDestroyNotify destroy_notify;
  void  *destroy_data;
} CtxBinding;

/**
 * ctx_get_bindings:
 *   what is terminating ... ?
 */
CtxBinding *ctx_get_bindings (Ctx *ctx);

typedef struct _CtxEvents CtxEvents;
struct _CtxEvents
{
  int             frozen;
  int             fullscreen;
  CtxList        *grabs; /* could split the grabs per device in the same way,
                            to make dispatch overhead smaller,. probably
                            not much to win though. */
  CtxEvent         drag_event[CTX_MAX_DEVICES];
  CtxList         *idles;
  CtxList         *idles_to_remove;
  CtxList         *idles_to_add;

  CtxList         *events; // for ctx_get_event
  CtxBinding       bindings[CTX_MAX_KEYBINDINGS]; /*< better as list, uses no mem if unused */
  int              n_bindings;
  CtxItem         *prev[CTX_MAX_DEVICES];
  float            pointer_x[CTX_MAX_DEVICES];
  float            pointer_y[CTX_MAX_DEVICES];
  unsigned char    pointer_down[CTX_MAX_DEVICES];
  int              event_depth; // dispatch-level depth - for detecting syntetic events
  uint64_t         last_key_time;
  unsigned int     in_idle_dispatch:1;
  unsigned int     ctx_get_event_enabled:1;
  CtxModifierState modifier_state;
  int              idle_id;
  CtxList         *items;
  CtxItem         *last_item;
  float            tap_hysteresis;
#if CTX_VT
  CtxList         *clients;
  CtxClient *active;
  CtxClient *active_tab;
#endif
  int              tap_delay_min;
  int              tap_delay_max;
  int              tap_delay_hold;
  void (*focus_cb)(Ctx *ctx, int id, void *user_data);
  void            *focus_cb_user_data;
};
#endif

typedef struct _CtxEidInfo
{
  char *eid;
  int   frame;
  int   width;
  int   height;
} CtxEidInfo;


struct _CtxGlyphEntry
{
  uint32_t  unichar;
  uint16_t  offset;
  CtxFont  *font;
};
typedef struct _CtxGlyphEntry CtxGlyphEntry;

struct _Ctx
{
  CtxBackend       *backend;
  void  (*process)  (Ctx *ctx, const CtxCommand *entry);
  CtxState          state;        /**/
  CtxDrawlist       drawlist;
  int               transformation;
  int               width;
  int               height;
  int               dirty;
  Ctx              *texture_cache;
  CtxList          *deferred;
  CtxList          *eid_db;
  int               frame; /* used for texture lifetime */
  uint32_t          bail;
  CtxBackend       *backend_pushed;
  CtxBuffer         texture[CTX_MAX_TEXTURES];
  int               exit;
  CtxCursor         cursor;
  CtxGlyph          glyphs[CTX_SHAPE_GLYPHS];
  int               n_glyphs;
#if CTX_EVENTS 
  CtxEvents         events;
  int               mouse_fd;
  int               mouse_x;
  int               mouse_y;
#endif
#if CTX_CURRENT_PATH
  CtxDrawlist       current_path; // possibly transformed coordinates !
  CtxIterator       current_path_iterator;
#endif
#if CTX_GLYPH_CACHE
  CtxGlyphEntry     glyph_index_cache[CTX_GLYPH_CACHE_SIZE];
#endif
  CtxFont *fonts; // a copy to keep it alive with mp's
                  // garbage collector, the fonts themselves
                  // are static and shared beyond ctx contexts
 
  int frontend_text;
};

#if 0
#define ctx_process(ctx,entry)  ctx->process (ctx, (CtxCommand *)(entry));
#else
static inline void
ctx_process (Ctx *ctx, const CtxEntry *entry)
{
  ctx->process (ctx, (CtxCommand *) entry);
}
#endif

CtxBuffer *ctx_buffer_new (int width, int height,
                           CtxPixelFormat pixel_format);
void ctx_buffer_destroy (CtxBuffer *buffer);

static void
ctx_state_gradient_clear_stops (CtxState *state);

void ctx_interpret_style         (CtxState *state, const CtxEntry *entry, void *data);
void ctx_interpret_transforms    (CtxState *state, const CtxEntry *entry, void *data);
void ctx_interpret_pos           (CtxState *state, CtxEntry *entry, void *data);
void ctx_interpret_pos_transform (CtxState *state, CtxEntry *entry, void *data);

struct _CtxInternalFsEntry
{
  char *path;
  int   length;
  char *data;
};


typedef void (*ctx_apply_coverage_fun) (unsigned int count, uint8_t * __restrict__ dst, uint8_t * __restrict__ src, uint8_t *coverage, CtxRasterizer *r, int x);

struct _CtxPixelFormatInfo
{
  CtxPixelFormat pixel_format:8;
  uint8_t        components; /* number of components */
  uint8_t        bpp; /* bits  per pixel - for doing offset computations
                         along with rowstride found elsewhere, if 0 it indicates
                         1/8  */
  uint8_t        ebpp; /*effective bytes per pixel - for doing offset
                         computations, for formats that get converted, the
                         ebpp of the working space applied */
  uint8_t        dither_red_blue;
  uint8_t        dither_green;
  CtxPixelFormat composite_format:8;

  void         (*to_comp) (CtxRasterizer *r,
                           int x, const void * __restrict__ src, uint8_t * __restrict__ comp, int count);
  void         (*from_comp) (CtxRasterizer *r,
                             int x, const uint8_t * __restrict__ comp, void *__restrict__ dst, int count);
  ctx_apply_coverage_fun apply_coverage;
  void         (*setup) (CtxRasterizer *r);
};


void
_ctx_user_to_device (CtxState *state, float *x, float *y);
void
_ctx_user_to_device_distance (CtxState *state, float *x, float *y);
void ctx_state_init (CtxState *state);
void
ctx_interpret_pos_bare (CtxState *state, const CtxEntry *entry, void *data);
void
ctx_drawlist_deinit (CtxDrawlist *drawlist);

//extern CtxPixelFormatInfo *(*ctx_pixel_format_info) (CtxPixelFormat format);
const CtxPixelFormatInfo *ctx_pixel_format_info (CtxPixelFormat format);



extern void (*ctx_composite_stroke_rect) (CtxRasterizer *rasterizer,
                           float          x0,
                           float          y0,
                           float          x1,
                           float          y1,
                           float          line_width);

extern void (*ctx_composite_setup) (CtxRasterizer *rasterizer);


extern void (*ctx_rasterizer_rasterize_edges) (CtxRasterizer *rasterizer, const int fill_rule);

extern void (*ctx_composite_fill_rect) (CtxRasterizer *rasterizer,
                           float        x0,
                           float        y0,
                           float        x1,
                           float        y1,
                           uint8_t      cov);


const char *ctx_utf8_skip (const char *s, int utf8_length);
int ctx_utf8_strlen (const char *s);
int
ctx_unichar_to_utf8 (uint32_t  ch,
                     uint8_t  *dest);

uint32_t
ctx_utf8_to_unichar (const char *input);


typedef struct _CtxHasher CtxHasher;

typedef void (*CtxFragment) (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz);

#define CTX_MAX_GAUSSIAN_KERNEL_DIM    512

typedef enum {
   CTX_COV_PATH_FALLBACK =0,
   CTX_COV_PATH_RGBA8_OVER,
   CTX_COV_PATH_RGBA8_COPY,
   CTX_COV_PATH_RGBA8_COPY_FRAGMENT,
   CTX_COV_PATH_RGBA8_OVER_FRAGMENT,
   CTX_COV_PATH_GRAYA8_COPY,
   CTX_COV_PATH_GRAY1_COPY,
   CTX_COV_PATH_GRAY2_COPY,
   CTX_COV_PATH_GRAY4_COPY,
   CTX_COV_PATH_RGB565_COPY,
   CTX_COV_PATH_RGB332_COPY,
   CTX_COV_PATH_GRAY8_COPY,
   CTX_COV_PATH_RGBAF_COPY,
   CTX_COV_PATH_RGB8_COPY,
   CTX_COV_PATH_CMYK8_COPY,
   CTX_COV_PATH_CMYKA8_COPY,
   CTX_COV_PATH_CMYKAF_COPY,
   CTX_COV_PATH_GRAYAF_COPY
} CtxCovPath;

struct _CtxRasterizer
{
  CtxBackend backend;
  /* these should be initialized and used as the bounds for rendering into the
     buffer as well XXX: not yet in use, and when in use will only be
     correct for axis aligned clips - proper rasterization of a clipping path
     would be yet another refinement on top.
   */


#define CTX_COMPOSITE_ARGUMENTS unsigned int count, uint8_t * __restrict__ dst, uint8_t * __restrict__ src, uint8_t * __restrict__ coverage, CtxRasterizer *rasterizer, int x0
  void (*comp_op)(CTX_COMPOSITE_ARGUMENTS);
  CtxFragment fragment;
  //Ctx       *ctx;
  CtxState  *state;
  CtxCovPath  comp;
  unsigned int  swap_red_green;
  ctx_apply_coverage_fun apply_coverage;

  unsigned int active_edges;
  unsigned int edge_pos;         // where we're at in iterating all edges
  unsigned int pending_edges;
  unsigned int horizontal_edges;
  unsigned int ending_edges;

  unsigned int aa;          // level of vertical aa
  int  convex;
  unsigned int  scan_aa[4]; // 0=none, 1 = 3, 2 = 5, 3 = 15

  int        scanline;
  int        scan_min;
  int        scan_max;
  int        col_min;
  int        col_max;

  int        inner_x;
  int        inner_y;

  float      x;
  float      y;

  int        first_edge;

  uint16_t    blit_x;
  uint16_t    blit_y;
  int32_t    blit_width;
  int32_t    blit_height;
  uint32_t    blit_stride;


  unsigned int  unused; // kept for layout
  unsigned int  clip_rectangle;
  int           has_prev;
  void      *buf;
#if CTX_ENABLE_SHADOW_BLUR
  unsigned int  in_shadow:1;
  float         feather_x;
  float         feather_y;
  float         feather;
#endif

  const CtxPixelFormatInfo *format;
  Ctx       *texture_source; /* normally same as ctx */
  uint8_t    color[8*5];   // in compositing format - placed right after a pointer to get good alignment
  uint16_t   color_nativeB[8];

  uint16_t   color_native;  //

                           //
  int edges[CTX_MAX_EDGES]; // integer position in edge array
  CtxDrawlist edge_list;
                           
  unsigned int  preserve;
  unsigned int  in_text;


#if static_OPAQUE
  uint8_t opaque[CTX_MAX_SCANLINE_LENGTH];
#endif
#if CTX_ENABLE_CLIP
  CtxBuffer *clip_buffer;
#endif

#if CTX_GRADIENTS
#if CTX_GRADIENT_CACHE
  int gradient_cache_valid;
  uint8_t gradient_cache_u8[CTX_GRADIENT_CACHE_ELEMENTS][4];
  int gradient_cache_elements;
#endif
#endif


#if CTX_BRAILLE_TEXT
  unsigned int  term_glyphs:1; // store appropriate glyphs for redisplay
#endif
#if CTX_BRAILLE_TEXT
  CtxList   *glyphs;
#endif

#if CTX_COMPOSITING_GROUPS
  void      *saved_buf; // when group redirected
  CtxBuffer *group[CTX_GROUP_MAX];
#endif
#if CTX_ENABLE_SHADOW_BLUR
  float      kernel[CTX_MAX_GAUSSIAN_KERNEL_DIM];
#endif
  unsigned int shadow_active_edges;
  unsigned int shadow_edge_pos;
  int shadow_edges[CTX_MAX_EDGES*2];

#if CTX_SCANBIN
  uint32_t scan_bins[CTX_MAX_SCANLINES][CTX_MAX_EDGES];
#if CTX_MAX_EDGES>255
  uint32_t scan_bin_count[CTX_MAX_SCANLINES];
#else
  uint8_t scan_bin_count[CTX_MAX_SCANLINES];
#endif
#endif


};

struct _CtxSHA1 {
    uint64_t length;
    uint32_t state[5], curlen;
    unsigned char buf[64];
};
typedef struct _CtxMurmur CtxMurmur;
struct _CtxMurmur {
    uint32_t state[2];
};


#pragma pack(push,1)
typedef struct CtxCommandState
{
  uint16_t pos;
  uint32_t active;
} CtxCommandState;
#pragma pack(pop)

struct _CtxHasher
{
  CtxRasterizer rasterizer;
  int           cols;
  int           rows;
  uint32_t      hashes[CTX_HASH_COLS*CTX_HASH_ROWS];
  CtxMurmur     murmur_fill[CTX_MAX_STATES]; 
  CtxMurmur     murmur_stroke[CTX_MAX_STATES];
  int           source_level;
  int           pos; 

  int           prev_command;

  CtxDrawlist  *drawlist;

};

#if CTX_RASTERIZER
void ctx_rasterizer_deinit (CtxRasterizer *rasterizer);
void ctx_rasterizer_destroy (void *rasterizer);
#endif

enum {
  NC_MOUSE_NONE  = 0,
  NC_MOUSE_PRESS = 1,  /* "mouse-pressed", "mouse-released" */
  NC_MOUSE_DRAG  = 2,  /* + "mouse-drag"   (motion with pressed button) */
  NC_MOUSE_ALL   = 3   /* + "mouse-motion" (also delivered for release) */
};
void _ctx_mouse (Ctx *term, int mode);
void nc_at_exit (void);

int ctx_terminal_width  (int in_fd, int out_fd);
int ctx_terminal_height (int in_fd, int out_fd);
int ctx_terminal_cols   (int in_fd, int out_fd);
int ctx_terminal_rows   (int in_fd, int out_fd);
extern int ctx_frame_ack;


typedef struct _CtxCtx CtxCtx;
struct _CtxCtx
{
   CtxBackend backend;
   int  flags;
   int  width;
   int  height;
   int  cols;
   int  rows;
   int  was_down;
};

extern int _ctx_max_threads;
extern int _ctx_enable_hash_cache;
void
ctx_set (Ctx *ctx, uint32_t key_hash, const char *string, int len);
const char *
ctx_get (Ctx *ctx, const char *key);

Ctx *ctx_new_ctx (int width, int height, int flags);
Ctx *ctx_new_fb (int width, int height);
Ctx *ctx_new_kms (int width, int height);
Ctx *ctx_new_sdl (int width, int height);
Ctx *ctx_new_term (int width, int height);

int ctx_resolve_font (const char *name);

#if CTX_U8_TO_FLOAT_LUT
extern float ctx_u8_float[256];
#define ctx_u8_to_float(val_u8) ctx_u8_float[((uint8_t)(val_u8))]
#else
#define ctx_u8_to_float(val_u8) (val_u8/255.0f)
#endif

static inline uint8_t ctx_float_to_u8 (float val_f)
{
#if 1 
  union { float f; uint32_t i; } u;
  u.f = 32768.0f + val_f * (255.0f / 256.0f);
  return (uint8_t)u.i;
#else
  return val_f < 0.0f ? 0 : val_f > 1.0f ? 0xff : 0xff * val_f +  0.5f;
#endif
}


#define CTX_CSS_LUMINANCE_RED   0.3f
#define CTX_CSS_LUMINANCE_GREEN 0.59f
#define CTX_CSS_LUMINANCE_BLUE  0.11f

/* works on both float and uint8_t */
#define CTX_CSS_RGB_TO_LUMINANCE(rgb)  (\
  (rgb[0]) * CTX_CSS_LUMINANCE_RED + \
  (rgb[1]) * CTX_CSS_LUMINANCE_GREEN +\
  (rgb[2]) * CTX_CSS_LUMINANCE_BLUE)

const char *ctx_nct_get_event (Ctx *n, int timeoutms, int *x, int *y);
const char *ctx_native_get_event (Ctx *n, int timeoutms);
void
ctx_color_get_rgba8 (CtxState *state, CtxColor *color, uint8_t *out);
void ctx_color_get_graya_u8 (CtxState *state, CtxColor *color, uint8_t *out);
float ctx_float_color_rgb_to_gray (CtxState *state, const float *rgb);
void ctx_color_get_graya (CtxState *state, CtxColor *color, float *out);
void ctx_rgb_to_cmyk (float r, float g, float b,
              float *c_out, float *m_out, float *y_out, float *k_out);
uint8_t ctx_u8_color_rgb_to_gray (CtxState *state, const uint8_t *rgb);
#if CTX_ENABLE_CMYK
void ctx_color_get_cmyka (CtxState *state, CtxColor *color, float *out);
#endif
void ctx_color_set_RGBA8 (CtxState *state, CtxColor *color, uint8_t r, uint8_t g, uint8_t b, uint8_t a);
void ctx_color_set_rgba (CtxState *state, CtxColor *color, float r, float g, float b, float a);
void ctx_color_set_drgba (CtxState *state, CtxColor *color, float r, float g, float b, float a);
void ctx_color_get_cmyka (CtxState *state, CtxColor *color, float *out);
void ctx_color_set_cmyka (CtxState *state, CtxColor *color, float c, float m, float y, float k, float a);
void ctx_color_set_dcmyka (CtxState *state, CtxColor *color, float c, float m, float y, float k, float a);
void ctx_color_set_graya (CtxState *state, CtxColor *color, float gray, float alpha);

int ctx_color_model_get_components (CtxColorModel model);

void ctx_state_set (CtxState *state, uint32_t key, float value);

static void
ctx_matrix_set (CtxMatrix *matrix, float a, float b, float c, float d, float e, float f, float g, float h, float i);


void ctx_font_setup (Ctx *ctx);
float ctx_state_get (CtxState *state, uint32_t hash);

#if CTX_RASTERIZER

void
ctx_rasterizer_rel_move_to (CtxRasterizer *rasterizer, float x, float y);
void
ctx_rasterizer_rel_line_to (CtxRasterizer *rasterizer, float x, float y);

void
ctx_rasterizer_move_to (CtxRasterizer *rasterizer, float x, float y);
void
ctx_rasterizer_line_to (CtxRasterizer *rasterizer, float x, float y);
void
ctx_rasterizer_curve_to (CtxRasterizer *rasterizer,
                         float x0, float y0,
                         float x1, float y1,
                         float x2, float y2);
void
ctx_rasterizer_rel_curve_to (CtxRasterizer *rasterizer,
                         float x0, float y0,
                         float x1, float y1,
                         float x2, float y2);

void
ctx_rasterizer_reset (CtxRasterizer *rasterizer);
void
ctx_rasterizer_arc (CtxRasterizer *rasterizer,
                    float        x,
                    float        y,
                    float        radius,
                    float        start_angle,
                    float        end_angle,
                    int          anticlockwise);

void
ctx_rasterizer_quad_to (CtxRasterizer *rasterizer,
                        float        cx,
                        float        cy,
                        float        x,
                        float        y);

void
ctx_rasterizer_rel_quad_to (CtxRasterizer *rasterizer,
                        float        cx,
                        float        cy,
                        float        x,
                        float        y);

void
ctx_rasterizer_rectangle (CtxRasterizer *rasterizer,
                          float x,
                          float y,
                          float width,
                          float height);

void ctx_rasterizer_close_path (CtxRasterizer *rasterizer);
void ctx_rasterizer_clip (CtxRasterizer *rasterizer);
void
ctx_rasterizer_set_font (CtxRasterizer *rasterizer, const char *font_name);

void
ctx_rasterizer_gradient_add_stop (CtxRasterizer *rasterizer, float pos, float *rgba);
void
ctx_rasterizer_set_pixel (CtxRasterizer *rasterizer,
                          uint16_t x,
                          uint16_t y,
                          uint8_t r,
                          uint8_t g,
                          uint8_t b,
                          uint8_t a);
void
ctx_rasterizer_round_rectangle (CtxRasterizer *rasterizer, float x, float y, float width, float height, float corner_radius);

#endif

#if CTX_ENABLE_CM // XXX to be moved to ctx.h
void
ctx_set_drgb_space (Ctx *ctx, int device_space);
void
ctx_set_dcmyk_space (Ctx *ctx, int device_space);
void
ctx_rgb_space (Ctx *ctx, int device_space);
void
ctx_set_cmyk_space (Ctx *ctx, int device_space);
#endif

#endif

CtxRasterizer *
ctx_rasterizer_init (CtxRasterizer *rasterizer, Ctx *ctx, Ctx *texture_source, CtxState *state, void *data, int x, int y, int width, int height, int stride, CtxPixelFormat pixel_format, CtxAntialias antialias);

CTX_INLINE static uint8_t ctx_lerp_u8 (uint8_t v0, uint8_t v1, uint8_t dx)
{
#if 0
  return v0 + ((v1-v0) * dx)/255;
#else
  return ( ( ( ( (v0) <<8) + (dx) * ( (v1) - (v0) ) ) ) >>8);
#endif
}

CTX_INLINE static uint32_t ctx_lerp_RGBA8 (const uint32_t v0, const uint32_t v1, const uint8_t dx)
{
#if 0
  char bv0[4];
  char bv1[4];
  char res[4];
  memcpy (&bv0[0], &v0, 4);
  memcpy (&bv1[0], &v1, 4);
  for (int c = 0; c < 4; c++)
    res [c] = ctx_lerp_u8 (bv0[c], bv1[c], dx);
  return ((uint32_t*)(&res[0]))[0];
#else
  const uint32_t cov = dx;
  const uint32_t si_ga = (v1 & 0xff00ff00);
  const uint32_t si_rb = v1 & 0x00ff00ff;
  const uint32_t di_rb = v0 & 0x00ff00ff;
  const uint32_t d_rb = si_rb - di_rb;
  const uint32_t di_ga = v0 & 0xff00ff00;
  const uint32_t d_ga = (si_ga >>8) - (di_ga>>8);
  return
     (((di_rb + ((0xff00ff + d_rb * cov)>>8)) & 0x00ff00ff)) |
     (((di_ga + (0xff00ff + d_ga * cov))      & 0xff00ff00));

#endif
}

CTX_INLINE static void ctx_lerp_RGBA8_split (const uint32_t v0, const uint32_t v1, const uint8_t dx,
                                             uint32_t *dest_ga, uint32_t *dest_rb)
{
  const uint32_t cov = dx;
  const uint32_t si_ga = v1 & 0xff00ff00;
  const uint32_t si_rb = v1 & 0x00ff00ff;
  const uint32_t di_ga = v0 & 0xff00ff00;
  const uint32_t di_rb = v0 & 0x00ff00ff;
  const uint32_t d_rb = si_rb - di_rb;
  const uint32_t d_ga = (si_ga >>8) - (di_ga >> 8);
  *dest_rb = (((di_rb + ((0xff00ff + d_rb * cov)>>8)) & 0x00ff00ff));
  *dest_ga = (((di_ga + (0xff00ff + d_ga * cov))      & 0xff00ff00));
}

CTX_INLINE static uint32_t ctx_lerp_RGBA8_merge (uint32_t di_ga, uint32_t di_rb, uint32_t si_ga, uint32_t si_rb, const uint8_t dx)
{
  const uint32_t cov = dx;
  const uint32_t d_rb = si_rb - di_rb;
  const uint32_t d_ga = (si_ga >> 8) - (di_ga >> 8);
  return
     (((di_rb + ((0xff00ff + d_rb * cov)>>8)) & 0x00ff00ff))  |
      ((di_ga + ((0xff00ff + d_ga * cov)      & 0xff00ff00)));
}

CTX_INLINE static uint32_t ctx_lerp_RGBA8_2 (const uint32_t v0, uint32_t si_ga, uint32_t si_rb, const uint8_t dx)
{
  const uint32_t cov = dx;
  const uint32_t di_ga = ( v0 & 0xff00ff00);
  const uint32_t di_rb = v0 & 0x00ff00ff;
  const uint32_t d_rb = si_rb - di_rb;
  const uint32_t d_ga = si_ga - (di_ga>>8);
  return
     (((di_rb + ((0xff00ff + d_rb * cov)>>8)) & 0x00ff00ff)) |
     (((di_ga + (0xff00ff + d_ga * cov))      & 0xff00ff00));
}

CTX_INLINE static float
ctx_lerpf (float v0, float v1, float dx)
{
  return v0 + (v1-v0) * dx;
}

CTX_INLINE static float
ctx_catmull_rom (float v0, float v1, float v2, float v3, float t)
{
   float ya = v0, yb = v1, yc = v2, yd = v3;
   float a3 = 0.5f * (-ya + 3 * yb - 3 * yc + yd);
   float a2 = 0.5f * (2 * ya - 5 * yb + 4 * yc - yd);
   float a1 = 0.5f * (-ya + yc);
   float a0 = yb;
   return a3 * t * t * t +
          a2 * t * t +
          a1 * t +
          a0;
}

CTX_INLINE static float
ctx_catmull_rom_left (float v0, float v1, float v2, float t)
{
   float ya = v0, yb = v1, yc = v2;
   float a2 = 0.5f * (ya - 2 * yb + yc);
   float a1 = 0.5f * (-3 * ya + 4 * yb - yc);
   float a0 = ya;
   return a2 * t * t +
          a1 * t +
          a0;
}

CTX_INLINE static float
ctx_catmull_rom_right (float v0, float v1, float v2, float t)
{
   float ya = v0, yb = v1, yc = v2;
   float a2 = 0.5f * (ya - 2 * yb + yc);
   float a1 = 0.5f * (-ya + yc);
   float a0 = yb;
   return a2 * t * t +
          a1 * t +
          a0;
}


#ifndef CTX_MIN
#define CTX_MIN(a,b)  (((a)<(b))?(a):(b))
#endif
#ifndef CTX_MAX
#define CTX_MAX(a,b)  (((a)>(b))?(a):(b))
#endif

static inline void *ctx_calloc (size_t size, size_t count);

void ctx_screenshot (Ctx *ctx, const char *output_path);


CtxSHA1 *ctx_sha1_new (void);
void ctx_sha1_free (CtxSHA1 *sha1);
int ctx_sha1_process(CtxSHA1 *sha1, const unsigned char * msg, unsigned long len);
int ctx_sha1_done(CtxSHA1 * sha1, unsigned char *out);

void _ctx_texture_lock (void);
void _ctx_texture_unlock (void);
uint8_t *ctx_define_texture_pixel_data (const CtxEntry *entry);
uint32_t ctx_define_texture_pixel_data_length (const CtxEntry *entry);
void ctx_buffer_pixels_free (void *pixels, void *userdata);

/*ctx_texture_init:
 * return value: eid, as passed in or if NULL generated by hashing pixels and width/height
 * XXX  this is low-level and not to be used directly use define_texture instead.  XXX
 */
const char *ctx_texture_init (
                      Ctx        *ctx,
                      const char *eid,
                      int         width,
                      int         height,
                      int         stride,
                      CtxPixelFormat format,
                      void       *space,
                      uint8_t    *pixels,
                      void (*freefunc) (void *pixels, void *user_data),
                      void *user_data);

typedef struct _EvSource EvSource;
struct _EvSource
{
  void   *priv; /* private storage  */

  /* returns non 0 if there is events waiting */
  int   (*has_event) (EvSource *ev_source);

  /* get an event, the returned event should be freed by the caller  */
  char *(*get_event) (EvSource *ev_source);

  /* destroy/unref this instance */
  void  (*destroy)   (EvSource *ev_source);

  /* get the underlying fd, useful for using select on  */
  int   (*get_fd)    (EvSource *ev_source);


  void  (*set_coord) (EvSource *ev_source, double x, double y);
  /* set_coord is needed to warp relative cursors into normalized range,
   * like normal mice/trackpads/nipples - to obey edges and more.
   */

  /* if this returns non-0 select can be used for non-blocking.. */
};

typedef struct CtxCbJob
{
  int      x0;
  int      y0;
  int      x1;
  int      y1;
  uint32_t bitmask;
  int      renderer;      // 0 - no render
  int      flags;
} CtxCbJob;

#define CTX_CB_MAX_JOBS 8
#define CTX_JOB_PENDING (-1)


typedef struct CtxCbBackend
{
  CtxBackend     backend;

  Ctx           *drawlist_copy;
  Ctx           *rctx[2];
  uint8_t       *temp[2];
  int            temp_len[2];

  int            rendering;
  int            frame_no;

  CtxCbConfig    config;
  int            min_col; // hasher cols and rows
  int            min_row; // hasher cols and rows
  int            max_col; // hasher cols and rows
  int            max_row; // hasher cols and rows
  uint16_t      *scratch;
  int            allocated_fb;
  Ctx           *ctx;

  int n_jobs;
  CtxCbJob  jobs[CTX_CB_MAX_JOBS];
  int jobs_done;

   EvSource    *evsource[4];
   int          evsource_count;

  uint32_t hashes[CTX_HASH_ROWS * CTX_HASH_COLS];

  CtxHasher     hasher;
  uint8_t res[CTX_HASH_ROWS * CTX_HASH_COLS];

  // when non-0 we have non-full res rendered
                                           
  mtx_t mtx;
} CtxCbBackend;

static inline Ctx *ctx_backend_get_ctx (void *backend)
{
  CtxBackend *r = (CtxBackend*)backend;
  if (r) return r->ctx;
  return NULL;
}

void
_ctx_texture_prepare_color_management (CtxState  *state,
                                       CtxBuffer *buffer);

int ctx_is_set (Ctx *ctx, uint32_t hash);

static inline void
_ctx_matrix_apply_transform (const CtxMatrix *m, float *x, float *y)
{
  float x_in = *x;
  float y_in = *y;
  float w =   (x_in * m->m[2][0]) + (y_in * m->m[2][1]) + m->m[2][2];
  float w_recip = 1.0f/w;
  *x = ( (x_in * m->m[0][0]) + (y_in * m->m[0][1]) + m->m[0][2]) * w_recip;
  *y = ( (x_in * m->m[1][0]) + (y_in * m->m[1][1]) + m->m[1][2]) * w_recip;
}

static inline void
_ctx_matrix_multiply (CtxMatrix       *result,
                      const CtxMatrix *t,
                      const CtxMatrix *s)
{
  CtxMatrix r;

  for (unsigned int i = 0; i < 3; i++)
  {
    r.m[i][0] = t->m[i][0] * s->m[0][0]
              + t->m[i][1] * s->m[1][0]
              + t->m[i][2] * s->m[2][0];
    r.m[i][1] = t->m[i][0] * s->m[0][1]
              + t->m[i][1] * s->m[1][1]
              + t->m[i][2] * s->m[2][1];
    r.m[i][2] = t->m[i][0] * s->m[0][2]
              + t->m[i][1] * s->m[1][2]
              + t->m[i][2] * s->m[2][2];
  }
  *result = r;
}

static inline void
_ctx_matrix_identity (CtxMatrix *matrix)
{
  matrix->m[0][0] = 1.0f;
  matrix->m[0][1] = 0.0f;
  matrix->m[0][2] = 0.0f;
  matrix->m[1][0] = 0.0f;
  matrix->m[1][1] = 1.0f;
  matrix->m[1][2] = 0.0f;
  matrix->m[2][0] = 0.0f;
  matrix->m[2][1] = 0.0f;
  matrix->m[2][2] = 1.0f;
}

void
_ctx_user_to_device_prepped (CtxState *state, float x, float y, int *out_x, int *out_y);
void
_ctx_user_to_device_prepped_fixed (CtxState *state, int x, int y, int *x_out, int *y_out);

int ctx_float_to_string_index (float val);

void
ctx_render_ctx_masked (Ctx *ctx, Ctx *d_ctx, uint32_t mask);

void ctx_state_set_blob (CtxState *state, uint32_t key, const void*data, int len);
void *ctx_state_get_blob (CtxState *state, uint32_t key);

static inline void
_ctx_transform_prime (CtxState *state);

void ctx_push_backend (Ctx *ctx,
                       void *backend);
void ctx_pop_backend (Ctx *ctx);

static CTX_INLINE float ctx_fmod1f (float val)
{
  val = ctx_fabsf(val);
  return val - (int)(val);
}

static CTX_INLINE float ctx_fmodf (float val, float modulus)
{
  return ctx_fmod1f(val/modulus) * modulus;
}

static CTX_INLINE int ctx_nearly_zero(float val)
{
  return (val > 0.001f) & (val > -0.001f);
}

#if EMSCRIPTEN
#define CTX_EXPORT EMSCRIPTEN_KEEPALIVE
#else
#define CTX_EXPORT
#endif

float ctx_get_feather (Ctx *ctx);
void  ctx_feather     (Ctx *ctx, float x);

CtxColor   *ctx_color_new      (void);
int         ctx_get_int        (Ctx *ctx, uint32_t hash);
int         ctx_get_is_set     (Ctx *ctx, uint32_t hash);
Ctx        *ctx_new_for_buffer (CtxBuffer *buffer);

/**
 * ctx_pixel_format_components:
 *
 * Returns the number of components for a given pixel format.
 */
int ctx_pixel_format_components     (CtxPixelFormat format);

void ctx_init (int *argc, char ***argv); // is a no-op but could launch
                                         // terminal

void ctx_svg_arc_to (Ctx *ctx, float rx, float ry, 
                     float rotation,  int large, int sweep,
                     float x1, float y1);

/**
 * ctx_clear_bindings:
 * @ctx: a context
 *
 * Clears registered key-bindings.
 */
void  ctx_clear_bindings     (Ctx *ctx);
Ctx *ctx_new_net (int width, int height, int flags, const char *hostip, int port);
Ctx *ctx_new_fds (int width, int height, int in_fd, int out_fd, int flags);

#endif
void
ctx_drawlist_process (Ctx *ctx, const CtxCommand *command);
CtxBackend *ctx_drawlist_backend_new (void);

void ctx_events_deinit (Ctx *ctx);
void
ctx_path_extents_path (Ctx *ctx, float *ex1, float *ey1, float *ex2, float *ey2, CtxDrawlist *path);
int ctx_in_fill_path (Ctx *ctx, float x, float y, CtxDrawlist *path);
void ctx_buffer_deinit (CtxBuffer *buffer);
void ctx_wait_frame (Ctx *ctx, VT *vt);
extern int _ctx_depth;
int ctx_term_raw (int fd);
void ctx_term_noraw (int fd);
void ctx_color_raw (Ctx *ctx, CtxColorModel model, float *components, int stroke);
int ctx_ydec (const char *tmp_src, char *dst, int count);
int ctx_yenc (const char *src, char *dst, int count);
void ctx_font_setup (Ctx *ctx);

typedef struct CtxIdleCb {
  int (*cb) (Ctx *ctx, void *idle_data);
  void *idle_data;

  void (*destroy_notify)(void *destroy_data);
  void *destroy_data;

  int   ticks_full;
  int   ticks_remaining;
  int   is_idle;
  int   id;
} CtxIdleCb;

#define TRANSFORM_SHIFT (10)
#define TRANSFORM_SCALE (1<<TRANSFORM_SHIFT)

static inline int
_ctx_determine_transform_type (const CtxMatrix *m)
{
  // XXX : does not set 4 - which is perspective
  if ((m->m[2][0] != 0.0f) |
      (m->m[2][1] != 0.0f) |
      (m->m[2][2] != 1.0f))
    return 3;
  if ((m->m[0][1] != 0.0f) |
      (m->m[1][0] != 0.0f))
    return 3;
  if ((m->m[0][2] != 0.0f) |
      (m->m[1][2] != 0.0f) |
      (m->m[0][0] != 1.0f) |
      (m->m[1][1] != 1.0f))
    return 2;
  return 1;
}
static inline void
_ctx_transform_prime (CtxState *state)
{
   state->gstate.transform_type = 
     _ctx_determine_transform_type (&state->gstate.transform);

   for (int c = 0; c < 3; c++)
   {
     state->gstate.prepped_transform.m[0][c] =
             (int)(state->gstate.transform.m[0][c] * TRANSFORM_SCALE);
     state->gstate.prepped_transform.m[1][c] =
             (int)(state->gstate.transform.m[1][c] * TRANSFORM_SCALE);
     state->gstate.prepped_transform.m[2][c] =
             (int)(state->gstate.transform.m[2][c] * TRANSFORM_SCALE);
   }
   float scale = ctx_matrix_get_scale (&state->gstate.transform);
   scale = ctx_fabsf (scale);
   if (scale <= 0.01f)
      scale = 0.01f;
     
   {
     state->gstate.tolerance = 0.25f/scale;
     state->gstate.tolerance *= state->gstate.tolerance;
     state->gstate.tolerance_fixed =
     (state->gstate.tolerance * CTX_FIX_SCALE * CTX_FIX_SCALE);
   }
}

static inline void ctx_span_set_color (uint32_t *dst_pix, uint32_t val, int count)
{
  if (count>0)
  while(count--)
    *dst_pix++=val;
}
static inline void ctx_span_set_color_x4 (uint32_t *dst_pix, uint32_t *val, int count)
{
  if (count>0)
  while(count--)
  {
    *dst_pix++=val[0];
    *dst_pix++=val[1];
    *dst_pix++=val[2];
    *dst_pix++=val[3];
  }
}

static inline uint32_t
ctx_over_RGBA8_full_2 (uint32_t dst, uint32_t si_ga_full, uint32_t si_rb_full, uint32_t si_a)
{
  uint32_t rcov = si_a^255;
  uint32_t di_ga = ( dst & 0xff00ff00) >> 8;
  uint32_t di_rb = dst & 0x00ff00ff;
  return
     ((((si_rb_full) + (di_rb * rcov)) & 0xff00ff00) >> 8)  |
      (((si_ga_full) + (di_ga * rcov)) & 0xff00ff00);
}

static inline void
ctx_init_uv (CtxRasterizer *rasterizer,
             int x0,
             int y0,
             float *u0, float *v0, float *w0, float *ud, float *vd, float *wd)
             //float *u0, float *v0, float *w0, float *ud, float *vd, float *wd)
{
  CtxMatrix *transform = &rasterizer->state->gstate.source_fill.transform;
  *u0 = transform->m[0][0] * (x0 + 0.0f) +
        transform->m[0][1] * (y0 + 0.0f) +
        transform->m[0][2];
  *v0 = transform->m[1][0] * (x0 + 0.0f) +
        transform->m[1][1] * (y0 + 0.0f) +
        transform->m[1][2];
  *w0 = transform->m[2][0] * (x0 + 0.0f) +
        transform->m[2][1] * (y0 + 0.0f) +
        transform->m[2][2];
  *ud = transform->m[0][0];
  *vd = transform->m[1][0];
  *wd = transform->m[2][0];
}


void
CTX_SIMD_SUFFIX (ctx_composite_fill_rect) (CtxRasterizer *rasterizer,
                          float          x0,
                          float          y0,
                          float          x1,
                          float          y1,
                          uint8_t        cov);
void
CTX_SIMD_SUFFIX(ctx_composite_stroke_rect) (CtxRasterizer *rasterizer,
                           float          x0,
                           float          y0,
                           float          x1,
                           float          y1,
                           float          line_width);

static inline uint16_t
ctx_565_pack (uint8_t  red,
              uint8_t  green,
              uint8_t  blue,
              const int      byteswap)
{
#if 0
  // is this extra precision warranted?
  // for 332 it gives more pure white..
  // it might be the case also for generic 565
  red = ctx_sadd8 (red, 4);
  green = ctx_sadd8 (green, 3);
  blue = ctx_sadd8 (blue, 4);
#endif

  uint32_t c = (red >> 3) << 11;
  c |= (green >> 2) << 5;
  c |= blue >> 3;
  if (byteswap)
    { return (c>>8) | (c<<8); } /* swap bytes */
  return c;
}
static inline uint32_t
ctx_565_unpack_32 (const uint16_t pixel,
                   const int byteswap)
{
  uint16_t byteswapped;
  if (byteswap)
    { byteswapped = (pixel>>8) | (pixel<<8); }
  else
    { byteswapped  = pixel; }
  uint32_t b   = (byteswapped & 31) <<3;
  uint32_t g = ( (byteswapped>>5) & 63) <<2;
  uint32_t r   = ( (byteswapped>>11) & 31) <<3;
#if 0
  b = (b > 248) * 255 + (b <= 248) * b;
  g = (g > 248) * 255 + (g <= 248) * g;
  r = (r > 248) * 255 + (r <= 248) * r;
#endif

  return r +  (g << 8) + (b << 16) + (((unsigned)0xff) << 24);
}



void
CTX_SIMD_SUFFIX (ctx_composite_setup) (CtxRasterizer *rasterizer);
void
CTX_SIMD_SUFFIX (ctx_rasterizer_rasterize_edges) (CtxRasterizer *rasterizer, const int fill_rule);

void
CTX_SIMD_SUFFIX(ctx_RGBA8_source_over_normal_full_cov_fragment) (CTX_COMPOSITE_ARGUMENTS, int scanlines);

extern const CtxPixelFormatInfo CTX_SIMD_SUFFIX(ctx_pixel_formats)[];
void
ctx_rasterizer_define_texture (CtxRasterizer *rasterizer,
                               const char    *eid,
                               int            width,
                               int            height,
                               int            format,
                               char unsigned *data,
                               int            steal_data);
void ctx_cb_destroy (void *data);
void ctx_hasher_process (Ctx *ctx, const CtxCommand *command);

static void
ctx_matrix_set (CtxMatrix *matrix, float a, float b, float c, float d, float e, float f, float g, float h, float i)
{
  matrix->m[0][0] = a;
  matrix->m[0][1] = b;
  matrix->m[0][2] = c;
  matrix->m[1][0] = d;
  matrix->m[1][1] = e;
  matrix->m[1][2] = f;
  matrix->m[2][0] = g;
  matrix->m[2][1] = h;
  matrix->m[2][2] = i;
}

void
_ctx_text (Ctx        *ctx,
           const char *string,
           int         stroke,
           int         visible);

int
_ctx_glyph (Ctx *ctx, int glyph_id, int stroke);

#if CTX_ENABLE_RGB565

static inline void
ctx_RGBA8_to_RGB565_BS (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint16_t *pixel = (uint16_t *) buf;
  while (count--)
    {
#if CTX_RGB565_ALPHA
      if (rgba[3]==0)
        { pixel[0] = ctx_565_pack (255, 0, 255, 1); }
      else
#endif
        { pixel[0] = ctx_565_pack (rgba[0], rgba[1], rgba[2], 1); }
      pixel+=1;
      rgba +=4;
    }
}

static inline void
ctx_RGB565_BS_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint16_t *pixel = (uint16_t *) buf;
  while (count--)
    {
      ((uint32_t*)(rgba))[0] = ctx_565_unpack_32 (*pixel, 1);
#if CTX_RGB565_ALPHA
      if ((rgba[0]==255) & (rgba[2] == 255) & (rgba[1]==0))
        { rgba[3] = 0; }
      else
        { rgba[3] = 255; }
#endif
      pixel+=1;
      rgba +=4;
    }
}

#endif

#define ctx_evsource_has_event(es)   (es)->has_event((es))
#define ctx_evsource_get_event(es)   (es)->get_event((es))
#define ctx_evsource_destroy(es)     do{if((es)->destroy)(es)->destroy((es));}while(0)
#define ctx_evsource_set_coord(es,x,y) do{if((es)->set_coord)(es)->set_coord((es),(x),(y));}while(0)
#define ctx_evsource_get_fd(es)      ((es)->get_fd?(es)->get_fd((es)):0)

#if CTX_EVENTS
extern int _ctx_mice_fd;
#endif

void ctx_drain_fd (int infd);
void ctx_rasterizer_clip (CtxRasterizer *rasterizer);
typedef struct _VtLine   VtLine;
#if CTX_EVENTS
int ctx_clients_handle_events (Ctx *ctx);
void ctx_consume_events (Ctx *ctx);
void _ctx_bindings_key_press (CtxEvent *event, void *data1, void *data2);
Ctx *ctx_new_ui (int width, int height, const char *backend);
EvSource *ctx_evsource_mice_new (void);
EvSource *ctx_evsource_kb_term_new (void);
EvSource *ctx_evsource_kb_raw_new (void);
EvSource *ctx_evsource_linux_ts_new (void);
void ctx_nct_consume_events (Ctx *ctx);

typedef struct _CtxTermGlyph CtxTermGlyph;

struct _CtxTermGlyph
{
  uint32_t unichar;
  int      col;
  int      row;
  uint8_t  rgba_bg[4];
  uint8_t  rgba_fg[4];
};

#include <sys/select.h>
#endif

void ctx_update_current_path (Ctx *ctx, const CtxEntry *entry);
void ctx_rasterizer_process (Ctx *ctx, const CtxCommand *command);
#define CTX_RGBA8_R_SHIFT  0
#define CTX_RGBA8_G_SHIFT  8
#define CTX_RGBA8_B_SHIFT  16
#define CTX_RGBA8_A_SHIFT  24

#define CTX_RGBA8_R_MASK   (0xff << CTX_RGBA8_R_SHIFT)
#define CTX_RGBA8_G_MASK   (0xff << CTX_RGBA8_G_SHIFT)
#define CTX_RGBA8_B_MASK   (0xff << CTX_RGBA8_B_SHIFT)
#define CTX_RGBA8_A_MASK   (0xff << CTX_RGBA8_A_SHIFT)

#define CTX_RGBA8_RB_MASK  (CTX_RGBA8_R_MASK | CTX_RGBA8_B_MASK)
#define CTX_RGBA8_GA_MASK  (CTX_RGBA8_G_MASK | CTX_RGBA8_A_MASK)

static inline void
ctx_RGBA8_associate_alpha (uint8_t *u8)
{
#if 1
  uint32_t val = *((uint32_t*)(u8));
  uint32_t a = u8[3];
  uint32_t g = (((val & CTX_RGBA8_G_MASK) * a) >> 8) & CTX_RGBA8_G_MASK;
  uint32_t rb =(((val & CTX_RGBA8_RB_MASK) * a) >> 8) & CTX_RGBA8_RB_MASK;
  uint32_t res = g|rb|(a << CTX_RGBA8_A_SHIFT);
  memcpy(u8, &res, 4);
#else
  uint32_t a = u8[3];
  u8[0] = (u8[0] * a + 255) >> 8;
  u8[1] = (u8[1] * a + 255) >> 8;
  u8[2] = (u8[2] * a + 255) >> 8;
#endif
}

typedef struct _CtxTerm CtxTerm;
void ctx_term_destroy (CtxTerm *term);
typedef struct _CtxNet CtxNet;
void ctx_net_destroy (CtxNet *net);
extern CtxList *registered_contents;
void ctx_parser_feed_byte (CtxParser *parser, char byte);
inline static void
ctx_332_unpack (uint8_t pixel,
                uint8_t *red,
                uint8_t *green,
                uint8_t *blue)
{
  *green = (((pixel >> 2) & 7)*255)/7;
  *red   = (((pixel >> 5) & 7)*255)/7;
  *blue  = ((((pixel & 3) << 1) | ((pixel >> 2) & 1))*255)/7;
}
CtxRasterizer *
ctx_hasher_init (CtxRasterizer *rasterizer, Ctx *ctx, CtxState *state, int width, int height, int cols, int rows, CtxDrawlist *drawlist);

CtxFont *ctx_font_get_available (void);
int ctx_glyph_unichar (Ctx *ctx, uint32_t unichar, int stroke);

int
ctx_text_substitute_ligatures (Ctx *ctx, CtxFont *font,
                                uint32_t *unichar, uint32_t next_unichar, uint32_t next_next_unichar);
CtxGlyph *_ctx_glyph_target (Ctx *ctx, int len);
void ctx_reset_caches (Ctx *ctx);

typedef enum {
  CTX_FONT_TYPE_CTX  = 0,
  CTX_FONT_TYPE_NONE = 1,
  CTX_FONT_TYPE_FS   = 3,
  CTX_FONT_TYPE_HB   = 4
} CtxFontType;
void ctx_cmyk_to_rgb (float c, float m, float y, float k, float *r, float *g, float *b);

#ifndef CTX_DRAWLIST_H
#define CTX_DRAWLIST_H

static inline int
ctx_conts_for_entry (const CtxEntry *entry)
{
    switch (entry->code)
    {
      case CTX_DATA:
        return entry->data.u32[1];
      case CTX_RADIAL_GRADIENT:
      case CTX_ARC:
      case CTX_CURVE_TO:
      case CTX_REL_CURVE_TO:
      case CTX_COLOR:
      case CTX_ROUND_RECTANGLE:
      case CTX_SHADOW_COLOR:
        return 2;
      case CTX_ARC_TO:
      case CTX_REL_ARC_TO:
        return 3;
      case CTX_APPLY_TRANSFORM:
      case CTX_SOURCE_TRANSFORM:
        return 4;
      case CTX_FILL_RECT:
      case CTX_STROKE_RECT:
      case CTX_RECTANGLE:
      case CTX_VIEW_BOX:
      case CTX_REL_QUAD_TO:
      case CTX_QUAD_TO:
      case CTX_LINEAR_GRADIENT:
      case CTX_CONIC_GRADIENT:
        return 1;

      case CTX_TEXT:
      case CTX_LINE_DASH:
      case CTX_COLOR_SPACE:
      case CTX_FONT:
      case CTX_TEXTURE:
        {
          int eid_len = entry[1].data.u32[1];
          return eid_len + 1;
        }
      case CTX_DEFINE_TEXTURE:
        {
          int eid_len = entry[2].data.u32[1];
          int pix_len = entry[2 + eid_len + 1].data.u32[1];
          return eid_len + pix_len + 2 + 1;
        }
      default:
        return 0;
    }
}

void
ctx_iterator_init (CtxIterator      *iterator,
                   CtxDrawlist  *drawlist,
                   int               start_pos,
                   int               flags);

int ctx_iterator_pos (CtxIterator *iterator);

void
ctx_drawlist_resize (CtxDrawlist *drawlist, int desired_size);
int
ctx_drawlist_add_single (CtxDrawlist *drawlist, const CtxEntry *entry);
int ctx_drawlist_add_entry (CtxDrawlist *drawlist, const CtxEntry *entry);
int
ctx_drawlist_insert_entry (CtxDrawlist *drawlist, int pos, CtxEntry *entry);
int
ctx_add_data (Ctx *ctx, void *data, int length);

int ctx_drawlist_add_u32 (CtxDrawlist *drawlist, CtxCode code, uint32_t u32[2]);
int ctx_drawlist_add_data (CtxDrawlist *drawlist, const void *data, int length);

static CtxEntry
ctx_void (CtxCode code);
static inline CtxEntry
ctx_f (CtxCode code, float x, float y)
{
  CtxEntry command;
  command.code = code;
  command.data.f[0] = x;
  command.data.f[1] = y;
  return command;
}

static inline CtxEntry
ctx_void (CtxCode code)
{
  CtxEntry command;
  command.code = code;
  return command;
}

static CtxEntry
ctx_u32 (CtxCode code, uint32_t x, uint32_t y);
#if 0
static CtxEntry
ctx_s32 (CtxCode code, int32_t x, int32_t y);
#endif

static inline CtxEntry
ctx_s16 (CtxCode code, int x0, int y0, int x1, int y1);
static CtxEntry
ctx_u8 (CtxCode code,
        uint8_t a, uint8_t b, uint8_t c, uint8_t d,
        uint8_t e, uint8_t f, uint8_t g, uint8_t h);

#define CTX_PROCESS_VOID(cmd) do {\
  CtxEntry commands[1] = {{cmd,{{0}}}};\
  ctx_process (ctx, &commands[0]);}while(0) \

#define CTX_PROCESS_F(cmd,x,y) do {\
  CtxEntry commands[1] = {ctx_f(cmd,x,y),};\
  ctx_process (ctx, &commands[0]);}while(0) \

#define CTX_PROCESS_F1(cmd,x) do {\
  CtxEntry commands[1] = {ctx_f(cmd,x,0),};\
  ctx_process (ctx, &commands[0]);}while(0) \

#define CTX_PROCESS_U32(cmd, x, y) do {\
  CtxEntry commands[1] = {ctx_u32(cmd, x, y)};\
  ctx_process (ctx, &commands[0]);}while(0)

#define CTX_PROCESS_U8(cmd, x) do {\
  CtxEntry commands[4] = {ctx_u8(cmd, x,0,0,0,0,0,0,0)};\
  ctx_process (ctx, &commands[0]);}while(0)


#if CTX_BITPACK_PACKER
static unsigned int
ctx_last_history (CtxDrawlist *drawlist);
#endif

#if CTX_BITPACK_PACKER
static void
ctx_drawlist_remove_tiny_curves (CtxDrawlist *drawlist, int start_pos);

static void
ctx_drawlist_bitpack (CtxDrawlist *drawlist, unsigned int start_pos);
#endif

void
ctx_process_cmd_str (Ctx *ctx, CtxCode code, const char *string, uint32_t arg0, uint32_t arg1);
static void
ctx_process_cmd_str_float (Ctx *ctx, CtxCode code, const char *string, float arg0, float arg1);
static void
ctx_process_cmd_str_with_len (Ctx *ctx, CtxCode code, const char *string, uint32_t arg0, uint32_t arg1, int len);

#pragma pack(push,1)
typedef union 
CtxSegment {
#if CTX_32BIT_SEGMENTS
   struct {
     int16_t code;
     int16_t aa;
     int32_t x0;
     int32_t y0;
     int32_t y1;
     int32_t x1;
     int32_t val;
     int32_t delta;
   };
   struct {
     int16_t code__;
     int16_t aa__;
     int32_t y0_;
     int32_t y1_;
   };
#else
   struct {
     int8_t code;
     int8_t aa;
     int32_t x0;
     int16_t y0;
     int16_t y1;
     int32_t x1;
   };
   struct {
     int8_t code_;
     int8_t aa_;
     int32_t val;
     int16_t y0_;
     int16_t y1_;
     int32_t delta;
   };
#endif
   uint32_t u32[2];
  } CtxSegment;
#pragma pack(pop)

static inline CtxSegment
ctx_segment_s16 (CtxRasterizerCode code, int x0, int y0, int x1, int y1)
{
  CtxSegment segment;
  segment.x0 = x0;
  segment.y0 = y0;
  segment.x1 = x1;
  segment.y1 = y1;
  segment.code = code;
  return segment;
}

static inline void
ctx_edgelist_resize (CtxDrawlist *drawlist, int desired_size)
{
#if CTX_DRAWLIST_STATIC
    {
      static CtxSegment sbuf[CTX_MAX_EDGE_LIST_SIZE];
      drawlist->entries = (CtxEntry*)&sbuf[0];
      drawlist->size = CTX_MAX_EDGE_LIST_SIZE;
      drawlist->flags = CTX_DRAWLIST_DOESNT_OWN_ENTRIES;
    }
#else
  int new_size = desired_size;
  int min_size = CTX_MIN_JOURNAL_SIZE;
  int max_size = CTX_MAX_JOURNAL_SIZE;
    {
      min_size = CTX_MIN_EDGE_LIST_SIZE;
      max_size = CTX_MAX_EDGE_LIST_SIZE;
    }

  if (CTX_UNLIKELY(drawlist->size == max_size))
    { return; }
  new_size = ctx_maxi (new_size, min_size);
  //if (new_size < drawlist->count)
  //  { new_size = drawlist->count + 4; }
  new_size = ctx_mini (new_size, max_size);
  if (new_size != drawlist->size)
    {
      int item_size = sizeof (CtxSegment);
      //fprintf (stderr, "growing drawlist %p %i to %d from %d\n", drawlist, flags, new_size, drawlist->size);
  if (drawlist->entries)
    {
      //printf ("grow %p to %d from %d\n", drawlist, new_size, drawlist->size);
      CtxEntry *ne =  (CtxEntry *) ctx_malloc (item_size * new_size);
      memcpy (ne, drawlist->entries, drawlist->size * item_size );
      ctx_free (drawlist->entries);
      drawlist->entries = ne;
      //drawlist->entries = (CtxEntry*)ctx_malloc (drawlist->entries, item_size * new_size);
    }
  else
    {
      //fprintf (stderr, "allocating for %p %d\n", drawlist, new_size);
      drawlist->entries = (CtxEntry *) ctx_malloc (item_size * new_size);
    }
  drawlist->size = new_size;
    }
  //fprintf (stderr, "drawlist %p is %d\n", drawlist, drawlist->size);
#endif
}

static CTX_INLINE int
ctx_edgelist_add_single (CtxDrawlist *drawlist, CtxEntry *entry)
{
  int ret = drawlist->count;

  if (CTX_UNLIKELY(ret + 2 >= drawlist->size))
    {
      if (CTX_UNLIKELY(ret+2 >= CTX_MAX_EDGE_LIST_SIZE- 20))
        return 0;
      int new_ = ctx_maxi (drawlist->size * 2, ret + 1024);
      new_ = ctx_mini (CTX_MAX_EDGE_LIST_SIZE, new_);
      ctx_edgelist_resize (drawlist, new_);
    }

  ((CtxSegment*)(drawlist->entries))[ret] = *(CtxSegment*)entry;
  drawlist->count++;
  return ret;
}

// special return values - controlling argument behavior for some codes
#define CTX_ARG_COLLECT_NUMBERS             50
#define CTX_ARG_STRING_OR_NUMBER            100
#define CTX_ARG_NUMBER_OF_COMPONENTS        200
#define CTX_ARG_NUMBER_OF_COMPONENTS_PLUS_1 201

static inline int ctx_arguments_for_code (CtxCode code)
{
  switch (code)
    {
      case CTX_SAVE:
      case CTX_START_GROUP:
      case CTX_END_GROUP:
      case CTX_IDENTITY:
      case CTX_CLOSE_PATH:
      case CTX_RESET_PATH:
      case CTX_START_FRAME:
      case CTX_END_FRAME:
      case CTX_RESTORE:
      case CTX_STROKE:
      case CTX_FILL:
      case CTX_PAINT:
      case CTX_DEFINE_FONT:
      case CTX_NEW_PAGE:
      case CTX_CLIP:
        return 0;
      case CTX_GLOBAL_ALPHA:
      case CTX_COMPOSITING_MODE:
      case CTX_BLEND_MODE:
      case CTX_EXTEND:
      case CTX_FONT_SIZE:
      case CTX_LINE_JOIN:
      case CTX_LINE_CAP:
      case CTX_LINE_WIDTH:
      case CTX_LINE_DASH_OFFSET:
      case CTX_STROKE_POS:
      case CTX_FEATHER:
      case CTX_LINE_HEIGHT:
      case CTX_WRAP_LEFT:
      case CTX_WRAP_RIGHT:
      case CTX_IMAGE_SMOOTHING:
      case CTX_SHADOW_BLUR:
      case CTX_SHADOW_OFFSET_X:
      case CTX_SHADOW_OFFSET_Y:
      case CTX_FILL_RULE:
      case CTX_TEXT_ALIGN:
      case CTX_TEXT_BASELINE:
      case CTX_TEXT_DIRECTION:
      case CTX_MITER_LIMIT:
      case CTX_REL_VER_LINE_TO:
      case CTX_REL_HOR_LINE_TO:
      case CTX_HOR_LINE_TO:
      case CTX_VER_LINE_TO:
      case CTX_ROTATE:
      case CTX_GLYPH:
        return 1;
      case CTX_TRANSLATE:
      case CTX_REL_SMOOTHQ_TO:
      case CTX_LINE_TO:
      case CTX_MOVE_TO:
      case CTX_SCALE:
      case CTX_REL_LINE_TO:
      case CTX_REL_MOVE_TO:
      case CTX_SMOOTHQ_TO:
        return 2;
      case CTX_CONIC_GRADIENT:
      case CTX_LINEAR_GRADIENT:
      case CTX_REL_QUAD_TO:
      case CTX_QUAD_TO:
      case CTX_RECTANGLE:
      case CTX_FILL_RECT:
      case CTX_STROKE_RECT:
      case CTX_REL_SMOOTH_TO:
      case CTX_VIEW_BOX:
      case CTX_SMOOTH_TO:
        return 4;
      case CTX_ROUND_RECTANGLE:
        return 5;
      case CTX_ARC:
      case CTX_CURVE_TO:
      case CTX_REL_CURVE_TO:
      case CTX_RADIAL_GRADIENT:
        return 6;
      case CTX_ARC_TO:
      case CTX_REL_ARC_TO:
        return 7;
      case CTX_APPLY_TRANSFORM:
      case CTX_SOURCE_TRANSFORM:
        return 9;
      case CTX_TEXT:
      case CTX_FONT:
      case CTX_COLOR_SPACE:
      case CTX_DEFINE_GLYPH:
      case CTX_KERNING_PAIR:
      case CTX_TEXTURE:
      case CTX_DEFINE_TEXTURE:
        return CTX_ARG_STRING_OR_NUMBER;
      case CTX_LINE_DASH: /* append to current dashes for each argument encountered */
        return CTX_ARG_COLLECT_NUMBERS;
      //case CTX_SET_KEY:
      case CTX_COLOR:
      case CTX_SHADOW_COLOR:
        return CTX_ARG_NUMBER_OF_COMPONENTS;
      case CTX_GRADIENT_STOP:
        return CTX_ARG_NUMBER_OF_COMPONENTS_PLUS_1;

        default:
#if 1
        case CTX_SET_RGBA_U8:
        case CTX_NOP:
        case CTX_CONT:
        case CTX_DATA:
        case CTX_DATA_REV:
        case CTX_SET_PIXEL:
        case CTX_REL_LINE_TO_X4:
        case CTX_REL_LINE_TO_REL_CURVE_TO:
        case CTX_REL_CURVE_TO_REL_LINE_TO:
        case CTX_REL_CURVE_TO_REL_MOVE_TO:
        case CTX_REL_LINE_TO_X2:
        case CTX_MOVE_TO_REL_LINE_TO:
        case CTX_REL_LINE_TO_REL_MOVE_TO:
        case CTX_FILL_MOVE_TO:
        case CTX_REL_QUAD_TO_REL_QUAD_TO:
        case CTX_REL_QUAD_TO_S16:
        case CTX_STROKE_SOURCE:
#endif
        return 0;
    }
}

static CtxEntry
ctx_u32 (CtxCode code, uint32_t x, uint32_t y)
{
  CtxEntry command = ctx_void (code);
  command.data.u32[0] = x;
  command.data.u32[1] = y;
  return command;
}

static CtxEntry
ctx_u8 (CtxCode code,
        uint8_t a, uint8_t b, uint8_t c, uint8_t d,
        uint8_t e, uint8_t f, uint8_t g, uint8_t h)
{
  CtxEntry command;
  command.code = code;
  command.data.u8[0] = a;
  command.data.u8[1] = b;
  command.data.u8[2] = c;
  command.data.u8[3] = d;
  command.data.u8[4] = e;
  command.data.u8[5] = f;
  command.data.u8[6] = g;
  command.data.u8[7] = h;
  return command;
}

static void
ctx_process_cmd_str_with_len (Ctx *ctx, CtxCode code, const char *string, uint32_t arg0, uint32_t arg1, int len)
{
  CtxEntry commands[1 + 2 + (len+1+1)/9];
  memset (commands, 0, sizeof (commands) );
  commands[0] = ctx_u32 (code, arg0, arg1);
  commands[1].code = CTX_DATA;
  commands[1].data.u32[0] = len;
  commands[1].data.u32[1] = (len+1+1)/9 + 1;
  memcpy( (char *) &commands[2].data.u8[0], string, len);
  ( (char *) (&commands[2].data.u8[0]) ) [len]=0;
  ctx_process (ctx, commands);
}

static void
ctx_process_cmd_str_float (Ctx *ctx, CtxCode code, const char *string, float arg0, float arg1)
{
  uint32_t iarg0;
  uint32_t iarg1;
  memcpy (&iarg0, &arg0, sizeof (iarg0));
  memcpy (&iarg1, &arg1, sizeof (iarg1));
  ctx_process_cmd_str_with_len (ctx, code, string, iarg0, iarg1, ctx_strlen (string));
}

void
ctx_drawlist_compact (CtxDrawlist *drawlist);

#endif


#ifndef __clang__
#if CTX_COMPOSITE_O3
#pragma GCC push_options
#pragma GCC optimize("O3")
#endif
#if CTX_COMPOSITE_O2
#pragma GCC push_options
#pragma GCC optimize("O2")
#endif
#endif

#if CTX_COMPOSITE

#define CTX_REFERENCE 0




inline static void
ctx_RGBA8_associate_global_alpha (uint8_t *u8, uint8_t global_alpha)
{
  uint32_t val = *((uint32_t*)(u8));
  uint32_t a = (u8[3] * global_alpha + 255) >> 8;
  uint32_t g = (((val & CTX_RGBA8_G_MASK) * a) >> 8) & CTX_RGBA8_G_MASK;
  uint32_t rb =(((val & CTX_RGBA8_RB_MASK) * a) >> 8) & CTX_RGBA8_RB_MASK;
  *((uint32_t*)(u8)) = g|rb|(a << CTX_RGBA8_A_SHIFT);
}

inline static uint32_t
ctx_RGBA8_associate_global_alpha_u32 (uint32_t val, uint8_t global_alpha)
{
  uint32_t a = ((val>>24) * global_alpha + 255) >> 8;
  uint32_t g = (((val & CTX_RGBA8_G_MASK) * a) >> 8) & CTX_RGBA8_G_MASK;
  uint32_t rb =(((val & CTX_RGBA8_RB_MASK) * a) >> 8) & CTX_RGBA8_RB_MASK;
  return  g|rb|(a << CTX_RGBA8_A_SHIFT);
}

// mixes global alpha in with existing global alpha
inline static uint32_t
ctx_RGBA8_mul_alpha_u32(uint32_t val, uint8_t global_alpha)
{
  uint32_t a = ((val>>24) * global_alpha + 255) >> 8;
  uint32_t g = (((val & CTX_RGBA8_G_MASK) * global_alpha) >> 8) & CTX_RGBA8_G_MASK;
  uint32_t rb =(((val & CTX_RGBA8_RB_MASK) * global_alpha) >> 8) & CTX_RGBA8_RB_MASK;
  return  g|rb|(a << CTX_RGBA8_A_SHIFT);
}

CTX_INLINE static uint32_t ctx_bi_RGBA8_alpha (uint32_t isrc00, uint32_t isrc01, uint32_t isrc10, uint32_t isrc11, uint8_t dx, uint8_t dy)
{
  if (((isrc00 | isrc01 | isrc10 | isrc11) & CTX_RGBA8_A_MASK) == 0)
    return 0;
  uint32_t s0_ga, s0_rb, s1_ga, s1_rb;
  ctx_lerp_RGBA8_split (isrc00, isrc01, dx, &s0_ga, &s0_rb);
  ctx_lerp_RGBA8_split (isrc10, isrc11, dx, &s1_ga, &s1_rb);
  return ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, dy);
}

#if CTX_GRADIENTS
#if CTX_GRADIENT_CACHE

inline static int ctx_grad_index (CtxRasterizer *rasterizer, float v)
{
  int ret = (int)(v * (rasterizer->gradient_cache_elements - 1) + 0.5f);
  ret *= (ret>0);
  ret = ctx_mini (rasterizer->gradient_cache_elements-1, ret);
  return ret;
}

CTX_INLINE static int ctx_grad_index_i (CtxRasterizer *rasterizer, int v)
{
  v = v >> 8;
  v *= (v>0);
  return ctx_mini (rasterizer->gradient_cache_elements-1, v);
}

//static void
//ctx_gradient_cache_reset (void)
//{
//  ctx_gradient_cache_valid = 0;
//}
#endif


CTX_INLINE static void
_ctx_fragment_gradient_1d_RGBA8 (CtxRasterizer *rasterizer, float x, float y, uint8_t *rgba)
{
  float v = x;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  CtxState *state = rasterizer->state;
  CtxGradient *g = &state->gradient;
  v *= (v>0);
  if (v > 1) { v = 1; }

  if (g->n_stops == 0)
    {
      rgba[0] = rgba[1] = rgba[2] = (int)(v * 255);
      rgba[3] = 255;
      return;
    }
  CtxGradientStop *stop      = NULL;
  CtxGradientStop *next_stop = &g->stops[0];
  CtxColor *color;
  for (int s = 0; s < g->n_stops; s++)
    {
      stop      = &g->stops[s];
      next_stop = &g->stops[s+1];
      if (s + 1 >= g->n_stops) { next_stop = NULL; }
      if (v >= stop->pos && next_stop && v < next_stop->pos)
        { break; }
      stop = NULL;
      next_stop = NULL;
    }
  if (stop == NULL && next_stop)
    {
      color = & (next_stop->color);
    }
  else if (stop && next_stop == NULL)
    {
      color = & (stop->color);
    }
  else if (stop && next_stop)
    {
      uint8_t stop_rgba[4];
      uint8_t next_rgba[4];
      ctx_color_get_rgba8 (state, & (stop->color), stop_rgba);
      ctx_color_get_rgba8 (state, & (next_stop->color), next_rgba);
      int dx = (int)((v - stop->pos) * 255 / (next_stop->pos - stop->pos));
      ((uint32_t*)rgba)[0] = ctx_lerp_RGBA8 (((uint32_t*)stop_rgba)[0],
                                             ((uint32_t*)next_rgba)[0], dx);
      rgba[3]=(rgba[3]*global_alpha_u8+255)>>8;
      if (rasterizer->swap_red_green)
      {
         uint8_t tmp = rgba[0];
         rgba[0] = rgba[2];
         rgba[2] = tmp;
      }
      ctx_RGBA8_associate_alpha (rgba);
      return;
    }
  else
    {
      color = & (g->stops[g->n_stops-1].color);
    }
  ctx_color_get_rgba8 (state, color, rgba);
  if (rasterizer->swap_red_green)
  {
    uint8_t tmp = rgba[0];
    rgba[0] = rgba[2];
    rgba[2] = tmp;
  }
  rgba[3]=(rgba[3]*global_alpha_u8+255)>>8;
  ctx_RGBA8_associate_alpha (rgba);
}

#if CTX_GRADIENT_CACHE
static void
ctx_gradient_cache_prime (CtxRasterizer *rasterizer);
#endif

CTX_INLINE static void
ctx_fragment_gradient_1d_RGBA8 (CtxRasterizer *rasterizer, float x, float y, uint8_t *rgba)
{
#if CTX_GRADIENT_CACHE
  *((uint32_t*)rgba) = *((uint32_t*)(&rasterizer->gradient_cache_u8[ctx_grad_index(rasterizer, x)][0]));
#else
 _ctx_fragment_gradient_1d_RGBA8 (rasterizer, x, y, rgba);
#endif
}
#endif

CTX_INLINE static void
ctx_u8_associate_alpha (int components, uint8_t *u8)
{
  for (int c = 0; c < components-1; c++)
    u8[c] = (u8[c] * u8[components-1] + 255)>>8;
}

#if CTX_GRADIENTS
#if CTX_GRADIENT_CACHE
static void
ctx_gradient_cache_prime (CtxRasterizer *rasterizer)
{
  // XXX : todo  make the number of element dynamic depending on length of gradient
  // in device coordinates.

  if (rasterizer->gradient_cache_valid)
    return;
  

  {
    CtxSource *source = &rasterizer->state->gstate.source_fill;
    float length = 100;
    if (source->type == CTX_SOURCE_LINEAR_GRADIENT)
       length = source->linear_gradient.length;
    else if (source->type == CTX_SOURCE_RADIAL_GRADIENT)
       length = ctx_maxf (source->radial_gradient.r1, source->radial_gradient.r0);
    else if (source->type == CTX_SOURCE_CONIC_GRADIENT)
      length = CTX_GRADIENT_CACHE_ELEMENTS;
  {
     float u = length; float v = length;
     const CtxMatrix *m = &rasterizer->state->gstate.transform;
     //CtxMatrix *transform = &source->transform;
     //
     //  combine with above source transform?
     _ctx_matrix_apply_transform (m, &u, &v);
     length = ctx_maxf (u, v);
  }
    if (length < 4) length = 4;
  
    rasterizer->gradient_cache_elements = ctx_mini ((int)length, CTX_GRADIENT_CACHE_ELEMENTS);
  }

  for (int u = 0; u < rasterizer->gradient_cache_elements; u++)
  {
    float v = u / (rasterizer->gradient_cache_elements - 1.0f);
    _ctx_fragment_gradient_1d_RGBA8 (rasterizer, v, 0.0f, &rasterizer->gradient_cache_u8[u][0]);
    //*((uint32_t*)(&rasterizer->gradient_cache_u8_a[u][0]))= *((uint32_t*)(&rasterizer->gradient_cache_u8[u][0]));
    //memcpy(&rasterizer->gradient_cache_u8_a[u][0], &rasterizer->gradient_cache_u8[u][0], 4);
    //ctx_RGBA8_associate_alpha (&rasterizer->gradient_cache_u8_a[u][0]);
  }
  rasterizer->gradient_cache_valid = 1;
}
#endif

CTX_INLINE static void
ctx_fragment_gradient_1d_GRAYA8 (CtxRasterizer *rasterizer, float x, float y, uint8_t *rgba)
{
  float v = x;
  CtxState *state = rasterizer->state;
  CtxGradient *g = &state->gradient;
  if (v < 0) { v = 0; }
  if (v > 1) { v = 1; }
  if (g->n_stops == 0)
    {
      rgba[0] = rgba[1] = rgba[2] = (int)(v * 255);
      rgba[1] = 255;
      return;
    }
  CtxGradientStop *stop      = NULL;
  CtxGradientStop *next_stop = &g->stops[0];
  CtxColor *color;
  for (int s = 0; s < g->n_stops; s++)
    {
      stop      = &g->stops[s];
      next_stop = &g->stops[s+1];
      if (s + 1 >= g->n_stops) { next_stop = NULL; }
      if (v >= stop->pos && next_stop && v < next_stop->pos)
        { break; }
      stop = NULL;
      next_stop = NULL;
    }
  if (stop == NULL && next_stop)
    {
      color = & (next_stop->color);
    }
  else if (stop && next_stop == NULL)
    {
      color = & (stop->color);
    }
  else if (stop && next_stop)
    {
      uint8_t stop_rgba[4];
      uint8_t next_rgba[4];
      ctx_color_get_graya_u8 (state, & (stop->color), stop_rgba);
      ctx_color_get_graya_u8 (state, & (next_stop->color), next_rgba);
      int dx = (int)((v - stop->pos) * 255 / (next_stop->pos - stop->pos));
      for (int c = 0; c < 2; c++)
        { rgba[c] = ctx_lerp_u8 (stop_rgba[c], next_rgba[c], dx); }
      return;
    }
  else
    {
      color = & (g->stops[g->n_stops-1].color);
    }
  ctx_color_get_graya_u8 (state, color, rgba);
}

CTX_INLINE static void
ctx_fragment_gradient_1d_RGBAF (CtxRasterizer *rasterizer, float v, float y, float *rgba)
{
  float global_alpha = rasterizer->state->gstate.global_alpha_f;
  CtxState *state = rasterizer->state;
  CtxGradient *g = &state->gradient;
  v *= (v>0);
  if (v > 1) { v = 1; }
  if (g->n_stops == 0)
    {
      rgba[0] = rgba[1] = rgba[2] = v;
      rgba[3] = 1.0;
      return;
    }
  CtxGradientStop *stop      = NULL;
  CtxGradientStop *next_stop = &g->stops[0];
  CtxColor *color;
  for (int s = 0; s < g->n_stops; s++)
    {
      stop      = &g->stops[s];
      next_stop = &g->stops[s+1];
      if (s + 1 >= g->n_stops) { next_stop = NULL; }
      if (v >= stop->pos && next_stop && v < next_stop->pos)
        { break; }
      stop = NULL;
      next_stop = NULL;
    }
  if (stop == NULL && next_stop)
    {
      color = & (next_stop->color);
    }
  else if (stop && next_stop == NULL)
    {
      color = & (stop->color);
    }
  else if (stop && next_stop)
    {
      float stop_rgba[4];
      float next_rgba[4];
      ctx_color_get_rgba (state, & (stop->color), stop_rgba);
      ctx_color_get_rgba (state, & (next_stop->color), next_rgba);
      float dx = (v - stop->pos) / (next_stop->pos - stop->pos);
      for (int c = 0; c < 4; c++)
        { rgba[c] = ctx_lerpf (stop_rgba[c], next_rgba[c], dx); }
      rgba[3] *= global_alpha;
      for (int c = 0; c < 3; c++)
        rgba[c] *= rgba[3];

      return;
    }
  else
    {
      color = & (g->stops[g->n_stops-1].color);
    }
  ctx_color_get_rgba (state, color, rgba);
  rgba[3] *= global_alpha;
  for (int c = 0; c < 3; c++)
    rgba[c] *= rgba[3];
}
#endif

static void
ctx_fragment_image_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dw)
{
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  uint8_t is_assoc = (buffer->format->pixel_format == CTX_FORMAT_RGBA8 ||
                      buffer->format->pixel_format == CTX_FORMAT_BGRA8);

  int width = buffer->width;
  int height = buffer->height;
  int image_smoothing = rasterizer->state->gstate.image_smoothing;
  if (width == 1 || height == 1)
    image_smoothing=0;
  for (int i = 0; i < count; i ++)
  {

  int u = (int)x;
  int v = (int)y;
  if ( (u < 0) | (v < 0) | (u >= width) | (v >= height))
      *((uint32_t*)(rgba)) = 0;
  else
    {
      int bpp = buffer->format->bpp/8;
      if (image_smoothing)
      {
        uint8_t *src00 = (uint8_t *) buffer->data;
        src00 += v * buffer->stride + u * bpp;
        uint8_t *src01 = src00;
        if ( u + 1 < width)
        {
          src01 = src00 + bpp;
        }
        uint8_t *src11 = src01;
        uint8_t *src10 = src00;
        if ( v + 1 < height)
        {
          src10 = src00 + buffer->stride;
          src11 = src01 + buffer->stride;
        }
        float dx = (x-(int)(x)) * 255.9f;
        float dy = (y-(int)(y)) * 255.9f;
        uint8_t dxb = (uint8_t)dx;
        uint8_t dyb = (uint8_t)dy;
  
        switch (bpp)
        {
          case 1:
            rgba[0] = rgba[1] = rgba[2] = ctx_lerp_u8 (ctx_lerp_u8 (src00[0], src01[0], dxb),
                                   ctx_lerp_u8 (src10[0], src11[0], dxb), dyb);
            rgba[3] = global_alpha_u8;
            break;
          case 2: // TODO : could be RGB565
            rgba[0] = rgba[1] = rgba[2] = ctx_lerp_u8 (ctx_lerp_u8 (src00[0], src01[0], dxb),
                                   ctx_lerp_u8 (src10[0], src11[0], dxb), dyb);
            rgba[3] = ctx_lerp_u8 (ctx_lerp_u8 (src00[1], src01[1], dxb),
                                   ctx_lerp_u8 (src10[1], src11[1], dxb), dyb);
            rgba[3] = (rgba[3] * global_alpha_u8) / 255;
            break;
          case 3:
            for (int c = 0; c < bpp; c++)
              { rgba[c] = ctx_lerp_u8 (ctx_lerp_u8 (src00[c], src01[c], dxb),
                                       ctx_lerp_u8 (src10[c], src11[c], dxb), dyb);
                      
              }
            rgba[3]=global_alpha_u8;
            break;
          break;
          case 4:
            if (is_assoc)
            {
              if (global_alpha_u8==255) {
                for (int c = 0; c < bpp; c++)
                  rgba[c] = ctx_lerp_u8 (ctx_lerp_u8 (src00[c], src01[c], dxb),
                                          ctx_lerp_u8 (src10[c], src11[c], dxb), dyb);
              }
              else
                for (int c = 0; c < bpp; c++)
                  rgba[c] = (ctx_lerp_u8 (ctx_lerp_u8 (src00[c], src01[c], dxb),
                                          ctx_lerp_u8 (src10[c], src11[c], dxb), dyb) * global_alpha_u8) / 255;
            }
            else
            {
              for (int c = 0; c < bpp; c++)
              { rgba[c] = ctx_lerp_u8 (ctx_lerp_u8 (src00[c], src01[c], dxb),
                                       ctx_lerp_u8 (src10[c], src11[c], dxb), dyb);
                      
              }
              rgba[3] = (rgba[3] * global_alpha_u8) / 255;
            }
        }
      }
      else
      {
      uint8_t *src = (uint8_t *) buffer->data;
      src += v * buffer->stride + u * bpp;
      switch (bpp)
        {
          case 1:
            for (int c = 0; c < 3; c++)
              { rgba[c] = src[0]; }
            rgba[3] = global_alpha_u8;
            break;
          case 2: // todo could be RGB 565
            for (int c = 0; c < 3; c++)
              { rgba[c] = src[0]; }
            rgba[3] = src[1];
            rgba[3] = (rgba[3] * global_alpha_u8) / 255;
            break;
          case 3:
            for (int c = 0; c < 3; c++)
              { rgba[c] = src[c]; }
            rgba[3] = global_alpha_u8;
            break;
          case 4:
            if (is_assoc)
            {
              if (global_alpha_u8==255)
                for (int c = 0; c < 4; c++)
                  rgba[c] = src[c];
              else
                for (int c = 0; c < 4; c++)
                  rgba[c] = (src[c] * global_alpha_u8)/255;
            }
            else
            {
              for (int c = 0; c < 4; c++)
                { rgba[c] = src[c]; }
              rgba[3] = (rgba[3] * global_alpha_u8) / 255;
            }
            break;
        }

      }
      if (rasterizer->swap_red_green)
      {
        uint8_t tmp = rgba[0];
        rgba[0] = rgba[2];
        rgba[2] = tmp;
      }
    }
    if (!is_assoc)
      ctx_RGBA8_associate_alpha (rgba);
    rgba += 4;
    x += dx;
    y += dy;
  }
}

#if CTX_DITHER
static inline int ctx_dither_mask_a (int x, int y, int c, int divisor)
{
  /* https://pippin.gimp.org/a_dither/ */
  return ( ( ( ( (x + c * 67) + y * 236) * 119) & 255 )-127) / divisor;
}

inline static void
ctx_dither_rgba_u8 (uint8_t *rgba, int x, int y, int dither_red_blue, int dither_green)
{
  if (dither_red_blue == 0)
    { return; }
  for (int c = 0; c < 3; c ++)
    {
      int val = rgba[c] + ctx_dither_mask_a (x, y, 0, c==1?dither_green:dither_red_blue);
      rgba[c] = CTX_CLAMP (val, 0, 255);
    }
}

inline static void
ctx_dither_graya_u8 (uint8_t *rgba, int x, int y, int dither_red_blue, int dither_green)
{
  if (dither_red_blue == 0)
    { return; }
  for (int c = 0; c < 1; c ++)
    {
      int val = rgba[c] + ctx_dither_mask_a (x, y, 0, dither_red_blue);
      rgba[c] = CTX_CLAMP (val, 0, 255);
    }
}
#endif

#if 0
CTX_INLINE static void
ctx_RGBA8_deassociate_alpha (const uint8_t *in, uint8_t *out)
{
    uint32_t val = *((uint32_t*)(in));
    int a = val >> CTX_RGBA8_A_SHIFT;
    if (a)
    {
    if (a ==255)
    {
      *((uint32_t*)(out)) = val;
    } else
    {
      uint32_t g = (((val & CTX_RGBA8_G_MASK) * 255 / a) >> 8) & CTX_RGBA8_G_MASK;
      uint32_t rb =(((val & CTX_RGBA8_RB_MASK) * 255 / a) >> 8) & CTX_RGBA8_RB_MASK;
      *((uint32_t*)(out)) = g|rb|(a << CTX_RGBA8_A_SHIFT);
    }
    }
    else
    {
      *((uint32_t*)(out)) = 0;
    }
}
#endif

CTX_INLINE static void
ctx_u8_deassociate_alpha (int components, const uint8_t *in, uint8_t *out)
{
  if (in[components-1])
  {
    if (in[components-1] != 255)
    for (int c = 0; c < components-1; c++)
      out[c] = (in[c] * 255) / in[components-1];
    else
    for (int c = 0; c < components-1; c++)
      out[c] = in[c];
    out[components-1] = in[components-1];
  }
  else
  {
  for (int c = 0; c < components; c++)
    out[c] = 0;
  }
}

CTX_INLINE static void
ctx_float_associate_alpha (int components, float *rgba)
{
  float alpha = rgba[components-1];
  for (int c = 0; c < components-1; c++)
    rgba[c] *= alpha;
}

CTX_INLINE static void
ctx_float_deassociate_alpha (int components, float *rgba, float *dst)
{
  float ralpha = rgba[components-1];
  if (ralpha != 0.0f) ralpha = 1.0f/ralpha;

  for (int c = 0; c < components-1; c++)
    dst[c] = (rgba[c] * ralpha);
  dst[components-1] = rgba[components-1];
}

CTX_INLINE static void
ctx_RGBAF_associate_alpha (float *rgba)
{
  ctx_float_associate_alpha (4, rgba);
}

CTX_INLINE static void
ctx_RGBAF_deassociate_alpha (float *rgba, float *dst)
{
  ctx_float_deassociate_alpha (4, rgba, dst);
}


static inline void ctx_swap_red_green_u8 (void *data)
{
  uint8_t *rgba = (uint8_t*)data;
  uint8_t tmp = rgba[0];
  rgba[0] = rgba[2];
  rgba[2] = tmp;
}

/**** rgb8 ***/

#define CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(frag) \
static void \
frag##_swap_red_green (CtxRasterizer *rasterizer,\
                       float x, float y, float z,\
                       void *out, int count, float dx, float dy, float dz)\
{\
  frag (rasterizer, x, y, z, out, count, dx, dy, dz);\
  ctx_fragment_swap_red_green_u8 (out, count);\
}



static inline void
ctx_RGBA8_apply_global_alpha_and_associate (CtxRasterizer *rasterizer,
                                         uint8_t *buf, int count)
{
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  uint8_t *rgba = (uint8_t *) buf;
  if (global_alpha_u8 != 255)
  {
    for (int i = 0; i < count; i++)
    {
      ctx_RGBA8_associate_global_alpha (rgba, global_alpha_u8);
      rgba += 4;
    }
  }
  else
  {
    for (int i = 0; i < count; i++)
    {
      ctx_RGBA8_associate_alpha (rgba);
      rgba += 4;
    }
  }
}

#if CTX_FRAGMENT_SPECIALIZE

static void
ctx_fragment_swap_red_green_u8 (void *out, int count)
{
  uint8_t *rgba = (uint8_t*)out;
  for (int x = 0; x < count; x++)
  {
    ctx_swap_red_green_u8 (rgba);
    rgba += 4;
  }
}


static void
ctx_fragment_image_rgb8_RGBA8_box (CtxRasterizer *rasterizer,
                                   float x, float y, float z,
                                   void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  int width = buffer->width;
  int height = buffer->height;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
  int dim = (int)((1.0f / factor) / 3);

  int i = 0;

  for (; i < count && (x - dim< 0 || y - dim < 0 || x + dim >= height || y + dim >= height); i++)
  {
    *((uint32_t*)(rgba))=0;
    rgba += 4;
    x += dx;
    y += dy;
  }

  for (; i < count && !(
       x - dim < 0 || y - dim < 0 ||
       x + dim >= width ||
       y + dim >= height); i++)
  {

  int u = (int)x;
  int v = (int)y;
    {
      int bpp = 3;
      rgba[3]=global_alpha_u8; // gets lost
          uint64_t sum[4]={0,0,0,0};
          int count = 0;

          {
            for (int ov = - dim; ov <= dim; ov++)
            {
              uint8_t *src = (uint8_t *) buffer->data + bpp * ((v+ov) * width + (u - dim));
              for (int ou = - dim; ou <= dim; ou++)
              {
                for (int c = 0; c < bpp; c++)
                  sum[c] += src[c];
                count ++;
                src += bpp;
              }

            }
          }

          int recip = 65536/count;
          for (int c = 0; c < bpp; c++)
            rgba[c] = sum[c] * recip >> 16;
          ctx_RGBA8_associate_alpha (rgba);
    }
    rgba += 4;
    x += dx;
    y += dy;
  }

  for (; i < count; i++)
  {
    *((uint32_t*)(rgba))= 0;
    rgba += 4;
  }
}


static void
ctx_fragment_image_rgb8_RGBA8_nearest (CtxRasterizer *rasterizer,
                                       float x, float y, float z,
                                       void *out, int scount,
                                       float dx, float dy, float dz);
static inline void
ctx_fragment_image_rgb8_RGBA8_bi (CtxRasterizer *rasterizer,
                                  float x, float y, float z,
                                  void *out, int scount,
                                  float dx, float dy, float dz)
{
  ctx_fragment_image_rgb8_RGBA8_nearest (rasterizer,
                                         x, y, z,
                                         out, scount,
                                         dx, dy, dz);
  return;
}

static void
ctx_fragment_image_rgb8_RGBA8_nearest (CtxRasterizer *rasterizer,
                                       float x, float y, float z,
                                       void *out, int scount,
                                       float dx, float dy, float dz)
{
  unsigned int count = scount;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  const int bwidth = buffer->width;
  const int bheight = buffer->height;
  unsigned int i = 0;
  uint8_t *data = ((uint8_t*)buffer->data);

  int yi_delta = (int)(dy * 65536);
  int xi_delta = (int)(dx * 65536);
  int zi_delta = (int)(dz * 65536);
  int32_t yi = (int)(y * 65536);
  int32_t xi = (int)(x * 65536);
  int32_t zi = (int)(z * 65536);
  {
    int32_t u1 = xi + xi_delta* (count-1);
    int32_t v1 = yi + yi_delta* (count-1);
    int32_t z1 = zi + zi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      float z_recip = (z1!=0) * (1.0f/z1);
      if ((u1*z_recip) <0 ||
          (v1*z_recip) <0 ||
          (u1*z_recip) >= (bwidth) - 1 ||
          (v1*z_recip) >= (bheight) - 1)
      {
        *edst-- = 0;
        count --;
        u1 -= xi_delta;
        v1 -= yi_delta;
        z1 -= zi_delta;
      }
      else break;
    }
  }

  for (i= 0; i < count; i ++)
  {
    float z_recip = (zi!=0) * (1.0f/zi);
    int u = (int)(xi * z_recip);
    int v = (int)(yi * z_recip);
    if ( u  <= 0 || v  <= 0 || u+1 >= bwidth-1 || v+1 >= bheight-1)
    {
      *((uint32_t*)(rgba))= 0;
    }
    else
      break;
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;
  }

  while (i < count)
  {
    float z_recip = (zi!=0) * (1.0f/zi);
    int u = (int)(xi * z_recip);
    int v = (int)(yi * z_recip);
    for (unsigned int c = 0; c < 3; c++)
      rgba[c] = data[(bwidth *v +u)*3+c];
    rgba[3] = global_alpha_u8;
    ctx_RGBA8_associate_alpha (rgba);
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;
    i++;
  }
}



CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgb8_RGBA8_box)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgb8_RGBA8_bi)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgb8_RGBA8_nearest)


static inline void
ctx_fragment_image_rgb8_RGBA8 (CtxRasterizer *rasterizer,
                               float x,
                               float y,
                               float z,
                               void *out, int count, float dx, float dy, float dz)
{
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  int image_smoothing = rasterizer->state->gstate.image_smoothing;
  if (buffer->width == 1 || buffer->height == 1)
        image_smoothing = 0;
  if (rasterizer->swap_red_green)
  {
    if (image_smoothing)
    {
      float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
      if (factor <= 0.50f)
        ctx_fragment_image_rgb8_RGBA8_box_swap_red_green (rasterizer,x,y,z,out,count,dx,dy,dz);
  #if CTX_ALWAYS_USE_NEAREST_FOR_SCALE1
      else if ((factor > 0.99f) & (factor < 1.01f))
        ctx_fragment_image_rgb8_RGBA8_nearest_swap_red_green (rasterizer,x,y,z,
                                                            out,count,dx,dy,dz);
  #endif
      else
        ctx_fragment_image_rgb8_RGBA8_bi_swap_red_green (rasterizer,x,y,z,
                                                         out,count, dx, dy, dz);
    }
    else
    {
      ctx_fragment_image_rgb8_RGBA8_nearest_swap_red_green (rasterizer,x,y,z,
                                                            out,count,dx,dy,dz);
    }
  }
  else
  {
    if (image_smoothing)
    {
      float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
      if (factor <= 0.50f)
        ctx_fragment_image_rgb8_RGBA8_box (rasterizer,x,y,z,out,
                                           count,dx,dy,dz);
  #if CTX_ALWAYS_USE_NEAREST_FOR_SCALE1
      else if ((factor > 0.99f) & (factor < 1.01f))
        ctx_fragment_image_rgb8_RGBA8_nearest (rasterizer, x, y, z, out, count, dx, dy, dz);
  #endif
      else
        ctx_fragment_image_rgb8_RGBA8_bi (rasterizer,x,y,z,out,count,dx,dy,dz);
    }
    else
    {
        ctx_fragment_image_rgb8_RGBA8_nearest (rasterizer,x,y,z,out,
                                               count,dx,dy, dz);
    }
  }
}


/************** rgba8 */

static void
ctx_fragment_image_rgba8_RGBA8_box (CtxRasterizer *rasterizer,
                                    float x, float y, float z,
                                    void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  int width = buffer->width;
  int height = buffer->height;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
  int dim = (int)((1.0f / factor) / 3);

  int i = 0;

  for (; i < count && (x - dim< 0 || y - dim < 0 || x + dim >= height || y + dim >= height); i++)
  {
    *((uint32_t*)(rgba))=0;
    rgba += 4;
    x += dx;
    y += dy;
  }

  for (; i < count && !(
       x - dim < 0 || y - dim < 0 ||
       x + dim >= width ||
       y + dim >= height); i++)
  {

  int u = (int)x;
  int v = (int)y;
    {
      int bpp = 4;
          uint64_t sum[4]={0,0,0,0};
          int count = 0;

          {
            for (int ov = - dim; ov <= dim; ov++)
            {
              uint8_t *src = (uint8_t *) buffer->data + bpp * ((v+ov) * width + (u - dim));
              for (int ou = - dim; ou <= dim; ou++)
              {
                for (int c = 0; c < bpp; c++)
                  sum[c] += src[c];
                count ++;
                src += bpp;
              }

            }
          }

          int recip = 65536/count;
          for (int c = 0; c < bpp; c++)
            rgba[c] = sum[c] * recip >> 16;
          rgba[3]=rgba[3]*global_alpha_u8/255; // gets lost
          ctx_RGBA8_associate_alpha (rgba);
    }
    rgba += 4;
    x += dx;
    y += dy;
  }


  for (; i < count; i++)
  {
    *((uint32_t*)(rgba))= 0;
    rgba += 4;
  }
#if CTX_DITHER
//ctx_dither_rgba_u8 (rgba, x, y, rasterizer->format->dither_red_blue,
//                    rasterizer->format->dither_green);
#endif
}


static void
ctx_fragment_image_rgba8_RGBA8_nearest_copy (CtxRasterizer *rasterizer,
                                             float x, float y, float z,
                                             void *out, int scount, float dx, float dy, float dz)
{ 
  unsigned int count = scount;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  //if (!buffer) // XXX : this should happen in setup
  //  return;
  uint32_t *dst = (uint32_t*)out;
  int bwidth  = buffer->width;
  int bheight = buffer->height;
  int u = (int)x;
  int v = (int)y;

  if ((!((v >= 0) & (v < bheight))))
  {
    memset (dst, 0, count*4);
    return;
  }
  uint32_t *src = ((uint32_t*)buffer->data) + bwidth * v + u;
#if defined(__GNUC__) && !defined(__clang__)
  int pre = ctx_mini(ctx_maxi(-u,0), count);
  for (int i = 0; i < pre;i++)
  { *dst++ = 0; }
  count-=pre;
  src+=pre;
  u+=pre;
 
  int limit = ctx_mini (count, bwidth - u);
  if (limit>0)
  {
    for (int i = 0; i < limit;i++)
     { *dst++ = *src++; }
  }

  count-=limit;
  for (unsigned int i = 0; i < count; i++)
    *dst++ = 0;
#else
  int i = 0;
  for (; (u<0) & ((unsigned)i < count); i++,u++,src++)
    *dst++ = 0;
  for (; (u<bwidth) & ((unsigned)i<count); i++, u++)
    *dst++ = *src++;
  for (; ((unsigned)i<count); i++)
    *dst++ = 0;
#endif
}

#if 0
static void
ctx_fragment_image_rgba8sepA_RGBA8_nearest_copy (CtxRasterizer *rasterizer,
                                                 float x, float y, float z,
                                                 void *out, int scount, float dx, float dy, float dz)
{
  ctx_fragment_image_rgba8_RGBA8_nearest_copy (rasterizer, x, y, z, out, scount, dx, dy, dz);
  ctx_RGBA8_apply_global_alpha_and_associate (rasterizer, (uint8_t*)out, scount);
}
#endif

static void
ctx_fragment_image_rgba8_RGBA8_nearest_copy_repeat (CtxRasterizer *rasterizer,
                                                    float x, float y, float z,
                                                    void *out, int count, float dx, float dy, float dz)
{
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  uint32_t *dst = (uint32_t*)out;
  int bwidth  = buffer->width;
  int bheight = buffer->height;
  int u = (int)x;
  int v = (int)y;
  if (v < 0) v += bheight * 8192;
  if (u < 0) u += bwidth * 8192;
  v %= bheight;
  u %= bwidth;

  uint32_t *src = ((uint32_t*)buffer->data) + bwidth * v;

  while (count)
  {
     int chunk = ctx_mini (bwidth - u, count);
     memcpy (dst, src + u, chunk * 4);
     dst += chunk;
     count -= chunk;
     u = (u + chunk) % bwidth;
  }
}

static CTX_INLINE void 
_ctx_coords_restrict (CtxExtend extend,
                      int *u, int *v,
                      int bwidth, int bheight)
{
  switch (extend)
  {
    case CTX_EXTEND_REPEAT:
      if(u)
      {
         while (*u < 0) *u += bwidth * 4096;   // XXX need better way to do this
         *u  %= bwidth;
      }
      if(v)
      {
        while (*v < 0) *v += bheight * 4096;
        *v  %= bheight;
      }
  //  return 1;
      break;
    case CTX_EXTEND_REFLECT:
      if (u)
      {
      while (*u < 0) *u += bwidth * 4096;   // XXX need better way to do this
      *u  %= (bwidth*2);

      *u = (*u>=bwidth) * (bwidth*2 - *u) +
           (*u<bwidth) * *u;
      }

      if (v)
      {
      while (*v < 0) *v += bheight * 4096;
      *v  %= (bheight*2);
      *v = (*v>=bheight) * (bheight*2 - *v) +
           (*v<bheight) * *v;
      }

 //   return 1;
      break;
    case CTX_EXTEND_PAD:
      if (u)*u = ctx_mini (ctx_maxi (*u, 0), bwidth-1);
      if (v)*v = ctx_mini (ctx_maxi (*v, 0), bheight-1);
 //   return 1;
      break;
    case CTX_EXTEND_NONE:
      {
      if (u) { int val=*u;  val *= (val>0); val= (val>=bwidth)*bwidth + val * (val<bwidth);  *u = val;}
      if (v) { int val=*v;  val *= (val>0); val= (val>=bheight)*bheight + val * (val<bheight); *v = val;}
  //  return 1;
      }
  }
 //return 0;
}

static void
ctx_fragment_image_rgba8_RGBA8_nearest_affine (CtxRasterizer *rasterizer,
                                               float x, float y, float z,
                                               void *out, int scount, float dx, float dy, float dz)
{
  unsigned int count = scount;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  CtxExtend extend = rasterizer->state->gstate.extend;
  const int bwidth = buffer->width;
  const int bheight = buffer->height;
  unsigned int i = 0;
  uint32_t *data = ((uint32_t*)buffer->data);

  int yi_delta = (int)(dy * 65536);
  int xi_delta = (int)(dx * 65536);
  int32_t yi = (int)(y * 65536);
  int32_t xi = (int)(x * 65536);
  switch (extend){
          case CTX_EXTEND_NONE:
                  {

    int32_t u1 = xi + xi_delta* (count-1);
    int32_t v1 = yi + yi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      if (((u1>>16) <0) |
          ((v1>>16) <0) |
          ((u1>>16) >= (bwidth) - 1) |
          ((v1>>16) >= (bheight) - 1))
      {
        *edst-- = 0;
        count --;
        u1 -= xi_delta;
        v1 -= yi_delta;
      }
      else break;
    }

  for (i= 0; i < count; i ++)
  {
    int u = xi >> 16;
    int v = yi >> 16;
    if ((u  <= 0) | (v  <= 0) | (u+1 >= bwidth-1) | (v+1 >= bheight-1))
    {
      *((uint32_t*)(rgba))= 0;
    }
    else break;
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;
  }

  if (global_alpha_u8 == 255)
  while (i < count)
  {
    int u = xi >> 16;
    int v = yi >> 16;
    ((uint32_t*)(&rgba[0]))[0] = data[bwidth *v +u];
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;
    i++;
  }
  else
  while (i < count)
  {
    int u = xi >> 16;
    int v = yi >> 16;
    ((uint32_t*)(&rgba[0]))[0] =
      ctx_RGBA8_mul_alpha_u32 (data[bwidth *v +u], global_alpha_u8);
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;
    i++;
  }
                  }
  break;
          default:
  if (global_alpha_u8 == 255)
    while (i < count)
    {
      int u = xi >> 16;
      int v = yi >> 16;
      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      ((uint32_t*)(&rgba[0]))[0] = data[bwidth *v +u];
      xi += xi_delta;
      yi += yi_delta;
      rgba += 4;
      i++;
    }
   else
    while (i < count)
    {
      int u = xi >> 16;
      int v = yi >> 16;
      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      ((uint32_t*)(&rgba[0]))[0] =
        ctx_RGBA8_mul_alpha_u32 (data[bwidth *v +u], global_alpha_u8);
      xi += xi_delta;
      yi += yi_delta;
      rgba += 4;
      i++;
    }
   break;
  }
}


static void
ctx_fragment_image_rgba8_RGBA8_nearest_scale (CtxRasterizer *rasterizer,
                                              float x, float y, float z,
                                              void *out, int scount, float dx, float dy, float dz)
{
  unsigned int count = scount;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  CtxExtend  extend = rasterizer->state->gstate.extend;
  uint32_t *src = NULL;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  int ideltax = (int)(dx * 65536);
  uint32_t *dst = (uint32_t*)out;
  int bwidth  = buffer->width;
  int bheight = buffer->height;
  int bbheight = bheight << 16;
  int bbwidth  = bwidth << 16;
//  x += 0.5f;
//  y += 0.5f;

  src = (uint32_t*)buffer->data;
  //if (!src){ fprintf (stderr, "eeek bailing in nearest fragment\n"); return;};

  {
    unsigned int i = 0;
    int32_t ix = (int)(x * 65536);
    int32_t iy = (int)(y * 65536);

    if (extend == CTX_EXTEND_NONE)
    {
    int32_t u1 = ix + ideltax * (count-1);
    int32_t v1 = iy;
    uint32_t *edst = ((uint32_t*)out)+count - 1;
    for (; i < count; )
    {
      if ((u1 <0) | (v1 < 0) | (u1 >= bbwidth) | (v1 >= bbheight))
      {
        *edst-- = 0;
        count --;
        u1 -= ideltax;
      }
      else break;
    }

    for (i = 0; i < count; i ++)
    {
      if ((ix < 0) | (iy < 0) | (ix >= bbwidth)  | (iy >= bbheight))
      {
        *dst++ = 0;
        x += dx;
        ix += ideltax;
      }
      else break;
    }

      int v = iy >> 16;
      int u = ix >> 16;
      int o = (v)*bwidth;
      if (global_alpha_u8==255)
        for (; i < count; i ++)
        {
          u = ix >> 16;
          *dst++ = src[o + (u)];
          ix += ideltax;
        }
      else
        for (; i < count; i ++)
        {
          u = ix >> 16;
          *dst++ = ctx_RGBA8_mul_alpha_u32 (src[o + (u)], global_alpha_u8);
          ix += ideltax;
        }
    }
    else
    {

      int v = iy >> 16;
      int u = ix >> 16;
      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      int o = (v)*bwidth;
      if (global_alpha_u8==255)
      for (; i < count; i ++)
      {
        u = ix >> 16;
        _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
        *dst++ = src[o + (u)];
        ix += ideltax;
      }
      else
      {
        u = ix >> 16;
        _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
        *dst++ = ctx_RGBA8_mul_alpha_u32 (src[o + (u)], global_alpha_u8);
        ix += ideltax;
      }
    }
  }
}

static void
ctx_fragment_image_rgba8_RGBA8_nearest_generic (CtxRasterizer *rasterizer,
                                                float x, float y, float z,
                                                void *out, int scount, float dx, float dy, float dz)
{
  unsigned int count = scount;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  CtxExtend extend = rasterizer->state->gstate.extend;
  const int bwidth = buffer->width;
  const int bheight = buffer->height;
  unsigned int i = 0;
  uint32_t *data = ((uint32_t*)buffer->data);

  int yi_delta = (int)(dy * 65536);
  int xi_delta = (int)(dx * 65536);
  int zi_delta = (int)(dz * 65536);
  int32_t yi = (int)(y * 65536);
  int32_t xi = (int)(x * 65536);
  int32_t zi = (int)(z * 65536);
  switch (extend){
          case CTX_EXTEND_NONE:
                  {

    int32_t u1 = xi + xi_delta* (count-1);
    int32_t v1 = yi + yi_delta* (count-1);
    int32_t z1 = zi + zi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      float z_recip = (z1!=0) * (1.0f/z1);

      if (((u1*z_recip) <0) |
          ((v1*z_recip) <0) |
          ((u1*z_recip) >= (bwidth) - 1) |
          ((v1*z_recip) >= (bheight) - 1))
      {
        *edst-- = 0;
        count --;
        u1 -= xi_delta;
        v1 -= yi_delta;
        z1 -= zi_delta;
      }
      else break;
    }

  for (i= 0; i < count; i ++)
  {
    float z_recip = (zi!=0) * (1.0f/zi);
    int u = (int)(xi * z_recip);
    int v = (int)(yi * z_recip);
    if ( (u <= 0) | (v  <= 0) | (u+1 >= bwidth-1) | (v+1 >= bheight-1))
    {
      *((uint32_t*)(rgba))= 0;
    }
    else
      break;
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;
  }

  if (global_alpha_u8!=255)
  while (i < count)
  {
    float z_recip = (zi!=0) * (1.0f/zi);
    int u = (int)(xi * z_recip);
    int v = (int)(yi * z_recip);
    ((uint32_t*)(&rgba[0]))[0] =
      ctx_RGBA8_mul_alpha_u32 (data[bwidth *v +u], global_alpha_u8);
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;
    i++;
  }
  else
  while (i < count)
  {
    float z_recip = (zi!=0) * (1.0f/zi);
    int u = (int)(xi * z_recip);
    int v = (int)(yi * z_recip);
    ((uint32_t*)(&rgba[0]))[0] = data[bwidth *v +u];
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;
    i++;
  }
                  }
  break;
  default:
    if (global_alpha_u8!=255)
    while (i < count)
    {
      float z_recip = (zi!=0) * (1.0f/zi);
      int u = (int)(xi * z_recip);
      int v = (int)(yi * z_recip);
      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      ((uint32_t*)(&rgba[0]))[0] =
        ctx_RGBA8_mul_alpha_u32 (data[bwidth *v +u], global_alpha_u8);
      xi += xi_delta;
      yi += yi_delta;
      zi += zi_delta;
      rgba += 4;
      i++;
    }
    else
    while (i < count)
    {
      float z_recip = (zi!=0) * (1.0f/zi);
      int u = (int)(xi * z_recip);
      int v = (int)(yi * z_recip);
      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      ((uint32_t*)(&rgba[0]))[0] = data[bwidth *v +u];
      xi += xi_delta;
      yi += yi_delta;
      zi += zi_delta;
      rgba += 4;
      i++;
    }
    break;
  }
}

static void
ctx_fragment_image_rgba8_RGBA8_nearest (CtxRasterizer *rasterizer,
                                   float x, float y, float z,
                                   void *out, int icount, float dx, float dy, float dz)
{
  unsigned int count = icount;
  CtxExtend extend = rasterizer->state->gstate.extend;
  if ((z == 1.0f) & (dz == 0.0f)) // this also catches other constant z!
  {
    if ((dy == 0.0f) & (dx == 1.0f) & (extend == CTX_EXTEND_NONE))
      ctx_fragment_image_rgba8_RGBA8_nearest_copy (rasterizer, x, y, z, out, count, dx, dy, dz);
    else
      ctx_fragment_image_rgba8_RGBA8_nearest_affine (rasterizer, x, y, z, out, count, dx, dy, dz);
  }
  else
  {
    ctx_fragment_image_rgba8_RGBA8_nearest_generic (rasterizer, x, y, z, out, count, dx, dy, dz);
  }
}



static inline void
ctx_fragment_image_rgba8_RGBA8_bi_scale_with_alpha (CtxRasterizer *rasterizer,
                                                    float x, float y, float z,
                                                    void *out, int scount, float dx, float dy, float dz)
{
    uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
    uint32_t count = scount;
    x -= 0.5f;
    y -= 0.5f;
    uint8_t *rgba = (uint8_t *) out;
    CtxSource *g = &rasterizer->state->gstate.source_fill;
    CtxExtend  extend = rasterizer->state->gstate.extend;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
    const int bwidth = buffer->width;
    const int bheight = buffer->height;
    unsigned int i = 0;

    if (!extend)
    {
    if (!((y >= 0) & (y < bheight)))
    {
      uint32_t *dst = (uint32_t*)rgba;
      for (i = 0 ; i < count; i++)
        *dst++ = 0;
      return;
    }
    }

    //x+=1; // XXX off by one somewhere? ,, needed for alignment with nearest

    int32_t yi = (int)(y * 65536);
    int32_t xi = (int)(x * 65536);

    int xi_delta = (int)(dx * 65536);

    if (!extend)
    {
    int32_t u1 = xi + xi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      if ((u1 <0) | (u1 +65536 >= (bwidth<<16)))
    {
      *edst-- = 0;
      count --;
      u1 -= xi_delta;
    }
    else break;
  }
    for (i= 0; i < count; i ++)
    {
      int u = xi >> 16;
      if ((u < 0) | (u >= bwidth-1))
      {
        *((uint32_t*)(rgba))= 0;
        xi += xi_delta;
        rgba += 4;
      }
      else
        break;
    }
    }

 
  int v = yi >> 16;


  int dv = (yi >> 8) & 0xff;

  int u = xi >> 16;

  int v1 = v+1;

  _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
  _ctx_coords_restrict (extend, NULL, &v1, bwidth, bheight);

  uint32_t *data = ((uint32_t*)buffer->data) + bwidth * v;
  uint32_t *ndata = data + bwidth * !((!extend) & (v1 > bheight-1));

  if (extend)
  {
    if (xi_delta == 65536)
    {
      uint32_t *src0 = data, *src1 = ndata;
      uint32_t s1_ga = 0, s1_rb = 0;
      int du = (xi >> 8) & 0xff;

      src0 = data + u;
      src1 = ndata + u;
      ctx_lerp_RGBA8_split (src0[0],src1[0], dv, &s1_ga, &s1_rb);
  
      for (; i < count; i ++)
      {
        uint32_t s0_ga = s1_ga;
        uint32_t s0_rb = s1_rb; 
        _ctx_coords_restrict (extend, &u, NULL, bwidth, bheight);
        ctx_lerp_RGBA8_split (src0[1],src1[1], dv, &s1_ga, &s1_rb);
        ((uint32_t*)(&rgba[0]))[0] = 
          ctx_RGBA8_mul_alpha_u32 (
                  ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, du), global_alpha_u8);
        rgba += 4;
        u++;
        src0 ++;
        src1 ++;
      }
    }
    else
    {
      uint32_t s0_ga = 0, s1_ga = 0, s0_rb = 0, s1_rb = 0;
      int prev_u = -1000;
      for (; (i < count); i++)
      {
        if (prev_u != u)
        {
          if (prev_u == u-1)
          {
            s0_ga = s1_ga;
            s0_rb = s1_rb;
            ctx_lerp_RGBA8_split (data[u+1],ndata[u+1], dv, &s1_ga, &s1_rb);
          }
          else
          {
            ctx_lerp_RGBA8_split (data[u],ndata[u], dv, &s0_ga, &s0_rb);
            ctx_lerp_RGBA8_split (data[u+1],ndata[u+1], dv, &s1_ga, &s1_rb);
          }
          prev_u = u;
        }
        ((uint32_t*)(&rgba[0]))[0] = 
          ctx_RGBA8_mul_alpha_u32 (
                  ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, (xi>>8)), global_alpha_u8);
        rgba += 4;
        u = (xi+=xi_delta) >> 16;
        _ctx_coords_restrict (extend, &u, NULL, bwidth, bheight);
      }
    }
  }
  else
  {
    if (xi_delta == 65536)
    {
      uint32_t *src0 = data, *src1 = ndata;
      uint32_t s1_ga = 0, s1_rb = 0;
      int du = (xi >> 8) & 0xff;
  
      src0 = data + u;
      src1 = ndata + u;
      ctx_lerp_RGBA8_split (src0[0],src1[0], dv, &s1_ga, &s1_rb);
  
      for (; i < count; i ++)
      {
        uint32_t s0_ga = s1_ga;
        uint32_t s0_rb = s1_rb;
        ctx_lerp_RGBA8_split (src0[1],src1[1], dv, &s1_ga, &s1_rb);
        ((uint32_t*)(&rgba[0]))[0] = 
          ctx_RGBA8_mul_alpha_u32 (
                  ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, du), global_alpha_u8);
        rgba += 4;
        u++;
        src0 ++;
        src1 ++;
      }
    }
    else
    {
      uint32_t s0_ga = 0, s1_ga = 0, s0_rb = 0, s1_rb = 0;
      int prev_u = -1000;
      for (; (i < count); i++)
      {
        if (prev_u != u)
        {
          if (prev_u == u-1)
          {
            s0_ga = s1_ga;
            s0_rb = s1_rb;
            ctx_lerp_RGBA8_split (data[u+1],ndata[u+1], dv, &s1_ga, &s1_rb);
          }
          else
          {
            ctx_lerp_RGBA8_split (data[u],ndata[u], dv, &s0_ga, &s0_rb);
            ctx_lerp_RGBA8_split (data[u+1],ndata[u+1], dv, &s1_ga, &s1_rb);
          }
          prev_u = u;
        }
        ((uint32_t*)(&rgba[0]))[0] = 
          ctx_RGBA8_mul_alpha_u32 (
                  ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, (xi>>8)), global_alpha_u8);
        rgba += 4;
        u = (xi+=xi_delta) >> 16;
      }
    }
  }
}

static inline void
ctx_fragment_image_rgba8_RGBA8_bi_scale (CtxRasterizer *rasterizer,
                                         float x, float y, float z,
                                         void *out, int scount, float dx, float dy, float dz)
{
    uint32_t count = scount;
    x -= 0.5f;
    y -= 0.5f;
    uint8_t *rgba = (uint8_t *) out;
    CtxSource *g = &rasterizer->state->gstate.source_fill;
    CtxExtend  extend = rasterizer->state->gstate.extend;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
    const int bwidth = buffer->width;
    const int bheight = buffer->height;
    unsigned int i = 0;

    if (!extend)
    {
    if (!((y >= 0) & (y < bheight)))
    {
      uint32_t *dst = (uint32_t*)rgba;
      for (i = 0 ; i < count; i++)
        *dst++ = 0;
      return;
    }
    }

    //x+=1; // XXX off by one somewhere? ,, needed for alignment with nearest

    int32_t yi = (int)(y * 65536);
    int32_t xi = (int)(x * 65536);

    int xi_delta = (int)(dx * 65536);

    if (!extend)
    {
    int32_t u1 = xi + xi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      if ((u1 <0) | (u1 +65536 >= (bwidth<<16)))
    {
      *edst-- = 0;
      count --;
      u1 -= xi_delta;
    }
    else break;
  }
    for (i= 0; i < count; i ++)
    {
      int u = xi >> 16;
      if ((u < 0) | (u >= bwidth-1))
      {
        *((uint32_t*)(rgba))= 0;
        xi += xi_delta;
        rgba += 4;
      }
      else
        break;
    }
    }

 
  int v = yi >> 16;
  int dv = (yi >> 8) & 0xff;
  int u = xi >> 16;

  int v1 = v+1;

  _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
  _ctx_coords_restrict (extend, NULL, &v1, bwidth, bheight);

  uint32_t *data = ((uint32_t*)buffer->data) + bwidth * v;
  uint32_t *ndata = data + bwidth * !((!extend) & (v1 > bheight-1));

  if (extend)
  {
    if (xi_delta == 65536)
    {
      uint32_t *src0 = data, *src1 = ndata;
      uint32_t s1_ga = 0, s1_rb = 0;
      int du = (xi >> 8) & 0xff;

      src0 = data + u;
      src1 = ndata + u;
      ctx_lerp_RGBA8_split (src0[0],src1[0], dv, &s1_ga, &s1_rb);
  
      for (; i < count; i ++)
      {
        uint32_t s0_ga = s1_ga;
        uint32_t s0_rb = s1_rb; 
        _ctx_coords_restrict (extend, &u, NULL, bwidth, bheight);
        ctx_lerp_RGBA8_split (src0[1],src1[1], dv, &s1_ga, &s1_rb);
        ((uint32_t*)(&rgba[0]))[0] = ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, du);
        rgba += 4;
        u++;
        src0 ++;
        src1 ++;
      }
    }
    else
    {
      uint32_t s0_ga = 0, s1_ga = 0, s0_rb = 0, s1_rb = 0;
      int prev_u = -1000;
      for (; (i < count); i++)
      {
        if (prev_u != u)
        {
          ctx_lerp_RGBA8_split (data[u],ndata[u], dv, &s0_ga, &s0_rb);
          ctx_lerp_RGBA8_split (data[u+1],ndata[u+1], dv, &s1_ga, &s1_rb);
          prev_u = u;
        }
        ((uint32_t*)(&rgba[0]))[0] = ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, (xi>>8));
        rgba += 4;
        u = (xi+=xi_delta) >> 16;
        _ctx_coords_restrict (extend, &u, NULL, bwidth, bheight);
      }
    }
  }
  else // no extend
  {
    if (xi_delta == 65536)
    {
      uint32_t *src0 = data, *src1 = ndata;
      uint32_t s1_ga = 0, s1_rb = 0;
      int du = (xi >> 8) & 0xff;
  
      src0 = data + u;
      src1 = ndata + u;
      ctx_lerp_RGBA8_split (src0[0],src1[0], dv, &s1_ga, &s1_rb);
  
      for (; i < count; i ++)
      {
        uint32_t s0_ga = s1_ga;
        uint32_t s0_rb = s1_rb;
        ctx_lerp_RGBA8_split (src0[1],src1[1], dv, &s1_ga, &s1_rb);
        ((uint32_t*)(&rgba[0]))[0] = ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, du);
        rgba += 4;
        u++;
        src0 ++;
        src1 ++;
      }
    }
    else 
    {
      uint32_t s0_ga = 0, s1_ga = 0, s0_rb = 0, s1_rb = 0;
      int prev_u = -1000;
      for (; (i < count); i++)
      {
        if (prev_u != u)
        {
          ctx_lerp_RGBA8_split (data[u],ndata[u], dv, &s0_ga, &s0_rb);
          ctx_lerp_RGBA8_split (data[u+1],ndata[u+1], dv, &s1_ga, &s1_rb);
          prev_u = u;
        }
        ((uint32_t*)(&rgba[0]))[0] = ctx_lerp_RGBA8_merge (s0_ga, s0_rb, s1_ga, s1_rb, (xi>>8));
        rgba += 4;
        u = (xi+=xi_delta) >> 16;
      }
    }
  }
}

static inline void
ctx_fragment_image_rgba8_RGBA8_bi_affine_with_alpha (CtxRasterizer *rasterizer,
                                          float x, float y, float z,
                                          void *out, int scount,
                                          float dx, float dy, float dz)
{
  CtxState *state = rasterizer->state;
  uint8_t global_alpha_u8 = state->gstate.global_alpha_u8;
        x-=0.5f;
        y-=0.5f;
  uint32_t count = scount;
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  CtxExtend extend = state->gstate.extend;
  const int bwidth = buffer->width;
  const int bheight = buffer->height;
  unsigned int i = 0;
  uint32_t *data = ((uint32_t*)buffer->data);

  int yi_delta = (int)(dy * 65536);
  int xi_delta = (int)(dx * 65536);
  int32_t yi = (int)(y * 65536);
  int32_t xi = (int)(x * 65536);

  if (extend == CTX_EXTEND_NONE)
  {
    int32_t u1 = xi + xi_delta* (count-1);
    int32_t v1 = yi + yi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      if (((u1>>16) <0) |
          ((v1>>16) <0) |
          ((u1>>16) >= (bwidth) - 1) |
          ((v1>>16) >= (bheight) - 1))
      {
        *edst-- = 0;
        count --;
        u1 -= xi_delta;
        v1 -= yi_delta;
      }
      else break;
    }

  for (i= 0; i < count; i ++)
  {
    int u = xi >> 16;
    int v = yi >> 16;
    if ((u <= 0) | (v <= 0) | (u+1 >= bwidth-1) | (v+1 >= bheight-1))
    {
      *((uint32_t*)(rgba))= 0;
    }
    else
      break;
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;
  }
  }

  uint32_t *src00=data;
  uint32_t *src01=data;
  uint32_t *src10=data;
  uint32_t *src11=data;

  while (i < count)
  {
    int du = xi >> 8;
    int u = du >> 8;
    int dv = yi >> 8;
    int v = dv >> 8;
#if 0
    if (CTX_UNLIKELY((u < 0) | (v < 0) | (u+1 >= bwidth) | (v+1 >=bheight))) // default to next sample down and to right
    {
      int u1 = u + 1;
      int v1 = v + 1;

      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      _ctx_coords_restrict (extend, &u1, &v1, bwidth, bheight);

      src00 = data  + bwidth * v + u;
      src01 = data  + bwidth * v + u1;
      src10 = data  + bwidth * v1 + u;
      src11 = data  + bwidth * v1 + u1;
    }
    else 
#endif
    {
      src00 = data  + bwidth * v + u;
      src01 = src00 + 1;
      src10 = src00 + bwidth;
      src11 = src01 + bwidth;
    }
    ((uint32_t*)(&rgba[0]))[0] = ctx_RGBA8_mul_alpha_u32 ( ctx_bi_RGBA8_alpha (*src00,*src01,*src10,*src11, du,dv), global_alpha_u8);
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;

    i++;
  }
}

static inline void
ctx_fragment_image_rgba8_RGBA8_bi_affine (CtxRasterizer *rasterizer,
                                          float x, float y, float z,
                                          void *out, int scount,
                                          float dx, float dy, float dz)
{
  x-=0.5f;
  y-=0.5f;
  uint32_t count = scount;
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  CtxExtend extend = rasterizer->state->gstate.extend;
  const int bwidth = buffer->width;
  const int bheight = buffer->height;
  unsigned int i = 0;
  uint32_t *data = ((uint32_t*)buffer->data);

  int yi_delta = (int)(dy * 65536);
  int xi_delta = (int)(dx * 65536);
  int32_t yi = (int)(y * 65536);
  int32_t xi = (int)(x * 65536);

  if (extend == CTX_EXTEND_NONE)
  {
    int32_t u1 = xi + xi_delta* (count-1);
    int32_t v1 = yi + yi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      if (((u1>>16) <0) |
          ((v1>>16) <0) |
          ((u1>>16) >= (bwidth) - 1) |
          ((v1>>16) >= (bheight) - 1))
      {
        *edst-- = 0;
        count --;
        u1 -= xi_delta;
        v1 -= yi_delta;
      }
      else break;
    }

  for (i= 0; i < count; i ++)
  {
    int u = xi >> 16;
    int v = yi >> 16;
    if ((u <= 0) | (v <= 0) | (u+1 >= bwidth-1) | (v+1 >= bheight-1))
    {
      *((uint32_t*)(rgba))= 0;
    }
    else
      break;
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;
  }
  }

  uint32_t *src00=data;
  uint32_t *src01=data;
  uint32_t *src10=data;
  uint32_t *src11=data;

  while (i < count)
  {
    int du = xi >> 8;
    int u = du >> 8;
    int dv = yi >> 8;
    int v = dv >> 8;


    //if (((u < 0) | (v < 0) | (u+1 >= bwidth) | (v+1 >=bheight))) // default to next sample down and to right
#if 0
    if(0){
      int u1 = u + 1;
      int v1 = v + 1;

      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      _ctx_coords_restrict (extend, &u1, &v1, bwidth, bheight);

      src00 = data  + bwidth * v + u;
      src01 = data  + bwidth * v + u1;
      src10 = data  + bwidth * v1 + u;
      src11 = data  + bwidth * v1 + u1;
    }
    else 
#endif
    {
      src00 = data  + bwidth * v + u;
      src01 = src00 + 1;
      src10 = src00 + bwidth;
      src11 = src01 + bwidth;
    }
    ((uint32_t*)(&rgba[0]))[0] = ctx_bi_RGBA8_alpha (*src00,*src01,*src10,*src11, du,dv);
    xi += xi_delta;
    yi += yi_delta;
    rgba += 4;

    i++;
  }
}


static inline void
ctx_fragment_image_rgba8_RGBA8_bi_generic (CtxRasterizer *rasterizer,
                                           float x, float y, float z,
                                           void *out, int scount,
                                           float dx, float dy, float dz)
{
        x-=0.5f;
        y-=0.5f;
  uint32_t count = scount;
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  CtxExtend extend = rasterizer->state->gstate.extend;
  const int bwidth = buffer->width;
  const int bheight = buffer->height;
  unsigned int i = 0;
  uint32_t *data = ((uint32_t*)buffer->data);

  int yi_delta = (int)(dy * 65536);
  int xi_delta = (int)(dx * 65536);
  int zi_delta = (int)(dz * 65536);
  int32_t yi = (int)(y * 65536);
  int32_t xi = (int)(x * 65536);
  int32_t zi = (int)(z * 65536);
  if (extend == CTX_EXTEND_NONE) {
    int32_t u1 = xi + xi_delta* (count-1);
    int32_t v1 = yi + yi_delta* (count-1);
    int32_t z1 = zi + zi_delta* (count-1);
    uint32_t *edst = ((uint32_t*)out)+(count-1);
    for (; i < count; )
    {
      float z_recip = (z1!=0) * (1.0f/z1);
      if ((u1*z_recip) <0 ||
          (v1*z_recip) <0 ||
          (u1*z_recip) >= (bwidth) - 1 ||
          (v1*z_recip) >= (bheight) - 1)
      {
        *edst-- = 0;
        count --;
        u1 -= xi_delta;
        v1 -= yi_delta;
        z1 -= zi_delta;
      }
      else break;
    }

  for (i= 0; i < count; i ++)
  {
    float z_recip = (zi!=0) * (1.0f/zi);
    int u = (int)(xi * z_recip);
    int v = (int)(yi * z_recip);
    if ((u <= 0) | (v <= 0) | (u+1 >= bwidth-1) | (v+1 >= bheight-1))
    {
      *((uint32_t*)(rgba))= 0;
    }
    else
      break;
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;
  }
  }

  uint32_t *src00=data;
  uint32_t *src01=data;
  uint32_t *src10=data;
  uint32_t *src11=data;

  if (global_alpha_u8==255)
  while (i < count)
  {
    float zr = (zi!=0)*(1.0f/zi) * 256;
    int du = (int)(xi * zr);
    int u = du >> 8;
    int dv = (int)(yi * zr);
    int v = dv >> 8;
    if (CTX_UNLIKELY((u < 0) | (v < 0) | (u+1 >= bwidth) | (v+1 >=bheight))) // default to next sample down and to right
    {
      int u1 = u + 1;
      int v1 = v + 1;

      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      _ctx_coords_restrict (extend, &u1, &v1, bwidth, bheight);

      src00 = data  + bwidth * v + u;
      src01 = data  + bwidth * v + u1;
      src10 = data  + bwidth * v1 + u;
      src11 = data  + bwidth * v1 + u1;
    }
    else 
    {
      src00 = data  + bwidth * v + u;
      src01 = src00 + 1;
      src10 = src00 + bwidth;
      src11 = src01 + bwidth;
    }
    ((uint32_t*)(&rgba[0]))[0] = ctx_bi_RGBA8_alpha (*src00,*src01,*src10,*src11, du,dv);
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;

    i++;
  }
  else
  while (i < count)
  {
    float zr = (zi!=0)*(1.0f/zi) * 256;
    int du = (int)(xi * zr);
    int u = du >> 8;
    int dv = (int)(yi * zr);
    int v = dv >> 8;
    if (CTX_UNLIKELY((u < 0) | (v < 0) | (u+1 >= bwidth) | (v+1 >=bheight))) // default to next sample down and to right
    {
      int u1 = u + 1;
      int v1 = v + 1;

      _ctx_coords_restrict (extend, &u, &v, bwidth, bheight);
      _ctx_coords_restrict (extend, &u1, &v1, bwidth, bheight);

      src00 = data  + bwidth * v + u;
      src01 = data  + bwidth * v + u1;
      src10 = data  + bwidth * v1 + u;
      src11 = data  + bwidth * v1 + u1;
    }
    else 
    {
      src00 = data  + bwidth * v + u;
      src01 = src00 + 1;
      src10 = src00 + bwidth;
      src11 = src01 + bwidth;
    }
    ((uint32_t*)(&rgba[0]))[0] =
        ctx_RGBA8_mul_alpha_u32 (
            ctx_bi_RGBA8_alpha (*src00,*src01,*src10,*src11, du,dv), global_alpha_u8);
    xi += xi_delta;
    yi += yi_delta;
    zi += zi_delta;
    rgba += 4;

    i++;
  }
}


static void
ctx_fragment_image_rgba8_RGBA8_bi (CtxRasterizer *rasterizer,
                                   float x, float y, float z,
                                   void *out, int icount, float dx, float dy, float dz)
{
  unsigned int count = icount;
  if ((dy == 0.0f) & (dx > 0.0f) & (z==1.0f) & (dz==0.0f))
  {
    ctx_fragment_image_rgba8_RGBA8_bi_scale (rasterizer, x, y, z, out, count, dx, dy, dz);
  }
  else if ((z == 1.0f) & (dz == 0.0f))
    ctx_fragment_image_rgba8_RGBA8_bi_affine (rasterizer, x, y, z, out, count, dx, dy, dz);
  else
  {
    ctx_fragment_image_rgba8_RGBA8_bi_generic (rasterizer, x, y, z, out, count, dx, dy, dz);
  }
}
#endif

#define ctx_clamp_byte(val) \
  val *= val > 0;\
  val = (val > 255) * 255 + (val <= 255) * val

#if CTX_YUV_LUTS
static const int16_t ctx_y_to_cy[256]={
-19,-18,-17,-16,-14,-13,-12,-11,-10,-9,-7,-6,-5,-4,-3,
-2,0,1,2,3,4,5,6,8,9,10,11,12,13,15,
16,17,18,19,20,22,23,24,25,26,27,29,30,31,32,
33,34,36,37,38,39,40,41,43,44,45,46,47,48,50,
51,52,53,54,55,57,58,59,60,61,62,64,65,66,67,
68,69,71,72,73,74,75,76,78,79,80,81,82,83,84,
86,87,88,89,90,91,93,94,95,96,97,98,100,101,102,
103,104,105,107,108,109,110,111,112,114,115,116,117,118,119,
121,122,123,124,125,126,128,129,130,131,132,133,135,136,137,
138,139,140,142,143,144,145,146,147,149,150,151,152,153,154,
156,157,158,159,160,161,163,164,165,166,167,168,169,171,172,
173,174,175,176,178,179,180,181,182,183,185,186,187,188,189,
190,192,193,194,195,196,197,199,200,201,202,203,204,206,207,
208,209,210,211,213,214,215,216,217,218,220,221,222,223,224,
225,227,228,229,230,231,232,234,235,236,237,238,239,241,242,
243,244,245,246,248,249,250,251,252,253,254,256,257,258,259,
260,261,263,264,265,266,267,268,270,271,272,273,274,275,277,
278};
static const int16_t ctx_u_to_cb[256]={
-259,-257,-255,-253,-251,-249,-247,-245,-243,-241,-239,-237,-234,-232,-230,
-228,-226,-224,-222,-220,-218,-216,-214,-212,-210,-208,-206,-204,-202,-200,
-198,-196,-194,-192,-190,-188,-186,-184,-182,-180,-178,-176,-174,-172,-170,
-168,-166,-164,-162,-160,-158,-156,-154,-152,-150,-148,-146,-144,-142,-140,
-138,-136,-134,-132,-130,-128,-126,-124,-122,-120,-117,-115,-113,-111,-109,
-107,-105,-103,-101,-99,-97,-95,-93,-91,-89,-87,-85,-83,-81,-79,
-77,-75,-73,-71,-69,-67,-65,-63,-61,-59,-57,-55,-53,-51,-49,
-47,-45,-43,-41,-39,-37,-35,-33,-31,-29,-27,-25,-23,-21,-19,
-17,-15,-13,-11,-9,-7,-5,-3,0,2,4,6,8,10,12,
14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,
44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
104,106,108,110,112,114,116,119,121,123,125,127,129,131,133,
135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,
165,167,169,171,173,175,177,179,181,183,185,187,189,191,193,
195,197,199,201,203,205,207,209,211,213,215,217,219,221,223,
225,227,229,231,233,236,238,240,242,244,246,248,250,252,254,
256};
static const int16_t ctx_v_to_cr[256]={
-205,-203,-202,-200,-198,-197,-195,-194,-192,-190,-189,-187,-186,-184,-182,
-181,-179,-178,-176,-174,-173,-171,-170,-168,-166,-165,-163,-162,-160,-159,
-157,-155,-154,-152,-151,-149,-147,-146,-144,-143,-141,-139,-138,-136,-135,
-133,-131,-130,-128,-127,-125,-123,-122,-120,-119,-117,-115,-114,-112,-111,
-109,-107,-106,-104,-103,-101,-99,-98,-96,-95,-93,-91,-90,-88,-87,
-85,-83,-82,-80,-79,-77,-76,-74,-72,-71,-69,-68,-66,-64,-63,
-61,-60,-58,-56,-55,-53,-52,-50,-48,-47,-45,-44,-42,-40,-39,
-37,-36,-34,-32,-31,-29,-28,-26,-24,-23,-21,-20,-18,-16,-15,
-13,-12,-10,-8,-7,-5,-4,-2,0,1,3,4,6,7,9,
11,12,14,15,17,19,20,22,23,25,27,28,30,31,33,
35,36,38,39,41,43,44,46,47,49,51,52,54,55,57,
59,60,62,63,65,67,68,70,71,73,75,76,78,79,81,
82,84,86,87,89,90,92,94,95,97,98,100,102,103,105,
106,108,110,111,113,114,116,118,119,121,122,124,126,127,129,
130,132,134,135,137,138,140,142,143,145,146,148,150,151,153,
154,156,158,159,161,162,164,165,167,169,170,172,173,175,177,
178,180,181,183,185,186,188,189,191,193,194,196,197,199,201,
202};

#endif

static inline uint32_t ctx_yuv_to_rgba32 (uint8_t y, uint8_t u, uint8_t v)
{
#if CTX_YUV_LUTS
  int cy  = ctx_y_to_cy[y];
  int red = cy + ctx_v_to_cr[v];
  int green = cy - (((u-128) * 25674 + (v-128) * 53278) >> 16);
  int blue = cy + ctx_u_to_cb[u];
#else
  int cy  = ((y - 16) * 76309) >> 16;
  int cr  = (v - 128);
  int cb  = (u - 128);
  int red = cy + ((cr * 104597) >> 16);
  int green = cy - ((cb * 25674 + cr * 53278) >> 16);
  int blue = cy + ((cb * 132201) >> 16);
#endif
  ctx_clamp_byte (red);
  ctx_clamp_byte (green);
  ctx_clamp_byte (blue);
  return red |
  (green << 8) |
  (blue << 16) |
  (0xff << 24);
}

static void
ctx_fragment_image_yuv420_RGBA8_nearest (CtxRasterizer *rasterizer,
                                         float x, float y, float z,
                                         void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  CtxBuffer *buffer = g->texture.buffer;
#if CTX_ENABLE_CM
  if (buffer->color_managed)
    buffer = buffer->color_managed;
#endif
  uint8_t *src = (uint8_t *) buffer->data;
  int bwidth  = buffer->width;
  int bheight = buffer->height;
  int bwidth_div_2  = bwidth/2;
  int bheight_div_2  = bheight/2;
  x += 0.5f;
  y += 0.5f;

#if CTX_DITHER
  int bits = rasterizer->format->bpp;
  int scan = rasterizer->scanline / CTX_FULL_AA;
  int dither_red_blue = rasterizer->format->dither_red_blue;
  int dither_green  = rasterizer->format->dither_green;
#endif

  if (isinf(dx) || isnan(dx) || isnan (dy) || isinf (dy))
    return;

  if (!src)
    return;

  {
    int i = 0;

    float  u1 = x + dx * (count-1);
    float  v1 = y + dy * (count-1);
    uint32_t *edst = ((uint32_t*)out)+count - 1;
    for (; i < count; )
    {
      if ((u1 <0) | (v1 < 0) | (u1 >= bwidth) | (v1 >= bheight))
      {
        *edst-- = 0;
        count --;
        u1 -= dx;
        v1 -= dy;
      }
      else break;
    }

    for (; i < count; i ++)
    {
      int u = (int)x;
      int v = (int)y;
      if ((u < 0) | (v < 0) | (u >= bwidth) | (v >= bheight))
      {
        *((uint32_t*)(rgba))= 0;
      }
      else
      {
        break;
      }
      x += dx;
      y += dy;
      rgba += 4;
    }

    uint32_t u_offset = bheight * bwidth;
    uint32_t v_offset = u_offset + bheight_div_2 * bwidth_div_2;

    if (rasterizer->swap_red_green)
    {
      v_offset = bheight * bwidth;
      u_offset = v_offset + bheight_div_2 * bwidth_div_2;
    }

    // XXX this is incorrect- but fixes some bug!
    int ix = 65536;//x * 65536;
    int iy = (int)(y * 65536);

    int ideltax = (int)(dx * 65536);
    int ideltay = (int)(dy * 65536);

    if (ideltay == 0)
    {
      int u = ix >> 16;
      int v = iy >> 16;

      uint32_t y  = v * bwidth;
      uint32_t uv = (v / 2) * bwidth_div_2;

      if ((v < 0) | (v >= bheight) | 
          (u < 0) | (u >= bwidth) |
          (((iy + ideltay * count)>>16) < 0) | (((iy + ideltay *count)>>16) >= bheight) | 
          (((ix + ideltax * count)>>16) < 0) | (((ix + ideltax *count)>>16) >= bwidth))
        return;

      if ((v >= 0) & (v < bheight))
      {
#if CTX_DITHER
       if (bits < 24)
       {
         while (i < count)// && u >= 0 && u+1 < bwidth)
         {
           *((uint32_t*)(rgba))= ctx_yuv_to_rgba32 (src[y+u],
                        src[u_offset+uv+u/2], src[v_offset+uv+u/2]);

           ctx_dither_rgba_u8 (rgba, i, scan, dither_red_blue, dither_green);
           ix += ideltax;
           rgba += 4;
           u = ix >> 16;
           i++;
         }
        }
        else
#endif
        while (i < count)// && u >= 0 && u+1 < bwidth)
        {
          *((uint32_t*)(rgba))= ctx_yuv_to_rgba32 (src[y+u],
                          src[u_offset+uv+u/2], src[v_offset+uv+u/2]);
  
          ix += ideltax;
          rgba += 4;
          u = ix >> 16;
          i++;
        }
      }
    }
    else
    {
      int u = ix >> 16;
      int v = iy >> 16;

      if ((v < 0) | (v >= bheight) | 
          (u < 0) | (u >= bwidth) |
          (((iy + ideltay * count)>>16) < 0) | (((iy + ideltay *count)>>16) >= bheight) | 
          (((ix + ideltax * count)>>16) < 0) | (((ix + ideltax *count)>>16) >= bwidth))
        return;

#if CTX_DITHER
       if (bits < 24)
       {
         while (i < count)// && u >= 0 && v >= 0 && u < bwidth && v < bheight)
         {
           uint32_t y  = v * bwidth + u;
           uint32_t uv = (v / 2) * bwidth_div_2 + (u / 2);

           *((uint32_t*)(rgba))= ctx_yuv_to_rgba32 (src[y],
                        src[u_offset+uv], src[v_offset+uv]);

           ctx_dither_rgba_u8 (rgba, i, scan, dither_red_blue, dither_green);
           ix += ideltax;
           iy += ideltay;
           rgba += 4;
           u = ix >> 16;
           v = iy >> 16;
           i++;
         }
       } else
#endif
       while (i < count)// && u >= 0 && v >= 0 && u < bwidth && v < bheight)
       {
          uint32_t y  = v * bwidth + u;
          uint32_t uv = (v / 2) * bwidth_div_2 + (u / 2);

          *((uint32_t*)(rgba))= ctx_yuv_to_rgba32 (src[y],
                        src[u_offset+uv], src[v_offset+uv]);

          ix += ideltax;
          iy += ideltay;
          rgba += 4;
          u = ix >> 16;
          v = iy >> 16;
          i++;
       }
    }

    for (; i < count; i++)
    {
      *((uint32_t*)(rgba))= 0;
      rgba += 4;
    }
  }

  if (rasterizer->state->gstate.global_alpha_u8 != 255)
    ctx_RGBA8_apply_global_alpha_and_associate (rasterizer, (uint8_t*)out, count);
}

#if CTX_FRAGMENT_SPECIALIZE

CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_box)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_bi)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_nearest)

CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_nearest_copy)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_nearest_copy_repeat)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_nearest_scale)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_nearest_affine)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_nearest_generic)

CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_bi_scale)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_bi_affine)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_bi_generic)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_bi_scale_with_alpha)
CTX_DECLARE_SWAP_RED_GREEN_FRAGMENT(ctx_fragment_image_rgba8_RGBA8_bi_affine_with_alpha)

static inline void
ctx_fragment_image_rgba8_RGBA8 (CtxRasterizer *rasterizer,
                                float x, float y, float z,
                                void *out, int count, float dx, float dy, float dz)
{
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  int image_smoothing = rasterizer->state->gstate.image_smoothing;
  if (buffer->width == 1 || buffer->height == 1)
        image_smoothing = 0;
  if (image_smoothing)
  {
    float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
    if (factor <= 0.50f)
    {
      if (rasterizer->swap_red_green)
        ctx_fragment_image_rgba8_RGBA8_box_swap_red_green (rasterizer, x, y, z, out, count, dx, dy, dz);
      else
        ctx_fragment_image_rgba8_RGBA8_box (rasterizer, x, y, z, out, count, dx, dy, dz);
    }
#if CTX_ALWAYS_USE_NEAREST_FOR_SCALE1
    else if ((factor > 0.99f) & (factor < 1.01f))
    {
      // XXX: also verify translate == 0 for this fast path to be valid
      if (rasterizer->swap_red_green)
        ctx_fragment_image_rgba8_RGBA8_nearest_swap_red_green (rasterizer, x, y, z, out, count, dx, dy, dz);
      else
        ctx_fragment_image_rgba8_RGBA8_nearest (rasterizer, x, y, z, out, count, dx, dy, dz);
    }
#endif
    else
    {
      if (rasterizer->swap_red_green)
        ctx_fragment_image_rgba8_RGBA8_bi_swap_red_green (rasterizer, x, y, z, out, count, dx, dy, dz);
      else
        ctx_fragment_image_rgba8_RGBA8_bi (rasterizer, x, y, z, out, count, dx, dy, dz);
    }
  }
  else
  {
    if (rasterizer->swap_red_green)
      ctx_fragment_image_rgba8_RGBA8_nearest_swap_red_green (rasterizer, x, y, z, out, count, dx, dy, dz);
    else
      ctx_fragment_image_rgba8_RGBA8_nearest (rasterizer, x, y, z, out, count, dx, dy, dz);
  }
  //ctx_fragment_swap_red_green_u8 (out, count);
#if 0
#if CTX_DITHER
  uint8_t *rgba = (uint8_t*)out;
  ctx_dither_rgba_u8 (rgba, x, y, rasterizer->format->dither_red_blue,
                      rasterizer->format->dither_green);
#endif
#endif
}

static void
ctx_fragment_image_gray1_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  CtxBuffer *buffer = g->texture.buffer;
  for (int i = 0; i < count; i ++)
  {
  int u = (int)x;
  int v = (int)y;
  if ( (u < 0) | (v < 0) |
       (u >= buffer->width) |
       (v >= buffer->height))
    {
      rgba[0] = rgba[1] = rgba[2] = rgba[3] = 0;
    }
  else
    {
      uint8_t *src = (uint8_t *) buffer->data;
      src += v * buffer->stride + u / 8;
      if (*src & (1<< (u & 7) ) )
        {
          rgba[0] = rgba[1] = rgba[2] = rgba[3] = 0;
        }
      else
        {
          for (int c = 0; c < 4; c++)
            { rgba[c] = 255;
            }//g->texture.rgba[c];
            //}
        }
    }

    rgba += 4;
    x += dx;
    y += dy;
  }
}

#endif


#if CTX_GRADIENTS
static void
ctx_fragment_radial_gradient_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_DITHER
  int scan = rasterizer->scanline / CTX_FULL_AA;
  int dither_red_blue = rasterizer->format->dither_red_blue;
  int dither_green  = rasterizer->format->dither_green;
  int ox = (int)x;
#endif

  float rg_x0 = g->radial_gradient.x0;
  float rg_y0 = g->radial_gradient.y0;
  float rg_r0 = g->radial_gradient.r0;
  float rg_rdelta = g->radial_gradient.rdelta;

  x = rg_x0 - x;
  y = rg_y0 - y;

  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  if (global_alpha_u8 != 255)
  for (int i = 0; i <  count; i ++)
  {
    float v = (ctx_hypotf_fast (x, y) - rg_r0) * (rg_rdelta);
#if CTX_GRADIENT_CACHE
    uint32_t *rgbap = (uint32_t*)&(rasterizer->gradient_cache_u8[ctx_grad_index(rasterizer, v)][0]);
    *((uint32_t*)rgba) = *rgbap;
#else
    ctx_fragment_gradient_1d_RGBA8 (rasterizer, v, 0.0, rgba);
#endif

#if CTX_DITHER
    ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
    *((uint32_t*)rgba) =
      ctx_RGBA8_mul_alpha_u32(*((uint32_t*)rgba), global_alpha_u8);
    rgba += 4;
    x -= dx;
    y -= dy;
  }
  else
  if (dy == 0.0f)
  {
     float sq_y = y * y;
  for (int i = 0; i <  count; i ++)
  {
    float v = (ctx_sqrtf_fast (x*x+sq_y) - rg_r0) * (rg_rdelta);
#if CTX_GRADIENT_CACHE
    uint32_t *rgbap = (uint32_t*)&(rasterizer->gradient_cache_u8[ctx_grad_index(rasterizer, v)][0]);
    *((uint32_t*)rgba) = *rgbap;
#else
    ctx_fragment_gradient_1d_RGBA8 (rasterizer, v, 0.0, rgba);
#endif

#if CTX_DITHER
    ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
    rgba += 4;
    x -= dx;
  }
  }
  else
  for (int i = 0; i <  count; i ++)
  {
    float v = (ctx_hypotf_fast (x, y) - rg_r0) * (rg_rdelta);
#if CTX_GRADIENT_CACHE
    uint32_t *rgbap = (uint32_t*)&(rasterizer->gradient_cache_u8[ctx_grad_index(rasterizer, v)][0]);
    *((uint32_t*)rgba) = *rgbap;
#else
    ctx_fragment_gradient_1d_RGBA8 (rasterizer, v, 0.0, rgba);
#endif

#if CTX_DITHER
    ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
    rgba += 4;
    x -= dx;
    y -= dy;
  }
}

static void
ctx_fragment_conic_gradient_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;
#if CTX_DITHER
  int scan = rasterizer->scanline / CTX_FULL_AA;
  int dither_red_blue = rasterizer->format->dither_red_blue;
  int dither_green  = rasterizer->format->dither_green;
  int ox = (int)x;
#endif
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float cx = g->conic_gradient.x;
  float cy = g->conic_gradient.y;
  float offset = g->conic_gradient.start_angle;
  float cycles = g->conic_gradient.cycles;
  if (cycles < 0.01) cycles = 1.0f;

  float scale = cycles/(M_PI * 2);
#if CTX_GRADIENT_CACHE
  float fscale = (rasterizer->gradient_cache_elements-1) * 256;
#endif

  x-=cx;
  y-=cy;

  offset += M_PI;

  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  if (global_alpha_u8 != 255)
  for (int i = 0; i < count ; i++)
  {
#if CTX_GRADIENT_CACHE
    int vv = ctx_fmod1f((ctx_atan2f (x,y) + offset) * scale) * fscale;
  *((uint32_t*)rgba) = *((uint32_t*)(&rasterizer->gradient_cache_u8[ctx_grad_index_i (rasterizer, vv)][0]));
#else
    float vv = ctx_fmod1f((ctx_atan2f (x,y) + offset) * scale);
  _ctx_fragment_gradient_1d_RGBA8 (rasterizer, vv, 1.0, rgba);
#endif
#if CTX_DITHER
      ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
  *((uint32_t*)rgba) =
    ctx_RGBA8_mul_alpha_u32(*((uint32_t*)rgba), global_alpha_u8);
    rgba+= 4;
    x += dx;
    y += dy;
  }
  else
  {
  if ((dy == 0.0f) & (y != 0.0f))
  {
    float y_recip = 1.0f/y;
  for (int i = 0; i < count ; i++)
  {
#if CTX_GRADIENT_CACHE
    int vv = ctx_fmod1f((ctx_atan2f_rest (x,y_recip) + offset) * scale) * fscale;
  *((uint32_t*)rgba) = *((uint32_t*)(&rasterizer->gradient_cache_u8[ctx_grad_index_i (rasterizer, vv)][0]));
#else
    float vv = ctx_fmod1f((ctx_atan2f_rest (x,y_recip) + offset) * scale);
  _ctx_fragment_gradient_1d_RGBA8 (rasterizer, vv, 1.0f, rgba);
#endif
#if CTX_DITHER
      ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
    rgba+= 4;
    x += dx;
  }
  }
  else
  for (int i = 0; i < count ; i++)
  {
#if CTX_GRADIENT_CACHE
    int vv = ctx_fmod1f((ctx_atan2f (x,y) + offset) * scale) * fscale;
  *((uint32_t*)rgba) = *((uint32_t*)(&rasterizer->gradient_cache_u8[ctx_grad_index_i (rasterizer, vv)][0]));
#else
    float vv = ctx_fmod1f((ctx_atan2f (x,y) + offset) * scale);
  _ctx_fragment_gradient_1d_RGBA8 (rasterizer, vv, 1.0f, rgba);
#endif
#if CTX_DITHER
      ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
    rgba+= 4;
    x += dx;
    y += dy;
  }
    
  }
}
  
static void
ctx_fragment_linear_gradient_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba = (uint8_t *) out;

  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float u0 = x; float v0 = y;
  float ud = dx; float vd = dy;
  float linear_gradient_dx = g->linear_gradient.dx_scaled;
  float linear_gradient_dy = g->linear_gradient.dy_scaled;
  float linear_gradient_start = g->linear_gradient.start_scaled;

#if CTX_DITHER
  int dither_red_blue = rasterizer->format->dither_red_blue;
  int dither_green = rasterizer->format->dither_green;
  int scan = rasterizer->scanline / CTX_FULL_AA;
  int ox = (int)x;
#endif

  u0 *= linear_gradient_dx;
  v0 *= linear_gradient_dy;
  ud *= linear_gradient_dx;
  vd *= linear_gradient_dy;

#if CTX_GRADIENT_CACHE
  int vv = (int)(((u0 + v0) - linear_gradient_start) * (rasterizer->gradient_cache_elements-1) * 256);
  int ud_plus_vd = (int)((ud + vd) * (rasterizer->gradient_cache_elements-1) * 256);
#else
  float vv = ((u0 + v0) - linear_gradient_start);
  float ud_plus_vd = (ud + vd);
#endif

  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  if (global_alpha_u8 != 255)
  for (int i = 0; i < count ; i++)
  {
#if CTX_GRADIENT_CACHE
  *((uint32_t*)rgba) = *((uint32_t*)(&rasterizer->gradient_cache_u8[ctx_grad_index_i (rasterizer, vv)][0]));
#else
  _ctx_fragment_gradient_1d_RGBA8 (rasterizer, vv, 1.0, rgba);
#endif
#if CTX_DITHER
      ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
  *((uint32_t*)rgba) =
    ctx_RGBA8_mul_alpha_u32(*((uint32_t*)rgba), global_alpha_u8);
    rgba+= 4;
    vv += ud_plus_vd;
  }
  else
  for (int i = 0; i < count ; i++)
  {
#if CTX_GRADIENT_CACHE
  *((uint32_t*)rgba) = *((uint32_t*)(&rasterizer->gradient_cache_u8[ctx_grad_index_i (rasterizer, vv)][0]));
#else
  _ctx_fragment_gradient_1d_RGBA8 (rasterizer, vv, 1.0, rgba);
#endif
#if CTX_DITHER
      ctx_dither_rgba_u8 (rgba, ox+i, scan, dither_red_blue, dither_green);
#endif
    rgba+= 4;
    vv += ud_plus_vd;
  }
}

#endif

static void
ctx_fragment_none_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba_out = (uint8_t *) out;
  uint32_t blank = 0;
  for (int i = 0; i < count; i++)
    memcpy (rgba_out + count * 4, &blank, 4);
}

static void
ctx_fragment_color_RGBA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *rgba_out = (uint8_t *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  ctx_color_get_rgba8 (rasterizer->state, &g->color, rgba_out);
  ctx_RGBA8_associate_alpha (rgba_out);
  if (rasterizer->swap_red_green)
  {
    int tmp = rgba_out[0];
    rgba_out[0] = rgba_out[2];
    rgba_out[2] = tmp;
  }
  for (int i = 1; i < count; i++)
    memcpy (rgba_out + count * 4, rgba_out, 4);
}
#if CTX_ENABLE_FLOAT

#if CTX_GRADIENTS
static void
ctx_fragment_linear_gradient_RGBAF (CtxRasterizer *rasterizer, float u0, float v0, float z, void *out, int count, float ud, float vd, float dz)
{
  float *rgba = (float *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float linear_gradient_dx = g->linear_gradient.dx_scaled;
  float linear_gradient_dy = g->linear_gradient.dy_scaled;
  float linear_gradient_start = g->linear_gradient.start_scaled;

  u0 *= linear_gradient_dx;
  v0 *= linear_gradient_dy;
  ud *= linear_gradient_dx;
  vd *= linear_gradient_dy;

  float vv = ((u0 + v0) - linear_gradient_start);
  float ud_plus_vd = (ud + vd);

  for (int i = 0; i < count ; i++)
  {
    ctx_fragment_gradient_1d_RGBAF (rasterizer, vv, 1.0f, rgba);
    rgba+= 4;
    vv += ud_plus_vd;
  }
}

static void
ctx_fragment_radial_gradient_RGBAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *rgba = (float *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float rg_x0 = g->radial_gradient.x0;
  float rg_y0 = g->radial_gradient.y0;
  float rg_r0 = g->radial_gradient.r0;
  float rg_rdelta = g->radial_gradient.rdelta;
  for (int i = 0; i < count; i++)
  {
    float v = (ctx_hypotf (rg_x0 - x, rg_y0 - y) - rg_r0) * rg_rdelta;
    ctx_fragment_gradient_1d_RGBAF (rasterizer, v, 0.0f, rgba);
    x+=dx;
    y+=dy;
    rgba +=4;
  }
}

static void
ctx_fragment_conic_gradient_RGBAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *rgba = (float *) out;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float cx = g->conic_gradient.x;
  float cy = g->conic_gradient.y;
  float offset = g->conic_gradient.start_angle;
  float cycles = g->conic_gradient.cycles;
  if (cycles < 0.01) cycles = 1.0f;

  float scale = cycles/(M_PI * 2);

  x-=cx;
  y-=cy;

  offset += M_PI;

  for (int i = 0; i < count ; i++)
  {
    float v = (ctx_atan2f (x,y) + offset) * scale;
    v = ctx_fmod1f(v);
    ctx_fragment_gradient_1d_RGBAF (rasterizer, v, 0.0f, rgba);
    rgba+= 4;
    x += dx;
    y += dy;
  }
}
  
#endif

static void
ctx_fragment_none_RGBAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *rgba = (float *) out;
  for (int i = 0; i < count * 4; i++)
  {
    rgba[i] = 0.0f;
  }
}

static void
ctx_fragment_color_RGBAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *rgba = (float *) out;
  float  in[4];
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  ctx_color_get_rgba (rasterizer->state, &g->color, in);
  for (int c = 0; c < 3; c++)
    in[c] *= in[3];
  while (count--)
  {
    for (int c = 0; c < 4; c++)
      rgba[c] = in[c];
    rgba += 4;
  }
}


static void ctx_fragment_image_RGBAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *outf = (float *) out;
  uint8_t rgba[4 * count];
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
  CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
  CtxBuffer *buffer = g->texture.buffer;
#endif
  switch (buffer->format->bpp)
    {
#if CTX_FRAGMENT_SPECIALIZE
      case 1:  ctx_fragment_image_gray1_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz); break;
      case 24: ctx_fragment_image_rgb8_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz);  break;
      case 32: ctx_fragment_image_rgba8_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz); break;
#endif
      default: ctx_fragment_image_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz);       break;
    }
  for (int c = 0; c < 4 * count; c ++) { outf[c] = ctx_u8_to_float (rgba[c]); }
}

static CtxFragment ctx_rasterizer_get_fragment_RGBAF (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  switch (gstate->source_fill.type)
    {
      case CTX_SOURCE_TEXTURE:         return ctx_fragment_image_RGBAF;
      case CTX_SOURCE_COLOR:           return ctx_fragment_color_RGBAF;
      case CTX_SOURCE_NONE:            return ctx_fragment_none_RGBAF;
#if CTX_GRADIENTS
      case CTX_SOURCE_LINEAR_GRADIENT: return ctx_fragment_linear_gradient_RGBAF;
      case CTX_SOURCE_RADIAL_GRADIENT: return ctx_fragment_radial_gradient_RGBAF;
      case CTX_SOURCE_CONIC_GRADIENT: return ctx_fragment_conic_gradient_RGBAF;
#endif
    }
  return ctx_fragment_none_RGBAF;
}
#endif


static inline int
ctx_matrix_no_perspective (CtxMatrix *matrix)
{
  if (fabsf(matrix->m[2][0]) >0.001f) return 0;
  if (fabsf(matrix->m[2][1]) >0.001f) return 0;
  if (fabsf(matrix->m[2][2] - 1.0f)>0.001f) return 0;
  return 1;
}

/* for multiples of 90 degree rotations, we return no rotation */
static inline int
ctx_matrix_no_skew_or_rotate (CtxMatrix *matrix)
{
  if (fabsf(matrix->m[0][1]) >0.001f) return 0;
  if (fabsf(matrix->m[1][0]) >0.001f) return 0;
  return ctx_matrix_no_perspective (matrix);
}

static inline float
ctx_matrix_determinant (const CtxMatrix *m);

static int ctx_sane_transform(CtxMatrix *transform)
{
  if ((int)(ctx_fabsf (transform->m[0][0]) < 0.0001f) |
      (int)(ctx_fabsf (transform->m[1][1]) < 0.0001f) |
      (int)(ctx_fabsf (transform->m[2][2]) < 0.0001f))
          return 0;
  return 1;
  //return (ctx_fabsf(ctx_matrix_determinant (&gstate->transform)) >= 0.0001f);
}

static CtxFragment ctx_rasterizer_get_fragment_RGBA8 (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  switch (gstate->source_fill.type)
    {
      case CTX_SOURCE_TEXTURE:
      {
#if CTX_ENABLE_CM
         CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
         CtxBuffer *buffer = g->texture.buffer;
#endif


        if (!buffer || !buffer->format)
          return ctx_fragment_none_RGBA8;

#if CTX_FRAGMENT_SPECIALIZE
         int image_smoothing = gstate->image_smoothing;
         if (buffer->width == 1 || buffer->height == 1)
           image_smoothing = 0;
#endif
  
        if (!ctx_sane_transform(&gstate->source_fill.transform))
          return ctx_fragment_none_RGBA8;


        if (buffer->format->pixel_format == CTX_FORMAT_YUV420)
        {
          return ctx_fragment_image_yuv420_RGBA8_nearest;
        }
        else
#if CTX_FRAGMENT_SPECIALIZE
        switch (buffer->format->bpp)
          {
            case 1: return ctx_fragment_image_gray1_RGBA8;
#if 1
            case 24: 
              {
                if (image_smoothing)
                {
                  float factor = ctx_matrix_get_scale (&gstate->transform);
                          //fprintf (stderr, "{%.3f}", factor);
                  if (factor < 0.5f)
                  {
                    if (rasterizer->swap_red_green)
                      return ctx_fragment_image_rgb8_RGBA8_box_swap_red_green;
                    return ctx_fragment_image_rgb8_RGBA8_box;
                  }
#if CTX_ALWAYS_USE_NEAREST_FOR_SCALE1
                  else if ((factor > 0.99f) & (factor < 1.01f))
                  {
                    if (rasterizer->swap_red_green)
                      return ctx_fragment_image_rgb8_RGBA8_nearest_swap_red_green;
                    return ctx_fragment_image_rgb8_RGBA8_nearest;
                  }
#endif
                  else
                  {
                    if (rasterizer->swap_red_green)
                      return ctx_fragment_image_rgb8_RGBA8_bi_swap_red_green;
                    return ctx_fragment_image_rgb8_RGBA8_bi;
                  }
                }
                else
                {
                  if (rasterizer->swap_red_green)
                    return ctx_fragment_image_rgb8_RGBA8_nearest_swap_red_green;
                  return ctx_fragment_image_rgb8_RGBA8_nearest;
                }
              }
              break;
#endif
            case 32:
              {
                CtxMatrix *transform = &gstate->source_fill.transform;
                CtxExtend extend = rasterizer->state->gstate.extend;
                if (image_smoothing)
                {
                  float factor = ctx_matrix_get_scale (&gstate->transform);
                          //fprintf (stderr, "[%.3f]", factor);
                  if (factor < 0.5f)
                  {
                    if (rasterizer->swap_red_green)
                      return ctx_fragment_image_rgba8_RGBA8_box_swap_red_green;
                    return ctx_fragment_image_rgba8_RGBA8_box;
                  }
#if CTX_ALWAYS_USE_NEAREST_FOR_SCALE1
                  else if ((factor > 0.99f) & (factor < 1.01f) & (extend == CTX_EXTEND_NONE))
                  {
                    if (rasterizer->swap_red_green)
                      return ctx_fragment_image_rgba8_RGBA8_nearest_copy_swap_red_green;
                    return ctx_fragment_image_rgba8_RGBA8_nearest_copy;
                  }
#endif
                  else
                  {
                    if (rasterizer->swap_red_green)
                    {
                      if (ctx_matrix_no_perspective (transform))
                      {
                        if (ctx_matrix_no_skew_or_rotate (transform))
                        {
                          if ((int)(ctx_fabsf (transform->m[0][0] - 1.0f) < 0.001f) &
                              (ctx_fabsf (transform->m[1][1] - 1.0f) < 0.001f) &
                              (ctx_fmod1f (transform->m[0][2]) < 0.001f) &
                              (ctx_fmod1f (transform->m[1][2]) < 0.001f))
                          {
                            if (extend == CTX_EXTEND_NONE)
                              return ctx_fragment_image_rgba8_RGBA8_nearest_copy_swap_red_green;
                            else if (extend == CTX_EXTEND_REPEAT)
                              return ctx_fragment_image_rgba8_RGBA8_nearest_copy_repeat_swap_red_green;
                          }
                          return gstate->global_alpha_u8==255?
                              ctx_fragment_image_rgba8_RGBA8_bi_scale_swap_red_green
                             :ctx_fragment_image_rgba8_RGBA8_bi_scale_with_alpha_swap_red_green;
                        }
                        return gstate->global_alpha_u8==255?
                        ctx_fragment_image_rgba8_RGBA8_bi_affine_swap_red_green
                        :ctx_fragment_image_rgba8_RGBA8_bi_affine_with_alpha_swap_red_green;
                      }
                        return ctx_fragment_image_rgba8_RGBA8_bi_generic_swap_red_green;
                    }

                    if (ctx_matrix_no_perspective (transform))
                    {
                      if (ctx_matrix_no_skew_or_rotate (transform))
                      {
                        if ((int)(ctx_fabsf (transform->m[0][0] - 1.0f) < 0.001f) &
                            (ctx_fabsf (transform->m[1][1] - 1.0f) < 0.001f) &
                            (ctx_fmod1f (transform->m[0][2]) < 0.001f) &
                            (ctx_fmod1f (transform->m[1][2]) < 0.001f))
                        {
                          if (extend == CTX_EXTEND_NONE)
                            return ctx_fragment_image_rgba8_RGBA8_nearest_copy;
                          else if (extend == CTX_EXTEND_REPEAT)
                            return ctx_fragment_image_rgba8_RGBA8_nearest_copy_repeat;
                        }
                        return gstate->global_alpha_u8==255?
                               ctx_fragment_image_rgba8_RGBA8_bi_scale:
                               ctx_fragment_image_rgba8_RGBA8_bi_scale_with_alpha;
                      }
                      return gstate->global_alpha_u8==255?
                        ctx_fragment_image_rgba8_RGBA8_bi_affine:
                        ctx_fragment_image_rgba8_RGBA8_bi_affine_with_alpha;
                    }
                      return ctx_fragment_image_rgba8_RGBA8_bi_generic;
                  }
                }
                else
                {
                  if (rasterizer->swap_red_green)
                  {
                    if (ctx_matrix_no_perspective (transform))
                    {
                      if (ctx_matrix_no_skew_or_rotate (transform))
                      {
                        if ((int)(ctx_fabsf (transform->m[0][0] - 1.0f) < 0.001f) &
                            (ctx_fabsf (transform->m[1][1] - 1.0f) < 0.001f))
                        {
                           return ctx_fragment_image_rgba8_RGBA8_nearest_copy_swap_red_green;
                         if (extend == CTX_EXTEND_NONE)
                           return ctx_fragment_image_rgba8_RGBA8_nearest_copy_swap_red_green;
                         else if (extend == CTX_EXTEND_REPEAT)
                           return ctx_fragment_image_rgba8_RGBA8_nearest_copy_repeat_swap_red_green;
                        }
                        return ctx_fragment_image_rgba8_RGBA8_nearest_scale_swap_red_green;
                      }
                      return ctx_fragment_image_rgba8_RGBA8_nearest_affine_swap_red_green;
                    }
                    return ctx_fragment_image_rgba8_RGBA8_nearest_generic_swap_red_green;
                  }
                  if (ctx_matrix_no_perspective (transform))
                  {
                    if (ctx_matrix_no_skew_or_rotate (transform))
                    {
                      if ((int)(ctx_fabsf (transform->m[0][0] - 1.0f) < 0.001f) &
                          (ctx_fabsf (transform->m[1][1] - 1.0f) < 0.001f))
                      {
                         if (extend == CTX_EXTEND_NONE)
                           return ctx_fragment_image_rgba8_RGBA8_nearest_copy;
                         else if (extend == CTX_EXTEND_REPEAT)
                           return ctx_fragment_image_rgba8_RGBA8_nearest_copy_repeat;
                      }
                      return ctx_fragment_image_rgba8_RGBA8_nearest_scale;
                    }
                    return ctx_fragment_image_rgba8_RGBA8_nearest_affine;
                  }
                  return ctx_fragment_image_rgba8_RGBA8_nearest_generic;
                }
              }
            default: return ctx_fragment_image_RGBA8;
          }
#else
          return ctx_fragment_image_RGBA8;
#endif
      }

      case CTX_SOURCE_COLOR:           return ctx_fragment_color_RGBA8;
      case CTX_SOURCE_NONE:            return ctx_fragment_none_RGBA8;
#if CTX_GRADIENTS
      case CTX_SOURCE_CONIC_GRADIENT: return ctx_fragment_conic_gradient_RGBA8;
      case CTX_SOURCE_LINEAR_GRADIENT: return ctx_fragment_linear_gradient_RGBA8;
      case CTX_SOURCE_RADIAL_GRADIENT: return ctx_fragment_radial_gradient_RGBA8;
#endif
    }
  return ctx_fragment_none_RGBA8;
}

static inline void
ctx_u8_copy_normal (int components, CTX_COMPOSITE_ARGUMENTS)
{
  if (CTX_UNLIKELY(rasterizer->fragment))
    {
      float u0 = 0; float v0 = 0;
      float ud = 0; float vd = 0;
      float w0 = 1; float wd = 0;
      ctx_init_uv (rasterizer, x0, rasterizer->scanline/CTX_FULL_AA, &u0, &v0, &w0, &ud, &vd, &wd);
      while (count--)
      {
        uint8_t cov = *coverage;
        if (CTX_UNLIKELY(cov == 0))
        {
          u0+=ud;
          v0+=vd;
        }
        else
        {
          rasterizer->fragment (rasterizer, u0, v0, w0, src, 1, ud, vd, wd);
          u0+=ud;
          v0+=vd;
          if (cov == 255)
          {
            for (int c = 0; c < components; c++)
              dst[c] = src[c];
          }
          else
          {
            uint8_t rcov = 255 - cov;
            for (int c = 0; c < components; c++)
              { dst[c] = (src[c]*cov + dst[c]*rcov)/255; }
          }
        }
        dst += components;
        coverage ++;
      }
      return;
    }

  while (count--)
  {
    uint8_t cov = *coverage;
    uint8_t rcov = 255-cov;
    for (int c = 0; c < components; c++)
      { dst[c] = (src[c]*cov+dst[c]*rcov)/255; }
    dst += components;
    coverage ++;
  }
}

static void
ctx_u8_clear_normal (int components, CTX_COMPOSITE_ARGUMENTS)
{
  while (count--)
  {
    uint8_t cov = *coverage;
    for (int c = 0; c < components; c++)
      { dst[c] = (dst[c] * (256-cov)) >> 8; }
    coverage ++;
    dst += components;
  }
}

typedef enum {
  CTX_PORTER_DUFF_0,
  CTX_PORTER_DUFF_1,
  CTX_PORTER_DUFF_ALPHA,
  CTX_PORTER_DUFF_1_MINUS_ALPHA,
} CtxPorterDuffFactor;

#define  \
ctx_porter_duff_factors(mode, foo, bar)\
{\
  switch (mode)\
  {\
     case CTX_COMPOSITE_SOURCE_ATOP:\
        f_s = CTX_PORTER_DUFF_ALPHA;\
        f_d = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
      break;\
     case CTX_COMPOSITE_DESTINATION_ATOP:\
        f_s = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
        f_d = CTX_PORTER_DUFF_ALPHA;\
      break;\
     case CTX_COMPOSITE_DESTINATION_IN:\
        f_s = CTX_PORTER_DUFF_0;\
        f_d = CTX_PORTER_DUFF_ALPHA;\
      break;\
     case CTX_COMPOSITE_DESTINATION:\
        f_s = CTX_PORTER_DUFF_0;\
        f_d = CTX_PORTER_DUFF_1;\
       break;\
     case CTX_COMPOSITE_SOURCE_OVER:\
        f_s = CTX_PORTER_DUFF_1;\
        f_d = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
       break;\
     case CTX_COMPOSITE_DESTINATION_OVER:\
        f_s = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
        f_d = CTX_PORTER_DUFF_1;\
       break;\
     case CTX_COMPOSITE_XOR:\
        f_s = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
        f_d = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
       break;\
     case CTX_COMPOSITE_DESTINATION_OUT:\
        f_s = CTX_PORTER_DUFF_0;\
        f_d = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
       break;\
     case CTX_COMPOSITE_SOURCE_OUT:\
        f_s = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
        f_d = CTX_PORTER_DUFF_0;\
       break;\
     case CTX_COMPOSITE_SOURCE_IN:\
        f_s = CTX_PORTER_DUFF_ALPHA;\
        f_d = CTX_PORTER_DUFF_0;\
       break;\
     case CTX_COMPOSITE_COPY:\
        f_s = CTX_PORTER_DUFF_1;\
        f_d = CTX_PORTER_DUFF_1_MINUS_ALPHA;\
       break;\
     default:\
     case CTX_COMPOSITE_CLEAR:\
        f_s = CTX_PORTER_DUFF_0;\
        f_d = CTX_PORTER_DUFF_0;\
       break;\
  }\
}

static inline void
ctx_u8_source_over_normal_color (int components,
                                 unsigned int count,
                                 uint8_t * __restrict__ dst,
                                 uint8_t * __restrict__ src,
                                 uint8_t * __restrict__ coverage,
                                 CtxRasterizer         *rasterizer,
                                 int                    x0)
{
  uint8_t tsrc[5];
  *((uint32_t*)tsrc) = *((uint32_t*)src);

  while (count--)
  {
    uint8_t cov = *coverage++;
    for (int c = 0; c < components; c++)
      dst[c] =  ((((tsrc[c] * cov)) + (dst[c] * (((((255+(tsrc[components-1] * cov))>>8))^255 ))))>>8);
    dst+=components;
  }
}

static inline void
ctx_u8_source_copy_normal_color (int components, CTX_COMPOSITE_ARGUMENTS)
{
  while (count--)
  {
    for (int c = 0; c < components; c++)
      dst[c] =  ctx_lerp_u8(dst[c],src[c],coverage[0]);
    coverage ++;
    dst+=components;
  }
}

static CTX_INLINE void
ctx_RGBA8_source_over_normal_buf (CTX_COMPOSITE_ARGUMENTS, uint8_t *tsrc)
{
  while (count--)
  {
     uint32_t si_ga = ((*((uint32_t*)tsrc)) & 0xff00ff00) >> 8;
     uint32_t si_rb = (*((uint32_t*)tsrc)) & 0x00ff00ff;
//   uint32_t di_ga = ((*((uint32_t*)dst)) & 0xff00ff00) >> 8;
//   uint32_t di_rb = (*((uint32_t*)dst)) & 0x00ff00ff;
     uint32_t si_a  = si_ga >> 16;
     uint32_t cov = *coverage;
     uint32_t racov = (255-((255+si_a*cov)>>8));
     *((uint32_t*)(dst)) =

     (((si_rb*cov+0xff00ff+(((*((uint32_t*)(dst)))&0x00ff00ff)*racov))>>8)&0x00ff00ff)|
     ((si_ga*cov+0xff00ff+((((*((uint32_t*)(dst)))&0xff00ff00)>>8)*racov))&0xff00ff00);

     coverage ++;
     tsrc += 4;
     dst  += 4;
  }
}

static CTX_INLINE void
ctx_RGBA8_source_over_normal_full_cov_buf (CTX_COMPOSITE_ARGUMENTS, uint8_t *__restrict__ tsrc)
{
  uint32_t *ttsrc = (uint32_t*)tsrc;
  uint32_t *ddst  = (uint32_t*)dst;
  while (count--)
  {
     uint32_t si_ga = ((*ttsrc) & 0xff00ff00) >> 8;
     uint32_t si_rb = (*ttsrc++) & 0x00ff00ff;
     uint32_t si_a  = si_ga >> 16;
     uint32_t racov = si_a^255;
     *(ddst) =
     (((si_rb*255+0xff00ff+(((*ddst)&0x00ff00ff)*racov))>>8)&0x00ff00ff)|
     ((si_ga*255+0xff00ff+((((*ddst)&0xff00ff00)>>8)*racov))&0xff00ff00);
     ddst++;
  }
}

static inline void
ctx_RGBA8_source_copy_normal_buf (CTX_COMPOSITE_ARGUMENTS, uint8_t *__restrict__ tsrc)
{
  uint32_t *ttsrc = (uint32_t*)tsrc;
  uint32_t *ddst  = (uint32_t*)dst;
  while (count--)
  {
    *ddst=ctx_lerp_RGBA8 (*ddst, *(ttsrc++), *(coverage++));
    ddst++;
  }
}

static inline void
ctx_RGBA8_source_over_normal_fragment (CTX_COMPOSITE_ARGUMENTS)
{
  float u0 = 0; float v0 = 0;
  float ud = 0; float vd = 0;
  float w0 = 1; float wd = 0;
  ctx_init_uv (rasterizer, x0, rasterizer->scanline/CTX_FULL_AA, &u0, &v0, &w0, &ud, &vd, &wd);
  uint8_t _tsrc[4 * (count)];
  rasterizer->fragment (rasterizer, u0, v0, w0, &_tsrc[0], count, ud, vd, wd);
  ctx_RGBA8_source_over_normal_buf (count,
                       dst, src, coverage, rasterizer, x0, &_tsrc[0]);
}

void
CTX_SIMD_SUFFIX(ctx_RGBA8_source_over_normal_full_cov_fragment) (CTX_COMPOSITE_ARGUMENTS, int scanlines)
{
  CtxMatrix *transform = &rasterizer->state->gstate.source_fill.transform;
  int scan = rasterizer->scanline /CTX_FULL_AA;
  CtxFragment fragment = rasterizer->fragment;

  if (CTX_LIKELY(ctx_matrix_no_perspective (transform)))
  {
    float u0, v0, ud, vd, w0, wd;
    uint8_t _tsrc[4 * count];
    ctx_init_uv (rasterizer, x0, scan, &u0, &v0, &w0, &ud, &vd, &wd);
    for (int y = 0; y < scanlines; y++)
    {
      fragment (rasterizer, u0, v0, w0, &_tsrc[0], count, ud, vd, wd);
      ctx_RGBA8_source_over_normal_full_cov_buf (count,
                          dst, src, coverage, rasterizer, x0, &_tsrc[0]);
      u0 -= vd;
      v0 += ud;
      dst += rasterizer->blit_stride;
    }
  }
  else
  {
    uint8_t _tsrc[4 * count];
    for (int y = 0; y < scanlines; y++)
    {
      float u0, v0, ud, vd, w0, wd;
      ctx_init_uv (rasterizer, x0, scan+y, &u0, &v0, &w0, &ud, &vd, &wd);
      fragment (rasterizer, u0, v0, w0, &_tsrc[0], count, ud, vd, wd);
      ctx_RGBA8_source_over_normal_full_cov_buf (count,
                          dst, src, coverage, rasterizer, x0, &_tsrc[0]);
      dst += rasterizer->blit_stride;
    }
  }
}

static inline void
ctx_RGBA8_source_copy_normal_fragment (CTX_COMPOSITE_ARGUMENTS)
{
  float u0 = 0; float v0 = 0;
  float ud = 0; float vd = 0;
  float w0 = 1; float wd = 0;
  ctx_init_uv (rasterizer, x0, rasterizer->scanline/CTX_FULL_AA, &u0, &v0, &w0, &ud, &vd, &wd);
  uint8_t _tsrc[4 * (count)];
  rasterizer->fragment (rasterizer, u0, v0, w0, &_tsrc[0], count, ud, vd, wd);
  ctx_RGBA8_source_copy_normal_buf (count,
                       dst, src, coverage, rasterizer, x0, &_tsrc[0]);
}


static void
ctx_RGBA8_source_over_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
#if CTX_REFERENCE
  ctx_u8_source_over_normal_color (4, count, dst, src, coverage, count, rasterizer, x0);
#else
  uint32_t si_ga = ((uint32_t*)rasterizer->color)[1];
  uint32_t si_rb = ((uint32_t*)rasterizer->color)[2];
  uint32_t si_a  = si_ga >> 16;

  while (count--)
  {
     uint32_t cov   = *coverage++;
     uint32_t rcov  = (((255+si_a * cov)>>8))^255;
     uint32_t di    = *((uint32_t*)dst);
     uint32_t di_ga = ((di & 0xff00ff00) >> 8);
     uint32_t di_rb = (di & 0x00ff00ff);
     *((uint32_t*)(dst)) =
     (((si_rb * cov + 0xff00ff + di_rb * rcov) & 0xff00ff00) >> 8)  |
      ((si_ga * cov + 0xff00ff + di_ga * rcov) & 0xff00ff00);
     dst+=4;
  }
#endif
}

static void
ctx_RGBA8_source_copy_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
#if CTX_REFERENCE
  ctx_u8_source_copy_normal_color (4, rasterizer, dst, src, x0, coverage, count);
#else
  uint32_t si_ga = ((uint32_t*)rasterizer->color)[1];
  uint32_t si_rb = ((uint32_t*)rasterizer->color)[2];

  while (count--)
  {
     uint32_t cov   = *coverage++;
     uint32_t di    = *((uint32_t*)dst);
     uint32_t di_ga = (di & 0xff00ff00);
     uint32_t di_rb = (di & 0x00ff00ff);

     uint32_t d_rb  = si_rb - di_rb;
     uint32_t d_ga  = si_ga - (di_ga>>8);

     *((uint32_t*)(dst)) =

     (((di_rb + ((d_rb * cov)>>8)) & 0x00ff00ff))  |
      ((di_ga + ((d_ga * cov)      & 0xff00ff00)));
     dst +=4;
  }
#endif
}

static void
ctx_RGBA8_clear_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_u8_clear_normal (4, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_u8_blend_normal (int components, uint8_t * __restrict__ dst, uint8_t *src, uint8_t *blended, int count)
{
  for (int j = 0; j < count; j++)
  {
  switch (components)
  {
     case 3:
       ((uint8_t*)(blended))[2] = ((uint8_t*)(src))[2];
       *((uint16_t*)(blended)) = *((uint16_t*)(src));
       break;
     case 2:
       *((uint16_t*)(blended)) = *((uint16_t*)(src));
       break;
     case 5:
       *((uint32_t*)(blended)) = *((uint32_t*)(src));
       ((uint8_t*)(blended))[4] = ((uint8_t*)(src))[4];
       break;
     case 4:
       *((uint32_t*)(blended)) = *((uint32_t*)(src));
       break;
     default:
       {
        for (int i = 0; i<components;i++)
           blended[i] = src[i];
       }
       break;
  }
    blended+=components;
    src+=components;
  }
}

/* branchless 8bit add that maxes out at 255 */
static inline uint8_t ctx_sadd8(uint8_t a, uint8_t b)
{
  uint16_t s = (uint16_t)a+b;
  return -(s>>8) | (uint8_t)s;
}

#if CTX_BLENDING_AND_COMPOSITING

#define ctx_u8_blend_define(name, CODE) \
static inline void \
ctx_u8_blend_##name (int components, uint8_t * __restrict__ dst, uint8_t *src, uint8_t *blended, int count)\
{\
  for (int j = 0; j < count; j++) { \
  uint8_t *s=src; uint8_t b[components];\
  ctx_u8_deassociate_alpha (components, dst, b);\
    CODE;\
  blended[components-1] = src[components-1];\
  ctx_u8_associate_alpha (components, blended);\
  src += components;\
  dst += components;\
  blended += components;\
  }\
}

#define ctx_u8_blend_define_seperable(name, CODE) \
        ctx_u8_blend_define(name, for (int c = 0; c < components-1; c++) { CODE ;}) \

ctx_u8_blend_define_seperable(multiply,     blended[c] = (b[c] * s[c])/255;)
ctx_u8_blend_define_seperable(screen,       blended[c] = s[c] + b[c] - (s[c] * b[c])/255;)
ctx_u8_blend_define_seperable(overlay,      blended[c] = b[c] < 127 ? (s[c] * b[c])/255 :
                                                         s[c] + b[c] - (s[c] * b[c])/255;)
ctx_u8_blend_define_seperable(darken,       blended[c] = ctx_mini (b[c], s[c]))
ctx_u8_blend_define_seperable(lighten,      blended[c] = ctx_maxi (b[c], s[c]))
ctx_u8_blend_define_seperable(color_dodge,  blended[c] = b[c] == 0 ? 0 :
                                     s[c] == 255 ? 255 : ctx_mini(255, (255 * b[c]) / (255-s[c])))
ctx_u8_blend_define_seperable(color_burn,   blended[c] = b[c] == 1 ? 1 :
                                     s[c] == 0 ? 0 : 255 - ctx_mini(255, (255*(255 - b[c])) / s[c]))
ctx_u8_blend_define_seperable(hard_light,   blended[c] = s[c] < 127 ? (b[c] * s[c])/255 :
                                                          b[c] + s[c] - (b[c] * s[c])/255;)
ctx_u8_blend_define_seperable(difference,   blended[c] = (b[c] - s[c]))
ctx_u8_blend_define_seperable(divide,       blended[c] = s[c]?(255 * b[c]) / s[c]:0)
ctx_u8_blend_define_seperable(addition,     blended[c] = ctx_sadd8 (s[c], b[c]))
ctx_u8_blend_define_seperable(subtract,     blended[c] = ctx_maxi(0, s[c]-b[c]))
ctx_u8_blend_define_seperable(exclusion,    blended[c] = b[c] + s[c] - 2 * (b[c] * s[c]/255))
ctx_u8_blend_define_seperable(soft_light,
  if (s[c] <= 255/2)
  {
    blended[c] = b[c] - (255 - 2 * s[c]) * b[c] * (255 - b[c]) / (255 * 255);
  }
  else
  {
    int d;
    if (b[c] <= 255/4)
      d = (((16 * b[c] - 12 * 255)/255 * b[c] + 4 * 255) * b[c])/255;
    else
      d = (int)(ctx_sqrtf(b[c]/255.0f) * 255.4f);
    blended[c] = (b[c] + (2 * s[c] - 255) * (d - b[c]))/255;
  }
)

static int ctx_int_get_max (int components, int *c)
{
  int max = 0;
  for (int i = 0; i < components - 1; i ++)
  {
    if (c[i] > max) max = c[i];
  }
  return max;
}

static int ctx_int_get_min (int components, int *c)
{
  int min = 400;
  for (int i = 0; i < components - 1; i ++)
  {
    if (c[i] < min) min = c[i];
  }
  return min;
}

static int ctx_int_get_lum (int components, int *c)
{
  switch (components)
  {
    case 3:
    case 4:
            return (int)(CTX_CSS_RGB_TO_LUMINANCE(c));
    case 1:
    case 2:
            return c[0];
            break;
    default:
       {
         int sum = 0;
         for (int i = 0; i < components - 1; i ++)
         {
           sum += c[i];
         }
         return sum / (components - 1);
       }
            break;
  }
}

static int ctx_u8_get_lum (int components, uint8_t *c)
{
  switch (components)
  {
    case 3:
    case 4:
            return (int)(CTX_CSS_RGB_TO_LUMINANCE(c));
    case 1:
    case 2:
            return c[0];
            break;
    default:
       {
         int sum = 0;
         for (int i = 0; i < components - 1; i ++)
         {
           sum += c[i];
         }
         return sum / (components - 1);
       }
            break;
  }
}
static int ctx_u8_get_sat (int components, uint8_t *c)
{
  switch (components)
  {
    case 3:
    case 4:
            { int r = c[0];
              int g = c[1];
              int b = c[2];
              return ctx_maxi(r, ctx_maxi(g,b)) - ctx_mini(r,ctx_mini(g,b));
            }
            break;
    case 1:
    case 2:
            return 0.0;
            break;
    default:
       {
         int min = 1000;
         int max = -1000;
         for (int i = 0; i < components - 1; i ++)
         {
           if (c[i] < min) min = c[i];
           if (c[i] > max) max = c[i];
         }
         return max-min;
       }
       break;
  }
}

static void ctx_u8_set_lum (int components, uint8_t *c, uint8_t lum)
{
  int d = lum - ctx_u8_get_lum (components, c);
  int tc[components];
  for (int i = 0; i < components - 1; i++)
  {
    tc[i] = c[i] + d;
  }

  int l = ctx_int_get_lum (components, tc);
  int n = ctx_int_get_min (components, tc);
  int x = ctx_int_get_max (components, tc);

  if ((n < 0) & (l!=n))
  {
    for (int i = 0; i < components - 1; i++)
      tc[i] = l + (((tc[i] - l) * l) / (l-n));
  }

  if ((x > 255) & (x!=l))
  {
    for (int i = 0; i < components - 1; i++)
      tc[i] = l + (((tc[i] - l) * (255 - l)) / (x-l));
  }
  for (int i = 0; i < components - 1; i++)
    c[i] = tc[i];
}

static void ctx_u8_set_sat (int components, uint8_t *c, uint8_t sat)
{
  int max = 0, mid = 1, min = 2;
  
  if (c[min] > c[mid]){int t = min; min = mid; mid = t;}
  if (c[mid] > c[max]){int t = mid; mid = max; max = t;}
  if (c[min] > c[mid]){int t = min; min = mid; mid = t;}

  if (c[max] > c[min])
  {
    c[mid] = ((c[mid]-c[min]) * sat) / (c[max] - c[min]);
    c[max] = sat;
  }
  else
  {
    c[mid] = c[max] = 0;
  }
  c[min] = 0;
}

ctx_u8_blend_define(color,
  for (int i = 0; i < components; i++)
    blended[i] = s[i];
  ctx_u8_set_lum(components, blended, ctx_u8_get_lum (components, s));
)

ctx_u8_blend_define(hue,
  int in_sat = ctx_u8_get_sat(components, b);
  int in_lum = ctx_u8_get_lum(components, b);
  for (int i = 0; i < components; i++)
    blended[i] = s[i];
  ctx_u8_set_sat(components, blended, in_sat);
  ctx_u8_set_lum(components, blended, in_lum);
)

ctx_u8_blend_define(saturation,
  int in_sat = ctx_u8_get_sat(components, s);
  int in_lum = ctx_u8_get_lum(components, b);
  for (int i = 0; i < components; i++)
    blended[i] = b[i];
  ctx_u8_set_sat(components, blended, in_sat);
  ctx_u8_set_lum(components, blended, in_lum);
)

ctx_u8_blend_define(luminosity,
  int in_lum = ctx_u8_get_lum(components, s);
  for (int i = 0; i < components; i++)
    blended[i] = b[i];
  ctx_u8_set_lum(components, blended, in_lum);
)
#endif

CTX_INLINE static void
ctx_u8_blend (int components, CtxBlend blend, uint8_t * __restrict__ dst, uint8_t *src, uint8_t *blended, int count)
{
#if CTX_BLENDING_AND_COMPOSITING
  switch (blend)
  {
    case CTX_BLEND_NORMAL:      ctx_u8_blend_normal      (components, dst, src, blended, count); break;
    case CTX_BLEND_MULTIPLY:    ctx_u8_blend_multiply    (components, dst, src, blended, count); break;
    case CTX_BLEND_SCREEN:      ctx_u8_blend_screen      (components, dst, src, blended, count); break;
    case CTX_BLEND_OVERLAY:     ctx_u8_blend_overlay     (components, dst, src, blended, count); break;
    case CTX_BLEND_DARKEN:      ctx_u8_blend_darken      (components, dst, src, blended, count); break;
    case CTX_BLEND_LIGHTEN:     ctx_u8_blend_lighten     (components, dst, src, blended, count); break;
    case CTX_BLEND_COLOR_DODGE: ctx_u8_blend_color_dodge (components, dst, src, blended, count); break;
    case CTX_BLEND_COLOR_BURN:  ctx_u8_blend_color_burn  (components, dst, src, blended, count); break;
    case CTX_BLEND_HARD_LIGHT:  ctx_u8_blend_hard_light  (components, dst, src, blended, count); break;
    case CTX_BLEND_SOFT_LIGHT:  ctx_u8_blend_soft_light  (components, dst, src, blended, count); break;
    case CTX_BLEND_DIFFERENCE:  ctx_u8_blend_difference  (components, dst, src, blended, count); break;
    case CTX_BLEND_EXCLUSION:   ctx_u8_blend_exclusion   (components, dst, src, blended, count); break;
    case CTX_BLEND_COLOR:       ctx_u8_blend_color       (components, dst, src, blended, count); break;
    case CTX_BLEND_HUE:         ctx_u8_blend_hue         (components, dst, src, blended, count); break;
    case CTX_BLEND_SATURATION:  ctx_u8_blend_saturation  (components, dst, src, blended, count); break;
    case CTX_BLEND_LUMINOSITY:  ctx_u8_blend_luminosity  (components, dst, src, blended, count); break;
    case CTX_BLEND_ADDITION:    ctx_u8_blend_addition    (components, dst, src, blended, count); break;
    case CTX_BLEND_DIVIDE:      ctx_u8_blend_divide      (components, dst, src, blended, count); break;
    case CTX_BLEND_SUBTRACT:    ctx_u8_blend_subtract    (components, dst, src, blended, count); break;
  }
#else
  switch (blend)
  {
    default:                    ctx_u8_blend_normal      (components, dst, src, blended, count); break;
  }

#endif
}

CTX_INLINE static void
__ctx_u8_porter_duff (CtxRasterizer         *rasterizer,
                     int                    components,
                     uint8_t *              dst,
                     uint8_t *              src,
                     int                    x0,
                     uint8_t * __restrict__ coverage,
                     int                    count,
                     CtxCompositingMode     compositing_mode,
                     CtxFragment            fragment,
                     CtxBlend               blend)
{
  CtxPorterDuffFactor f_s, f_d;
  ctx_porter_duff_factors (compositing_mode, &f_s, &f_d);
  CtxGState *gstate = &rasterizer->state->gstate;
  uint8_t global_alpha_u8 = gstate->global_alpha_u8;
  uint8_t tsrc[components * count];
  int src_step = 0;

  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
  {
    src = &tsrc[0];
    memcpy (src, rasterizer->color, 4);
    if (blend != CTX_BLEND_NORMAL)
      ctx_u8_blend (components, blend, dst, src, src, 1);
  }
  else
  {
    float u0 = 0; float v0 = 0;
    float ud = 0; float vd = 0;
    float w0 = 1; float wd = 0;
    src = &tsrc[0];

    ctx_init_uv (rasterizer, x0, rasterizer->scanline/CTX_FULL_AA, &u0, &v0, &w0, &ud, &vd, &wd);
    fragment (rasterizer, u0, v0, w0, src, count, ud, vd, wd);
    if (blend != CTX_BLEND_NORMAL)
      ctx_u8_blend (components, blend, dst, src, src, count);
    src_step = components;
  }

  while (count--)
  {
    uint32_t cov = *coverage;

    if (CTX_UNLIKELY(global_alpha_u8 != 255))
      cov = (cov * global_alpha_u8 + 255) >> 8;

    uint8_t csrc[components];
    for (int c = 0; c < components; c++)
      csrc[c] = (src[c] * cov + 255) >> 8;

    for (int c = 0; c < components; c++)
    {
      uint32_t res = 0;
#if 1
      switch (f_s)
      {
        case CTX_PORTER_DUFF_0:             break;
        case CTX_PORTER_DUFF_1:             res += (csrc[c] ); break;
        case CTX_PORTER_DUFF_ALPHA:         res += (csrc[c] * dst[components-1] + 255) >> 8; break;
        case CTX_PORTER_DUFF_1_MINUS_ALPHA: res += (csrc[c] * (256-dst[components-1])) >> 8; break;
      }
      switch (f_d)
      {
        case CTX_PORTER_DUFF_0: break;
        case CTX_PORTER_DUFF_1:             res += dst[c]; break;
        case CTX_PORTER_DUFF_ALPHA:         res += (dst[c] * csrc[components-1] + 255) >> 8; break;
        case CTX_PORTER_DUFF_1_MINUS_ALPHA: res += (dst[c] * (256-csrc[components-1])) >> 8; break;
      }
#else
      switch (f_s)
      {
        case CTX_PORTER_DUFF_0:             break;
        case CTX_PORTER_DUFF_1:             res += (csrc[c] ); break;
        case CTX_PORTER_DUFF_ALPHA:         res += (csrc[c] * dst[components-1])/255; break;
        case CTX_PORTER_DUFF_1_MINUS_ALPHA: res += (csrc[c] * (255-dst[components-1]))/255; break;
      }
      switch (f_d)
      {
        case CTX_PORTER_DUFF_0: break;
        case CTX_PORTER_DUFF_1:             res += dst[c]; break;
        case CTX_PORTER_DUFF_ALPHA:         res += (dst[c] * csrc[components-1])/255; break;
        case CTX_PORTER_DUFF_1_MINUS_ALPHA: res += (dst[c] * (255-csrc[components-1]))/255; break;
      }
#endif
      dst[c] = res;
    }
    coverage ++;
    src+=src_step;
    dst+=components;
  }
}

CTX_INLINE static void
_ctx_u8_porter_duff (CtxRasterizer         *rasterizer,
                     int                    components,
                     uint8_t *              dst,
                     uint8_t * __restrict__ src,
                     int                    x0,
                     uint8_t *              coverage,
                     int                    count,
                     CtxCompositingMode     compositing_mode,
                     CtxFragment            fragment,
                     CtxBlend               blend)
{
  __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count, compositing_mode, fragment, blend);
}

#define _ctx_u8_porter_duffs(comp_format, components, source, fragment, blend) \
   switch (rasterizer->state->gstate.compositing_mode) \
   { \
     case CTX_COMPOSITE_SOURCE_ATOP: \
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count, \
        CTX_COMPOSITE_SOURCE_ATOP, fragment, blend);\
      break;\
     case CTX_COMPOSITE_DESTINATION_ATOP:\
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_ATOP, fragment, blend);\
      break;\
     case CTX_COMPOSITE_DESTINATION_IN:\
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_IN, fragment, blend);\
      break;\
     case CTX_COMPOSITE_DESTINATION:\
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION, fragment, blend);\
       break;\
     case CTX_COMPOSITE_SOURCE_OVER:\
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_SOURCE_OVER, fragment, blend);\
       break;\
     case CTX_COMPOSITE_DESTINATION_OVER:\
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_OVER, fragment, blend);\
       break;\
     case CTX_COMPOSITE_XOR:\
      __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_XOR, fragment, blend);\
       break;\
     case CTX_COMPOSITE_DESTINATION_OUT:\
       __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_OUT, fragment, blend);\
       break;\
     case CTX_COMPOSITE_SOURCE_OUT:\
       __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_SOURCE_OUT, fragment, blend);\
       break;\
     case CTX_COMPOSITE_SOURCE_IN:\
       __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_SOURCE_IN, fragment, blend);\
       break;\
     case CTX_COMPOSITE_COPY:\
       __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_COPY, fragment, blend);\
       break;\
     case CTX_COMPOSITE_CLEAR:\
       __ctx_u8_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_CLEAR, fragment, blend);\
       break;\
   }

/* generating one function per compositing_mode would be slightly more efficient,
 * but on embedded targets leads to slightly more code bloat,
 * here we trade off a slight amount of performance
 */
#define ctx_u8_porter_duff(comp_format, components, source, fragment, blend) \
static void \
ctx_##comp_format##_porter_duff_##source (CTX_COMPOSITE_ARGUMENTS) \
{ \
  _ctx_u8_porter_duffs(comp_format, components, source, fragment, blend);\
}

ctx_u8_porter_duff(RGBA8, 4,generic, rasterizer->fragment, rasterizer->state->gstate.blend_mode)
//ctx_u8_porter_duff(comp_name, components,color_##blend_name,  NULL, blend_mode)


#if CTX_INLINED_NORMAL_RGBA8

ctx_u8_porter_duff(RGBA8, 4,color,   rasterizer->fragment, rasterizer->state->gstate.blend_mode)

#if CTX_GRADIENTS
ctx_u8_porter_duff(RGBA8, 4,linear_gradient, ctx_fragment_linear_gradient_RGBA8, rasterizer->state->gstate.blend_mode)
ctx_u8_porter_duff(RGBA8, 4,radial_gradient, ctx_fragment_radial_gradient_RGBA8, rasterizer->state->gstate.blend_mode)
#endif
ctx_u8_porter_duff(RGBA8, 4,image,           ctx_fragment_image_RGBA8,           rasterizer->state->gstate.blend_mode)
#endif


static inline void
ctx_RGBA8_nop (CTX_COMPOSITE_ARGUMENTS)
{
}


static inline void
ctx_setup_native_color (CtxRasterizer *rasterizer)
{
  if (rasterizer->state->gstate.source_fill.type == CTX_SOURCE_COLOR)
  {
    rasterizer->format->from_comp (rasterizer, 0,
      &rasterizer->color[0],
      &rasterizer->color_native,
      1);
  }
}

static void
ctx_setup_apply_coverage (CtxRasterizer *rasterizer)
{
  rasterizer->apply_coverage = rasterizer->format->apply_coverage ?
                               rasterizer->format->apply_coverage :
                               rasterizer->comp_op;
}

static void
ctx_setup_RGBA8 (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  rasterizer->fragment = ctx_rasterizer_get_fragment_RGBA8 (rasterizer);
  rasterizer->comp_op  = ctx_RGBA8_porter_duff_generic;
  rasterizer->comp = CTX_COV_PATH_FALLBACK;
  CtxSourceType source_type = (CtxSourceType)gstate->source_fill.type;

  int blend_mode       = gstate->blend_mode;
  int compositing_mode = gstate->compositing_mode;

  if (source_type == CTX_SOURCE_NONE)
  {
    ctx_setup_apply_coverage (rasterizer);
    return;
  }
  if (source_type == CTX_SOURCE_COLOR)
    {
      ctx_fragment_color_RGBA8 (rasterizer, 0,0, 1,rasterizer->color, 1, 0,0,0);
      if (gstate->global_alpha_u8 != 255)
      {
        for (int c = 0; c < 4; c ++)
          rasterizer->color[c] = (rasterizer->color[c] * gstate->global_alpha_u8 + 255)>>8;
      }
      uint32_t src_pix    = ((uint32_t*)rasterizer->color)[0];
      uint32_t si_ga      = (src_pix & 0xff00ff00) >> 8;
      uint32_t si_rb      = src_pix & 0x00ff00ff;
      uint32_t si_ga_full = si_ga * 255 + 0xff00ff;
      uint32_t si_rb_full = si_rb * 255 + 0xff00ff;

      ((uint32_t*)rasterizer->color)[1] = si_ga;
      ((uint32_t*)rasterizer->color)[2] = si_rb;
      ((uint32_t*)rasterizer->color)[3] = si_ga_full;
      ((uint32_t*)rasterizer->color)[4] = si_rb_full;
    }

#if CTX_INLINED_NORMAL_RGBA8
  if (gstate->compositing_mode == CTX_COMPOSITE_CLEAR)
    rasterizer->comp_op = ctx_RGBA8_clear_normal;
  else
    switch (gstate->blend_mode)
    {
      case CTX_BLEND_NORMAL:
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp_op = ctx_RGBA8_copy_normal;
          if (gstate->source_fill.type == CTX_SOURCE_COLOR)
            rasterizer->comp = CTX_COV_PATH_RGBA8_COPY;

        }
        else if (gstate->global_alpha_u8 == 0)
        {
          rasterizer->comp_op = ctx_RGBA8_nop;
        }
        else
        switch (source_type)
        {
          case CTX_SOURCE_COLOR:
            if (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
            {
              rasterizer->comp_op = ctx_RGBA8_source_over_normal_color;
              if (rasterizer->color[3] == 255)
                rasterizer->comp = CTX_COV_PATH_RGBA8_COPY;
            }
            else
            {
              rasterizer->comp_op = ctx_RGBA8_porter_duff_color_normal;
            }
            break;
#if CTX_GRADIENTS
          case CTX_SOURCE_LINEAR_GRADIENT:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_linear_gradient_normal;
            break;
          case CTX_SOURCE_RADIAL_GRADIENT:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_radial_gradient_normal;
            break;
#endif
          case CTX_SOURCE_TEXTURE:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_image_normal;
            break;
          default:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_generic_normal;
            break;
        }
        break;
      default:
        switch (source_type)
        {
          case CTX_SOURCE_COLOR:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_color;
            break;
#if CTX_GRADIENTS
          case CTX_SOURCE_LINEAR_GRADIENT:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_linear_gradient;
            break;
          case CTX_SOURCE_RADIAL_GRADIENT:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_radial_gradient;
            break;
#endif
          case CTX_SOURCE_TEXTURE:
            rasterizer->comp_op = ctx_RGBA8_porter_duff_image;
            break;
        }
        break;
    }

#else

  if (source_type == CTX_SOURCE_COLOR)
    {
      if (blend_mode == CTX_BLEND_NORMAL)
      {
        if(compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp_op = ctx_RGBA8_source_copy_normal_color;
          rasterizer->comp = CTX_COV_PATH_RGBA8_COPY;
        }
        else if (compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
        {
          if (rasterizer->color[3] == 255)
          {
            rasterizer->comp_op = ctx_RGBA8_source_copy_normal_color;
            rasterizer->comp = CTX_COV_PATH_RGBA8_COPY;
          }
          else
          {
            rasterizer->comp_op = ctx_RGBA8_source_over_normal_color;
            rasterizer->comp = CTX_COV_PATH_RGBA8_OVER;
          }
        }
      }
      else if (compositing_mode == CTX_COMPOSITE_CLEAR)
      {
        rasterizer->comp_op = ctx_RGBA8_clear_normal;
      }
  }
  else if (blend_mode == CTX_BLEND_NORMAL)
  {
    if(compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
    {
       rasterizer->comp_op = ctx_RGBA8_source_over_normal_fragment;
       rasterizer->comp = CTX_COV_PATH_RGBA8_OVER_FRAGMENT;
    }
    else if (compositing_mode == CTX_COMPOSITE_COPY)
    {
       rasterizer->comp_op = ctx_RGBA8_source_copy_normal_fragment;
       rasterizer->comp = CTX_COV_PATH_RGBA8_COPY_FRAGMENT;
    }
  }
#endif
  ctx_setup_apply_coverage (rasterizer);
}


static inline void
ctx_setup_RGB (CtxRasterizer *rasterizer)
{
  ctx_setup_RGBA8 (rasterizer);
  ctx_setup_native_color (rasterizer);

  rasterizer->comp = CTX_COV_PATH_FALLBACK;
}



#if CTX_ENABLE_RGB332
static void
ctx_setup_RGB332 (CtxRasterizer *rasterizer)
{
  ctx_setup_RGBA8 (rasterizer);
  ctx_setup_native_color (rasterizer);

  if (rasterizer->comp == CTX_COV_PATH_RGBA8_COPY)
    rasterizer->comp = CTX_COV_PATH_RGB332_COPY;
  else
    rasterizer->comp = CTX_COV_PATH_FALLBACK;
}
#endif

#if CTX_ENABLE_RGB565
static void
ctx_setup_RGB565 (CtxRasterizer *rasterizer)
{
  ctx_setup_RGBA8 (rasterizer);
  ctx_setup_native_color (rasterizer);

  if (rasterizer->comp == CTX_COV_PATH_RGBA8_COPY)
    rasterizer->comp = CTX_COV_PATH_RGB565_COPY;
  else
    rasterizer->comp = CTX_COV_PATH_FALLBACK;
}
#endif

#if CTX_ENABLE_RGB8
static void
ctx_setup_RGB8 (CtxRasterizer *rasterizer)
{
  ctx_setup_RGBA8 (rasterizer);
  ctx_setup_native_color (rasterizer);

  if (rasterizer->comp == CTX_COV_PATH_RGBA8_COPY)
    rasterizer->comp = CTX_COV_PATH_RGB8_COPY;
  else
    rasterizer->comp = CTX_COV_PATH_FALLBACK;
}
#endif

static inline void
ctx_composite_convert (CTX_COMPOSITE_ARGUMENTS)
{
  uint8_t pixels[count * rasterizer->format->ebpp];
  rasterizer->format->to_comp (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  rasterizer->format->from_comp (rasterizer, x0, &pixels[0], dst, count);
}

#if CTX_ENABLE_FLOAT
static inline void
ctx_float_copy_normal (int components, CTX_COMPOSITE_ARGUMENTS)
{
  float *dstf = (float*)dst;
  float *srcf = (float*)src;
  float u0 = 0; float v0 = 0;
  float ud = 0; float vd = 0;
  float w0 = 1; float wd = 0;

  ctx_init_uv (rasterizer, x0, rasterizer->scanline/CTX_FULL_AA, &u0, &v0, &w0, &ud, &vd, &wd);

  while (count--)
  {
    uint8_t cov = *coverage;
    float covf = ctx_u8_to_float (cov);
    for (int c = 0; c < components; c++)
      dstf[c] = dstf[c]*(1.0f-covf) + srcf[c]*covf;
    dstf += components;
    coverage ++;
  }
}

static inline void
ctx_float_clear_normal (int components, CTX_COMPOSITE_ARGUMENTS)
{
  float *dstf = (float*)dst;
  while (count--)
  {
#if 0
    uint8_t cov = *coverage;
    if (cov == 0)
    {
    }
    else if (cov == 255)
    {
#endif
      switch (components)
      {
        case 2:
          ((uint64_t*)(dst))[0] = 0;
          break;
        case 4:
          ((uint64_t*)(dst))[0] = 0;
          ((uint64_t*)(dst))[1] = 0;
          break;
        default:
          for (int c = 0; c < components; c++)
            dstf[c] = 0.0f;
      }
#if 0
    }
    else
    {
      float ralpha = 1.0f - ctx_u8_to_float (cov);
      for (int c = 0; c < components; c++)
        { dstf[c] = (dstf[c] * ralpha); }
    }
    coverage ++;
#endif
    dstf += components;
  }
}


static inline void
ctx_float_source_over_normal_color (int components, CTX_COMPOSITE_ARGUMENTS)
{
  float *dstf = (float*)dst;
  float *srcf = (float*)src;
  while (count--)
  {
    uint8_t cov = *coverage;
    float fcov = ctx_u8_to_float (cov);
    float ralpha = 1.0f - fcov * srcf[components-1];
    for (int c = 0; c < components; c++)
      dstf[c] = srcf[c]*fcov + dstf[c] * ralpha;
    coverage ++;
    dstf+= components;
  }
}

static inline void
ctx_float_source_copy_normal_color (int components, CTX_COMPOSITE_ARGUMENTS)
{
  float *dstf = (float*)dst;
  float *srcf = (float*)src;

  while (count--)
  {
    uint8_t cov = *coverage;
    float fcov = ctx_u8_to_float (cov);
    float ralpha = 1.0f - fcov;
    for (int c = 0; c < components; c++)
      dstf[c] = (srcf[c]*fcov + dstf[c] * ralpha);
    coverage ++;
    dstf+= components;
  }
}

inline static void
ctx_float_blend_normal (int components, float *dst, float *src, float *blended)
{
  float a = src[components-1];
  for (int c = 0; c <  components - 1; c++)
    blended[c] = src[c] * a;
  blended[components-1]=a;
}

static float ctx_float_get_max (int components, float *c)
{
  float max = -1000.0f;
  for (int i = 0; i < components - 1; i ++)
  {
    if (c[i] > max) max = c[i];
  }
  return max;
}

static float ctx_float_get_min (int components, float *c)
{
  float min = 400.0;
  for (int i = 0; i < components - 1; i ++)
  {
    if (c[i] < min) min = c[i];
  }
  return min;
}

static float ctx_float_get_lum (int components, float *c)
{
  switch (components)
  {
    case 3:
    case 4:
            return CTX_CSS_RGB_TO_LUMINANCE(c);
    case 1:
    case 2:
            return c[0];
            break;
    default:
       {
         float sum = 0;
         for (int i = 0; i < components - 1; i ++)
         {
           sum += c[i];
         }
         return sum / (components - 1);
       }
  }
}

static float ctx_float_get_sat (int components, float *c)
{
  switch (components)
  {
    case 3:
    case 4:
            { float r = c[0];
              float g = c[1];
              float b = c[2];
              return ctx_maxf(r, ctx_maxf(g,b)) - ctx_minf(r,ctx_minf(g,b));
            }
            break;
    case 1:
    case 2: return 0.0;
            break;
    default:
       {
         float min = 1000;
         float max = -1000;
         for (int i = 0; i < components - 1; i ++)
         {
           if (c[i] < min) min = c[i];
           if (c[i] > max) max = c[i];
         }
         return max-min;
       }
  }
}

static void ctx_float_set_lum (int components, float *c, float lum)
{
  float d = lum - ctx_float_get_lum (components, c);
  float tc[components];
  for (int i = 0; i < components - 1; i++)
  {
    tc[i] = c[i] + d;
  }

  float l = ctx_float_get_lum (components, tc);
  float n = ctx_float_get_min (components, tc);
  float x = ctx_float_get_max (components, tc);

  if ((n < 0.0f) & (l != n))
  {
    for (int i = 0; i < components - 1; i++)
      tc[i] = l + (((tc[i] - l) * l) / (l-n));
  }

  if ((x > 1.0f) & (x != l))
  {
    for (int i = 0; i < components - 1; i++)
      tc[i] = l + (((tc[i] - l) * (1.0f - l)) / (x-l));
  }
  for (int i = 0; i < components - 1; i++)
    c[i] = tc[i];
}

static void ctx_float_set_sat (int components, float *c, float sat)
{
  int max = 0, mid = 1, min = 2;
  
  if (c[min] > c[mid]){int t = min; min = mid; mid = t;}
  if (c[mid] > c[max]){int t = mid; mid = max; max = t;}
  if (c[min] > c[mid]){int t = min; min = mid; mid = t;}

  if (c[max] > c[min])
  {
    c[mid] = ((c[mid]-c[min]) * sat) / (c[max] - c[min]);
    c[max] = sat;
  }
  else
  {
    c[mid] = c[max] = 0.0f;
  }
  c[min] = 0.0f;

}

#define ctx_float_blend_define(name, CODE) \
static inline void \
ctx_float_blend_##name (int components, float * __restrict__ dst, float *src, float *blended)\
{\
  float *s = src; float b[components];\
  ctx_float_deassociate_alpha (components, dst, b);\
    CODE;\
  blended[components-1] = s[components-1];\
  ctx_float_associate_alpha (components, blended);\
}

#define ctx_float_blend_define_seperable(name, CODE) \
        ctx_float_blend_define(name, for (int c = 0; c < components-1; c++) { CODE ;}) \

ctx_float_blend_define_seperable(multiply,    blended[c] = (b[c] * s[c]);)
ctx_float_blend_define_seperable(screen,      blended[c] = b[c] + s[c] - (b[c] * s[c]);)
ctx_float_blend_define_seperable(overlay,     blended[c] = b[c] < 0.5f ? (s[c] * b[c]) :
                                                          s[c] + b[c] - (s[c] * b[c]);)
ctx_float_blend_define_seperable(darken,      blended[c] = ctx_minf (b[c], s[c]))
ctx_float_blend_define_seperable(lighten,     blended[c] = ctx_maxf (b[c], s[c]))
ctx_float_blend_define_seperable(color_dodge, blended[c] = (b[c] == 0.0f) ? 0.0f :
                                     s[c] == 1.0f ? 1.0f : ctx_minf(1.0f, (b[c]) / (1.0f-s[c])))
ctx_float_blend_define_seperable(color_burn,  blended[c] = (b[c] == 1.0f) ? 1.0f :
                                     s[c] == 0.0f ? 0.0f : 1.0f - ctx_minf(1.0f, ((1.0f - b[c])) / s[c]))
ctx_float_blend_define_seperable(hard_light,  blended[c] = s[c] < 0.f ? (b[c] * s[c]) :
                                                          b[c] + s[c] - (b[c] * s[c]);)
ctx_float_blend_define_seperable(difference,  blended[c] = (b[c] - s[c]))

ctx_float_blend_define_seperable(divide,      blended[c] = s[c]?(b[c]) / s[c]:0.0f)
ctx_float_blend_define_seperable(addition,    blended[c] = s[c]+b[c])
ctx_float_blend_define_seperable(subtract,    blended[c] = s[c]-b[c])

ctx_float_blend_define_seperable(exclusion,   blended[c] = b[c] + s[c] - 2.0f * b[c] * s[c])
ctx_float_blend_define_seperable(soft_light,
  if (s[c] <= 0.5f)
  {
    blended[c] = b[c] - (1.0f - 2.0f * s[c]) * b[c] * (1.0f - b[c]);
  }
  else
  {
    int d;
    if (b[c] <= 255/4)
      d = (((16 * b[c] - 12.0f) * b[c] + 4.0f) * b[c]);
    else
      d = ctx_sqrtf(b[c]);
    blended[c] = (b[c] + (2.0f * s[c] - 1.0f) * (d - b[c]));
  }
)


ctx_float_blend_define(color,
  for (int i = 0; i < components; i++)
    blended[i] = s[i];
  ctx_float_set_lum(components, blended, ctx_float_get_lum (components, s));
)

ctx_float_blend_define(hue,
  float in_sat = ctx_float_get_sat(components, b);
  float in_lum = ctx_float_get_lum(components, b);
  for (int i = 0; i < components; i++)
    blended[i] = s[i];
  ctx_float_set_sat(components, blended, in_sat);
  ctx_float_set_lum(components, blended, in_lum);
)

ctx_float_blend_define(saturation,
  float in_sat = ctx_float_get_sat(components, s);
  float in_lum = ctx_float_get_lum(components, b);
  for (int i = 0; i < components; i++)
    blended[i] = b[i];
  ctx_float_set_sat(components, blended, in_sat);
  ctx_float_set_lum(components, blended, in_lum);
)

ctx_float_blend_define(luminosity,
  float in_lum = ctx_float_get_lum(components, s);
  for (int i = 0; i < components; i++)
    blended[i] = b[i];
  ctx_float_set_lum(components, blended, in_lum);
)

inline static void
ctx_float_blend (int components, CtxBlend blend, float * __restrict__ dst, float *src, float *blended)
{
  switch (blend)
  {
    case CTX_BLEND_NORMAL:      ctx_float_blend_normal      (components, dst, src, blended); break;
    case CTX_BLEND_MULTIPLY:    ctx_float_blend_multiply    (components, dst, src, blended); break;
    case CTX_BLEND_SCREEN:      ctx_float_blend_screen      (components, dst, src, blended); break;
    case CTX_BLEND_OVERLAY:     ctx_float_blend_overlay     (components, dst, src, blended); break;
    case CTX_BLEND_DARKEN:      ctx_float_blend_darken      (components, dst, src, blended); break;
    case CTX_BLEND_LIGHTEN:     ctx_float_blend_lighten     (components, dst, src, blended); break;
    case CTX_BLEND_COLOR_DODGE: ctx_float_blend_color_dodge (components, dst, src, blended); break;
    case CTX_BLEND_COLOR_BURN:  ctx_float_blend_color_burn  (components, dst, src, blended); break;
    case CTX_BLEND_HARD_LIGHT:  ctx_float_blend_hard_light  (components, dst, src, blended); break;
    case CTX_BLEND_SOFT_LIGHT:  ctx_float_blend_soft_light  (components, dst, src, blended); break;
    case CTX_BLEND_DIFFERENCE:  ctx_float_blend_difference  (components, dst, src, blended); break;
    case CTX_BLEND_EXCLUSION:   ctx_float_blend_exclusion   (components, dst, src, blended); break;
    case CTX_BLEND_COLOR:       ctx_float_blend_color       (components, dst, src, blended); break;
    case CTX_BLEND_HUE:         ctx_float_blend_hue         (components, dst, src, blended); break;
    case CTX_BLEND_SATURATION:  ctx_float_blend_saturation  (components, dst, src, blended); break;
    case CTX_BLEND_LUMINOSITY:  ctx_float_blend_luminosity  (components, dst, src, blended); break;
    case CTX_BLEND_ADDITION:    ctx_float_blend_addition    (components, dst, src, blended); break;
    case CTX_BLEND_SUBTRACT:    ctx_float_blend_subtract    (components, dst, src, blended); break;
    case CTX_BLEND_DIVIDE:      ctx_float_blend_divide      (components, dst, src, blended); break;
  }
}

/* this is the grunt working function, when inlined code-path elimination makes
 * it produce efficient code.
 */
CTX_INLINE static void
ctx_float_porter_duff (CtxRasterizer         *rasterizer,
                       int                    components,
                       uint8_t * __restrict__ dst,
                       uint8_t * __restrict__ src,
                       int                    x0,
                       uint8_t * __restrict__ coverage,
                       int                    count,
                       CtxCompositingMode     compositing_mode,
                       CtxFragment            fragment,
                       CtxBlend               blend)
{
  float *dstf = (float*)dst;

  CtxPorterDuffFactor f_s, f_d;
  ctx_porter_duff_factors (compositing_mode, &f_s, &f_d);
  uint8_t global_alpha_u8 = rasterizer->state->gstate.global_alpha_u8;
  float   global_alpha_f = rasterizer->state->gstate.global_alpha_f;
  
  if (rasterizer->state->gstate.source_fill.type == CTX_SOURCE_COLOR)
  {
    float tsrc[components];

    while (count--)
    {
      uint8_t cov = *coverage;
#if 1
      if (
        CTX_UNLIKELY((compositing_mode == CTX_COMPOSITE_DESTINATION_OVER && dst[components-1] == 1.0f)||
        (cov == 0 && (compositing_mode == CTX_COMPOSITE_SOURCE_OVER ||
        compositing_mode == CTX_COMPOSITE_XOR               ||
        compositing_mode == CTX_COMPOSITE_DESTINATION_OUT   ||
        compositing_mode == CTX_COMPOSITE_SOURCE_ATOP      
        ))))
      {
        coverage ++;
        dstf+=components;
        continue;
      }
#endif
      memcpy (tsrc, rasterizer->color, sizeof(tsrc));

      if (blend != CTX_BLEND_NORMAL)
        ctx_float_blend (components, blend, dstf, tsrc, tsrc);
      float covf = ctx_u8_to_float (cov);

      if (global_alpha_u8 != 255)
        covf = covf * global_alpha_f;

      if (covf != 1.0f)
      {
        for (int c = 0; c < components; c++)
          tsrc[c] *= covf;
      }

      for (int c = 0; c < components; c++)
      {
        float res;
        /* these switches and this whole function is written to be
         * inlined when compiled when the enum values passed in are
         * constants.
         */
        switch (f_s)
        {
          case CTX_PORTER_DUFF_0: res = 0.0f; break;
          case CTX_PORTER_DUFF_1:             res = (tsrc[c]); break;
          case CTX_PORTER_DUFF_ALPHA:         res = (tsrc[c] *       dstf[components-1]); break;
          case CTX_PORTER_DUFF_1_MINUS_ALPHA: res = (tsrc[c] * (1.0f-dstf[components-1])); break;
        }
        switch (f_d)
        {
          case CTX_PORTER_DUFF_0: dstf[c] = res; break;
          case CTX_PORTER_DUFF_1:             dstf[c] = res + (dstf[c]); break;
          case CTX_PORTER_DUFF_ALPHA:         dstf[c] = res + (dstf[c] *       tsrc[components-1]); break;
          case CTX_PORTER_DUFF_1_MINUS_ALPHA: dstf[c] = res + (dstf[c] * (1.0f-tsrc[components-1])); break;
        }
      }
      coverage ++;
      dstf     +=components;
    }
  }
  else
  {
    float tsrc[components];
    float u0 = 0; float v0 = 0;
    float ud = 0; float vd = 0;
    float w0 = 1; float wd = 0;
    for (int c = 0; c < components; c++) tsrc[c] = 0.0f;
    ctx_init_uv (rasterizer, x0, rasterizer->scanline/CTX_FULL_AA, &u0, &v0, &w0, &ud, &vd, &wd);

    while (count--)
    {
      uint8_t cov = *coverage;
#if 1
      if (
        CTX_UNLIKELY((compositing_mode == CTX_COMPOSITE_DESTINATION_OVER && dst[components-1] == 1.0f)||
        (cov == 0 && (compositing_mode == CTX_COMPOSITE_SOURCE_OVER ||
        compositing_mode == CTX_COMPOSITE_XOR               ||
        compositing_mode == CTX_COMPOSITE_DESTINATION_OUT   ||
        compositing_mode == CTX_COMPOSITE_SOURCE_ATOP      
        ))))
      {
        u0 += ud;
        v0 += vd;
        coverage ++;
        dstf+=components;
        continue;
      }
#endif

      fragment (rasterizer, u0, v0, w0, tsrc, 1, ud, vd, wd);
      if (blend != CTX_BLEND_NORMAL)
        ctx_float_blend (components, blend, dstf, tsrc, tsrc);
      u0 += ud;
      v0 += vd;
      float covf = ctx_u8_to_float (cov);

      if (global_alpha_u8 != 255)
        covf = covf * global_alpha_f;

      if (covf != 1.0f)
      {
        for (int c = 0; c < components; c++)
          tsrc[c] *= covf;
      }

      for (int c = 0; c < components; c++)
      {
        float res;
        /* these switches and this whole function is written to be
         * inlined when compiled when the enum values passed in are
         * constants.
         */
        switch (f_s)
        {
          case CTX_PORTER_DUFF_0: res = 0.0f; break;
          case CTX_PORTER_DUFF_1:             res = (tsrc[c]); break;
          case CTX_PORTER_DUFF_ALPHA:         res = (tsrc[c] *       dstf[components-1]); break;
          case CTX_PORTER_DUFF_1_MINUS_ALPHA: res = (tsrc[c] * (1.0f-dstf[components-1])); break;
        }
        switch (f_d)
        {
          case CTX_PORTER_DUFF_0: dstf[c] = res; break;
          case CTX_PORTER_DUFF_1:             dstf[c] = res + (dstf[c]); break;
          case CTX_PORTER_DUFF_ALPHA:         dstf[c] = res + (dstf[c] *       tsrc[components-1]); break;
          case CTX_PORTER_DUFF_1_MINUS_ALPHA: dstf[c] = res + (dstf[c] * (1.0f-tsrc[components-1])); break;
        }
      }
      coverage ++;
      dstf     +=components;
    }
  }
}

/* generating one function per compositing_mode would be slightly more efficient,
 * but on embedded targets leads to slightly more code bloat,
 * here we trade off a slight amount of performance
 */
#define ctx_float_porter_duff(compformat, components, source, fragment, blend) \
static void \
ctx_##compformat##_porter_duff_##source (CTX_COMPOSITE_ARGUMENTS) \
{ \
   switch (rasterizer->state->gstate.compositing_mode) \
   { \
     case CTX_COMPOSITE_SOURCE_ATOP: \
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count, \
        CTX_COMPOSITE_SOURCE_ATOP, fragment, blend);\
      break;\
     case CTX_COMPOSITE_DESTINATION_ATOP:\
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_ATOP, fragment, blend);\
      break;\
     case CTX_COMPOSITE_DESTINATION_IN:\
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_IN, fragment, blend);\
      break;\
     case CTX_COMPOSITE_DESTINATION:\
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION, fragment, blend);\
       break;\
     case CTX_COMPOSITE_SOURCE_OVER:\
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_SOURCE_OVER, fragment, blend);\
       break;\
     case CTX_COMPOSITE_DESTINATION_OVER:\
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_OVER, fragment, blend);\
       break;\
     case CTX_COMPOSITE_XOR:\
      ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_XOR, fragment, blend);\
       break;\
     case CTX_COMPOSITE_DESTINATION_OUT:\
       ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_DESTINATION_OUT, fragment, blend);\
       break;\
     case CTX_COMPOSITE_SOURCE_OUT:\
       ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_SOURCE_OUT, fragment, blend);\
       break;\
     case CTX_COMPOSITE_SOURCE_IN:\
       ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_SOURCE_IN, fragment, blend);\
       break;\
     case CTX_COMPOSITE_COPY:\
       ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_COPY, fragment, blend);\
       break;\
     case CTX_COMPOSITE_CLEAR:\
       ctx_float_porter_duff (rasterizer, components, dst, src, x0, coverage, count,\
        CTX_COMPOSITE_CLEAR, fragment, blend);\
       break;\
   }\
}
#endif

#if CTX_ENABLE_RGBAF

ctx_float_porter_duff(RGBAF, 4,color,   rasterizer->fragment, rasterizer->state->gstate.blend_mode)
ctx_float_porter_duff(RGBAF, 4,generic, rasterizer->fragment, rasterizer->state->gstate.blend_mode)

#if CTX_INLINED_NORMAL
#if CTX_GRADIENTS
ctx_float_porter_duff(RGBAF, 4,conic_gradient, ctx_fragment_conic_gradient_RGBAF, rasterizer->state->gstate.blend_mode)
ctx_float_porter_duff(RGBAF, 4,linear_gradient, ctx_fragment_linear_gradient_RGBAF, rasterizer->state->gstate.blend_mode)
ctx_float_porter_duff(RGBAF, 4,radial_gradient, ctx_fragment_radial_gradient_RGBAF, rasterizer->state->gstate.blend_mode)
#endif
ctx_float_porter_duff(RGBAF, 4,image,           ctx_fragment_image_RGBAF,           rasterizer->state->gstate.blend_mode)


#if CTX_GRADIENTS
#define ctx_float_porter_duff_blend(comp_name, components, blend_mode, blend_name)\
ctx_float_porter_duff(comp_name, components,color_##blend_name,            rasterizer->fragment,                               blend_mode)\
ctx_float_porter_duff(comp_name, components,generic_##blend_name,          rasterizer->fragment,               blend_mode)\
ctx_float_porter_duff(comp_name, components,linear_gradient_##blend_name,  ctx_fragment_linear_gradient_RGBA8, blend_mode)\
ctx_float_porter_duff(comp_name, components,radial_gradient_##blend_name,  ctx_fragment_radial_gradient_RGBA8, blend_mode)\
ctx_float_porter_duff(comp_name, components,image_##blend_name,            ctx_fragment_image_RGBAF,           blend_mode)
#else
#define ctx_float_porter_duff_blend(comp_name, components, blend_mode, blend_name)\
ctx_float_porter_duff(comp_name, components,color_##blend_name,            rasterizer->fragment,                               blend_mode)\
ctx_float_porter_duff(comp_name, components,generic_##blend_name,          rasterizer->fragment,               blend_mode)\
ctx_float_porter_duff(comp_name, components,image_##blend_name,            ctx_fragment_image_RGBAF,           blend_mode)
#endif

ctx_float_porter_duff_blend(RGBAF, 4, CTX_BLEND_NORMAL, normal)


static void
ctx_RGBAF_copy_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_copy_normal (4, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_RGBAF_clear_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_clear_normal (4, count, dst, src, coverage, rasterizer, x0);
}

#if 1
static void
ctx_RGBAF_source_over_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_source_over_normal_color (4, count, dst, rasterizer->color, coverage, rasterizer, x0);
}
#endif
#endif

static void
ctx_setup_RGBAF (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  int components = 4;

  rasterizer->comp_op  = ctx_RGBAF_porter_duff_generic;
  rasterizer->fragment = ctx_rasterizer_get_fragment_RGBAF (rasterizer);
  rasterizer->comp = CTX_COV_PATH_FALLBACK;
#if 1
  if (gstate->source_fill.type == CTX_SOURCE_NONE)
  {
    ctx_setup_apply_coverage (rasterizer);
    return;
  }
  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
    {
      rasterizer->comp_op = ctx_RGBAF_porter_duff_color;
      ctx_fragment_color_RGBAF (rasterizer, 0,0,1, rasterizer->color, 1, 0,0,0);
      if (gstate->global_alpha_u8 != 255)
        for (int c = 0; c < components; c ++)
          ((float*)rasterizer->color)[c] *= gstate->global_alpha_f;

      if (rasterizer->format->from_comp)
        rasterizer->format->from_comp (rasterizer, 0,
          &rasterizer->color[0],
          &rasterizer->color_native,
          1);
    }
  else
#endif
  {
    rasterizer->comp_op = ctx_RGBAF_porter_duff_generic;
  }

#if CTX_INLINED_NORMAL
  if (gstate->compositing_mode == CTX_COMPOSITE_CLEAR)
    rasterizer->comp_op = ctx_RGBAF_clear_normal;
  else
    switch (gstate->blend_mode)
    {
      case CTX_BLEND_NORMAL:
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp_op = ctx_RGBAF_copy_normal;
          if (gstate->source_fill.type == CTX_SOURCE_COLOR)
            rasterizer->comp = CTX_COV_PATH_RGBAF_COPY;

        }
        else if (gstate->global_alpha_u8 == 0)
        {
          rasterizer->comp_op = ctx_RGBA8_nop;
        }
        else
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            if (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
            {
              rasterizer->comp_op = ctx_RGBAF_source_over_normal_color;
              if ( ((float*)rasterizer->color)[3] >= 0.999f)
                rasterizer->comp = CTX_COV_PATH_RGBAF_COPY;
            }
            else
            {
              rasterizer->comp_op = ctx_RGBAF_porter_duff_color_normal;
            }
            break;
#if CTX_GRADIENTS
          case CTX_SOURCE_LINEAR_GRADIENT:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_linear_gradient_normal;
            break;
          case CTX_SOURCE_RADIAL_GRADIENT:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_radial_gradient_normal;
            break;
#endif
          case CTX_SOURCE_TEXTURE:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_image_normal;
            break;
          default:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_generic_normal;
            break;
        }
        break;
      default:
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_color;
            break;
#if CTX_GRADIENTS
          case CTX_SOURCE_LINEAR_GRADIENT:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_linear_gradient;
            break;
          case CTX_SOURCE_RADIAL_GRADIENT:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_radial_gradient;
            break;
#endif
          case CTX_SOURCE_TEXTURE:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_image;
            break;
          default:
            rasterizer->comp_op = ctx_RGBAF_porter_duff_generic;
            break;
        }
        break;
    }
#endif
  ctx_setup_apply_coverage (rasterizer);
}

#endif
#if CTX_ENABLE_GRAYAF

#if CTX_GRADIENTS
static void
ctx_fragment_linear_gradient_GRAYAF (CtxRasterizer *rasterizer, float u0, float v0, float z, void *out, int count, float ud, float vd, float dz)
{
  float rgba[4];
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float linear_gradient_dx = g->linear_gradient.dx_scaled;
  float linear_gradient_dy = g->linear_gradient.dy_scaled;
  float linear_gradient_start = g->linear_gradient.start_scaled;

  u0 *= linear_gradient_dx;
  v0 *= linear_gradient_dy;
  ud *= linear_gradient_dx;
  vd *= linear_gradient_dy;

  float vv = ((u0 + v0) - linear_gradient_start);
  float ud_plus_vd = ud + vd;

  for (int i = 0 ; i < count; i++)
  {
    ctx_fragment_gradient_1d_RGBAF (rasterizer, vv, 1.0f, rgba);
    ((float*)out)[0] = ctx_float_color_rgb_to_gray (rasterizer->state, rgba);
    ((float*)out)[1] = rgba[3];
     out = ((float*)(out)) + 2;
    vv += ud_plus_vd;
  }
}

static void
ctx_fragment_radial_gradient_GRAYAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float rgba[4];
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float rg_x0 = g->radial_gradient.x0;
  float rg_y0 = g->radial_gradient.y0;
  float rg_r0 = g->radial_gradient.r0;
  float rg_rdelta = g->radial_gradient.rdelta;
  for (int i = 0; i < count; i ++)
  {
  float v = (ctx_hypotf (rg_x0 - x, rg_y0 - y) - rg_r0) * (rg_rdelta);
  ctx_fragment_gradient_1d_RGBAF (rasterizer, v, 0.0, rgba);
  ((float*)out)[0] = ctx_float_color_rgb_to_gray (rasterizer->state, rgba);
  ((float*)out)[1] = rgba[3];
     out = ((float*)(out)) + 2;
     x += dx;
     y += dy;
  }
}
#endif

static void
ctx_fragment_none_GRAYAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *ga = (float*)out;
  for (int i = 0; i < count * 2; i++)
    ga[i] = 0.0f;
}

static void
ctx_fragment_color_GRAYAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  for (int i = 0; i < count; i++)
  {
     ctx_color_get_graya (rasterizer->state, &g->color, (float*)out);
     out = ((float*)(out)) + 2;
     x += dx;
     y += dy;
  }
}

static void ctx_fragment_image_GRAYAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t rgba[4*count];
  float rgbaf[4*count];
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
         CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
         CtxBuffer *buffer = g->texture.buffer;
#endif
  switch (buffer->format->bpp)
    {
#if CTX_FRAGMENT_SPECIALIZE
      case 1:  ctx_fragment_image_gray1_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz); break;
      case 24: ctx_fragment_image_rgb8_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz);  break;
      case 32: ctx_fragment_image_rgba8_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz); break;
#endif
      default: ctx_fragment_image_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz);       break;
    }
  for (int c = 0; c < 2 * count; c ++) { 
    rgbaf[c] = ctx_u8_to_float (rgba[c]);
    ((float*)out)[0] = ctx_float_color_rgb_to_gray (rasterizer->state, rgbaf);
    ((float*)out)[1] = rgbaf[3];
    out = ((float*)out) + 2;
  }
}

static CtxFragment ctx_rasterizer_get_fragment_GRAYAF (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  switch (gstate->source_fill.type)
    {
      case CTX_SOURCE_TEXTURE:           return ctx_fragment_image_GRAYAF;
      case CTX_SOURCE_COLOR:           return ctx_fragment_color_GRAYAF;
      case CTX_SOURCE_NONE:            return ctx_fragment_none_GRAYAF;
#if CTX_GRADIENTS
      case CTX_SOURCE_LINEAR_GRADIENT: return ctx_fragment_linear_gradient_GRAYAF;
      case CTX_SOURCE_RADIAL_GRADIENT: return ctx_fragment_radial_gradient_GRAYAF;
#endif
    }
  return ctx_fragment_none_GRAYAF;
}

ctx_float_porter_duff(GRAYAF, 2,color,   rasterizer->fragment, rasterizer->state->gstate.blend_mode)
ctx_float_porter_duff(GRAYAF, 2,generic, rasterizer->fragment, rasterizer->state->gstate.blend_mode)

#if CTX_INLINED_NORMAL
ctx_float_porter_duff(GRAYAF, 2,color_normal,   rasterizer->fragment, CTX_BLEND_NORMAL)
ctx_float_porter_duff(GRAYAF, 2,generic_normal, rasterizer->fragment, CTX_BLEND_NORMAL)

static void
ctx_GRAYAF_copy_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_copy_normal (2, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_GRAYAF_clear_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_clear_normal (2, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_GRAYAF_source_copy_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_source_copy_normal_color (2, count, dst, rasterizer->color, coverage, rasterizer, x0);
}
#endif

static void
ctx_setup_GRAYAF (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  int components = 2;

  rasterizer->comp_op = ctx_GRAYAF_porter_duff_generic;
  rasterizer->fragment = ctx_rasterizer_get_fragment_GRAYAF (rasterizer);
  rasterizer->comp = CTX_COV_PATH_FALLBACK;
  if (gstate->source_fill.type == CTX_SOURCE_NONE)
  {
    ctx_setup_apply_coverage (rasterizer);
    return;
  }

  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
    {
      rasterizer->comp_op = ctx_GRAYAF_porter_duff_color;
      ctx_color_get_rgba (rasterizer->state, &gstate->source_fill.color, (float*)rasterizer->color);
      if (gstate->global_alpha_u8 != 255)
        for (int c = 0; c < components; c ++)
          ((float*)rasterizer->color)[c] *= gstate->global_alpha_f;

      if (rasterizer->format->from_comp)
        rasterizer->format->from_comp (rasterizer, 0,
          &rasterizer->color[0],
          &rasterizer->color_native,
          1);
    }

#if CTX_INLINED_NORMAL
  if (gstate->compositing_mode == CTX_COMPOSITE_CLEAR)
    rasterizer->comp_op = ctx_GRAYAF_clear_normal;
  else
    switch (gstate->blend_mode)
    {
      case CTX_BLEND_NORMAL:
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp_op = ctx_GRAYAF_copy_normal;
        }
        else if (gstate->global_alpha_u8 == 0)
          rasterizer->comp_op = ctx_RGBA8_nop;
        else
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            if (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
            {
              if (((float*)rasterizer->color)[components-1] == 0.0f)
                rasterizer->comp_op = ctx_RGBA8_nop;
#if 1
              else //if (((float*)rasterizer->color)[components-1] == 0.0f)
                rasterizer->comp_op = ctx_GRAYAF_source_copy_normal_color;
#endif
              //else
          //      rasterizer->comp_op = ctx_GRAYAF_porter_duff_color_normal;
            }
            else
            {
              rasterizer->comp_op = ctx_GRAYAF_porter_duff_color_normal;
            }
            break;
          default:
            rasterizer->comp_op = ctx_GRAYAF_porter_duff_generic_normal;
            break;
        }
        break;
      default:
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            rasterizer->comp_op = ctx_GRAYAF_porter_duff_color;
            break;
          default:
            rasterizer->comp_op = ctx_GRAYAF_porter_duff_generic;
            break;
        }
        break;
    }
#endif
  ctx_setup_apply_coverage (rasterizer);
}

#endif
#if CTX_ENABLE_GRAYF

static void
ctx_composite_GRAYF (CTX_COMPOSITE_ARGUMENTS)
{
  float *dstf = (float*)dst;

  float temp[count*2];
  for (unsigned int i = 0; i < count; i++)
  {
    temp[i*2] = dstf[i];
    temp[i*2+1] = 1.0f;
  }
  rasterizer->comp_op (count, (uint8_t*)temp, rasterizer->color, coverage, rasterizer, x0);
  for (unsigned int i = 0; i < count; i++)
  {
    dstf[i] = temp[i*2];
  }
}

#endif
#if CTX_ENABLE_BGRA8

inline static void
ctx_swap_red_green (uint8_t *rgba)
{
  uint32_t *buf  = (uint32_t *) rgba;
  uint32_t  orig = *buf;
  uint32_t  green_alpha = (orig & 0xff00ff00);
  uint32_t  red_blue    = (orig & 0x00ff00ff);
  uint32_t  red         = red_blue << 16;
  uint32_t  blue        = red_blue >> 16;
  *buf = green_alpha | red | blue;
}

static void
ctx_BGRA8_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  uint32_t *srci = (uint32_t *) buf;
  uint32_t *dsti = (uint32_t *) rgba;
  while (count--)
    {
      uint32_t val = *srci++;
      ctx_swap_red_green ( (uint8_t *) &val);
      *dsti++      = val;
    }
}

static void
ctx_RGBA8_to_BGRA8 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  ctx_BGRA8_to_RGBA8 (rasterizer, x, rgba, (uint8_t *) buf, count);
}

static void
ctx_composite_BGRA8 (CTX_COMPOSITE_ARGUMENTS)
{
  // for better performance, this could be done without a pre/post conversion,
  // by swapping R and B of source instead... as long as it is a color instead
  // of gradient or image
  //
  //
  uint8_t pixels[count * 4];
  ctx_BGRA8_to_RGBA8 (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_BGRA8_to_RGBA8  (rasterizer, x0, &pixels[0], dst, count);
}


#endif
static inline void
ctx_composite_direct (CTX_COMPOSITE_ARGUMENTS)
{
  // for better performance, this could be done without a pre/post conversion,
  // by swapping R and B of source instead... as long as it is a color instead
  // of gradient or image
  //
  //
  rasterizer->comp_op (count, dst, rasterizer->color, coverage, rasterizer, x0);
}

#if CTX_ENABLE_CMYKAF

static void
ctx_fragment_other_CMYKAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  float *cmyka = (float*)out;
  float _rgba[4 * count];
  float *rgba = &_rgba[0];
  CtxGState *gstate = &rasterizer->state->gstate;
  switch (gstate->source_fill.type)
    {
      case CTX_SOURCE_TEXTURE:
        ctx_fragment_image_RGBAF (rasterizer, x, y, z, rgba, count, dx, dy, dz);
        break;
      case CTX_SOURCE_COLOR:
        ctx_fragment_color_RGBAF (rasterizer, x, y, z, rgba, count, dx, dy, dz);
        break;
      case CTX_SOURCE_NONE:
        ctx_fragment_none_RGBAF (rasterizer, x, y, z, rgba, count, dx, dy, dz);
        break;
#if CTX_GRADIENTS
      case CTX_SOURCE_CONIC_GRADIENT:
        ctx_fragment_conic_gradient_RGBAF (rasterizer, x, y, z, rgba, count, dx, dy, dz);
        break;
      case CTX_SOURCE_LINEAR_GRADIENT:
        ctx_fragment_linear_gradient_RGBAF (rasterizer, x, y, z, rgba, count, dx, dy, dz);
        break;
      case CTX_SOURCE_RADIAL_GRADIENT:
        ctx_fragment_radial_gradient_RGBAF (rasterizer, x, y, z, rgba, count, dx, dy, dz);
        break;
#endif
      default:
        rgba[0]=rgba[1]=rgba[2]=rgba[3]=0.0f;
        break;
    }
  for (int i = 0; i < count; i++)
  {
    cmyka[4]=rgba[3];
    ctx_rgb_to_cmyk (rgba[0], rgba[1], rgba[2], &cmyka[0], &cmyka[1], &cmyka[2], &cmyka[3]);
    cmyka += 5;
    rgba += 4;
  }
}

static void
ctx_fragment_color_CMYKAF (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  float *cmyka = (float*)out;
  float cmyka_in[5];
  ctx_color_get_cmyka (rasterizer->state, &gstate->source_fill.color, cmyka_in);
  for (int i = 0; i < count; i++)
  {
    for (int c = 0; c < 4; c ++)
    {
      cmyka[c] = (1.0f - cmyka_in[c]);
    }
    cmyka[4] = cmyka_in[4];
    cmyka += 5;
  }
}

static CtxFragment ctx_rasterizer_get_fragment_CMYKAF (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  switch (gstate->source_fill.type)
    {
      case CTX_SOURCE_COLOR:
        return ctx_fragment_color_CMYKAF;
    }
  return ctx_fragment_other_CMYKAF;
}

ctx_float_porter_duff (CMYKAF, 5,color,           rasterizer->fragment, rasterizer->state->gstate.blend_mode)
ctx_float_porter_duff (CMYKAF, 5,generic,         rasterizer->fragment, rasterizer->state->gstate.blend_mode)

#if CTX_INLINED_NORMAL
ctx_float_porter_duff (CMYKAF, 5,color_normal,            rasterizer->fragment, CTX_BLEND_NORMAL)
ctx_float_porter_duff (CMYKAF, 5,generic_normal,          rasterizer->fragment, CTX_BLEND_NORMAL)

static void
ctx_CMYKAF_copy_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_copy_normal (5, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_CMYKAF_clear_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_clear_normal (5, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_CMYKAF_source_copy_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_float_source_copy_normal_color (5, count, dst, rasterizer->color, coverage, rasterizer, x0);
}
#endif

static void
ctx_setup_CMYKAF (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  int components = 5;
  rasterizer->fragment = ctx_rasterizer_get_fragment_CMYKAF (rasterizer);
  rasterizer->comp = CTX_COV_PATH_FALLBACK;
  rasterizer->comp_op = ctx_CMYKAF_porter_duff_generic;
  if (gstate->source_fill.type == CTX_SOURCE_NONE)
  {
    ctx_setup_apply_coverage (rasterizer);
    return;
  }

  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
    {
      rasterizer->comp_op = ctx_CMYKAF_porter_duff_color;
      rasterizer->comp_op = ctx_CMYKAF_porter_duff_generic;
      ctx_color_get_cmyka (rasterizer->state, &gstate->source_fill.color, (float*)rasterizer->color);
      if (gstate->global_alpha_u8 != 255)
        ((float*)rasterizer->color)[components-1] *= gstate->global_alpha_f;

      if (rasterizer->format->from_comp)
        rasterizer->format->from_comp (rasterizer, 0,
          &rasterizer->color[0],
          &rasterizer->color_native,
          1);
    }

#if CTX_INLINED_NORMAL
  if (gstate->compositing_mode == CTX_COMPOSITE_CLEAR)
    rasterizer->comp_op = ctx_CMYKAF_clear_normal;
  else
    switch (gstate->blend_mode)
    {
      case CTX_BLEND_NORMAL:
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp_op = ctx_CMYKAF_copy_normal;
        }
        else if (gstate->global_alpha_u8 == 0)
          rasterizer->comp_op = ctx_RGBA8_nop;
        else
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            if (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
            {
              if (((float*)rasterizer->color)[components-1] == 0.0f)
                rasterizer->comp_op = ctx_RGBA8_nop;
              else if (((float*)rasterizer->color)[components-1] == 1.0f)
              {
                rasterizer->comp_op = ctx_CMYKAF_source_copy_normal_color;
                rasterizer->comp = CTX_COV_PATH_CMYKAF_COPY;
              }
              else
                rasterizer->comp_op = ctx_CMYKAF_porter_duff_color_normal;
            }
            else
            {
              rasterizer->comp_op = ctx_CMYKAF_porter_duff_color_normal;
            }
            break;
          default:
            rasterizer->comp_op = ctx_CMYKAF_porter_duff_generic_normal;
            break;
        }
        break;
      default:
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            rasterizer->comp_op = ctx_CMYKAF_porter_duff_color;
            break;
          default:
            rasterizer->comp_op = ctx_CMYKAF_porter_duff_generic;
            break;
        }
        break;
    }
#else

    if (gstate->blend_mode == CTX_BLEND_NORMAL &&
        gstate->source_fill.type == CTX_SOURCE_COLOR)
    {
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp = CTX_COV_PATH_CMYKAF_COPY;
        }
        else if (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER &&
                 rasterizer->color[components-1] == 255)
        {
          rasterizer->comp = CTX_COV_PATH_CMYKAF_COPY;
        }
    }
#endif
  ctx_setup_apply_coverage (rasterizer);
}

static void
ctx_setup_CMYKA8 (CtxRasterizer *rasterizer)
{
  ctx_setup_CMYKAF (rasterizer);

  if (rasterizer->comp == CTX_COV_PATH_CMYKAF_COPY)
    rasterizer->comp = CTX_COV_PATH_CMYKA8_COPY;
}

static void
ctx_setup_CMYK8 (CtxRasterizer *rasterizer)
{
  ctx_setup_CMYKAF (rasterizer);
  if (rasterizer->comp == CTX_COV_PATH_CMYKAF_COPY)
    rasterizer->comp = CTX_COV_PATH_CMYK8_COPY;
}

#endif
#if CTX_ENABLE_CMYKA8

static void
ctx_CMYKA8_to_CMYKAF (CtxRasterizer *rasterizer, uint8_t *src, float *dst, int count)
{
  for (int i = 0; i < count; i ++)
    {
      for (int c = 0; c < 4; c ++)
        { dst[c] = ctx_u8_to_float ( (255-src[c]) ); }
      dst[4] = ctx_u8_to_float (src[4]);
      for (int c = 0; c < 4; c++)
        { dst[c] *= dst[4]; }
      src += 5;
      dst += 5;
    }
}
static void
ctx_CMYKAF_to_CMYKA8 (CtxRasterizer *rasterizer, float *src, uint8_t *dst, int count)
{
  for (int i = 0; i < count; i ++)
    {
      int a = ctx_float_to_u8 (src[4]);
      if ((a != 0) & (a != 255))
      {
        float recip = 1.0f/src[4];
        for (int c = 0; c < 4; c++)
        {
          dst[c] = ctx_float_to_u8 (1.0f - src[c] * recip);
        }
      }
      else
      {
        for (int c = 0; c < 4; c++)
          dst[c] = 255 - ctx_float_to_u8 (src[c]);
      }
      dst[4]=a;

      src += 5;
      dst += 5;
    }
}

static void
ctx_composite_CMYKA8 (CTX_COMPOSITE_ARGUMENTS)
{
  float pixels[count * 5];
  ctx_CMYKA8_to_CMYKAF (rasterizer, dst, &pixels[0], count);
  rasterizer->comp_op (count, (uint8_t *) &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_CMYKAF_to_CMYKA8 (rasterizer, &pixels[0], dst, count);
}

#endif
#if CTX_ENABLE_CMYK8

static void
ctx_CMYK8_to_CMYKAF (CtxRasterizer *rasterizer, uint8_t *src, float *dst, int count)
{
  for (int i = 0; i < count; i ++)
    {
      dst[0] = ctx_u8_to_float (255-src[0]);
      dst[1] = ctx_u8_to_float (255-src[1]);
      dst[2] = ctx_u8_to_float (255-src[2]);
      dst[3] = ctx_u8_to_float (255-src[3]);
      dst[4] = 1.0f;
      src += 4;
      dst += 5;
    }
}
static void
ctx_CMYKAF_to_CMYK8 (CtxRasterizer *rasterizer, float *src, uint8_t *dst, int count)
{
  for (int i = 0; i < count; i ++)
    {
      float c = src[0];
      float m = src[1];
      float y = src[2];
      float k = src[3];
      float a = src[4];
      if ((a != 0.0f) & (a != 1.0f))
        {
          float recip = 1.0f/a;
          c *= recip;
          m *= recip;
          y *= recip;
          k *= recip;
        }
      c = 1.0f - c;
      m = 1.0f - m;
      y = 1.0f - y;
      k = 1.0f - k;
      dst[0] = ctx_float_to_u8 (c);
      dst[1] = ctx_float_to_u8 (m);
      dst[2] = ctx_float_to_u8 (y);
      dst[3] = ctx_float_to_u8 (k);
      src += 5;
      dst += 4;
    }
}

static void
ctx_composite_CMYK8 (CTX_COMPOSITE_ARGUMENTS)
{
  float pixels[count * 5];
  ctx_CMYK8_to_CMYKAF (rasterizer, dst, &pixels[0], count);
  rasterizer->comp_op (count, (uint8_t *) &pixels[0], src, coverage, rasterizer, x0);
  ctx_CMYKAF_to_CMYK8 (rasterizer, &pixels[0], dst, count);
}
#endif


#if CTX_ENABLE_BGR8

inline static void
ctx_BGR8_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (const uint8_t *) buf;
  uint32_t *dst = (uint32_t*)rgba;
  while (count--)
    {
      *dst = pixel[1] +  (pixel[0] << 8) + (pixel[2] << 16) + (((unsigned)0xff) << 24);
      pixel+=3;
      dst++;
    }
}

inline static void
ctx_RGBA8_to_BGR8 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  const uint32_t *src = (const uint32_t*)rgba;
  while (count--)
    {
      uint32_t s = *src;
      uint8_t r = s & 0xff;
      uint8_t g = (s>>8) & 0xff;
      uint8_t b = (s>>16) & 0xff;
      pixel[0] = g;
      pixel[1] = r;
      pixel[2] = b;
      pixel+=3;
      src++;
    }
}

static void
ctx_composite_BGR8 (CTX_COMPOSITE_ARGUMENTS)
{
#if 1 // code is OK - but less code is better
  if (rasterizer->comp_op == ctx_RGBA8_source_over_normal_color)
  {
    uint8_t *src = ((uint8_t*)rasterizer->color);
    uint8_t *dst_u8 = (uint8_t*)dst;
    while (count--)
    {
        uint32_t cov = ((*coverage++) * src[3] + 255) >> 8;
        dst_u8[0] = ctx_lerp_u8 (dst_u8[0], src[1], cov);
        dst_u8[1] = ctx_lerp_u8 (dst_u8[1], src[0], cov);
        dst_u8[2] = ctx_lerp_u8 (dst_u8[2], src[2], cov);
        dst_u8+=3;
    }
    return;
  }
#endif
#if 1
  if (rasterizer->comp_op == ctx_RGBA8_source_copy_normal_color)
  {
    uint8_t *src = ((uint8_t*)rasterizer->color);
    uint8_t *dst_u8 = (uint8_t*)dst;
    while (count--)
    {
        uint32_t cov = *coverage++;
        dst_u8[0] = ctx_lerp_u8 (dst_u8[0], src[1], cov);
        dst_u8[1] = ctx_lerp_u8 (dst_u8[1], src[0], cov);
        dst_u8[2] = ctx_lerp_u8 (dst_u8[2], src[2], cov);
        dst_u8+=3;
    }
    return;
  }
#endif

  uint8_t pixels[count * 4];
  ctx_BGR8_to_RGBA8 (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_RGBA8_to_BGR8 (rasterizer, x0, &pixels[0], dst, count);
}

#endif

#if CTX_ENABLE_RGB8

inline static void
ctx_RGB8_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (const uint8_t *) buf;
  uint32_t *dst = (uint32_t*)rgba;
  while (count--)
    {
      *dst = pixel[0] +  (pixel[1] << 8) + (pixel[2] << 16) + (((unsigned)0xff) << 24);
      pixel+=3;
      dst++;
    }
}

inline static void
ctx_RGBA8_to_RGB8 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  const uint32_t *src = (const uint32_t*)rgba;
  while (count--)
    {
      uint32_t s = *src;
      uint8_t r = s & 0xff;
      uint8_t g = (s>>8) & 0xff;
      uint8_t b = (s>>16) & 0xff;
      pixel[0] = r;
      pixel[1] = g;
      pixel[2] = b;
      pixel+=3;
      src++;
    }
}

static void
ctx_composite_RGB8 (CTX_COMPOSITE_ARGUMENTS)
{
#if 1 // code is OK - but less code is better
  if (rasterizer->comp_op == ctx_RGBA8_source_over_normal_color)
  {
    uint8_t *src = ((uint8_t*)rasterizer->color);
    uint8_t *dst_u8 = (uint8_t*)dst;
    while (count--)
    {
        uint32_t cov = ((*coverage++) * src[3] + 255) >> 8;
        dst_u8[0] = ctx_lerp_u8 (dst_u8[0], src[0], cov);
        dst_u8[1] = ctx_lerp_u8 (dst_u8[1], src[1], cov);
        dst_u8[2] = ctx_lerp_u8 (dst_u8[2], src[2], cov);
        dst_u8+=3;
    }
    return;
  }
#endif
#if 1
  if (rasterizer->comp_op == ctx_RGBA8_source_copy_normal_color)
  {
    uint8_t *src = ((uint8_t*)rasterizer->color);
    uint8_t *dst_u8 = (uint8_t*)dst;
    while (count--)
    {
        //uint32_t cov = ((*coverage++) * src[3] + 255) >> 8;
        uint32_t cov = *coverage++;
        dst_u8[0] = ctx_lerp_u8 (dst_u8[0], src[0], cov);
        dst_u8[1] = ctx_lerp_u8 (dst_u8[1], src[1], cov);
        dst_u8[2] = ctx_lerp_u8 (dst_u8[2], src[2], cov);
        dst_u8+=3;
    }
    return;
  }
#endif

  uint8_t pixels[count * 4];
  ctx_RGB8_to_RGBA8 (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_RGBA8_to_RGB8 (rasterizer, x0, &pixels[0], dst, count);
}

#endif
#if CTX_ENABLE_GRAY1

#if CTX_NATIVE_GRAYA8
inline static void
ctx_GRAY1_to_GRAYA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *graya, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int bitno = x&7;
      if ((bitno == 0) & (count >= 7))
      {
        if (*pixel == 0)
        {
          for (int i = 0; i < 8; i++)
          {
            *graya++ = 0; *graya++ = 255;
          }
          x+=8; count-=7; pixel++;
          continue;
        }
        else if (*pixel == 0xff)
        {
          for (int i = 0; i < 8 * 2; i++)
          {
            *graya++ = 255;
          }
          x+=8; count-=7; pixel++;
          continue;
        }
      }
      *graya++ = 255 * ((*pixel) & (1<<bitno));
      *graya++ = 255;
      pixel+= (bitno ==7);
      x++;
    }
}

inline static void
ctx_GRAYA8_to_GRAY1 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int gray = rgba[0];
      int bitno = x&7;
      if (gray >= 128)
        *pixel |= (1<<bitno);
      else
        *pixel &= (~ (1<<bitno));
      pixel+= (bitno==7);
      x++;
      rgba +=2;
    }
}

#else

inline static void
ctx_GRAY1_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  uint32_t *dst = (uint32_t*)rgba;
  while (count--)
    {
      int bitno = x&7;
      uint8_t pval = *pixel;
      if ((bitno == 0) & (count >=7))
      {
        /* special case some bit patterns when decoding */
        if (pval == 0)
        {
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          x+=8; count-=7; pixel++;
          continue;
        }
        else if (pval == 0xff)
        {
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          x+=8; count-=7; pixel++;
          continue;
        }
        else if (pval == 0x0f)
        {
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          x+=8; count-=7; pixel++;
          continue;
        }
        else if (pval == 0xfc)
        {
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          x+=8; count-=7; pixel++;
          continue;
        }
        else if (pval == 0x3f)
        {
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          x+=8; count-=7; pixel++;
          continue;
        }
      }
      *dst++=0xff000000 + 0x00ffffff * ((pval & (1<< bitno ) )!=0);
      pixel += (bitno ==7);
      x++;
    }
}

inline static void
ctx_RGBA8_to_GRAY1 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int gray = ctx_u8_color_rgb_to_gray (rasterizer->state, rgba);
      int bitno = x&7;
      //gray += ctx_dither_mask_a (x, rasterizer->scanline/aa, 0, 127);
      if (gray >= 128)
        *pixel |= (1<< bitno);
      else
        *pixel &= (~ (1<< bitno));
      pixel+= (bitno ==7);
      x++;
      rgba +=4;
    }
}
#endif

#endif
#if CTX_ENABLE_GRAY2

#if CTX_NATIVE_GRAYA8
inline static void
ctx_GRAY2_to_GRAYA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      uint8_t val = (((*pixel) >> ( (x&3) <<1)) & 3) * 85;
      rgba[0] = val;
      rgba[1] = 255;
      if ( (x&3) ==3)
        { pixel+=1; }
      x++;
      rgba +=2;
    }
}

inline static void
ctx_GRAYA8_to_GRAY2 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int val = rgba[0];
      val = ctx_sadd8 (val, 40) >> 6;
      *pixel = (*pixel & (~ (3 << ( (x&3) <<1) ) ))
                      | ( (val << ( (x&3) <<1) ) );
      if ( (x&3) ==3)
        { pixel+=1; }
      x++;
      rgba +=2;
    }
}
#else

inline static void
ctx_GRAY2_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  uint32_t *dst = (uint32_t*)rgba;
  while (count--)
    {
      int bitno = x & 3;
      if ((bitno == 0) & (count >=3))
      {
        /* special case some bit patterns when decoding */
        if (*pixel == 0)
        {
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          x+=4; count-=3; pixel++;
          continue;
        }
        else if (*pixel == 0xff)
        {
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          x+=4; count-=3; pixel++;
          continue;
        }
        else if (*pixel == 0x55)
        {
          *dst++ = 0xff555555;
          *dst++ = 0xff555555;
          *dst++ = 0xff555555;
          *dst++ = 0xff555555;
          x+=4; count-=3; pixel++;
          continue;
        }
        else if (*pixel == 0xaa)
        {
          *dst++ = 0xffaaaaaa;
          *dst++ = 0xffaaaaaa;
          *dst++ = 0xffaaaaaa;
          *dst++ = 0xffaaaaaa;
          x+=4; count-=3; pixel++;
          continue;
        }
        else if (*pixel == 0x0f)
        {
          *dst++ = 0xff000000;
          *dst++ = 0xff000000;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          x+=4; count-=3; pixel++;
          continue;
        }
        else if (*pixel == 0xfc)
        {
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xff000000;
          x+=4; count-=3; pixel++;
          continue;
        }
        else if (*pixel == 0x3f)
        {
          *dst++ = 0xff000000;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          *dst++ = 0xffffffff;
          x+=4; count-=3; pixel++;
          continue;
        }
      }
      {
        uint8_t val = (((*pixel) >> ( (bitno) <<1)) & 3) * 85;
        *dst = val + val * 256u + val * 256u * 256u + 255u * 256u * 256u * 256u;
        if (bitno==3)
          { pixel+=1; }
        x++;
        dst++;
      }
    }
}

inline static void
ctx_RGBA8_to_GRAY2 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  CtxState *state = rasterizer->state;
  while (count--)
    {
      int val = ctx_u8_color_rgb_to_gray (state, rgba);
      val >>= 6;
      *pixel = (*pixel & (~ (3 << ((x&3) <<1) ) ))
                      | ( (val << ((x&3) <<1) ) );
      if ( (x&3) ==3)
        { pixel+=1; }
      x++;
      rgba +=4;
    }
}
#endif

#endif
#if CTX_ENABLE_GRAY4

#if CTX_NATIVE_GRAYA8
inline static void
ctx_GRAY4_to_GRAYA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int val = (*pixel & (15 << ( (x & 1) <<2) ) ) >> ( (x&1) <<2);
      val <<= 4;
      rgba[0] = val;
      rgba[1] = 255;
      if ( (x&1) ==1)
        { pixel+=1; }
      x++;
      rgba +=2;
    }
}

inline static void
ctx_GRAYA8_to_GRAY4 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int val = rgba[0];
      val >>= 4;
      *pixel = *pixel & (~ (15 << ( (x&1) <<2) ) );
      *pixel = *pixel | ( (val << ( (x&1) <<2) ) );
      if ( (x&1) ==1)
        { pixel+=1; }
      x++;
      rgba +=2;
    }
}
#else
inline static void
ctx_GRAY4_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      int val = (*pixel & (15 << ( (x & 1) <<2) ) ) >> ( (x&1) <<2);
      val <<= 4;
      rgba[0] = val;
      rgba[1] = val;
      rgba[2] = val;
      rgba[3] = 255;
      if ( (x&1) ==1)
        { pixel+=1; }
      x++;
      rgba +=4;
    }
}

inline static void
ctx_RGBA8_to_GRAY4 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  CtxState *state = rasterizer->state;
  while (count--)
    {
      int val = ctx_u8_color_rgb_to_gray (state, rgba);
      val >>= 4;
      *pixel = *pixel & (~ (15 << ( (x&1) <<2) ) );
      *pixel = *pixel | ( (val << ( (x&1) <<2) ) );
      if ( (x&1) ==1)
        { pixel+=1; }
      x++;
      rgba +=4;
    }
}
#endif

#endif
#if CTX_ENABLE_GRAY8

#if CTX_NATIVE_GRAYA8
inline static void
ctx_GRAY8_to_GRAYA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      rgba[0] = pixel[0];
      rgba[1] = 255;
      pixel+=1;
      rgba +=2;
    }
}

inline static void
ctx_GRAYA8_to_GRAY8 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      pixel[0] = rgba[0];
      pixel+=1;
      rgba +=2;
    }
}
#else
inline static void
ctx_GRAY8_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      rgba[0] = pixel[0];
      rgba[1] = pixel[0];
      rgba[2] = pixel[0];
      rgba[3] = 255;
      pixel+=1;
      rgba +=4;
    }
}

inline static void
ctx_RGBA8_to_GRAY8 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  CtxState *state = rasterizer->state;
  for (int i = 0; i < count; i ++)
    {
      pixel[i] = ctx_u8_color_rgb_to_gray (state, rgba + i * 4);
    }
}
#endif

#endif
#if CTX_ENABLE_GRAYA8

inline static void
ctx_GRAYA8_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (const uint8_t *) buf;
  while (count--)
    {
      rgba[0] = pixel[0];
      rgba[1] = pixel[0];
      rgba[2] = pixel[0];
      rgba[3] = pixel[1];
      pixel+=2;
      rgba +=4;
    }
}

inline static void
ctx_RGBA8_to_GRAYA8 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  CtxState *state = rasterizer->state;
  while (count--)
    {
      pixel[0] = ctx_u8_color_rgb_to_gray (state, rgba);
      pixel[1] = rgba[3];
      pixel+=2;
      rgba +=4;
    }
}

#if CTX_NATIVE_GRAYA8
CTX_INLINE static void ctx_rgba_to_graya_u8 (CtxState *state, uint8_t *in, uint8_t *out)
{
  out[0] = ctx_u8_color_rgb_to_gray (state, in);
  out[1] = in[3];
}

#if CTX_GRADIENTS
static void
ctx_fragment_linear_gradient_GRAYA8 (CtxRasterizer *rasterizer, float u0, float v0, float z, void *out, int count, float ud, float vd, float dz)
{
  CtxSource *g = &rasterizer->state->gstate.source_fill;
        uint8_t *dst = (uint8_t*)out;

  float linear_gradient_dx = g->linear_gradient.dx_scaled;
  float linear_gradient_dy = g->linear_gradient.dy_scaled;
  float linear_gradient_start = g->linear_gradient.start_scaled;

  u0 *= linear_gradient_dx;
  v0 *= linear_gradient_dy;
  ud *= linear_gradient_dx;
  vd *= linear_gradient_dy;

  float vv = ((u0 + v0) - linear_gradient_start);
  float ud_plus_vd = (ud + vd);

#if CTX_DITHER
  int scan = rasterizer->scanline / CTX_FULL_AA;
  int ox = (int)u0;
#endif
  for (int i = 0; i < count;i ++)
  {
    uint8_t rgba[4];
    ctx_fragment_gradient_1d_RGBA8 (rasterizer, vv, 1.0f, rgba);
    ctx_rgba_to_graya_u8 (rasterizer->state, rgba, dst);

#if CTX_DITHER
  ctx_dither_graya_u8 ((uint8_t*)dst, ox + i, scan, rasterizer->format->dither_red_blue,
                      rasterizer->format->dither_green);
#endif
    dst += 2;
    vv += ud_plus_vd;
  }
}

static void
ctx_fragment_radial_gradient_GRAYA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t *dst = (uint8_t*)out;
#if CTX_DITHER
  int scan = rasterizer->scanline / CTX_FULL_AA;
  int ox = (int)x;
#endif

  CtxSource *g = &rasterizer->state->gstate.source_fill;
  float rg_x0 = g->radial_gradient.x0;
  float rg_y0 = g->radial_gradient.y0;
  float rg_r0 = g->radial_gradient.r0;
  float rg_rdelta = g->radial_gradient.rdelta;
  for (int i = 0; i < count;i ++)
  {
  float v = (ctx_hypotf (rg_x0 - x, rg_y0 - y) - rg_r0) * (rg_rdelta);
  {
    uint8_t rgba[4];
    ctx_fragment_gradient_1d_RGBA8 (rasterizer, v, 1.0, rgba);
    ctx_rgba_to_graya_u8 (rasterizer->state, rgba, dst);
  }
#if CTX_DITHER
  ctx_dither_graya_u8 ((uint8_t*)dst, ox+i, scan, rasterizer->format->dither_red_blue,
                      rasterizer->format->dither_green);
#endif
  dst += 2;
  x += dx;
  y += dy;
  }
}
#endif

static void
ctx_fragment_color_GRAYA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  CtxSource *g = &rasterizer->state->gstate.source_fill;
  uint16_t *dst = (uint16_t*)out;
  uint16_t pix;
  ctx_color_get_graya_u8 (rasterizer->state, &g->color, (uint8_t*)&pix);
  for (int i = 0; i <count; i++)
  {
    dst[i]=pix;
  }
}

static void ctx_fragment_image_GRAYA8 (CtxRasterizer *rasterizer, float x, float y, float z, void *out, int count, float dx, float dy, float dz)
{
  uint8_t rgba[4*count];
  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
         CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
         CtxBuffer *buffer = g->texture.buffer;
#endif
  switch (buffer->format->bpp)
    {
#if CTX_FRAGMENT_SPECIALIZE
      case 1:  ctx_fragment_image_gray1_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz); break;
      case 24: ctx_fragment_image_rgb8_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz);  break;
      case 32: ctx_fragment_image_rgba8_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz); break;
#endif
      default: ctx_fragment_image_RGBA8 (rasterizer, x, y, z, rgba, count, dx, dy, dz);       break;
    }
  for (int i = 0; i < count; i++)
    ctx_rgba_to_graya_u8 (rasterizer->state, &rgba[i*4], &((uint8_t*)out)[i*2]);
}

static CtxFragment ctx_rasterizer_get_fragment_GRAYA8 (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  switch (gstate->source_fill.type)
    {
      case CTX_SOURCE_TEXTURE:           return ctx_fragment_image_GRAYA8;
      case CTX_SOURCE_COLOR:           return ctx_fragment_color_GRAYA8;
#if CTX_GRADIENTS
      case CTX_SOURCE_LINEAR_GRADIENT: return ctx_fragment_linear_gradient_GRAYA8;
      case CTX_SOURCE_RADIAL_GRADIENT: return ctx_fragment_radial_gradient_GRAYA8;
#endif
    }
  return ctx_fragment_color_GRAYA8;
}

ctx_u8_porter_duff(GRAYA8, 2,generic, rasterizer->fragment, rasterizer->state->gstate.blend_mode)

#if CTX_INLINED_NORMAL
ctx_u8_porter_duff(GRAYA8, 2,generic_normal, rasterizer->fragment, CTX_BLEND_NORMAL)

static void
ctx_GRAYA8_copy_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_u8_copy_normal (2, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_GRAYA8_clear_normal (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_u8_clear_normal (2, count, dst, src, coverage, rasterizer, x0);
}

static void
ctx_GRAYA8_source_over_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
#if 1
  ctx_u8_source_over_normal_color (2, count, dst, rasterizer->color, coverage, rasterizer, x0);
#else
  uint8_t tsrc[5];
  *((uint32_t*)tsrc) = *((uint32_t*)src);

  while (count--)
  {
    uint32_t cov = *coverage++;
    uint32_t common =(((((255+(tsrc[1] * cov))>>8))^255 ));
    dst[0] =  ((((tsrc[0] * cov)) + (dst[0] * common ))>>8);
    dst[1] =  ((((tsrc[1] * cov)) + (dst[1] * common ))>>8);
    dst+=2;
  }
#endif
}

static void
ctx_GRAYA8_source_copy_normal_color (CTX_COMPOSITE_ARGUMENTS)
{
  ctx_u8_source_copy_normal_color (2, count, dst, rasterizer->color, coverage, rasterizer, x0);
}
#endif

inline static int
ctx_is_opaque_color (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  if (gstate->global_alpha_u8 != 255)
    return 0;
  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
  {
    uint8_t ga[2];
    ctx_color_get_graya_u8 (rasterizer->state, &gstate->source_fill.color, ga);
    return ga[1] == 255;
  }
  return 0;
}

static void
ctx_setup_GRAYA8 (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  int components = 2;
  rasterizer->fragment = ctx_rasterizer_get_fragment_GRAYA8 (rasterizer);
  rasterizer->comp_op  = ctx_GRAYA8_porter_duff_generic;
  rasterizer->comp = CTX_COV_PATH_FALLBACK;
  if (gstate->source_fill.type == CTX_SOURCE_NONE)
  {
    ctx_setup_apply_coverage (rasterizer);
    return;
  }
  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
    {
      ctx_fragment_color_GRAYA8 (rasterizer, 0,0, 1,rasterizer->color, 1, 0,0,0);
      if (gstate->global_alpha_u8 != 255)
        for (int c = 0; c < components; c ++)
          rasterizer->color[c] = (rasterizer->color[c] * gstate->global_alpha_u8)/255;

      if (rasterizer->format->from_comp)
        rasterizer->format->from_comp (rasterizer, 0,
          &rasterizer->color[0],
          &rasterizer->color_native,
          1);
    }

#if CTX_INLINED_NORMAL
  if (gstate->compositing_mode == CTX_COMPOSITE_CLEAR)
    rasterizer->comp_op = ctx_GRAYA8_clear_normal;
  else
    switch (gstate->blend_mode)
    {
      case CTX_BLEND_NORMAL:
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp_op = ctx_GRAYA8_copy_normal;
          rasterizer->comp = CTX_COV_PATH_GRAYA8_COPY;
        }
        else if (gstate->global_alpha_u8 == 0)
          rasterizer->comp_op = ctx_RGBA8_nop;
        else
        switch (gstate->source_fill.type)
        {
          case CTX_SOURCE_COLOR:
            if (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER)
            {
              if (rasterizer->color[components-1] == 0)
                rasterizer->comp_op = ctx_RGBA8_nop;
              else if (rasterizer->color[components-1] == 255)
              {
                rasterizer->comp_op = ctx_GRAYA8_source_copy_normal_color;
                rasterizer->comp = CTX_COV_PATH_GRAYA8_COPY;
              }
              else
                rasterizer->comp_op = ctx_GRAYA8_source_over_normal_color;
            }
            else
            {
              rasterizer->comp_op = ctx_GRAYA8_porter_duff_generic_normal;
            }
            break;
          default:
            rasterizer->comp_op = ctx_GRAYA8_porter_duff_generic_normal;
            break;
        }
        break;
    }
#else
    if ((gstate->blend_mode == CTX_BLEND_NORMAL) &
        (gstate->source_fill.type == CTX_SOURCE_COLOR))
    {
        if (gstate->compositing_mode == CTX_COMPOSITE_COPY)
        {
          rasterizer->comp = CTX_COV_PATH_GRAYA8_COPY;
        }
        else if ((gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OVER) &
                 (rasterizer->color[components-1] == 255))
        {
          rasterizer->comp = CTX_COV_PATH_GRAYA8_COPY;
        }
    }
#endif
  ctx_setup_apply_coverage (rasterizer);
}

#if CTX_ENABLE_GRAY4
static void
ctx_setup_GRAY4 (CtxRasterizer *rasterizer)
{
  ctx_setup_GRAYA8 (rasterizer);
  if (rasterizer->comp == CTX_COV_PATH_GRAYA8_COPY)
    rasterizer->comp = CTX_COV_PATH_GRAY4_COPY;
  else
  rasterizer->comp = CTX_COV_PATH_FALLBACK;
}
#endif

#if CTX_ENABLE_GRAY2
static void
ctx_setup_GRAY2 (CtxRasterizer *rasterizer)
{
  ctx_setup_GRAYA8 (rasterizer);
  if (rasterizer->comp == CTX_COV_PATH_GRAYA8_COPY)
    rasterizer->comp = CTX_COV_PATH_GRAY2_COPY;
  else
    rasterizer->comp = CTX_COV_PATH_FALLBACK;
}
#endif

#if CTX_ENABLE_GRAY1
static void
ctx_setup_GRAY1 (CtxRasterizer *rasterizer)
{
  ctx_setup_GRAYA8 (rasterizer);
  if (rasterizer->comp == CTX_COV_PATH_GRAYA8_COPY)
    rasterizer->comp = CTX_COV_PATH_GRAY1_COPY;
  else
    rasterizer->comp = CTX_COV_PATH_FALLBACK;
}
#endif

static void
ctx_setup_GRAY8 (CtxRasterizer *rasterizer)
{
  ctx_setup_GRAYA8 (rasterizer);
  if (rasterizer->comp == CTX_COV_PATH_GRAYA8_COPY)
    rasterizer->comp = CTX_COV_PATH_GRAY8_COPY;
  else
    rasterizer->comp = CTX_COV_PATH_FALLBACK;
}

#endif

#endif


static inline uint8_t
ctx_332_pack (uint8_t red,
              uint8_t green,
              uint8_t blue)
{
  return ((ctx_sadd8(red,15) >> 5) << 5)
        |((ctx_sadd8(green,15) >> 5) << 2)
        |(ctx_sadd8(blue,15) >> 6);
}
#if CTX_ENABLE_RGB332

static inline uint8_t
ctx_888_to_332 (uint32_t in)
{
  uint8_t *rgb=(uint8_t*)(&in);
  return ctx_332_pack (rgb[0],rgb[1],rgb[2]);
}

static inline uint32_t
ctx_332_to_888 (uint8_t in)
{
  uint32_t ret = 0;
  uint8_t *rgba=(uint8_t*)&ret;
  ctx_332_unpack (in,
                  &rgba[0],
                  &rgba[1],
                  &rgba[2]);
  rgba[3] = 255;
  return ret;
}

static inline void
ctx_RGB332_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
      ctx_332_unpack (*pixel, &rgba[0], &rgba[1], &rgba[2]);
#if CTX_RGB332_ALPHA
      if ((rgba[0]==255) & (rgba[2] == 255) & (rgba[1]==0))
        { rgba[3] = 0; }
      else
#endif
        { rgba[3] = 255; }
      pixel+=1;
      rgba +=4;
    }
}

static inline void
ctx_RGBA8_to_RGB332 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint8_t *pixel = (uint8_t *) buf;
  while (count--)
    {
#if CTX_RGB332_ALPHA
      if (rgba[3]==0)
        { pixel[0] = ctx_332_pack (255, 0, 255); }
      else
#endif
        { pixel[0] = ctx_332_pack (rgba[0], rgba[1], rgba[2]); }
      pixel+=1;
      rgba +=4;
    }
}

static void
ctx_composite_RGB332 (CTX_COMPOSITE_ARGUMENTS)
{
#if 0 // it is slower
  if (CTX_LIKELY(rasterizer->comp_op == ctx_RGBA8_source_over_normal_color))
  {
    uint32_t si_ga = ((uint32_t*)rasterizer->color)[1];
    uint32_t si_rb = ((uint32_t*)rasterizer->color)[2];
    uint32_t si_a  = si_ga >> 16;

    while (count--)
    {
      uint32_t cov   = *coverage++;
      uint32_t rcov  = (((255+si_a * cov)>>8))^255;
      uint32_t di    = ctx_332_to_888 (*((uint8_t*)dst));
      uint32_t di_ga = ((di & 0xff00ff00) >> 8);
      uint32_t di_rb = (di & 0x00ff00ff);
      *((uint8_t*)(dst)) =
      ctx_888_to_332((((si_rb * cov + 0xff00ff + di_rb * rcov) & 0xff00ff00) >> 8)  |
       ((si_ga * cov + 0xff00ff + di_ga * rcov) & 0xff00ff00));
       dst+=1;
    }
    return;
  }
#endif
  uint8_t pixels[count * 4];
  ctx_RGB332_to_RGBA8 (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_RGBA8_to_RGB332 (rasterizer, x0, &pixels[0], dst, count);
}

#endif
#if CTX_ENABLE_RGB565 | CTX_ENABLE_RGB565_BYTESWAPPED

static inline void
ctx_565_unpack (const uint16_t pixel,
                uint8_t *red,
                uint8_t *green,
                uint8_t *blue,
                const int byteswap)
{
  uint16_t byteswapped;
  if (byteswap)
    { byteswapped = (pixel>>8) | (pixel<<8); }
  else
    { byteswapped  = pixel; }
  uint8_t b  =  (byteswapped & 31) <<3;
  uint8_t g  = ( (byteswapped>>5) & 63) <<2;
  uint8_t r  = ( (byteswapped>>11) & 31) <<3;

#if 0
  *blue  = (b > 248) * 255 + (b <= 248) * b;
  *green = (g > 248) * 255 + (g <= 248) * g;
  *red   = (r > 248) * 255 + (r <= 248) * r;
#else
  *blue = b;
  *green = g;
  *red = r;
#endif
}


static inline uint16_t
ctx_888_to_565 (uint32_t in, int byteswap)
{
  uint8_t *rgb=(uint8_t*)(&in);
  return ctx_565_pack (rgb[0],rgb[1],rgb[2], byteswap);
}

static inline uint32_t
ctx_565_to_888 (uint16_t in, int byteswap)
{
  uint32_t ret = 0;
  uint8_t *rgba=(uint8_t*)&ret;
  ctx_565_unpack (in,
                  &rgba[0],
                  &rgba[1],
                  &rgba[2],
                  byteswap);
  //rgba[3]=255;
  return ret;
}

#endif
#if CTX_ENABLE_RGB565


static inline void
ctx_RGB565_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count)
{
  const uint16_t *pixel = (uint16_t *) buf;
  while (count--)
    {
      // XXX : checking the raw value for alpha before unpack will be faster
      ((uint32_t*)(rgba))[0] = ctx_565_unpack_32 (*pixel, 0);
#if CTX_RGB565_ALPHA
      if ((rgba[0]==255) & (rgba[2] == 255) & (rgba[1]==0))
        { rgba[3] = 0; }
#endif
      pixel+=1;
      rgba +=4;
    }
}

static inline void
ctx_RGBA8_to_RGB565 (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count)
{
  uint16_t *pixel = (uint16_t *) buf;
  while (count--)
    {
#if CTX_RGB565_ALPHA
      if (rgba[3]==0)
        { pixel[0] = ctx_565_pack (255, 0, 255, 0); }
      else
#endif
        { pixel[0] = ctx_565_pack (rgba[0], rgba[1], rgba[2], 0); }
      pixel+=1;
      rgba +=4;
    }
}

static void
ctx_RGBA8_source_over_normal_color (CTX_COMPOSITE_ARGUMENTS);
static void
ctx_RGBA8_source_copy_normal_color (CTX_COMPOSITE_ARGUMENTS);

static void
ctx_composite_RGB565 (CTX_COMPOSITE_ARGUMENTS)
{
  uint8_t pixels[count * 4];
  ctx_RGB565_to_RGBA8 (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_RGBA8_to_RGB565 (rasterizer, x0, &pixels[0], dst, count);
}
#endif
#if CTX_ENABLE_RGB565_BYTESWAPPED

static void
ctx_RGB565_BS_to_RGBA8 (CtxRasterizer *rasterizer, int x, const void *buf, uint8_t *rgba, int count);
static void
ctx_RGBA8_to_RGB565_BS (CtxRasterizer *rasterizer, int x, const uint8_t *rgba, void *buf, int count);

static void
ctx_composite_RGB565_BS (CTX_COMPOSITE_ARGUMENTS)
{
  uint8_t pixels[count * 4];
  ctx_RGB565_BS_to_RGBA8 (rasterizer, x0, dst, &pixels[0], count);
  rasterizer->comp_op (count, &pixels[0], rasterizer->color, coverage, rasterizer, x0);
  ctx_RGBA8_to_RGB565_BS (rasterizer, x0, &pixels[0], dst, count);
}
#endif


static inline uint32_t
ctx_over_RGBA8 (uint32_t dst, uint32_t src, uint32_t cov)
{
  uint32_t si_ga = (src & 0xff00ff00) >> 8;
  uint32_t si_rb = src & 0x00ff00ff;
  uint32_t si_a  = si_ga >> 16;
  uint32_t rcov  = ((255+si_a * cov)>>8)^255;
  uint32_t di_ga = ( dst & 0xff00ff00) >> 8;
  uint32_t di_rb = dst & 0x00ff00ff;
  return
     ((((si_rb * cov) + 0xff00ff + (di_rb * rcov)) & 0xff00ff00) >> 8)  |
      (((si_ga * cov) + 0xff00ff + (di_ga * rcov)) & 0xff00ff00);
}


static inline uint32_t
ctx_over_RGBA8_full (uint32_t dst, uint32_t src)
{
  uint32_t si_ga = (src & 0xff00ff00) >> 8;
  uint32_t si_rb = src & 0x00ff00ff;
  uint32_t si_a  = si_ga >> 16;
  uint32_t rcov  = si_a^255;
  uint32_t di_ga = (dst & 0xff00ff00) >> 8;
  uint32_t di_rb = dst & 0x00ff00ff;
  return
     ((((si_rb * 255) + 0xff00ff + (di_rb * rcov)) & 0xff00ff00) >> 8)  |
      (((si_ga * 255) + 0xff00ff + (di_ga * rcov)) & 0xff00ff00);
}

static inline uint32_t
ctx_over_RGBA8_2 (uint32_t dst, uint32_t si_ga, uint32_t si_rb, uint32_t si_a, uint32_t cov)
{
  uint32_t rcov  = ((si_a * cov)/255)^255;
  uint32_t di_ga = (dst & 0xff00ff00) >> 8;
  uint32_t di_rb = dst & 0x00ff00ff;
  return
     ((((si_rb * cov) + 0xff00ff + (di_rb * rcov)) & 0xff00ff00) >> 8)  |
      (((si_ga * cov) + 0xff00ff + (di_ga * rcov)) & 0xff00ff00);
}


static inline void ctx_span_set_colorb  (uint32_t *dst_pix, uint32_t val, int count)
{
  while(count--)
    *dst_pix++=val;
}

static inline void ctx_span_set_colorbu (uint32_t *dst_pix, uint32_t val, unsigned int count)
{
  while(count--)
    *dst_pix++=val;
}

#if CTX_FAST_FILL_RECT

#if 1

static inline void ctx_RGBA8_image_rgba8_RGBA8_nearest_fill_rect_copy (CtxRasterizer *rasterizer, int x0, int y0, int x1, int y1, const int copy)
{
#if 1
  float u0 = 0; float v0 = 0;
  float ud = 0; float vd = 0;
  float w0 = 1; float wd = 0;
  ctx_init_uv (rasterizer, x0, y0,&u0, &v0, &w0, &ud, &vd, &wd);
#endif

  uint32_t *dst = ( (uint32_t *) rasterizer->buf);
  int blit_stride = rasterizer->blit_stride/4;
  dst += (y0 - rasterizer->blit_y) * blit_stride;
  dst += (x0);

  unsigned int width = x1-x0+1;
  unsigned int height = y1-y0+1;

  CtxSource *g = &rasterizer->state->gstate.source_fill;
#if CTX_ENABLE_CM
         CtxBuffer *buffer = g->texture.buffer->color_managed?g->texture.buffer->color_managed:g->texture.buffer;
#else
         CtxBuffer *buffer = g->texture.buffer;
#endif
  int bwidth  = buffer->width;
  int bheight = buffer->height;
  int u = u0;// + 0.5f;
  int v = v0;// + 0.5f;

  uint32_t *src = ((uint32_t*)buffer->data) + bwidth * v + u;

  int pre = ctx_mini(ctx_maxi(-u,0), width);

  width-=pre;
  u+=pre;

  int core = ctx_mini (width, bwidth - u);

  if (core<0)
    return;
  if (copy)
  {
      uint32_t *t_dst = dst;
      src += pre;
      for (unsigned int y = 0; (y < height) & (v < bheight); y++)
      {
         memcpy (t_dst, src, core * 4);
         v++;
         src += bwidth;
         t_dst += blit_stride;
      }
  }
  else
  {
      uint32_t *t_dst = dst;
      for (unsigned int y = 0; (y < height) & (v < bheight); y++)
      {
         ctx_RGBA8_source_over_normal_full_cov_buf (core,
             (uint8_t*)t_dst, NULL, NULL, rasterizer, x0 + pre, (uint8_t*)src);
         v++;
         src += bwidth;
         t_dst += blit_stride;
      }
  }
}
#endif


static CTX_INLINE void
ctx_composite_fill_rect_aligned (CtxRasterizer *rasterizer,
                                 int            x0,
                                 int            y0,
                                 int            x1,
                                 int            y1,
                                 const uint8_t  cov)
{
  int blit_x      = rasterizer->blit_x;
  int blit_y      = rasterizer->blit_y;
  int blit_width  = rasterizer->blit_width;
  int blit_height = rasterizer->blit_height;
  int blit_stride = rasterizer->blit_stride;

  x0 = ctx_maxi (x0, blit_x);
  x1 = ctx_mini (x1, blit_x + blit_width - 1);
  y0 = ctx_maxi (y0, blit_y);
  y1 = ctx_mini (y1, blit_y + blit_height - 1);

  const int width = x1 - x0 + 1;
  const int height= y1 - y0 + 1;
  //
  if (((width <=0) | (height <= 0)))
    return;

  CtxCovPath comp = rasterizer->comp;
  uint8_t *dst;

  // this could be done here, but is not used
  // by a couple of the cases
#define INIT_ENV do {\
  rasterizer->scanline = y0 * CTX_FULL_AA; \
  dst = ( (uint8_t *) rasterizer->buf); \
  dst += (y0 - blit_y) * blit_stride; \
  dst += (x0 * rasterizer->format->bpp)/8;}while(0);

  if (cov == 255)
  {
    switch (comp)
    {
    case CTX_COV_PATH_RGBA8_COPY:
    {
      uint32_t color = ((uint32_t*)(rasterizer->color))[0];
      INIT_ENV;
      if (CTX_UNLIKELY(width == 1))
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          uint32_t *dst_i = (uint32_t*)&dst[0];
          *dst_i = color;
          dst += blit_stride;
        }
      }
      else
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          ctx_span_set_colorbu ((uint32_t*)&dst[0], color, width);
          dst += blit_stride;
        }
      }
      return;
    }
    case CTX_COV_PATH_RGBAF_COPY:
    case CTX_COV_PATH_GRAY8_COPY:
    case CTX_COV_PATH_GRAYA8_COPY:
    case CTX_COV_PATH_GRAYAF_COPY:
    case CTX_COV_PATH_CMYKAF_COPY:
    case CTX_COV_PATH_RGB565_COPY:
    case CTX_COV_PATH_RGB332_COPY:
    case CTX_COV_PATH_RGB8_COPY:
    case CTX_COV_PATH_CMYK8_COPY:
    case CTX_COV_PATH_CMYKA8_COPY:
    {
      uint8_t *color = (uint8_t*)&rasterizer->color_native;
      unsigned int bytes = rasterizer->format->bpp/8;
      INIT_ENV;

      switch (bytes)
      {
        case 1:
          {
          uint8_t col = *color;
          if (width == 1)
          for (unsigned int y = y0; y <= (unsigned)y1; y++)
          {
            *dst = col;
            dst += blit_stride;
          }
          else
          for (unsigned int y = y0; y <= (unsigned)y1; y++)
          {
#if 0
            uint8_t *dst_i = (uint8_t*)&dst[0];
            for (int x = 0; x < width; x++) *dst_i++ = col;
#else
            memset (dst, col, width);
#endif
            dst += blit_stride;
          }
          }
          break;
        case 2:
          {
            uint16_t val = ((uint16_t*)color)[0];
            for (unsigned int y = y0; y <= (unsigned)y1; y++)
            {
              uint16_t *dst_i = (uint16_t*)&dst[0];
              for (int x = 0; x < width; x++)
                 *dst_i++ = val;
              dst += blit_stride;
            }
          }
          break;
        case 3:
          for (unsigned int y = y0; y <= (unsigned)y1; y++)
          {
            uint8_t *dst_i = (uint8_t*)&dst[0];
            for (int x = 0; x < width; x++)
                for (unsigned int b = 0; b < 3; b++) *dst_i++ = color[b];
            dst += blit_stride;
          }
          break;
        case 4:
          {
            uint32_t val = ((uint32_t*)color)[0];
            if (width == 1)
            for (unsigned int y = y0; y <= (unsigned)y1; y++)
            {
              *((uint32_t*)&dst[0]) = val;
              dst += blit_stride;
            }
            else
            for (unsigned int y = y0; y <= (unsigned)y1; y++)
            {
              //uint32_t *dst_i = (uint32_t*)&dst[0];
              ctx_span_set_colorbu ((uint32_t*)&dst[0], val, width);
              dst += blit_stride;
            }
          }
          break;
        case 5:
          for (unsigned int y = y0; y <= (unsigned)y1; y++)
          {
            uint8_t *dst_i = (uint8_t*)&dst[0];
            for (int x = 0; x < width; x++)
               for (unsigned int b = 0; b < 5; b++) *dst_i++ = color[b];
            dst += blit_stride;
          }
          break;
        case 16:
          for (unsigned int y = y0; y <= (unsigned)y1; y++)
          {
            uint8_t *dst_i = (uint8_t*)&dst[0];
            for (int x = 0; x < width; x++)for (unsigned int b = 0; b < 16; b++) *dst_i++ = color[b];
            dst += blit_stride;
          }
          break;
        default:
          for (unsigned int y = y0; y <= (unsigned)y1; y++)
          {
            uint8_t *dst_i = (uint8_t*)&dst[0];
            for (int x = 0; x < width; x++)
              for (unsigned int b = 0; b < bytes; b++)
                *dst_i++ = color[b];
            dst += blit_stride;
          }
      }
      return;
    }
    case CTX_COV_PATH_RGBA8_OVER:
    {
      uint32_t si_ga_full = ((uint32_t*)rasterizer->color)[3];
      uint32_t si_rb_full = ((uint32_t*)rasterizer->color)[4];
      uint32_t si_a  = rasterizer->color[3];
      INIT_ENV;

      if (width == 1)
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          ((uint32_t*)(dst))[0] = ctx_over_RGBA8_full_2 (
             ((uint32_t*)(dst))[0], si_ga_full, si_rb_full, si_a);
          dst += blit_stride;
        }
      }
      else
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          uint32_t *dst_i = (uint32_t*)&dst[0];
          for (unsigned int i = 0; i < (unsigned)width; i++)
            dst_i[i] = ctx_over_RGBA8_full_2 (dst_i[i], si_ga_full, si_rb_full, si_a);
          dst += blit_stride;
        }
      }
      return;
    }
    case CTX_COV_PATH_RGBA8_COPY_FRAGMENT:
    {
      CtxFragment fragment = rasterizer->fragment;
      CtxMatrix *transform = &rasterizer->state->gstate.source_fill.transform;
      //CtxExtend extend = rasterizer->state->gstate.extend;
      INIT_ENV;

#if CTX_FRAGMENT_SPECIALIZE
      if (fragment == ctx_fragment_image_rgba8_RGBA8_nearest_copy)
      {
        ctx_RGBA8_image_rgba8_RGBA8_nearest_fill_rect_copy (rasterizer, x0, y0, x1, y1, 1);
        return;
      }
#endif
#if 0
      if (fragment == ctx_fragment_image_rgba8_RGBA8_bi_scale)
      {
        ctx_RGBA8_image_rgba8_RGBA8_bi_scaled_fill_rect (rasterizer, x0, y0, x1,
y1, 1);
        return;
      }
#endif

      if (CTX_LIKELY(ctx_matrix_no_perspective (transform)))
      {
        int scan = rasterizer->scanline/CTX_FULL_AA;
        float u0, v0, ud, vd, w0, wd;
        ctx_init_uv (rasterizer, x0, scan, &u0, &v0, &w0, &ud, &vd, &wd);
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          fragment (rasterizer, u0, v0, w0, &dst[0], width, ud, vd, wd);
          u0 -= vd;
          v0 += ud;
          dst += blit_stride;
        }
      }
      else
      {
        int scan = rasterizer->scanline/CTX_FULL_AA;
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          float u0, v0, ud, vd, w0, wd;
          ctx_init_uv (rasterizer, x0, scan + y-y0, &u0, &v0, &w0, &ud, &vd, &wd);
          fragment (rasterizer, u0, v0, w0, &dst[0], width, ud, vd, wd);
          dst += blit_stride;
        }
      }
      return;
    }
    case CTX_COV_PATH_RGBA8_OVER_FRAGMENT:
    {
#if CTX_FRAGMENT_SPECIALIZE
      CtxFragment fragment = rasterizer->fragment;
      //CtxExtend extend = rasterizer->state->gstate.extend;
      if (fragment == ctx_fragment_image_rgba8_RGBA8_nearest_copy)
      {
        ctx_RGBA8_image_rgba8_RGBA8_nearest_fill_rect_copy (rasterizer, x0, y0, x1, y1, 0);
        return;
      }
      else
#endif
#if 0
      if (fragment == ctx_fragment_image_rgba8_RGBA8_bi_scale)
      {
        ctx_RGBA8_image_rgba8_RGBA8_bi_scaled_fill_rect (rasterizer, x0, y0, x1,
y1, 0);
        return;
      }
#endif
      INIT_ENV;
      CTX_SIMD_SUFFIX(ctx_RGBA8_source_over_normal_full_cov_fragment) (width,
                         &dst[0], NULL, NULL, rasterizer, x0, y1-y0+1);
      return;
    }
    break;
    default:
    break;
    }
  }
  else
  {
    switch (comp)
    {
    case CTX_COV_PATH_RGBA8_COPY:
    {
      uint32_t color = ((uint32_t*)(rasterizer->color))[0];
      INIT_ENV;
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          uint32_t *dst_i = (uint32_t*)&dst[0];
          for (unsigned int i = 0; i < (unsigned)width; i++)
            dst_i[i] = ctx_lerp_RGBA8 (dst_i[i], color, cov);
          dst += blit_stride;
        }
        return;
      }
    }
    case CTX_COV_PATH_RGBAF_COPY:
    {
      float *color = ((float*)rasterizer->color);
      float covf = cov / 255.0f;
      INIT_ENV;
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          float *dst_f = (float*)&dst[0];
          for (unsigned int i = 0; i < (unsigned)width; i++)
          {
            for (unsigned int c = 0; c < 4; c++)
              dst_f[i*4+c] = ctx_lerpf (dst_f[i*4+c], color[c], covf);
          }
          dst += blit_stride;
        }
        return;
      }
    }
    case CTX_COV_PATH_RGBA8_OVER:
    {
      uint32_t color = ((uint32_t*)(rasterizer->color))[0];
      INIT_ENV;
      if (width == 1)
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          uint32_t *dst_i = (uint32_t*)&dst[0];
          *dst_i = ctx_over_RGBA8 (*dst_i, color, cov);
          dst += blit_stride;
        }
      }
      else
      {
        for (unsigned int y = y0; y <= (unsigned)y1; y++)
        {
          uint32_t *dst_i = (uint32_t*)&dst[0];
          for (unsigned int i = 0; i < (unsigned)width; i++)
            dst_i[i] = ctx_over_RGBA8 (dst_i[i], color, cov);
          dst += blit_stride;
        }
      }
      return;
    }
    break;
    default:
    break;
    }
  }

  INIT_ENV;
#undef INIT_ENV


  /* fallback */
  {
    uint8_t coverage[width];
    memset (coverage, cov, sizeof (coverage) );
    uint8_t *rasterizer_src = rasterizer->color;
    ctx_apply_coverage_fun apply_coverage =
      rasterizer->apply_coverage;

    for (unsigned int y = y0; y <= (unsigned)y1; y++)
    {
      apply_coverage (width, &dst[0], rasterizer_src, coverage, rasterizer, (int)x0);
      rasterizer->scanline += CTX_FULL_AA;
      dst += blit_stride;
    }
  }
}


void
CTX_SIMD_SUFFIX (ctx_composite_fill_rect) (CtxRasterizer *rasterizer,
                          float          x0,
                          float          y0,
                          float          x1,
                          float          y1,
                          uint8_t        cov)
{
  float x0_fm = ctx_fmod1f (x0);
  float y0_fm = ctx_fmod1f (y0);
  float x1_fm = ctx_fmod1f (x1);
  float y1_fm = ctx_fmod1f (y1);

  if(((int)(x0_fm < 0.01f) | (x0_fm > 0.99f)) &
     ((int)(y0_fm < 0.01f) | (y0_fm > 0.99f)) &
     ((int)(x1_fm < 0.01f) | (x1_fm > 0.99f)) &
     ((int)(y1_fm < 0.01f) | (y1_fm > 0.99f)))
  {
    /* best-case scenario axis aligned rectangle */
    int ix0 = (int)x0;
    int iy0 = (int)y0;
    int ix1 = (int)x1-1;
    int iy1 = (int)y1-1;
    if ((ix1 >= ix0) & (iy1 >= iy0))
      ctx_composite_fill_rect_aligned (rasterizer, ix0, iy0, ix1, iy1, 255);
    return;
  }

  int blit_x = rasterizer->blit_x;
  int blit_y = rasterizer->blit_y;
  int blit_stride = rasterizer->blit_stride;
  int blit_width = rasterizer->blit_width;
  int blit_height = rasterizer->blit_height;
  uint8_t *rasterizer_src = rasterizer->color;
  ctx_apply_coverage_fun apply_coverage = 
    rasterizer->apply_coverage;

  y1 += 1.0f;
  x1 += 7.0f/8.0f;

  uint8_t left = (int)(255-x0_fm * 255);
  uint8_t top  = (int)(255-y0_fm * 255);
  uint8_t right  = (int)(x1_fm * 255);
  uint8_t bottom = (int)(y1_fm * 255);


  int has_top    = (top < 255);
  int has_bottom = (bottom < 255);
  int has_right  = (right > 0);
  int has_left   = (left > 0);

  has_right *= !(x1 >= blit_x + blit_width);
  has_bottom *= !(y1 >= blit_y + blit_height);

  x0 = ctx_maxi (x0, blit_x);
  x1 = ctx_mini (x1, blit_x + blit_width);
  y0 = ctx_maxi (y0, blit_y);
  y1 = ctx_mini (y1, blit_y + blit_height);
  x0 = ctx_floorf (x0);
  y0 = ctx_floorf (y0);
  x1 = ctx_floorf (x1);
  y1 = ctx_floorf (y1);

  int width = (int)(x1 - x0);
  int height = (int)(y1 - y0);

  if ((width >0) & (height>0))
  {
     uint8_t *dst = ( (uint8_t *) rasterizer->buf);
     uint8_t coverage[width+2];
     uint32_t x0i = (int)x0+has_left;
     uint32_t x1i = (int)x1-has_right;
     uint32_t y0i = (int)y0+has_top;
     uint32_t y1i = (int)y1-has_bottom;
     dst += (((int)y0) - blit_y) * blit_stride;
     dst += ((int)x0) * rasterizer->format->bpp/8;

     if (has_top)
     {
       int i = 0;
       if (has_left)
       {
         coverage[i++] = (top * left + 255) >> 8;
       }
       for (unsigned int x = x0i; x < x1i; x++)
         coverage[i++] = top;
       if (has_right)
         coverage[i++]= (top * right + 255) >> 8;

       apply_coverage (width, dst, rasterizer_src, coverage, rasterizer, (int)x0);
       dst += blit_stride;
     }

  if (y1-y0-has_top-has_bottom > 0)
  {
    if (has_left)
      ctx_composite_fill_rect_aligned (rasterizer, (int)x0, y0i,
                                                   (int)x0, y1i-1, left);
    if (has_right)
      ctx_composite_fill_rect_aligned (rasterizer, (int)x1-1, y0i,
                                                   (int)x1-1, y1i-1, right);

    if (width - has_left - has_right > 0)
      ctx_composite_fill_rect_aligned (rasterizer, x0i,y0i,
                                          x1i-1,y1i-1,255);

    dst += blit_stride * (y1i-y0i);
  }
    if (has_bottom)
    {
      int i = 0;
      if (has_left)
        coverage[i++] = (bottom * left + 255) >> 8;
      for (unsigned int x = x0i; x < x1i; x++)
        coverage[i++] = bottom;
      coverage[i++]= (bottom * right + 255) >> 8;

      apply_coverage (width, dst, rasterizer_src, coverage, rasterizer, (int)x0);
    }
  }
}

#if CTX_FAST_STROKE_RECT

void
CTX_SIMD_SUFFIX(ctx_composite_stroke_rect) (CtxRasterizer *rasterizer,
                           float          x0,
                           float          y0,
                           float          x1,
                           float          y1,
                           float          line_width)
{
      float lwmod = ctx_fmod1f (line_width);
      int lw = (int)ctx_floorf (line_width + 0.5f);
      int is_compat_even = (lw % 2 == 0) && (lwmod < 0.1f); // only even linewidths implemented properly
      int is_compat_odd = (lw % 2 == 1) && (lwmod < 0.1f); // only even linewidths implemented properly

      float off_x = 0;
      float off_y = 0;

      if (is_compat_odd)
      {
        off_x = 0.5f;
        off_y = (CTX_FULL_AA/2)*1.0f / (CTX_FULL_AA);
      }

      if((is_compat_odd | is_compat_even) &

     (((int)(ctx_fmod1f (x0-off_x) < 0.01f) | (ctx_fmod1f(x0-off_x) > 0.99f)) &
     ((int)(ctx_fmod1f (y0-off_y) < 0.01f) | (ctx_fmod1f(y0-off_y) > 0.99f)) &
     ((int)(ctx_fmod1f (x1-off_x) < 0.01f) | (ctx_fmod1f(x1-off_x) > 0.99f)) &
     ((int)(ctx_fmod1f (y1-off_y) < 0.01f) | (ctx_fmod1f(y1-off_y) > 0.99f))))


      {
        int bw = lw/2+1;
        int bwb = lw/2;

        if (is_compat_even)
        {
          bw = lw/2;
        }
        /* top */
        ctx_composite_fill_rect_aligned (rasterizer,
                                         (int)x0-bwb, (int)y0-bwb,
                                         (int)x1+bw-1, (int)y0+bw-1, 255);
        /* bottom */
        ctx_composite_fill_rect_aligned (rasterizer,
                                         (int)x0-bwb, (int)y1-bwb,
                                         (int)x1-bwb-1, (int)y1+bw-1, 255);

        /* left */
        ctx_composite_fill_rect_aligned (rasterizer,
                                         (int)x0-bwb, (int)y0+1,
                                         (int)x0+bw-1, (int)y1-bwb, 255);
        /* right */
        ctx_composite_fill_rect_aligned (rasterizer,
                                         (int)x1-bwb, (int)y0+1,
                                         (int)x1+bw-1, (int)y1+bw-1, 255);
      }
      else
      {
        float hw = line_width/2;


        /* top */
        ctx_composite_fill_rect (rasterizer,
                                 x0+hw, y0-hw,
                                 x1-hw, y0+hw, 255);
        /* bottom */
        ctx_composite_fill_rect (rasterizer,
                                 x0+hw, y1-hw,
                                 x1-hw, y1+hw, 255);

        /* left */
        ctx_composite_fill_rect (rasterizer,
                                 x0-hw, y0+hw,
                                 x0+hw, y1-hw, 255);
        /* right */

        ctx_composite_fill_rect (rasterizer,
                                 x1-hw, y0+hw,
                                 x1+hw, y1-hw, 255);

        /* corners */

        ctx_composite_fill_rect (rasterizer,
                                 x0-hw, y0-hw,
                                 x0+hw, y0+hw, 255);
        ctx_composite_fill_rect (rasterizer,
                                 x1-hw, y1-hw,
                                 x1+hw, y1+hw, 255);
        ctx_composite_fill_rect (rasterizer,
                                 x1-hw, y0-hw,
                                 x1+hw, y0+hw, 255);
        ctx_composite_fill_rect (rasterizer,
                                 x0-hw, y1-hw,
                                 x0+hw, y1+hw, 255);
      }
}
#endif
#endif



void
CTX_SIMD_SUFFIX (ctx_composite_setup) (CtxRasterizer *rasterizer)
{
  if (rasterizer->comp_op==NULL)
  {
#if CTX_GRADIENTS
#if CTX_GRADIENT_CACHE
  switch (rasterizer->state->gstate.source_fill.type)
  {
    case CTX_SOURCE_CONIC_GRADIENT:
    case CTX_SOURCE_LINEAR_GRADIENT:
    case CTX_SOURCE_RADIAL_GRADIENT:
      ctx_gradient_cache_prime (rasterizer);
      break;
    case CTX_SOURCE_TEXTURE:

      _ctx_matrix_multiply (&rasterizer->state->gstate.source_fill.transform,
                            &rasterizer->state->gstate.transform,
                            &rasterizer->state->gstate.source_fill.set_transform
                            );
#if 0
      rasterizer->state->gstate.source_fill.transform_inv =
                           rasterizer->state->gstate.source_fill.transform;
#endif
      ctx_matrix_invert (&rasterizer->state->gstate.source_fill.transform);

#if 0
      if (!rasterizer->state->gstate.source_fill.texture.buffer->color_managed)
      {
        _ctx_texture_prepare_color_management (rasterizer->state,
        rasterizer->state->gstate.source_fill.texture.buffer);
      }
#endif
      break;
  }
#endif
#endif
  rasterizer->format->setup (rasterizer);
  }
}


const CtxPixelFormatInfo CTX_SIMD_SUFFIX(ctx_pixel_formats)[]=
{
#if CTX_ENABLE_RGBA8
  {
    CTX_FORMAT_RGBA8, 4, 32, 4, 0, 0, CTX_FORMAT_RGBA8,
    NULL, NULL, NULL, ctx_setup_RGBA8
  },
#endif
#if CTX_ENABLE_BGRA8
  {
    CTX_FORMAT_BGRA8, 4, 32, 4, 0, 0, CTX_FORMAT_RGBA8,
    ctx_BGRA8_to_RGBA8, ctx_RGBA8_to_BGRA8, ctx_composite_BGRA8, ctx_setup_RGBA8,
  },
#endif
#if CTX_ENABLE_GRAYF
  {
    CTX_FORMAT_GRAYF, 1, 32, 4 * 2, 0, 0, CTX_FORMAT_GRAYAF,
    NULL, NULL, ctx_composite_GRAYF, ctx_setup_GRAYAF,
  },
#endif
#if CTX_ENABLE_GRAYAF
  {
    CTX_FORMAT_GRAYAF, 2, 64, 4 * 2, 0, 0, CTX_FORMAT_GRAYAF,
    NULL, NULL, NULL, ctx_setup_GRAYAF,
  },
#endif
#if CTX_ENABLE_RGBAF
  {
    CTX_FORMAT_RGBAF, 4, 128, 4 * 4, 0, 0, CTX_FORMAT_RGBAF,
    NULL, NULL, NULL, ctx_setup_RGBAF,
  },
#endif
#if CTX_ENABLE_GRAY1
  {
#if CTX_NATIVE_GRAYA8
    CTX_FORMAT_GRAY1, 1, 1, 2, 1, 1, CTX_FORMAT_GRAYA8,
    ctx_GRAY1_to_GRAYA8, ctx_GRAYA8_to_GRAY1, ctx_composite_convert, ctx_setup_GRAY1,
#else
    CTX_FORMAT_GRAY1, 1, 1, 4, 1, 1, CTX_FORMAT_RGBA8,
    ctx_GRAY1_to_RGBA8, ctx_RGBA8_to_GRAY1, ctx_composite_convert, ctx_setup_RGB,
#endif
  },
#endif
#if CTX_ENABLE_GRAY2
  {
#if CTX_NATIVE_GRAYA8
    CTX_FORMAT_GRAY2, 1, 2, 2, 4, 4, CTX_FORMAT_GRAYA8,
    ctx_GRAY2_to_GRAYA8, ctx_GRAYA8_to_GRAY2, ctx_composite_convert, ctx_setup_GRAY2,
#else
    CTX_FORMAT_GRAY2, 1, 2, 4, 4, 4, CTX_FORMAT_RGBA8,
    ctx_GRAY2_to_RGBA8, ctx_RGBA8_to_GRAY2, ctx_composite_convert, ctx_setup_RGB,
#endif
  },
#endif
#if CTX_ENABLE_GRAY4
  {
#if CTX_NATIVE_GRAYA8
    CTX_FORMAT_GRAY4, 1, 4, 2, 16, 16, CTX_FORMAT_GRAYA8,
    ctx_GRAY4_to_GRAYA8, ctx_GRAYA8_to_GRAY4, ctx_composite_convert, ctx_setup_GRAY4,
#else
    CTX_FORMAT_GRAY4, 1, 4, 4, 16, 16, CTX_FORMAT_GRAYA8,
    ctx_GRAY4_to_RGBA8, ctx_RGBA8_to_GRAY4, ctx_composite_convert, ctx_setup_RGB,
#endif
  },
#endif
#if CTX_ENABLE_GRAY8
  {
#if CTX_NATIVE_GRAYA8
    CTX_FORMAT_GRAY8, 1, 8, 2, 0, 0, CTX_FORMAT_GRAYA8,
    ctx_GRAY8_to_GRAYA8, ctx_GRAYA8_to_GRAY8, ctx_composite_convert, ctx_setup_GRAY8,
#else
    CTX_FORMAT_GRAY8, 1, 8, 4, 0, 0, CTX_FORMAT_RGBA8,
    ctx_GRAY8_to_RGBA8, ctx_RGBA8_to_GRAY8, ctx_composite_convert, ctx_setup_RGB,
#endif
  },
#endif
#if CTX_ENABLE_GRAYA8
  {
#if CTX_NATIVE_GRAYA8
    CTX_FORMAT_GRAYA8, 2, 16, 2, 0, 0, CTX_FORMAT_GRAYA8,
    ctx_GRAYA8_to_RGBA8, ctx_RGBA8_to_GRAYA8, NULL, ctx_setup_GRAYA8,
#else
    CTX_FORMAT_GRAYA8, 2, 16, 4, 0, 0, CTX_FORMAT_RGBA8,
    ctx_GRAYA8_to_RGBA8, ctx_RGBA8_to_GRAYA8, ctx_composite_convert, ctx_setup_RGB,
#endif
  },
#endif
#if CTX_ENABLE_RGB332
  {
    CTX_FORMAT_RGB332, 3, 8, 4, 12, 12, CTX_FORMAT_RGBA8,
    ctx_RGB332_to_RGBA8,  ctx_RGBA8_to_RGB332,
    ctx_composite_RGB332, ctx_setup_RGB332,
  },
#endif
#if CTX_ENABLE_RGB565
  {
    CTX_FORMAT_RGB565, 3, 16, 4, 16, 32, CTX_FORMAT_RGBA8,
    ctx_RGB565_to_RGBA8,  ctx_RGBA8_to_RGB565,
    ctx_composite_RGB565, ctx_setup_RGB565,
  },
#endif
#if CTX_ENABLE_RGB8
  {
    CTX_FORMAT_RGB8, 3, 24, 4, 0, 0, CTX_FORMAT_RGBA8,
    ctx_RGB8_to_RGBA8, ctx_RGBA8_to_RGB8,
    ctx_composite_RGB8, ctx_setup_RGB8,
  },
#endif
#if CTX_ENABLE_BGR8
  {
    CTX_FORMAT_BGR8, 3, 24, 4, 0, 0, CTX_FORMAT_RGBA8,
    ctx_RGB8_to_RGBA8, ctx_RGBA8_to_RGB8,
    ctx_composite_BGR8, ctx_setup_RGB8,
  },
#endif
#if CTX_ENABLE_RGB565_BYTESWAPPED
  {
    CTX_FORMAT_RGB565_BYTESWAPPED, 3, 16, 4, 16, 32, CTX_FORMAT_RGBA8,
    ctx_RGB565_BS_to_RGBA8,
    ctx_RGBA8_to_RGB565_BS,
    ctx_composite_RGB565_BS, ctx_setup_RGB565,
  },
#endif
#if CTX_ENABLE_CMYKAF
  {
    CTX_FORMAT_CMYKAF, 5, 160, 4 * 5, 0, 0, CTX_FORMAT_CMYKAF,
    NULL, NULL, NULL, ctx_setup_CMYKAF,
  },
#endif
#if CTX_ENABLE_CMYKA8
  {
    CTX_FORMAT_CMYKA8, 5, 40, 4 * 5, 0, 0, CTX_FORMAT_CMYKAF,
    NULL, NULL, ctx_composite_CMYKA8, ctx_setup_CMYKA8,
  },
#endif
#if CTX_ENABLE_CMYK8
  {
    CTX_FORMAT_CMYK8, 5, 32, 4 * 5, 0, 0, CTX_FORMAT_CMYKAF,
    NULL, NULL, ctx_composite_CMYK8, ctx_setup_CMYK8,
  },
#endif
#if CTX_ENABLE_YUV420
  {
    CTX_FORMAT_YUV420, 1, 8, 4, 0, 0, CTX_FORMAT_RGBA8,
    NULL, NULL, ctx_composite_convert, ctx_setup_RGB,
  },
#endif
  {
    CTX_FORMAT_NONE, 0, 0, 0, 0, 0, (CtxPixelFormat)0, NULL, NULL, NULL, NULL,
  }
};

#endif // CTX_COMPOSITE

#ifndef __clang__
#if CTX_COMPOSITE_O3
#pragma GCC pop_options
#endif
#if CTX_COMPOSITE_O2
#pragma GCC pop_options
#endif
#endif

#endif // CTX_IMPLEMENTATION

#ifndef __clang__
#if CTX_RASTERIZER_O3
#pragma GCC push_options
#pragma GCC optimize("O3")
#endif
#if CTX_RASTERIZER_O2
#pragma GCC push_options
#pragma GCC optimize("O2")
#endif
#endif

#if CTX_IMPLEMENTATION || CTX_SIMD_BUILD
#if CTX_COMPOSITE 

#define CTX_AA_HALFSTEP    ((CTX_FULL_AA/2)+1)
#define CTX_AA_HALFSTEP2   (CTX_FULL_AA/2)


#define CTX_MAGIC_OFFSET  1 // without this we get scanline glitches

static inline void ctx_rasterizer_discard_edges (CtxRasterizer *rasterizer)
{
  int scanline = rasterizer->scanline + CTX_MAGIC_OFFSET;
  int next_scanline = scanline + CTX_FULL_AA;
  CtxSegment *segments = &((CtxSegment*)(rasterizer->edge_list.entries))[0];
  int *edges = rasterizer->edges;
  int ending_edges = 0;
  unsigned int active_edges = rasterizer->active_edges;
  for (unsigned int i = 0; i < active_edges; i++)
    {
      CtxSegment *segment = segments + edges[i];
      int edge_end = segment->y1;
      if (edge_end < scanline)
        {
#if 0
          for (unsigned int j = i; j < active_edges -1; j++)
            rasterizer->edges[j] = rasterizer->edges[j+1];
#else
          rasterizer->edges[i] = rasterizer->edges[active_edges-1];
#endif
          rasterizer->scan_aa[segment->aa]--;
          active_edges--;
          i--;
        }
      else ending_edges += (edge_end < next_scanline);
    }
  rasterizer->active_edges = active_edges;

  unsigned int pending_edges = rasterizer->pending_edges;
  for (unsigned int i = 0; i < pending_edges; i++)
    {
      int edge_end = ((CtxSegment*)(rasterizer->edge_list.entries))[rasterizer->edges[CTX_MAX_EDGES-1-i]].y1;
      ending_edges += (edge_end < next_scanline);
    }
  rasterizer->ending_edges = ending_edges;
}

CTX_INLINE static void ctx_rasterizer_increment_edges (CtxRasterizer *rasterizer, int count)
{
  CtxSegment *__restrict__ segments = &((CtxSegment*)(rasterizer->edge_list.entries))[0];
  unsigned int active_edges = rasterizer->active_edges;
  unsigned int pending_edges = rasterizer->pending_edges;
  unsigned int pending_base = CTX_MAX_EDGES-pending_edges;
  for (unsigned int i = 0; i < active_edges; i++)
    {
      CtxSegment *segment = segments + rasterizer->edges[i];
      segment->val += segment->delta * count;
    }
  for (unsigned int i = 0; i < pending_edges; i++)
    {
      CtxSegment *segment = segments + rasterizer->edges[pending_base+i];
      segment->val += segment->delta * count;
    }
}

CTX_INLINE static void ctx_rasterizer_sort_active_edges (CtxRasterizer *rasterizer)
{
  CtxSegment *segments= (CtxSegment*)rasterizer->edge_list.entries;
  int *entries = rasterizer->edges;
  unsigned int count = rasterizer->active_edges;

  for(unsigned int i=1; i<count; i++)
   {
     int temp = entries[i];
     int tv = segments[temp].val;
     int j = i-1;
     while (j >= 0 && tv - segments[entries[j]].val < 0)
     {
       entries[j+1] = entries[j];
       j--;
     }
     entries[j+1] = temp;
   }
}

CTX_INLINE static void ctx_rasterizer_feed_pending_edges (CtxRasterizer *rasterizer)
{
  CtxSegment *__restrict__ entries = (CtxSegment*)&rasterizer->edge_list.entries[0];
  int *edges = rasterizer->edges;
  unsigned int pending_edges   = rasterizer->pending_edges;
  int scanline = rasterizer->scanline + CTX_MAGIC_OFFSET;
  int active_edges = rasterizer->active_edges;
  for (unsigned int i = 0; i < pending_edges; i++)
    {
      if ((entries[edges[CTX_MAX_EDGES-1-i]].y0 <= scanline) &
          (active_edges < CTX_MAX_EDGES-2))
        {
          edges[active_edges] = edges[CTX_MAX_EDGES-1-i];
          active_edges++;
          edges[CTX_MAX_EDGES-1-i] =
            edges[CTX_MAX_EDGES-1-pending_edges + 1];
          pending_edges--;
          i--;
        }
    }
    rasterizer->active_edges = active_edges;
    rasterizer->pending_edges = pending_edges;
    ctx_rasterizer_discard_edges (rasterizer);
}

// makes us up-to date with ready to render rasterizer->scanline
inline static int ctx_rasterizer_feed_edges_full (CtxRasterizer *rasterizer,
                                                  int with_shadow,
                                                  float blur_radius)
{
  int miny;
  const int max_vaa = rasterizer->aa;
  ctx_rasterizer_feed_pending_edges (rasterizer);
  CtxSegment *__restrict__ entries = (CtxSegment*)&rasterizer->edge_list.entries[0];
  int *edges = rasterizer->edges;
  unsigned int pending_edges   = rasterizer->pending_edges;
  int scanline = rasterizer->scanline + CTX_MAGIC_OFFSET;

  int active_edges = rasterizer->active_edges;
  int horizontal_edges = 0;

  if (with_shadow)
  {
  int shadow_active_edges = rasterizer->shadow_active_edges;
  int *edges = rasterizer->shadow_edges;
  int blur_scanline_start = scanline - CTX_FULL_AA * (int)blur_radius;
  int next_scanline = scanline + CTX_FULL_AA * (int)blur_radius;
  unsigned int edge_pos = rasterizer->shadow_edge_pos;
  unsigned int edge_count = rasterizer->edge_list.count;
  for (int i = 0; i < shadow_active_edges;i++)
  {
    if (entries[edges[i]].y1 < blur_scanline_start)
    {
       edges[i]=edges[shadow_active_edges-1];
       shadow_active_edges--;
       i--;
    }
  }

  while ((edge_pos < edge_count &&
         (miny=entries[edge_pos].y0)  <= next_scanline))
  {
      int y1 = entries[edge_pos].y1;
      if ((shadow_active_edges < CTX_MAX_EDGES-2) &
        (y1 >= blur_scanline_start))
        {
          edges[shadow_active_edges++] = edge_pos;
        }
      edge_pos++;
  }
  rasterizer->shadow_edge_pos     = edge_pos;
  rasterizer->shadow_active_edges = shadow_active_edges;
  }


#if CTX_SCANBIN
   int scan = scanline / CTX_FULL_AA;
   int count = rasterizer->scan_bin_count[scan];
   if (count)
   for (int i = 0; i < count; i++)
   {
       int edge_pos = rasterizer->scan_bins[scan][i];
       miny = entries[edge_pos].y0;
#else
  int next_scanline = scanline + CTX_FULL_AA;
  unsigned int edge_pos = rasterizer->edge_pos;
  unsigned int edge_count = rasterizer->edge_list.count;
  while ((edge_pos < edge_count &&
         (miny=entries[edge_pos].y0)  <= next_scanline))
  {
#endif
      int y1 = entries[edge_pos].y1;
      if ((active_edges < CTX_MAX_EDGES-2) &
        (y1 >= scanline))
        {
          int dy = (y1 - miny);
          if (dy)
            {
              int yd = (scanline + CTX_AA_HALFSTEP2) - miny;
              unsigned int index = edges[active_edges] = edge_pos;
              int x0 = entries[index].x0;
              int x1 = entries[index].x1;
              int dx_dy = CTX_RASTERIZER_EDGE_MULTIPLIER * (x1 - x0) / dy;
              entries[index].delta = dx_dy;
              entries[index].val = x0 * CTX_RASTERIZER_EDGE_MULTIPLIER + (yd * dx_dy);

              {
                dx_dy = abs(dx_dy);

#if 0
#define CTX_RASTERIZER_AA_SLOPE_LIMIT3           ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*1.3)/CTX_SUBDIV/15/1024)
#define CTX_RASTERIZER_AA_SLOPE_LIMIT5           ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*14)/CTX_SUBDIV/15/1024)
#define CTX_RASTERIZER_AA_SLOPE_LIMIT15          ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*15)/CTX_SUBDIV/15/1024)
#else
#if 0
#define CTX_RASTERIZER_AA_SLOPE_LIMIT3           ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER)/CTX_SUBDIV/15/1024)
#define CTX_RASTERIZER_AA_SLOPE_LIMIT5           ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*3)/CTX_SUBDIV/15/1024)
#define CTX_RASTERIZER_AA_SLOPE_LIMIT15          ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*5)/CTX_SUBDIV/15/1024)
#else
#define CTX_RASTERIZER_AA_SLOPE_LIMIT3           ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*0.95)/CTX_SUBDIV/15/1024)
#define CTX_RASTERIZER_AA_SLOPE_LIMIT5           ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*6.5)/CTX_SUBDIV/15/1024)
#define CTX_RASTERIZER_AA_SLOPE_LIMIT15          ((65536*CTX_RASTERIZER_EDGE_MULTIPLIER*10.5)/CTX_SUBDIV/15/1024)
#endif
#endif

                int aa = 0;
                if (max_vaa > 5)
                aa = (dx_dy > CTX_RASTERIZER_AA_SLOPE_LIMIT3) 
                   +  (dx_dy > CTX_RASTERIZER_AA_SLOPE_LIMIT5) 
                   +  (dx_dy > CTX_RASTERIZER_AA_SLOPE_LIMIT15);
                else
                aa = (dx_dy > CTX_RASTERIZER_AA_SLOPE_LIMIT3) 
                   +  (dx_dy > CTX_RASTERIZER_AA_SLOPE_LIMIT5) * (max_vaa>3);
                
                rasterizer->scan_aa[aa]++;
                entries[index].aa = aa;
              }

              if ((miny > scanline) &
                  (pending_edges < CTX_MAX_PENDING-1))
              {
                  /* it is a pending edge - we add it to the end of the array
                     and keep a different count for items stored here, like
                     a heap and stack growing against each other
                  */
                  edges[CTX_MAX_EDGES-1-pending_edges] = edges[active_edges];
                  pending_edges++;
                  active_edges--;
              }
              active_edges++;
            }
            else
            {
              horizontal_edges++;
            }
        }
#if CTX_SCANBIN
#else
      edge_pos++;
#endif
  }
#if CTX_SCANBIN==0
    rasterizer->edge_pos         = edge_pos;
#endif
    rasterizer->active_edges     = active_edges;
    rasterizer->pending_edges    = pending_edges;
    if (active_edges + pending_edges == 0)
      return -1;

    if (rasterizer->ending_edges|pending_edges|horizontal_edges)
    {
      const unsigned int *scan_aa = rasterizer->scan_aa;
      int aa = scan_aa[3]?15:scan_aa[2]?5:3;
      return aa;
      //return ctx_mini(aa, rasterizer->aa);
    }
    return 0;
}

static inline void ctx_coverage_post_process (CtxRasterizer *rasterizer, const unsigned int minx, const unsigned int maxx, uint8_t *coverage, int *first_col, int *last_col)
{
#if CTX_ENABLE_CLIP
  if (CTX_UNLIKELY((rasterizer->clip_buffer!=NULL) &  (!rasterizer->clip_rectangle)))
  {
  int scanline     = rasterizer->scanline - CTX_FULL_AA; // we do the
                                                 // post process after
                                                 // coverage generation icnrement
    /* perhaps not working right for clear? */
    int y = scanline / CTX_FULL_AA;
    uint8_t *clip_line = &((uint8_t*)(rasterizer->clip_buffer->data))[rasterizer->blit_width*y];
#if CTX_1BIT_CLIP==0
    int blit_x = rasterizer->blit_x;
#endif
    for (unsigned int x = minx; x <= maxx; x ++)
    {
#if CTX_1BIT_CLIP
       coverage[x] = (coverage[x] * ((clip_line[x/8]&(1<<(x&8)))?255:0))/255;
#else
       coverage[x] = (255 + coverage[x] * clip_line[x-blit_x])>>8;
#endif
    }
  }
#endif
}

#define UPDATE_PARITY \
        if (scanline!=segment->y0-1)\
        { \
          if (is_winding)\
             parity = parity + -1+2*(segment->code == CTX_EDGE_FLIPPED);\
          else\
             parity = 1-parity; \
        }


CTX_INLINE static void
ctx_rasterizer_generate_coverage (CtxRasterizer *rasterizer,
                                  int            minx,
                                  int            maxx,
                                  uint8_t       *coverage,
                                  int            is_winding,
                                  const uint8_t  aa_factor,
                                  const uint8_t  fraction,
                                  int *ret_c0,
                                  int *ret_c1
                                  )
{
  CtxSegment *entries      = (CtxSegment*)(&rasterizer->edge_list.entries[0]);
  int        *edges        = rasterizer->edges;
  int         scanline     = rasterizer->scanline;
  int         active_edges = rasterizer->active_edges;
  int         parity       = 0;
  int         c0 = *ret_c0;
  int         c1 = *ret_c1;
  coverage -= minx;
  for (int t = 0; t < active_edges -1;t++)
    {
      CtxSegment *segment = &entries[edges[t]];
      UPDATE_PARITY;

      if (parity)
        {
          CtxSegment *next_segment = &entries[edges[t+1]];
          const int x0  = segment->val;
          const int x1  = next_segment->val;
          int graystart = x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256);
          int grayend   = x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256);
          int first     = graystart >> 8;
          int last      = grayend   >> 8;

          if (first < minx)
          { 
            first = minx;
            graystart=0;
          }
          if (last > maxx)
          {
            last = maxx;
            grayend=255;
          }

          graystart = fraction- (graystart&0xff)/aa_factor;
          grayend   = (grayend & 0xff) / aa_factor;

          if (first < last)
          {
              coverage[first] += graystart;
              for (int x = first + 1; x < last; x++)
                coverage[x]  += fraction;
              coverage[last] += grayend;
          }
          else if (first == last)
            coverage[first] += (graystart-fraction+grayend);
          c0 = ctx_mini(first, c0);
          c1 = ctx_maxi(last, c1);
        }
   }
  *ret_c0 = c0;
  *ret_c1 = c1;
}

static inline float ctx_p_line_sq_dist (float x, float y, float x1, float y1, float x2, float y2) {
  float A = x - x1;
  float B = y - y1;
  float C = x2 - x1;
  float D = y2 - y1;

  float dot = A * C + B * D;
  float len_sq = C * C + D * D;
  float param = -1.0f;
  float xx, yy;

  if (len_sq != 0.0f) //in case of 0 length line
      param = dot / len_sq;

  if (param < 0.0f) {
    xx = x1;
    yy = y1;
  }
  else if (param > 1.0f) {
    xx = x2;
    yy = y2;
  }
  else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  float dx = x - xx;
  float dy = y - yy;
  return dx * dx + dy * dy;
}

static inline float dist_to_edge_sq (int u, int v, CtxSegment *__restrict__ entries, int edge_no)
{
  CtxSegment *segment = &entries[edge_no];
  float y0 = segment->y0;
  float y1 = segment->y1;

  float x0 = segment->x0 * (1.0f * CTX_FULL_AA / CTX_SUBDIV );
  float x1 = segment->x1 * (1.0f * CTX_FULL_AA / CTX_SUBDIV );
  return ctx_p_line_sq_dist (u, v, x0, y0, x1, y1);
}

static inline float dist_to_edge (int u, int v, CtxSegment *__restrict__ entries, int edge_no)
{
  return ctx_sqrtf_fast (dist_to_edge_sq(u,v,entries,edge_no));
}

static inline float smin_exp( float a, float b, float k )
{
    k *= 1.0;
    float r = exp2(-a/k) + exp2(-b/k);
    return -k*log2(r);
}

static inline float smin_cubic( float a, float b, float k )
{
  k *= 4.0f;
  float h = k-ctx_fabsf(a-b);
  h = (h * (h>0))/k;
  return ctx_minf(a,b) - h*h*k*0.25f;
}

static CTX_INLINE float ctx_sdf_f (CtxSegment *entries, int u, int v, float sign, int edge_count, float blur, int *edges)
{
  float min_dist_sq = 2048 * 2048 * 15 * 15;
  float min_dist = 2048 * 15;
  for (int j = 0; j < edge_count; j++)
  {
#if CTX_RASTERIZER_BLUR_FUDGE
     float dist = dist_to_edge(u, v, entries, edges[j]);
     min_dist = smin_cubic(min_dist,dist, blur/2);
#else
     float sq_dist = dist_to_edge_sq(u, v, entries, edges[j]);
     min_dist_sq = ctx_minf(min_dist_sq, sq_dist);
#endif
  }

#if CTX_RASTERIZER_BLUR_FUDGE==0
  min_dist = ctx_sqrtf_fast (min_dist_sq);
#endif
  return min_dist * sign;
}
static inline float ctx_erf2(float x)
{
  #define CTX_2_SQRTPI 1.12837916709551257390f  /* 2/sqrt(pi) */
  x = x * CTX_2_SQRTPI;
  float xx = x * x;
  x = x + (0.24295f + (0.03395f + 0.0104f * xx) * xx) * (x * xx);
  return x * ctx_invsqrtf_fast (1.0f + x * x);
}

static inline uint8_t gaussian_approximation(float x)
{
  x = ctx_erf2(x);
  x+= 0.5f;
  if (x > 1.0f) return 255;
  if (x < 0.0f) return 0;
  return x * 255.0f;
}

#ifndef CTX_RASTERIZER_SDF_SKIP
#define CTX_RASTERIZER_SDF_SKIP 1
#endif

inline static void
ctx_rasterizer_generate_sdf (CtxRasterizer *rasterizer,
                                       const int      minx,
                                       const int      maxx,
                                       uint8_t       *coverage,
                                       const int      is_winding,
                                       float          blur)
{
  CtxSegment *entries = (CtxSegment*)(&rasterizer->edge_list.entries[0]);
  int *edges  = rasterizer->edges;
  int active_edges    = rasterizer->active_edges;
  int *shadow_edges  = rasterizer->shadow_edges;
  int shadow_active_edges    = rasterizer->shadow_active_edges;
  int scanline        = rasterizer->scanline;
  int parity        = 0;
  float inv_blur = 1.0/(blur * CTX_FULL_AA);
#if CTX_RASTERIZER_SDF_SKIP
  const int skip_len = blur / 2 + 1;
  // how far ahead we jump looking for
                          // same alpha runs - speeding up solid/blank and
#endif
  coverage -= minx;


  int c0 = maxx;
  int c1 = minx;

  for (int t = 0; t < active_edges -1;t++)
    {
      CtxSegment   *segment = &entries[edges[t]];
      UPDATE_PARITY;

      CtxSegment   *next_segment = &entries[edges[t+1]];
      int x0        = segment->val;
      const int x1  = next_segment->val;

      int graystart = x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256);
      int grayend   = x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256);
      int first     = graystart >> 8;
      int last      = grayend   >> 8;

      if (first < minx)
        first = minx;
      if (last > maxx)
        last = maxx;

      if (first <= last)
      {
        int u = x0 * 15 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV);

#define COMPUTE_SDF(u,v) \
        (gaussian_approximation(ctx_sdf_f(entries,(u),(v), sign, shadow_active_edges, blur, shadow_edges) * inv_blur))

        int i;
#if CTX_RASTERIZER_SDF_SKIP
        int prev = -1;
#endif
        float sign = parity?1.0f:-1.0f;
        for (i = first; i <= last; i++)
        {
          coverage[i] = COMPUTE_SDF(u,scanline);

#if CTX_RASTERIZER_SDF_SKIP
          if ((prev == coverage[i]) & ((prev == 0)|(prev==255)))
          {
            if (last-i > skip_len
                && COMPUTE_SDF(u+15*skip_len, scanline) == prev
                && COMPUTE_SDF(u+15*skip_len/2, scanline) == prev)
            {
              for (int j = 1; j < skip_len; j++)
                coverage[i+j] = prev;
              u += 15 * skip_len;
              i += (skip_len-1);
              continue;
            }
          }
          prev = coverage[i];
#endif
          u += 15;
        }
      }
      c0 = ctx_mini (c0, first);
      c1 = ctx_maxi (c1, last);
   }

  float sign = -1.0f;
   
  {
     int i = minx;

#if CTX_RASTERIZER_SDF_SKIP
  int prev = -1;
#endif
  for (; i < c0; i++)
  {
     coverage[i] = COMPUTE_SDF(i*15, scanline);
#if CTX_RASTERIZER_SDF_SKIP
     if (c0-i > skip_len &&
         COMPUTE_SDF((i+skip_len)*15, scanline) == prev)
     {
        for (int j = 1; j < skip_len; j++)
          coverage[i+j] = prev;
        i += (skip_len-1);
        continue;
     }
     prev = coverage[i];
#endif
  }
#if CTX_RASTERIZER_SDF_SKIP
  prev = -1;
#endif
  for (int i = c1+1; i < maxx; i++)
  {
     coverage[i] = COMPUTE_SDF(i*15, scanline);
#if CTX_RASTERIZER_SDF_SKIP
     if (maxx-i > skip_len && COMPUTE_SDF((i+skip_len)*15, scanline) == prev)
     {
        for (int j = 1; j < skip_len; j++)
          coverage[i+j] = prev;
        i += (skip_len-1);
        continue;
     }
     prev = coverage[i];
#endif
  }
  }
}


inline static void
ctx_rasterizer_generate_coverage_grads (CtxRasterizer *rasterizer,
                                            const int      minx,
                                            const int      maxx,
                                            uint8_t       *coverage,
                                            const int      is_winding,
                                            int           *c0_ret,
                                            int           *c1_ret)
{
  CtxSegment *entries = (CtxSegment*)(&rasterizer->edge_list.entries[0]);
  int *edges  = rasterizer->edges;
  int scanline        = rasterizer->scanline;
  int active_edges    = rasterizer->active_edges;
  int parity        = 0;

  coverage -= minx;

  const int minx_ = minx * CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV;
  const int maxx_ = maxx * CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV;

  int c0 = maxx;
  int c1 = minx;

  for (int t = 0; t < active_edges -1;t++)
    {
      CtxSegment   *segment = &entries[edges[t]];
      UPDATE_PARITY;

       if (parity)
        {
          CtxSegment   *next_segment = &entries[edges[t+1]];
          const int x0        = segment->val;
          const int x1        = next_segment->val;

          int graystart = x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256);
          int grayend   = x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256);
          int first     = graystart >> 8;
          int last      = grayend   >> 8;

          if (first < minx)
          { 
            first = minx;
            graystart=0;
          }
          if (last > maxx)
          {
            last = maxx;
            grayend=255;
          }
          graystart = (graystart&0xff) ^ 255;
          grayend   = (grayend & 0xff);

          if (first < last)
          {
            int pre = 1;
            int post = 1;

            if (segment->aa == 0)
            {
              coverage[first] += graystart;
              c0 = ctx_mini(first, c0);
            }
            else
            {
              const int delta0    = segment->delta;
              int x0_start = x0 - delta0 * CTX_AA_HALFSTEP2;
              int x0_end   = x0 + delta0 * CTX_AA_HALFSTEP;
              unsigned int u0x0 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_mini (x0_start, x0_end)));
              unsigned int u1x0 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_maxi (x0_start, x0_end)));

              int us = u0x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV);

              int mod = ((u0x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256) % 256)^255) *
                         (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/255);
              int sum = ((u1x0-u0x0+CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV)/255);

              int recip = (65535)/sum;
              int a = mod * recip;
              recip *= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV;
              c0 = ctx_mini(us, c0);
              for (unsigned int u = u0x0; u < u1x0; u+= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV)
              {
                coverage[us ++] += a>>16;
                a += recip;
              }
              pre = (us-1)-first+1;
            }
  
            if (next_segment->aa == 0)
            {
               coverage[last] += grayend;
               c1 = ctx_maxi(last, c1);
            }
            else
            {
              const int delta1    = next_segment->delta;
              int x1_start = x1 - delta1 * CTX_AA_HALFSTEP2;
              int x1_end   = x1 + delta1 * CTX_AA_HALFSTEP;
              unsigned int u0 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_mini (x1_start, x1_end)));
              unsigned int u1 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_maxi (x1_start, x1_end)));

              int us = u0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV);
              int mod = ((((u0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256) % 256)^255)) *
                    (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/255));
              int sum = ((u1-u0+CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV)/255);
              int recip = (65535) / sum;
              int a = (65536 * 255) - mod * recip;
              recip *= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV;
              post = last-us;
              for (unsigned int u = u0; u < u1; u+= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV)
              {
                coverage[us ++] += (a>>16);
                a -= recip;
              }
              c1 = ctx_maxi(us, c1);
            }
            last-=post;
            for (int i = first + pre; i <= last; i++)
              coverage[i] = 255;
          }
          else if (first == last)
          {
            coverage[last]+=(graystart-(grayend^255));
            c0 = ctx_mini(first, c0);
            c1 = ctx_maxi(last, c1);
          }
        }
   }

  *c0_ret = c0;
  *c1_ret = c1;
}

#define CTX_RASTERIZER_MAX_EMPTIES  16
#define CTX_RASTERIZER_MAX_SOLID    16

inline static void
ctx_rasterizer_apply_grads_generic (CtxRasterizer *rasterizer,
                                                     const int      minx,
                                                     const int      maxx,
                                                     uint8_t       *coverage,
                                                     const int      is_winding,
                                                     ctx_apply_coverage_fun apply_coverage)
{
#define CTX_APPLY_GRAD_A \
  CtxSegment *entries = (CtxSegment*)(&rasterizer->edge_list.entries[0]);\
  int *edges  = rasterizer->edges;\
  uint8_t *rasterizer_src = rasterizer->color;\
  int scanline        = rasterizer->scanline;\
  unsigned int active_edges    = rasterizer->active_edges - 1;\
  int parity        = 0;\
\
  uint8_t *dst = ( (uint8_t *) rasterizer->buf) +\
         (rasterizer->blit_stride * (scanline / CTX_FULL_AA));\
  coverage -= minx;\
\
  const int minx_ = minx * CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV;\
  const int maxx_ = maxx * CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV;\
\
  int cov_min = maxx;\
  int cov_max = minx;\
  const int  bpp      = rasterizer->format->bpp;
  CTX_APPLY_GRAD_A

#define CTX_APPLY_GRAD_B(empty_factor, solid_factor) \
  for (unsigned int t = 0; t < active_edges;t++) \
    { \
      CtxSegment   *segment = &entries[edges[t]]; \
      UPDATE_PARITY; \
\
       if (parity)\
        {\
          CtxSegment   *next_segment = &entries[edges[t+1]]; \
          const int x0        = segment->val; \
          const int x1        = next_segment->val;\
\
          int graystart = x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256); \
          int grayend   = x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256); \
          int first     = graystart >> 8; \
          int last      = grayend   >> 8; \
 \
          if (CTX_UNLIKELY (first < minx)) \
          {  \
            first = minx; \
            graystart=0; \
          } \
          if (CTX_UNLIKELY (last > maxx)) \
          { \
            last = maxx; \
            grayend=255; \
          } \
          graystart = (graystart&0xff) ^ 255; \
          grayend   = (grayend & 0xff); \
\
          if (first < last)\
          {\
            const int delta1 = next_segment->delta; \
            int x1_start = x1 - delta1 * CTX_AA_HALFSTEP2; \
            int x1_end   = x1 + delta1 * CTX_AA_HALFSTEP; \
            unsigned int u0x1 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_mini (x1_start, x1_end)));\
\
            unsigned int pre = 1;\
            unsigned int post = 1;\
\
            if (first - cov_max > CTX_RASTERIZER_MAX_EMPTIES * empty_factor)\
            {\
                 if (cov_max>=cov_min)\
                 {\
                   apply_coverage (cov_max-cov_min+1, &dst[((cov_min) * bpp)/8], rasterizer_src,\
                                   &coverage[cov_min], rasterizer, cov_min);\
                   cov_min = maxx;\
                   cov_max = minx;\
                 }\
            }\
\
            if (segment->aa == 0)\
            {\
              coverage[first] += graystart;\
              cov_min = ctx_mini (cov_min, first);\
              cov_max = ctx_maxi (cov_max, first);\
            }\
            else\
            {\
              const int delta0    = segment->delta; \
              int x0_start = x0 - delta0 * CTX_AA_HALFSTEP2; \
              int x0_end   = x0 + delta0 * CTX_AA_HALFSTEP; \
              unsigned int u0x0 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_mini (x0_start, x0_end)));\
              unsigned int u1x0 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_maxi (x0_start, x0_end)));\
\
              int us = u0x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV);\
              int mod = ((u0x0 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256) % 256)^255) *\
                         (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/255);\
              int sum = ((u1x0-u0x0+CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV)/255);\
\
              int recip = (65535)/sum;\
              int a = mod * recip;\
              recip *= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV;\
\
              cov_min = ctx_mini (cov_min, us);\
              for (unsigned int u = u0x0; u < u1x0; u+= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV)\
              {\
                coverage[us ++] += a>>16;\
                a += recip;\
              }\
              cov_max = us;\
\
              pre = (us-1)-first+1;\
            }\
            if (next_segment->aa != 0) \
            { \
              post = last - u0x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV); \
            }\
            {\
               int width = (last-post) - (first+pre) + 1;\
               if (width > CTX_RASTERIZER_MAX_SOLID * solid_factor)\
               {\
                 if (cov_max>=cov_min)\
                 {\
                   apply_coverage (cov_max-cov_min+1, &dst[((cov_min) * bpp)/8], rasterizer_src,\
                                   &coverage[cov_min], rasterizer, cov_min);\
                   cov_min = maxx;\
                   cov_max = minx;\
                 }
  CTX_APPLY_GRAD_B(1, 1)
                       {
#if static_OPAQUE
                       uint8_t *opaque = &rasterizer->opaque[0];
#else
                       uint8_t opaque[width];
                       memset (opaque, 255, sizeof (opaque));
#endif
                       apply_coverage (width,
                                   &dst[((first + pre) * bpp)/8],
                                   rasterizer_src,
                                   opaque,
                                   rasterizer,
                                   first + pre);
                       }
#define CTX_APPLY_GRAD_C \
                 }\
               else\
               {\
                 for (int i = 0; i < width; i++)\
                   coverage[first + pre + i] = 255;\
                 cov_min = ctx_mini (cov_min, first + pre);\
                 cov_max = first + pre + width;\
               }\
            }\
  \
            if (next_segment->aa == 0)\
            {\
               coverage[last] += grayend;\
               cov_min = ctx_mini (cov_min, last);\
               cov_max = last;\
            }\
            else\
            {\
              unsigned int u1x1 = ctx_mini (maxx_, ctx_maxi (minx_, ctx_maxi (x1_start, x1_end)));\
              int us = u0x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV);\
              int mod = ((((u0x1 / (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/256) % 256)^255)) *\
                    (CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV/255));\
              int sum = ((u1x1-u0x1+CTX_RASTERIZER_EDGE_MULTIPLIER * CTX_SUBDIV)/255);\
              int recip = (65535) / sum;\
              int a = (65536 * 255) - mod * recip;\
              recip *= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV;\
\
              cov_min = ctx_mini (cov_min, us);\
              for (unsigned int u = u0x1; u < u1x1; u+= CTX_RASTERIZER_EDGE_MULTIPLIER*CTX_SUBDIV)\
              {\
                coverage[us ++] += (a>>16);\
                a -= recip;\
              }\
              cov_max = us;\
            }\
          }\
          else if (first == last)\
          {\
            coverage[last]+=(graystart-(grayend^255)); \
            cov_min = ctx_mini (cov_min, first); \
            cov_max = last;\
          }\
        }\
   }\
  if (cov_max>=cov_min)\
     apply_coverage (cov_max-cov_min+1, &dst[(cov_min*bpp)/8], rasterizer_src, \
                     &coverage[cov_min], rasterizer, cov_min);
  CTX_APPLY_GRAD_C
}

inline static void
ctx_rasterizer_apply_grads_RGBA8_copy_normal_color (CtxRasterizer *rasterizer,
                                                                     const int      minx,
                                                                     const int      maxx,
                                                                     uint8_t       *coverage,
                                                                     const int      is_winding,
                                                                     ctx_apply_coverage_fun apply_coverage)
{
  CTX_APPLY_GRAD_A
  uint32_t src_pix = ((uint32_t*)rasterizer_src)[0];
  CTX_APPLY_GRAD_B(1, 1)
  ctx_span_set_color ((uint32_t*)(&dst[(first+pre) *4]), src_pix, width);
  CTX_APPLY_GRAD_C
}

inline static void
ctx_rasterizer_apply_grads_RGBA8_over_normal_color (CtxRasterizer *rasterizer,
                                                                     const int      minx,
                                                                     const int      maxx,
                                                                     uint8_t       *coverage,
                                                                     const int      is_winding,
                                                                     ctx_apply_coverage_fun apply_coverage)
{
  CTX_APPLY_GRAD_A
  uint32_t si_ga_full, si_rb_full, si_ga, si_a;
  si_ga = ((uint32_t*)rasterizer_src)[1];
  si_ga_full = ((uint32_t*)rasterizer_src)[3];
  si_rb_full = ((uint32_t*)rasterizer_src)[4];
  si_a  = si_ga >> 16;
  CTX_APPLY_GRAD_B(1, 1)
  uint32_t* dst_pix = (uint32_t*)(&dst[(first+pre) *4]);
  unsigned int count = width;
  while (count--)
  {
    *dst_pix = ctx_over_RGBA8_full_2(*dst_pix, si_ga_full, si_rb_full, si_a);
    dst_pix++;
  }
  CTX_APPLY_GRAD_C
}

inline static void
ctx_rasterizer_apply_grads_copy_normal_color (CtxRasterizer *rasterizer,
                                                                     const int      minx,
                                                                     const int      maxx,
                                                                     uint8_t       *coverage,
                                                                     const int      is_winding,
                                                                     const CtxCovPath comp,
                                                                     ctx_apply_coverage_fun apply_coverage)
{
  CTX_APPLY_GRAD_A
  unsigned int bytes = bpp/8;

  CTX_APPLY_GRAD_B(1, 1)

  uint8_t* dst_i = (uint8_t*)(&dst[(first+pre) * bytes]);
  uint8_t* color = ((uint8_t*)&rasterizer->color_native);
  switch (bytes)
  {
    case 16:
       ctx_span_set_color_x4 ((uint32_t*)dst_i, (uint32_t*)color, width);
       break;
    case 4:
      ctx_span_set_color ((uint32_t*)dst_i, ((uint32_t*)color)[0], width);
      break;
    case 2:
    {
      uint16_t val = ((uint16_t*)color)[0];
      while (width--)
      {
         ((uint16_t*)dst_i)[0] = val;
         dst_i+=2;
      }
    }
      break;
    case 3:
    {
       uint8_t r = color[0];
       uint8_t g = color[1];
       uint8_t b = color[2];
       while (width--)
       {
         *dst_i++ = r;
         *dst_i++ = g;
         *dst_i++ = b;
       }
     }
     break;
    case 1:
    {
       uint8_t val = color[0];
       while (width--)
       {
         *dst_i++ = val;
       }
     }
     break;
   default:
   while (width--)
   {
     for (unsigned int b = 0; b < bytes; b++)
       *dst_i++ = color[b];
   }
   break;

  }
  CTX_APPLY_GRAD_C
}

inline static void
ctx_rasterizer_apply_grads_RGBA8_copy_fragment (CtxRasterizer *rasterizer,
                                                                 const int      minx,
                                                                 const int      maxx,
                                                                 uint8_t       *coverage,
                                                                 const int      is_winding,
                                                                 ctx_apply_coverage_fun apply_coverage)
{
  CTX_APPLY_GRAD_A
  CTX_APPLY_GRAD_B(1, 1)
                   {
                       float u0 = 0; float v0 = 0;
                       float ud = 0; float vd = 0;
                       float w0 = 1; float wd = 0;
                       ctx_init_uv (rasterizer, first+pre, scanline/CTX_FULL_AA,&u0, &v0, &w0, &ud, &vd, &wd);
                       rasterizer->fragment (rasterizer, u0, v0, w0, &dst[(first+pre)*4],
                                             width, ud, vd, wd);
                   }
  CTX_APPLY_GRAD_C
}

inline static void
ctx_rasterizer_apply_grads_RGBA8_over_fragment (CtxRasterizer *rasterizer,
                                                                 const int      minx,
                                                                 const int      maxx,
                                                                 uint8_t       *coverage,
                                                                 const int      is_winding,
                                                                 ctx_apply_coverage_fun apply_coverage)
{
  CTX_APPLY_GRAD_A
  CTX_APPLY_GRAD_B(1, 1)
               CTX_SIMD_SUFFIX(ctx_RGBA8_source_over_normal_full_cov_fragment) (
                    width,
                     &dst[(first+pre)*4],
                     NULL,
                     NULL,
                     rasterizer,
                     first + pre,
                    1);
  CTX_APPLY_GRAD_C
}

#undef CTX_APPLY_GRAD_A
#undef CTX_APPLY_GRAD_B
#undef CTX_APPLY_GRAD_C


inline static void
ctx_rasterizer_apply_grads (CtxRasterizer *rasterizer,
                                             const int      minx,
                                             const int      maxx,
                                             uint8_t       *coverage,
                                             const int      is_winding,
                                             const CtxCovPath comp,
                                             ctx_apply_coverage_fun apply_coverage)
{
  if (rasterizer->active_edges < 2) return;
  switch (comp)
  {
#if CTX_RASTERIZER_SWITCH_DISPATCH
    case CTX_COV_PATH_RGBA8_OVER:
       ctx_rasterizer_apply_grads_RGBA8_over_normal_color (rasterizer, minx, maxx, coverage, is_winding, apply_coverage);
       break;
    case CTX_COV_PATH_RGBA8_COPY:
       ctx_rasterizer_apply_grads_RGBA8_copy_normal_color (rasterizer, minx, maxx, coverage, is_winding, apply_coverage);
       break;
    case CTX_COV_PATH_RGB565_COPY:
    case CTX_COV_PATH_RGBAF_COPY:
    case CTX_COV_PATH_RGB332_COPY:
    case CTX_COV_PATH_GRAY8_COPY:
    case CTX_COV_PATH_RGB8_COPY:
    case CTX_COV_PATH_GRAYA8_COPY:
    case CTX_COV_PATH_GRAYAF_COPY:
    case CTX_COV_PATH_CMYKAF_COPY:
    case CTX_COV_PATH_CMYK8_COPY:
    case CTX_COV_PATH_CMYKA8_COPY:
       ctx_rasterizer_apply_grads_copy_normal_color (rasterizer, minx, maxx, coverage, is_winding, comp, apply_coverage);
       break;
    case CTX_COV_PATH_RGBA8_COPY_FRAGMENT:
       ctx_rasterizer_apply_grads_RGBA8_copy_fragment (rasterizer, minx, maxx, coverage, is_winding, apply_coverage);
       break;
    case CTX_COV_PATH_RGBA8_OVER_FRAGMENT:
       ctx_rasterizer_apply_grads_RGBA8_over_fragment (rasterizer, minx, maxx, coverage, is_winding, apply_coverage);
       break;
#endif
     default:
        ctx_rasterizer_apply_grads_generic (rasterizer, minx, maxx, coverage, is_winding, apply_coverage);
  }
}

static inline void
ctx_rasterizer_reset_soft (CtxRasterizer *rasterizer)
{
#if CTX_SCANBIN==0
  rasterizer->edge_pos        =   
#endif
  rasterizer->shadow_edge_pos =   
  rasterizer->scanline        = 0;
  //rasterizer->comp_op       = NULL; // keep comp_op cached 
  //     between rasterizations where rendering attributes are
  //     nonchanging
}


static inline void
_ctx_rasterizer_reset (CtxRasterizer *rasterizer)
{
  ctx_rasterizer_reset_soft (rasterizer);
  rasterizer->first_edge = -1;
  rasterizer->has_prev        =   
  rasterizer->edge_list.count =    // ready for new edges
#if CTX_SCANBIN==0
  rasterizer->edge_pos        =   
#endif
  rasterizer->shadow_edge_pos =   
  rasterizer->scanline        = 0;
  if (CTX_LIKELY(!rasterizer->preserve))
  {
    rasterizer->scan_min      =
    rasterizer->col_min       = 50000000;
    rasterizer->scan_max      =
    rasterizer->col_max       = -50000000;
  }
  //rasterizer->comp_op       = NULL; // keep comp_op cached 
  //     between rasterizations where rendering attributes are
  //     nonchanging
}

#if CTX_SCANBIN==0
static CTX_INLINE int ctx_compare_edge (const void *ap, int by0)
{
  return ((const CtxSegment *) ap)->y0 - by0;
}

static CTX_INLINE int ctx_edge_qsort_partition (CtxSegment *A, int low, int high)
{
  int pivot_y0 = A[ (high+low) /2].y0;
  int i = low;
  int j = high;
  while (i <= j)
    {
      while (ctx_compare_edge (&A[i], pivot_y0) < 0) { i ++; }
      while (ctx_compare_edge (&A[j], pivot_y0) > 0) { j --; }
      if (i <= j)
        {
          CtxSegment tmp = A[i];
          A[i++] = A[j];
          A[j--] = tmp;
        }
    }
  return i;
}

static void ctx_edge_qsortb (CtxSegment *entries, int low, int high)
{
  do {
    int p = ctx_edge_qsort_partition (entries, low, high);
    if (low < p - 1)
      ctx_edge_qsortb (entries, low, p - 1);
    if (low >= high)
      return;
    low = p;
  } while (1);
}

static CTX_INLINE void ctx_edge_qsort (CtxSegment *entries, int low, int high)
{
  do {
    int p = ctx_edge_qsort_partition (entries, low, high);
    if (low < p - 1)
      ctx_edge_qsortb (entries, low, p - 1);
    if (low >= high)
      return;
    low = p;
  } while (1);
}

static CTX_INLINE void ctx_sort_edges (CtxRasterizer *rasterizer)
{
  ctx_edge_qsort ((CtxSegment*)& (rasterizer->edge_list.entries[0]), 0, rasterizer->edge_list.count-1);
}
#endif


static void
ctx_rasterizer_rasterize_edges2 (CtxRasterizer *rasterizer, const int fill_rule, const int allow_direct)
{
  rasterizer->pending_edges   =   
  rasterizer->active_edges    =   0;
  CtxGState     *gstate     = &rasterizer->state->gstate;
  const int      is_winding  = fill_rule == CTX_FILL_RULE_WINDING;
  const CtxCovPath comp = rasterizer->comp;
  uint8_t  *dst         = ((uint8_t *) rasterizer->buf);
  int       scan_start  = rasterizer->blit_y * CTX_FULL_AA;
  int       scan_end    = scan_start + (rasterizer->blit_height - 1) * CTX_FULL_AA;
  const int blit_width  = rasterizer->blit_width;
  const int blit_max_x  = rasterizer->blit_x + blit_width;
  int       minx        = rasterizer->col_min / CTX_SUBDIV - rasterizer->blit_x;
  int       maxx        = (rasterizer->col_max + CTX_SUBDIV-1) / CTX_SUBDIV -
                          rasterizer->blit_x;
  const int bpp = rasterizer->format->bpp;
  const int blit_stride = rasterizer->blit_stride;

  uint8_t *rasterizer_src = rasterizer->color;

  if (maxx > blit_max_x - 1)
    { maxx = blit_max_x - 1; }

  minx = ctx_maxi (gstate->clip_min_x, minx);
  maxx = ctx_mini (gstate->clip_max_x, maxx);
  minx *= (minx>0);
 
  int pixs = maxx - minx + 1;
  if (pixs <= 0)
  {
    //assert(0);
    //
    // sometimes reached by stroking code
    return;
  }
  uint8_t _coverage[pixs + 32]; // XXX this might hide some valid asan warnings
  uint8_t *coverage = &_coverage[0];
  ctx_apply_coverage_fun apply_coverage = rasterizer->apply_coverage;

  rasterizer->scan_min -= (rasterizer->scan_min % CTX_FULL_AA);
  {
     if (rasterizer->scan_min > scan_start)
       {
          dst += (blit_stride * (rasterizer->scan_min-scan_start) / CTX_FULL_AA);
          scan_start = rasterizer->scan_min;
       }
      scan_end = ctx_mini (rasterizer->scan_max, scan_end);
  }

  if (CTX_UNLIKELY(gstate->clip_min_y * CTX_FULL_AA > scan_start ))
    { 
       dst += (blit_stride * (gstate->clip_min_y * CTX_FULL_AA -scan_start) / CTX_FULL_AA);
       scan_start = gstate->clip_min_y * CTX_FULL_AA; 
    }
  scan_end = ctx_mini (gstate->clip_max_y * CTX_FULL_AA, scan_end);
  if (CTX_UNLIKELY((minx >= maxx) | (scan_start > scan_end) |
      (scan_start > (rasterizer->blit_y + (rasterizer->blit_height-1)) * CTX_FULL_AA) |
      (scan_end < (rasterizer->blit_y) * CTX_FULL_AA)))
  { 
    /* not affecting this rasterizers scanlines */
    return;
  }
  rasterizer->scan_aa[1]=
  rasterizer->scan_aa[2]=
  rasterizer->scan_aa[3]=0;

#if CTX_SCANBIN
  int ss = scan_start/CTX_FULL_AA;
  int se = scan_end/CTX_FULL_AA;
  if (ss < 0)ss =0;
  if (se >= CTX_MAX_SCANLINES) se = CTX_MAX_SCANLINES-1;

  for (int i = ss; i < se; i++)
    rasterizer->scan_bin_count[i]=0;

  for (unsigned int i = 0; i < rasterizer->edge_list.count; i++)
  {
    CtxSegment *segment = & ((CtxSegment*)rasterizer->edge_list.entries)[i];
    int scan = (segment->y0-CTX_FULL_AA+2) / CTX_FULL_AA;
    if (scan < ss) scan = ss;
    if (scan < se)
      rasterizer->scan_bins[scan][rasterizer->scan_bin_count[scan]++]=i;
  }
#else
  ctx_sort_edges (rasterizer);
#endif

  rasterizer->scanline = scan_start;

  while (rasterizer->scanline <= scan_end)
    {
      int c0 = minx;
      int c1 = maxx;
      int aa = ctx_rasterizer_feed_edges_full (rasterizer, 0, 0.0f);
      switch (aa)
      {
        case -1: /* no edges */
          rasterizer->scanline += CTX_FULL_AA;
          dst += blit_stride;
          continue;
        case 0: /* the scanline transitions does not contain multiple intersections - each aa segment is a linear ramp */
        case 1: /* level-1 aa is good enough - use same case for less iteration of edges */
        { 
          rasterizer->scanline += CTX_AA_HALFSTEP2;
          ctx_rasterizer_feed_pending_edges (rasterizer);
          ctx_rasterizer_sort_active_edges (rasterizer);
    
          memset (coverage, 0, pixs);
          if (allow_direct)
          {
            ctx_rasterizer_apply_grads (rasterizer, minx, maxx, coverage, is_winding, comp, apply_coverage);
            rasterizer->scanline += CTX_AA_HALFSTEP;
            ctx_rasterizer_increment_edges (rasterizer, CTX_FULL_AA);
    
            dst += blit_stride;
            continue;
          }
          ctx_rasterizer_generate_coverage_grads (rasterizer, minx, maxx, coverage, is_winding, &c0, &c1);
          rasterizer->scanline += CTX_AA_HALFSTEP;
          ctx_rasterizer_increment_edges (rasterizer, CTX_FULL_AA);
          break;
        }
#if 1
        case 3:
        { /* level of oversampling based on lowest steepness edges */
          const int raa=3;
          ctx_rasterizer_increment_edges (rasterizer, -CTX_AA_HALFSTEP2);
          memset (coverage, 0, pixs);
          const int scanline_increment = 15/raa;
          const uint8_t fraction = 255/raa;

          c0 = maxx;
          c1 = minx;
          for (int i = 1; i <= raa; i++)
          {
            ctx_rasterizer_sort_active_edges (rasterizer);
            ctx_rasterizer_generate_coverage (rasterizer, minx, maxx, coverage, is_winding, raa, fraction, &c0, &c1);
            rasterizer->scanline += scanline_increment;
            ctx_rasterizer_increment_edges (rasterizer, scanline_increment + CTX_AA_HALFSTEP2 * (i==raa));
            ctx_rasterizer_feed_pending_edges (rasterizer);
          }
        }
        break;
        case 5:
        { /* level of oversampling based on lowest steepness edges */
          const int raa=5;
          ctx_rasterizer_increment_edges (rasterizer, -CTX_AA_HALFSTEP2);
          memset (coverage, 0, pixs);
          const int scanline_increment = 15/raa;
          const uint8_t fraction = 255/raa;

          c0 = maxx;
          c1 = minx;
          for (int i = 1; i <= raa; i++)
          {
            ctx_rasterizer_sort_active_edges (rasterizer);
            ctx_rasterizer_generate_coverage (rasterizer, minx, maxx, coverage, is_winding, raa, fraction, &c0, &c1);
            rasterizer->scanline += scanline_increment;
            ctx_rasterizer_increment_edges (rasterizer, scanline_increment + CTX_AA_HALFSTEP2 * (i==raa));
            ctx_rasterizer_feed_pending_edges (rasterizer);
          }
        }
        break;
        case 15:
        { /* level of oversampling based on lowest steepness edges */
          const int raa=15;
          ctx_rasterizer_increment_edges (rasterizer, -CTX_AA_HALFSTEP2);
          memset (coverage, 0, pixs);
          const int scanline_increment = 15/raa;
          const uint8_t fraction = 255/raa;

          c0 = maxx;
          c1 = minx;
          for (int i = 1; i <= raa; i++)
          {
            ctx_rasterizer_sort_active_edges (rasterizer);
            ctx_rasterizer_generate_coverage (rasterizer, minx, maxx, coverage, is_winding, raa, fraction, &c0, &c1);
            rasterizer->scanline += scanline_increment;
            ctx_rasterizer_increment_edges (rasterizer, scanline_increment + CTX_AA_HALFSTEP2 * (i==raa));
            ctx_rasterizer_feed_pending_edges (rasterizer);
          }
        }
        break;
#else
        default:
        { /* level of oversampling based on lowest steepness edges */
          const int raa=aa;
          ctx_rasterizer_increment_edges (rasterizer, -CTX_AA_HALFSTEP2);
          memset (coverage, 0, pixs);
          const int scanline_increment = 15/raa;
          const uint8_t fraction = 255/raa;

          c0 = maxx;
          c1 = minx;
          for (int i = 1; i <= raa; i++)
          {
            ctx_rasterizer_sort_active_edges (rasterizer);
            ctx_rasterizer_generate_coverage (rasterizer, minx, maxx, coverage, is_winding, raa, fraction, &c0, &c1);
            rasterizer->scanline += scanline_increment;
            ctx_rasterizer_increment_edges (rasterizer, scanline_increment + CTX_AA_HALFSTEP2 * (i==raa));
            ctx_rasterizer_feed_pending_edges (rasterizer);
          }
        }
#endif
      }
  
      if (c1 >= c0)
      {
        ctx_coverage_post_process (rasterizer, c0, c1, coverage - minx, NULL, NULL);
        apply_coverage (c1-c0+1,
                        &dst[(c0 * bpp) /8],
                        rasterizer_src,
                        coverage + (c0-minx),
                        rasterizer, c0);
      }
      dst += blit_stride;

#if CONFIG_IDF_TARGET_ESP32C3
    if (rasterizer->scanline % (CTX_FULL_AA*10) == 0)
      taskYIELD();
#endif
    }

#if CTX_BLENDING_AND_COMPOSITING
  if (CTX_UNLIKELY((gstate->compositing_mode == CTX_COMPOSITE_SOURCE_OUT) |
      (gstate->compositing_mode == CTX_COMPOSITE_SOURCE_IN) |
      (gstate->compositing_mode == CTX_COMPOSITE_DESTINATION_IN) |
      (gstate->compositing_mode == CTX_COMPOSITE_DESTINATION_ATOP) |
      (gstate->compositing_mode == CTX_COMPOSITE_CLEAR)))
  {
     /* fill in the rest of the blitrect when compositing mode permits it */
     uint8_t nocoverage[rasterizer->blit_width];
     int gscan_start = gstate->clip_min_y * CTX_FULL_AA;
     //int gscan_end = gstate->clip_max_y * CTX_FULL_AA;
     memset (nocoverage, 0, sizeof(nocoverage));
     int startx   = gstate->clip_min_x;
     int endx     = gstate->clip_max_x;
     int clipw    = endx-startx + 1;
     uint8_t *dst = ( (uint8_t *) rasterizer->buf);

     dst = (uint8_t*)(rasterizer->buf) + blit_stride * (gscan_start / CTX_FULL_AA);
     for (rasterizer->scanline = gscan_start; rasterizer->scanline < scan_start;)
     {
       apply_coverage (clipw,
                       &dst[ (startx * rasterizer->format->bpp) /8],
                       rasterizer_src, nocoverage, rasterizer, 0);
       rasterizer->scanline += CTX_FULL_AA;
       dst += blit_stride;
     }

     if (0)//(minx > startx) & (minx<maxx))
     {
     dst = (uint8_t*)(rasterizer->buf) + blit_stride * (scan_start / CTX_FULL_AA);
     for (rasterizer->scanline = scan_start; rasterizer->scanline < scan_end;)
     {
       apply_coverage (minx-startx,
                       &dst[ (startx * rasterizer->format->bpp) /8],
                       rasterizer_src,
                       nocoverage, rasterizer, 0);
       dst += blit_stride;
     }
     }

     if (endx > maxx)
     {
     dst = (uint8_t*)(rasterizer->buf) + blit_stride * (scan_start / CTX_FULL_AA);
     for (rasterizer->scanline = scan_start; rasterizer->scanline < scan_end;)
     {
       apply_coverage (endx-maxx,
                       &dst[ (maxx * rasterizer->format->bpp) /8],
                       rasterizer_src, nocoverage, rasterizer, 0);

       rasterizer->scanline += CTX_FULL_AA;
       dst += blit_stride;
     }
     }
#if 0
     dst = (uint8_t*)(rasterizer->buf) + blit_stride * (scan_end / CTX_FULL_AA);
     for (rasterizer->scanline = scan_end; rasterizer->scanline < gscan_end;)
     {
       apply_coverage (clipw-1,
                       &dst[ (startx * rasterizer->format->bpp) /8],
                       rasterizer_src,
                       nocoverage, rasterizer, 0);

       rasterizer->scanline += CTX_FULL_AA;
       dst += blit_stride;
     }
#endif
  }
#endif
}

#if CTX_ENABLE_SHADOW_BLUR
static void
ctx_rasterizer_rasterize_edges3 (CtxRasterizer *rasterizer, const int fill_rule)
{
  rasterizer->pending_edges   =   
  rasterizer->active_edges    =   0;
  rasterizer->shadow_active_edges =   0;
  CtxGState *gstate     = &rasterizer->state->gstate;
  float blur_radius = rasterizer->feather;
  const int  is_winding = fill_rule == CTX_FILL_RULE_WINDING;
  uint8_t  *dst         = ((uint8_t *) rasterizer->buf);

  int       scan_start  = rasterizer->blit_y * CTX_FULL_AA;
  int       scan_end    = scan_start + (rasterizer->blit_height - 1) * CTX_FULL_AA;
  const int blit_width  = rasterizer->blit_width;
  const int blit_max_x  = rasterizer->blit_x + blit_width;
  int       minx        = rasterizer->col_min / CTX_SUBDIV - rasterizer->blit_x;
  int       maxx        = (rasterizer->col_max + CTX_SUBDIV-1) / CTX_SUBDIV -
                          rasterizer->blit_x;
  const int bpp = rasterizer->format->bpp;
  const int blit_stride = rasterizer->blit_stride;

  uint8_t *rasterizer_src = rasterizer->color;

  if (maxx > blit_max_x - 1)
    { maxx = blit_max_x - 1; }

  minx = ctx_maxi (gstate->clip_min_x, minx);
  maxx = ctx_mini (gstate->clip_max_x, maxx);
  minx *= (minx>0);
 
  int pixs = maxx - minx + 1;
  uint8_t _coverage[pixs+16]; // XXX this might hide some valid asan warnings
  uint8_t *coverage = &_coverage[0];
  ctx_apply_coverage_fun apply_coverage = rasterizer->apply_coverage;

  rasterizer->scan_min -= (rasterizer->scan_min % CTX_FULL_AA);
  {
     if (rasterizer->scan_min > scan_start)
       {
          dst += (blit_stride * (rasterizer->scan_min-scan_start) / CTX_FULL_AA);
          scan_start = rasterizer->scan_min;
       }
      scan_end = ctx_mini (rasterizer->scan_max, scan_end);
  }

  if (CTX_UNLIKELY(gstate->clip_min_y * CTX_FULL_AA > scan_start ))
    { 
       dst += (blit_stride * (gstate->clip_min_y * CTX_FULL_AA -scan_start) / CTX_FULL_AA);
       scan_start = gstate->clip_min_y * CTX_FULL_AA; 
    }
  scan_end = ctx_mini (gstate->clip_max_y * CTX_FULL_AA, scan_end);
  if (CTX_UNLIKELY((minx >= maxx) | (scan_start > scan_end) |
      (scan_start > (rasterizer->blit_y + (rasterizer->blit_height-1)) * CTX_FULL_AA) |
      (scan_end < (rasterizer->blit_y) * CTX_FULL_AA)))
  { 
    /* not affecting this rasterizers scanlines */
    return;
  }
  rasterizer->scan_aa[1]=
  rasterizer->scan_aa[2]=
  rasterizer->scan_aa[3]=0;

#if CTX_SCANBIN
  int ss = scan_start/CTX_FULL_AA;
  int se = scan_end/CTX_FULL_AA;
  if (ss < 0)ss =0;
  if (se >= CTX_MAX_SCANLINES) se = CTX_MAX_SCANLINES-1;

  for (int i = ss; i < se; i++)
    rasterizer->scan_bin_count[i]=0;

  for (unsigned int i = 0; i < rasterizer->edge_list.count; i++)
  {
    CtxSegment *segment = & ((CtxSegment*)rasterizer->edge_list.entries)[i];
    int scan = (segment->y0-CTX_FULL_AA+2) / CTX_FULL_AA;
    if (scan < ss) scan = ss;
    if (scan < se)
      rasterizer->scan_bins[scan][rasterizer->scan_bin_count[scan]++]=i;
  }
#else
  ctx_sort_edges (rasterizer);
#endif

  rasterizer->scanline = scan_start;

  while (rasterizer->scanline <= scan_end)
    {
      int c0 = minx;
      int c1 = maxx;
        ctx_rasterizer_feed_edges_full (rasterizer, 1, blur_radius);
        { 
          rasterizer->scanline += CTX_AA_HALFSTEP2;
          ctx_rasterizer_feed_pending_edges (rasterizer);
    
          memset (coverage, 0, pixs);
          ctx_rasterizer_sort_active_edges (rasterizer);
          ctx_rasterizer_generate_sdf (rasterizer, minx, maxx, coverage, is_winding, blur_radius);
          rasterizer->scanline += CTX_AA_HALFSTEP;
          ctx_rasterizer_increment_edges (rasterizer, CTX_FULL_AA);
        }
  
      {
        ctx_coverage_post_process (rasterizer, c0, c1, coverage - minx, NULL, NULL);
        apply_coverage (c1-c0+1,
                        &dst[(c0 * bpp) /8],
                        rasterizer_src,
                        coverage + (c0-minx),
                        rasterizer, c0);
      }
      dst += blit_stride;
    }
}
#endif




#if CTX_INLINE_FILL_RULE

// this can shave 1-2% percent off execution time, at the penalty of increased code size
void
CTX_SIMD_SUFFIX (ctx_rasterizer_rasterize_edges) (CtxRasterizer *rasterizer, const int fill_rule)
{
#if CTX_RASTERIZER_ALLOW_DIRECT
  int allow_direct = !(0 
#if CTX_ENABLE_CLIP
         | ((rasterizer->clip_buffer!=NULL) & (!rasterizer->clip_rectangle))
#endif
#if CTX_ENABLE_SHADOW_BLUR
         | rasterizer->in_shadow
#endif
         );
#else
  const int allow_direct = 0;  // temporarily disabled
                               // we seem to overrrun our scans
#endif

#if CTX_ENABLE_SHADOW_BLUR
    if (rasterizer->in_shadow)
    {
      if (fill_rule) ctx_rasterizer_rasterize_edges3 (rasterizer, 1);
      else           ctx_rasterizer_rasterize_edges3 (rasterizer, 0);
      return;
    }
#endif

#if 1
    if (allow_direct)
    {
      if (fill_rule) ctx_rasterizer_rasterize_edges2 (rasterizer, 1, 1);
      else           ctx_rasterizer_rasterize_edges2 (rasterizer, 0, 1);
    }
    else
    {
      if (fill_rule) ctx_rasterizer_rasterize_edges2 (rasterizer, 1, 0);
      else           ctx_rasterizer_rasterize_edges2 (rasterizer, 0, 0);
    }
#else
#endif
}
#else

void
CTX_SIMD_SUFFIX (ctx_rasterizer_rasterize_edges) (CtxRasterizer *rasterizer, const int fill_rule)
{
  int allow_direct = !(0 
#if CTX_ENABLE_CLIP
         | ((rasterizer->clip_buffer!=NULL) & (!rasterizer->clip_rectangle))
#endif
         );
#if CTX_ENABLE_SHADOW_BLUR
  if (rasterizer->in_shadow)
    ctx_rasterizer_rasterize_edges3 (rasterizer, fill_rule);
  else
#endif
    ctx_rasterizer_rasterize_edges2 (rasterizer, fill_rule, allow_direct);
}

#endif



extern const CtxPixelFormatInfo *ctx_pixel_formats;
void CTX_SIMD_SUFFIX(ctx_simd_setup)(void);
void CTX_SIMD_SUFFIX(ctx_simd_setup)(void)
{
  ctx_pixel_formats         = CTX_SIMD_SUFFIX(ctx_pixel_formats);
  ctx_composite_setup       = CTX_SIMD_SUFFIX(ctx_composite_setup);
  ctx_rasterizer_rasterize_edges = CTX_SIMD_SUFFIX(ctx_rasterizer_rasterize_edges);
#if CTX_FAST_FILL_RECT
  ctx_composite_fill_rect   = CTX_SIMD_SUFFIX(ctx_composite_fill_rect);
#if CTX_FAST_STROKE_RECT
  ctx_composite_stroke_rect = CTX_SIMD_SUFFIX(ctx_composite_stroke_rect);
#endif
#endif
}


#endif
#endif
#if CTX_IMPLEMENTATION
#if CTX_RASTERIZER


static void
_ctx_rasterizer_gradient_add_stop (CtxRasterizer *rasterizer, float pos, float *rgba)
{
  /* FIXME XXX we only have one gradient, but might need separate gradients
   * for fill/stroke !
   * 
   */
  CtxGradient *gradient = &rasterizer->state->gradient;
  CtxGradientStop *stop = &gradient->stops[gradient->n_stops];
  stop->pos = pos;
  ctx_color_set_rgba (rasterizer->state, & (stop->color), rgba[0], rgba[1], rgba[2], rgba[3]);
  if (gradient->n_stops < CTX_MAX_GRADIENT_STOPS-1) //we'll keep overwriting the last when out of stops
    { gradient->n_stops++; }
}

void
ctx_rasterizer_gradient_add_stop (CtxRasterizer *rasterizer, float pos, float *rgba)
{
  _ctx_rasterizer_gradient_add_stop (rasterizer, pos, rgba);
}

static inline void ctx_rasterizer_update_inner_point (CtxRasterizer *rasterizer, int x, int y)
{
  rasterizer->scan_min = ctx_mini (y, rasterizer->scan_min);
  rasterizer->scan_max = ctx_maxi (y, rasterizer->scan_max);
  rasterizer->col_min = ctx_mini (x, rasterizer->col_min);
  rasterizer->col_max = ctx_maxi (x, rasterizer->col_max);
  rasterizer->inner_x = x;
  rasterizer->inner_y = y;
}

static CTX_INLINE int ctx_rasterizer_add_point (CtxRasterizer *rasterizer, int x1, int y1)
{
  CtxSegment entry = {{CTX_EDGE, 0, 0, 0, 0, 0}};
  x1 -= rasterizer->blit_x * CTX_SUBDIV;

  entry.x0=rasterizer->inner_x;
  entry.y0=rasterizer->inner_y;

  entry.x1=x1;
  entry.y1=y1;

  ctx_rasterizer_update_inner_point (rasterizer, x1, y1);

  int ret = ctx_edgelist_add_single (&rasterizer->edge_list, (CtxEntry*)&entry);
  if (CTX_UNLIKELY(rasterizer->has_prev<=0))
    {
      CtxSegment *segment = & ((CtxSegment*)rasterizer->edge_list.entries)[rasterizer->edge_list.count-1];
      segment->code = CTX_NEW_EDGE;
      rasterizer->has_prev = 1;
      rasterizer->first_edge = rasterizer->edge_list.count-1;
    }
  return ret;
}

static inline void ctx_rasterizer_poly_to_edges (CtxRasterizer *rasterizer)
{
  unsigned int count = rasterizer->edge_list.count;
  CtxSegment *segment = (CtxSegment*)&rasterizer->edge_list.entries[0];
  int skipped = 0;
  for (unsigned int i = 0; i < count; i++)
    {
      if (segment[skipped].code == CTX_CLOSE_EDGE)
        skipped ++;
      else
      {
        if (segment[skipped].y1 < segment[skipped].y0)
        {
          segment[0] = ctx_segment_s16 (CTX_EDGE_FLIPPED,
                            segment[skipped].x1, segment[skipped].y1,
                            segment[skipped].x0, segment[skipped].y0);
        }
        else
        {
          segment[0] = segment[skipped];
        }
        segment++;
      }
    }
  rasterizer->edge_list.count = count - skipped;
}

static inline void
_ctx_rasterizer_close_path (CtxRasterizer *rasterizer)
{
  int x0 = rasterizer->inner_x;
  int y0 = rasterizer->inner_y;
  if (rasterizer->first_edge>=0)
    {
        if (rasterizer->edge_list.entries == NULL)
          return;
        CtxSegment *segment = & ((CtxSegment*)rasterizer->edge_list.entries)[rasterizer->first_edge];
        if (segment && segment->code == CTX_NEW_EDGE)
        {
          CtxSegment entry = {{CTX_EDGE, 0, 0, 0, 0, 0}};
          int x1 = segment->x0;
          int y1 = segment->y0;
          entry.x0=x0;
          entry.y0=y0;
          entry.x1=x1;
          entry.y1=y1;
          // XXX 
          rasterizer->has_prev = 0;
          rasterizer->first_edge = -1;
          ctx_edgelist_add_single (&rasterizer->edge_list, (CtxEntry*)&entry);
          entry = *segment;
          entry.code = CTX_CLOSE_EDGE;

          ctx_edgelist_add_single (&rasterizer->edge_list, (CtxEntry*)&entry);

          ctx_rasterizer_update_inner_point (rasterizer, x1, y1);

          float nx = x1 * (1.0f / CTX_SUBDIV);
          float ny = y1 * (1.0f / CTX_FULL_AA);
          ctx_device_to_user(rasterizer->backend.ctx, &nx, &ny);
          rasterizer->x = nx;
          rasterizer->y = ny;
          return;
        }
    }
}

void
ctx_rasterizer_close_path (CtxRasterizer *rasterizer)
{
  _ctx_rasterizer_close_path (rasterizer);
}

//#define MIN_Y -100
//#define MAX_Y 3800
//#define MIN_X -100
//#define MAX_X 3600*10


static inline void _ctx_rasterizer_move_to (CtxRasterizer *rasterizer, float x, float y)
{
  int tx = 0, ty = 0;

  rasterizer->x        = x;
  rasterizer->y        = y;
  rasterizer->first_edge = rasterizer->edge_list.count - 1; // ?
  rasterizer->has_prev = -1;
  _ctx_user_to_device_prepped (rasterizer->state, x,y, &tx, &ty);

  tx -= rasterizer->blit_x * CTX_SUBDIV;
  ctx_rasterizer_update_inner_point (rasterizer, tx, ty);
}

void ctx_rasterizer_move_to (CtxRasterizer *rasterizer, float x, float y)
{
  _ctx_rasterizer_move_to (rasterizer, x, y);
}

static CTX_INLINE void
ctx_rasterizer_line_to_fixed (CtxRasterizer *rasterizer, int x, int y)
{
  int tx = 0, ty = 0;
  _ctx_user_to_device_prepped_fixed (rasterizer->state, x, y, &tx, &ty);
  ctx_rasterizer_add_point (rasterizer, tx, ty);
}

static CTX_INLINE void
_ctx_rasterizer_line_to (CtxRasterizer *rasterizer, float x, float y)
{
  int tx = 0, ty = 0;
  rasterizer->y         = y;
  rasterizer->x         = x;

  _ctx_user_to_device_prepped (rasterizer->state, x, y, &tx, &ty);
  ctx_rasterizer_add_point (rasterizer, tx, ty);
}

void
ctx_rasterizer_line_to (CtxRasterizer *rasterizer, float x, float y)
{
  _ctx_rasterizer_line_to (rasterizer, x, y);
}

CTX_INLINE static float
ctx_bezier_sample_1d (float x0, float x1, float x2, float x3, float dt)
{
  return ctx_lerpf (
      ctx_lerpf (ctx_lerpf (x0, x1, dt),
                 ctx_lerpf (x1, x2, dt), dt),
      ctx_lerpf (ctx_lerpf (x1, x2, dt),
                 ctx_lerpf (x2, x3, dt), dt), dt);
}

CTX_INLINE static void
ctx_bezier_sample (float x0, float y0,
                   float x1, float y1,
                   float x2, float y2,
                   float x3, float y3,
                   float dt, float *x, float *y)
{
  *x = ctx_bezier_sample_1d (x0, x1, x2, x3, dt);
  *y = ctx_bezier_sample_1d (y0, y1, y2, y3, dt);
}

static inline void
ctx_rasterizer_bezier_divide (CtxRasterizer *rasterizer,
                              float ox, float oy,
                              float x0, float y0,
                              float x1, float y1,
                              float x2, float y2,
                              float sx, float sy,
                              float ex, float ey,
                              float s,
                              float e,
                              int   iteration,
                              float tolerance)
{
  float t = (s + e) * 0.5f;
  float x, y;
  float dx, dy;
  ctx_bezier_sample (ox, oy, x0, y0, x1, y1, x2, y2, t, &x, &y);
  dx = (sx+ex)/2 - x;
  dy = (sy+ey)/2 - y;

  if ((iteration<2) | ((iteration < 6) & (dx*dx+dy*dy > tolerance)))
  {
    ctx_rasterizer_bezier_divide (rasterizer, ox, oy, x0, y0, x1, y1, x2, y2,
                                  sx, sy, x, y, s, t, iteration + 1,
                                  tolerance);
    _ctx_rasterizer_line_to (rasterizer, x, y);
    ctx_rasterizer_bezier_divide (rasterizer, ox, oy, x0, y0, x1, y1, x2, y2,
                                  x, y, ex, ey, t, e, iteration + 1,
                                  tolerance);
  }
}

                      

CTX_INLINE static int
ctx_lerp_fixed (int v0, int v1, int dx)
{
  return v0 + (((v1-v0) * dx + ((1<<CTX_FIX_SHIFT)-1)) >> CTX_FIX_SHIFT);
}

CTX_INLINE static int
ctx_bezier_sample_1d_fixed (int x0, int x1, int x2, int x3, int dt)
{
  return ctx_lerp_fixed (
      ctx_lerp_fixed (ctx_lerp_fixed (x0, x1, dt),
                 ctx_lerp_fixed (x1, x2, dt), dt),
      ctx_lerp_fixed (ctx_lerp_fixed (x1, x2, dt),
                 ctx_lerp_fixed (x2, x3, dt), dt), dt);
}

typedef struct CtxFixedBezier
{
  int x0; int y0;
  int x1; int y1;
  int x2; int y2;
  int x3; int y3;
} CtxFixedBezier;

CTX_INLINE static void
ctx_bezier_sample_fixed (const CtxFixedBezier *b,
                         int dt, int *x, int *y)
{
  *x = ctx_bezier_sample_1d_fixed (b->x0, b->x1, b->x2, b->x3, dt);
  *y = ctx_bezier_sample_1d_fixed (b->y0, b->y1, b->y2, b->y3, dt);
}

static inline void
ctx_rasterizer_bezier_divide_fixed (CtxRasterizer *rasterizer,
                                    const CtxFixedBezier *b,
                                    int sx, int sy,
                                    int ex, int ey,
                                    int s,
                                    int e,
                                    int iteration, long int tolerance)
{
  int t = (s + e) / 2;
  int x, y;

  ctx_bezier_sample_fixed (b, t, &x, &y);

  int dx, dy;
#if 1
  dx = (sx+ex)/2 - x;
  dy = (sy+ey)/2 - y;
#else
  int lx, ly;
  lx = ctx_lerp_fixed (sx, ex, t);
  ly = ctx_lerp_fixed (sy, ey, t);
  dx = lx - x;
  dy = ly - y;
#endif

  if ((iteration < 2) | ((iteration < 6) & (((long)dx*dx+dy*dy) > tolerance)))
  {
    ctx_rasterizer_bezier_divide_fixed (rasterizer, b,
                                  sx, sy, x, y, s, t, iteration+1, tolerance
                                  );
    ctx_rasterizer_line_to_fixed (rasterizer, x, y);
    ctx_rasterizer_bezier_divide_fixed (rasterizer, b,
                                  x, y, ex, ey, t, e, iteration+1, tolerance
                                  );
  }
}

static inline void
_ctx_rasterizer_curve_to (CtxRasterizer *rasterizer,
                          float x0, float y0,
                          float x1, float y1,
                          float x2, float y2)
{
  float ox = rasterizer->state->x;
  float oy = rasterizer->state->y;


#if CTX_RASTERIZER_BEZIER_FIXED_POINT
  CtxFixedBezier b = {
            (int)(ox * CTX_FIX_SCALE), (int)(oy * CTX_FIX_SCALE), (int)(x0 * CTX_FIX_SCALE), (int)(y0 * CTX_FIX_SCALE),
            (int)(x1 * CTX_FIX_SCALE), (int)(y1 * CTX_FIX_SCALE), (int)(x2 * CTX_FIX_SCALE), (int)(y2 * CTX_FIX_SCALE)
  };
  ctx_rasterizer_bezier_divide_fixed (rasterizer, &b,
            (int)(ox * CTX_FIX_SCALE), (int)(oy * CTX_FIX_SCALE), (int)(x2 * CTX_FIX_SCALE), (int)(y2 * CTX_FIX_SCALE),
            0, CTX_FIX_SCALE, 0, rasterizer->state->gstate.tolerance_fixed);
#else
  ctx_rasterizer_bezier_divide (rasterizer,
                                ox, oy, x0, y0,
                                x1, y1, x2, y2,
                                ox, oy, x2, y2,
                                0.0f, 1.0f, 0, rasterizer->state->gstate.tolerance);
#endif
  _ctx_rasterizer_line_to (rasterizer, x2, y2);
}

void
ctx_rasterizer_curve_to (CtxRasterizer *rasterizer,
                          float x0, float y0,
                          float x1, float y1,
                          float x2, float y2)
{
  _ctx_rasterizer_curve_to (rasterizer, x0,  y0, x1,  y1, x2,  y2);
}

static inline void
_ctx_rasterizer_rel_move_to (CtxRasterizer *rasterizer, float x, float y)
{
  //if (CTX_UNLIKELY(x == 0.f && y == 0.f))
  //{ return; }
  x += rasterizer->x;
  y += rasterizer->y;
  _ctx_rasterizer_move_to (rasterizer, x, y);
}

void
ctx_rasterizer_rel_move_to (CtxRasterizer *rasterizer, float x, float y)
{
  _ctx_rasterizer_rel_move_to (rasterizer,x,y);
}

static inline void
_ctx_rasterizer_rel_line_to (CtxRasterizer *rasterizer, float x, float y)
{
  //if (CTX_UNLIKELY(x== 0.f && y==0.f))
  //  { return; }
  x += rasterizer->x;
  y += rasterizer->y;
  _ctx_rasterizer_line_to (rasterizer, x, y);
}
void
ctx_rasterizer_rel_line_to (CtxRasterizer *rasterizer, float x, float y)
{
  _ctx_rasterizer_rel_line_to (rasterizer, x, y);
}

static inline void
_ctx_rasterizer_rel_curve_to (CtxRasterizer *rasterizer,
                             float x0, float y0, float x1, float y1, float x2, float y2)
{
  x0 += rasterizer->x;
  y0 += rasterizer->y;
  x1 += rasterizer->x;
  y1 += rasterizer->y;
  x2 += rasterizer->x;
  y2 += rasterizer->y;
  _ctx_rasterizer_curve_to (rasterizer, x0, y0, x1, y1, x2, y2);
}
void
ctx_rasterizer_rel_curve_to (CtxRasterizer *rasterizer,
                             float x0, float y0, float x1, float y1, float x2, float y2)
{
  _ctx_rasterizer_rel_curve_to (rasterizer, x0, y0, x1, y1, x2, y2);
}



static int
ctx_rasterizer_find_texture (CtxRasterizer *rasterizer,
                             const char *eid)
{
  int no;
  for (no = 0; no < CTX_MAX_TEXTURES; no++)
  {
    if (rasterizer->texture_source->texture[no].data &&
        rasterizer->texture_source->texture[no].eid &&
        !strcmp (rasterizer->texture_source->texture[no].eid, eid))
      return no;
  }
  return -1;
}

static void
ctx_rasterizer_set_texture (CtxRasterizer *rasterizer,
                            const char *eid,
                            float x,
                            float y)
{
  int is_stroke = (rasterizer->state->source != 0);
  CtxSource *source = is_stroke?
                        &rasterizer->state->gstate.source_stroke:
                        &rasterizer->state->gstate.source_fill;
  rasterizer->state->source = 0;

  if (source->type == CTX_SOURCE_TEXTURE)
  {
    if (eid[0] != '!')
    {
      source->type = CTX_SOURCE_NONE;
      source->texture.buffer = NULL;
    }
  }
  else
  {
    source->type = CTX_SOURCE_NONE;
    source->texture.buffer = NULL;
  }
  int no = ctx_rasterizer_find_texture (rasterizer, eid);
  if (no < 0 || no >= CTX_MAX_TEXTURES) { no = 0; }
  if (rasterizer->texture_source->texture[no].data == NULL)
    {
      return;
    }
  else
  {
    rasterizer->texture_source->texture[no].frame = rasterizer->texture_source->frame;
  }
  source->texture.buffer = &rasterizer->texture_source->texture[no];
  if (source->texture.buffer)
  {
    source->type = CTX_SOURCE_TEXTURE;
    ctx_matrix_identity (&source->set_transform);
    ctx_matrix_translate (&source->set_transform, x, y);
  }
}

void
ctx_rasterizer_define_texture (CtxRasterizer *rasterizer,
                               const char    *eid,
                               int            width,
                               int            height,
                               int            format,
                               char unsigned *data,
                               int            steal_data)
{

  _ctx_texture_lock (); // we're using the same texture_source from all threads, keeping allocaitons down
                        // need synchronizing (it could be better to do a pre-pass)
  ctx_texture_init (rasterizer->texture_source,
                    eid,
                    width,
                    height,
                    ctx_pixel_format_get_stride ((CtxPixelFormat)format, width),
                    (CtxPixelFormat)format,
#if CTX_ENABLE_CM
                    (void*)rasterizer->state->gstate.texture_space,
#else
                    NULL,
#endif
                    data,
                    ctx_buffer_pixels_free, (steal_data?(void*)0:(void*)23));
                    /*  when userdata for ctx_buffer_pixels_free is 23, texture_init dups the data on
                     *  use
                     */

  int is_stroke = (rasterizer->state->source != 0);
  ctx_rasterizer_set_texture (rasterizer, eid, 0.0f, 0.0f);
#if CTX_ENABLE_CM
  CtxSource *source = is_stroke?
                        &rasterizer->state->gstate.source_stroke:
                        &rasterizer->state->gstate.source_fill;
  if (source->texture.buffer &&
      !source->texture.buffer->color_managed)
  {
    _ctx_texture_prepare_color_management (rasterizer->state,
      source->texture.buffer);
  }
#else
  if (is_stroke){};
#endif
  _ctx_texture_unlock ();
}


inline static int
ctx_is_transparent (CtxRasterizer *rasterizer, int stroke)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  if (gstate->global_alpha_u8 == 0)
    return 1;
  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
  {
    uint8_t ga[2];
    ctx_color_get_graya_u8 (rasterizer->state, &gstate->source_fill.color, ga);
    if (ga[1] == 0)
      return 1;
  }
  return 0;
}

static CTX_INLINE int ctx_perpdot(int ax,int ay,int bx, int by)
{ return (ax*by)-(ay*bx);
}

static void
ctx_rasterizer_fill (CtxRasterizer *rasterizer)
{
  CtxGState     *gstate     = &rasterizer->state->gstate;
  unsigned int preserved_count =
          (rasterizer->preserve&(rasterizer->edge_list.count!=0))?
             rasterizer->edge_list.count:1;
  int blit_x = rasterizer->blit_x;
  int blit_y = rasterizer->blit_y;
  int blit_width = rasterizer->blit_width;
  int blit_height = rasterizer->blit_height;

  CtxSegment temp[preserved_count]; /* copy of already built up path's poly line
                                       XXX - by building a large enough path
                                       the stack can be smashed!
                                     */
  int preserved = 0;
  if (rasterizer->preserve)
    { memcpy (temp, rasterizer->edge_list.entries, sizeof (CtxSegment)*preserved_count );
      preserved = 1;
    }

#if CTX_ENABLE_SHADOW_BLUR
  if (CTX_UNLIKELY(rasterizer->in_shadow))
  {
  for (unsigned int i = 0; i < rasterizer->edge_list.count; i++)
    {
      CtxSegment *segment = &((CtxSegment*)rasterizer->edge_list.entries)[i];
      segment->x0 += rasterizer->feather_x * CTX_SUBDIV;
      segment->y0 += rasterizer->feather_y * CTX_FULL_AA;
      segment->x1 += rasterizer->feather_x * CTX_SUBDIV;
      segment->y1 += rasterizer->feather_y * CTX_FULL_AA;
    }
    rasterizer->scan_min += ((rasterizer->feather_y - rasterizer->feather) +1) * CTX_FULL_AA;
    rasterizer->scan_max += ((rasterizer->feather_y + rasterizer->feather) +1) * CTX_FULL_AA;
    rasterizer->col_min  += ((rasterizer->feather_x - rasterizer->feather)+ 1) * CTX_SUBDIV;
    rasterizer->col_max  += ((rasterizer->feather_x + rasterizer->feather)+ 1) * CTX_SUBDIV;
  }
#endif

  if (CTX_UNLIKELY(ctx_is_transparent (rasterizer, 0) |
      (rasterizer->scan_min > CTX_FULL_AA * (blit_y + blit_height)) |
      (rasterizer->scan_max < CTX_FULL_AA * blit_y) |
      (rasterizer->col_min > CTX_SUBDIV * (blit_x + blit_width)) |
      (rasterizer->col_max < CTX_SUBDIV * blit_x)))
    {
    }
  else
  {
    ctx_composite_setup (rasterizer);

    rasterizer->state->ink_min_x = ctx_mini (rasterizer->state->ink_min_x, rasterizer->col_min / CTX_SUBDIV);
    rasterizer->state->ink_max_x = ctx_maxi (rasterizer->state->ink_min_x, rasterizer->col_max / CTX_SUBDIV);
    rasterizer->state->ink_min_y = ctx_mini (rasterizer->state->ink_min_y, rasterizer->scan_min / CTX_FULL_AA);
    rasterizer->state->ink_max_y = ctx_maxi (rasterizer->state->ink_max_y, rasterizer->scan_max / CTX_FULL_AA);

#if CTX_FAST_FILL_RECT
  if (rasterizer->edge_list.count == 5)
    {
      CtxSegment *entry0 = &(((CtxSegment*)(rasterizer->edge_list.entries)))[0];
      CtxSegment *entry1 = &(((CtxSegment*)(rasterizer->edge_list.entries)))[1];
      CtxSegment *entry2 = &(((CtxSegment*)(rasterizer->edge_list.entries)))[2];
      CtxSegment *entry3 = &(((CtxSegment*)(rasterizer->edge_list.entries)))[3];


      if (
          (!(gstate->clipped != 0)) &
          (entry0->x1 == entry1->x1) &
          (entry0->y1 == entry3->y1) &
          (entry1->y1 == entry2->y1) &
          (entry2->x1 == entry3->x1)
#if CTX_ENABLE_SHADOW_BLUR
           & (!rasterizer->in_shadow)
#endif
         )
       {
         float x0 = entry3->x1 * (1.0f / CTX_SUBDIV);
         float y0 = entry3->y1 * (1.0f / CTX_FULL_AA);
         float x1 = entry1->x1 * (1.0f / CTX_SUBDIV);
         float y1 = entry1->y1 * (1.0f / CTX_FULL_AA);

         x0 = ctx_maxf (x0, blit_x);
         y0 = ctx_maxf (y0, blit_y);
         x1 = ctx_minf (x1, blit_x + blit_width);
         y1 = ctx_minf (y1, blit_y + blit_height);

         if ((x1 > x0) & (y1 > y0))
         {
           ctx_composite_fill_rect (rasterizer, x0, y0, x1, y1, 255);
           goto done;
         }
       }
    }
#endif


    _ctx_rasterizer_close_path (rasterizer);
    ctx_rasterizer_poly_to_edges (rasterizer);

    ctx_rasterizer_rasterize_edges (rasterizer, gstate->fill_rule);
  }
#if CTX_FAST_FILL_RECT
done:
#endif
  if (preserved)
    {
      memcpy (rasterizer->edge_list.entries, temp, sizeof (CtxSegment)*preserved_count );
      rasterizer->edge_list.count = preserved_count;
    }
#if CTX_ENABLE_SHADOW_BLUR
  if (CTX_UNLIKELY(rasterizer->in_shadow))
  {
    rasterizer->scan_min -= ((rasterizer->feather_y - rasterizer->feather) +1) * CTX_FULL_AA;
    rasterizer->scan_max -= ((rasterizer->feather_y + rasterizer->feather) +1) * CTX_FULL_AA;
    rasterizer->col_min  -= ((rasterizer->feather_x - rasterizer->feather)+ 1) * CTX_SUBDIV;
    rasterizer->col_max  -= ((rasterizer->feather_x + rasterizer->feather)+ 1) * CTX_SUBDIV;
  }
#endif
  rasterizer->preserve = 0;
}


#if CTX_BRAILLE_TEXT
static CtxTermGlyph *
ctx_rasterizer_find_term_glyph (CtxRasterizer *rasterizer, int col, int row)
{
    CtxTermGlyph *glyph = NULL;
    
    for (CtxList *l = rasterizer->glyphs; l; l=l->next)
    {
      glyph = (CtxTermGlyph*)l->data;
      if ((glyph->col == col) &
          (glyph->row == row))
      {
        return glyph;
      }
    }

    glyph = (CtxTermGlyph*)ctx_calloc (1, sizeof (CtxTermGlyph));
    ctx_list_append (&rasterizer->glyphs, glyph);
    glyph->col = col;
    glyph->row = row;
    return glyph;
}
#endif

static void
ctx_rasterizer_glyph (CtxRasterizer *rasterizer, uint32_t unichar, int stroke)
{
  float tx = rasterizer->state->x;
  float ty = rasterizer->state->y - rasterizer->state->gstate.font_size;
  float tx2 = rasterizer->state->x + rasterizer->state->gstate.font_size;
  float ty2 = rasterizer->state->y + rasterizer->state->gstate.font_size;
  _ctx_user_to_device (rasterizer->state, &tx, &ty);
  _ctx_user_to_device (rasterizer->state, &tx2, &ty2);

  if ((tx2 < rasterizer->blit_x) | (ty2 < rasterizer->blit_y))
    return;
  if ((tx  > rasterizer->blit_x + rasterizer->blit_width) |
      (ty  > rasterizer->blit_y + rasterizer->blit_height))
    return;

#if CTX_TERM
#if CTX_BRAILLE_TEXT
  float font_size = 0;
  int ch = 1;
  int cw = 1;

  if (rasterizer->term_glyphs)
  {
    float tx = 0;
    font_size = rasterizer->state->gstate.font_size;

    ch = (int)ctx_term_get_cell_height (rasterizer->backend.ctx);
    cw = (int)ctx_term_get_cell_width (rasterizer->backend.ctx);

    _ctx_user_to_device_distance (rasterizer->state, &tx, &font_size);
  }
  if ((rasterizer->term_glyphs!=0) & (!stroke) &
      (fabsf (font_size - ch) < 0.5f))
  {
    float tx = rasterizer->x;
    float ty = rasterizer->y;
    _ctx_user_to_device (rasterizer->state, &tx, &ty);
    int col = (int)(tx / cw + 1);
    int row = (int)(ty / ch + 1);
    CtxTermGlyph *glyph = ctx_rasterizer_find_term_glyph (rasterizer, col, row);

    glyph->unichar = unichar;
    ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color,
                         &glyph->rgba_fg[0]);
  }
  else
#endif
#endif
  _ctx_glyph (rasterizer->backend.ctx, unichar, stroke);
}

static void
ctx_rasterizer_text (CtxRasterizer *rasterizer, const char *string, int stroke)
{
#if CTX_TERM
#if CTX_BRAILLE_TEXT
  float font_size = 0;
  if (rasterizer->term_glyphs)
  {
    float tx = 0;
    font_size = rasterizer->state->gstate.font_size;
    _ctx_user_to_device_distance (rasterizer->state, &tx, &font_size);
  }
  int   ch = (int)ctx_term_get_cell_height (rasterizer->backend.ctx);
  int   cw = (int)ctx_term_get_cell_width (rasterizer->backend.ctx);

  if ((rasterizer->term_glyphs!=0) & (!stroke) &
      (fabsf (font_size - ch) < 0.5f))
  {
    float tx = rasterizer->x;
    float ty = rasterizer->y;
    _ctx_user_to_device (rasterizer->state, &tx, &ty);
    int col = (int)(tx / cw + 1);
    int row = (int)(ty / ch + 1);

    for (int i = 0; string[i]; i++, col++)
    {
      CtxTermGlyph *glyph = ctx_rasterizer_find_term_glyph (rasterizer, col, row);

      glyph->unichar = string[i];
      ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color,
                      glyph->rgba_fg);
    }
  }
  else
#endif
#endif
  {
    _ctx_text (rasterizer->backend.ctx, string, stroke, 1);
  }
}

void
_ctx_font (Ctx *ctx, const char *name);
void
ctx_rasterizer_set_font (CtxRasterizer *rasterizer, const char *font_name)
{
  _ctx_font (rasterizer->backend.ctx, font_name);
}

void
ctx_rasterizer_arc (CtxRasterizer *rasterizer,
                    float          x,
                    float          y,
                    float          radius,
                    float          start_angle,
                    float          end_angle,
                    int            anticlockwise)
{
  float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
  int full_segments = CTX_RASTERIZER_MAX_CIRCLE_SEGMENTS;
  full_segments = (int)(factor * radius * CTX_PI * 2 / 4.0f);
  if (full_segments > CTX_RASTERIZER_MAX_CIRCLE_SEGMENTS)
    { full_segments = CTX_RASTERIZER_MAX_CIRCLE_SEGMENTS; }
  if (full_segments < 24) full_segments = 24;
  float step = CTX_PI*2.0f/full_segments;
  int steps;

  if (end_angle < -30.0f)
    end_angle = -30.0f;
  if (start_angle < -30.0f)
    start_angle = -30.0f;
  if (end_angle > 30.0f)
    end_angle = 30.0f;
  if (start_angle > 30.0f)
    start_angle = 30.0f;

  if (radius <= 0.0001f)
          return;

  if (end_angle == start_angle)
          // XXX also detect arcs fully outside render view
    {
    if (rasterizer->has_prev!=0)
      _ctx_rasterizer_line_to (rasterizer, x + ctx_cosf (end_angle) * radius,
                              y + ctx_sinf (end_angle) * radius);
      else
      _ctx_rasterizer_move_to (rasterizer, x + ctx_cosf (end_angle) * radius,
                               y + ctx_sinf (end_angle) * radius);
      return;
    }
#if 1
  if ( (!anticlockwise && fabsf((end_angle - start_angle) - CTX_PI*2) < 0.01f)  ||
       ( (anticlockwise && fabsf((start_angle - end_angle) - CTX_PI*2) < 0.01f ) ) 
  ||   (anticlockwise && fabsf((end_angle - start_angle) - CTX_PI*2) < 0.01f)  ||  (!anticlockwise && fabsf((start_angle - end_angle) - CTX_PI*2) < 0.01f )  )
    {
      steps = full_segments - 1;
    }
  else
#endif
    {
      if (anticlockwise)
      steps = (int)((start_angle - end_angle) / (CTX_PI*2) * full_segments);
      else
      steps = (int)((end_angle - start_angle) / (CTX_PI*2) * full_segments);
   // if (steps > full_segments)
   //   steps = full_segments;
    }

  if (anticlockwise) { step = step * -1; }
  int first = 1;
  if (steps == 0 /* || steps==full_segments -1  || (anticlockwise && steps == full_segments) */)
    {
      float xv = x + ctx_cosf (start_angle) * radius;
      float yv = y + ctx_sinf (start_angle) * radius;
      if (!rasterizer->has_prev)
        { ctx_rasterizer_move_to (rasterizer, xv, yv); }
      first = 0;
    }
  else
    {
      for (float angle = start_angle, i = 0; i < steps; angle += step, i++)
        {
          float xv = x + ctx_cosf (angle) * radius;
          float yv = y + ctx_sinf (angle) * radius;
          if (first & (!rasterizer->has_prev))
            { ctx_rasterizer_move_to (rasterizer, xv, yv); }
          else
            { _ctx_rasterizer_line_to (rasterizer, xv, yv); }
          first = 0;
        }
    }
  _ctx_rasterizer_line_to (rasterizer, x + ctx_cosf (end_angle) * radius,
                           y + ctx_sinf (end_angle) * radius);
}

void
ctx_rasterizer_quad_to (CtxRasterizer *rasterizer,
                        float        cx,
                        float        cy,
                        float        x,
                        float        y)
{
  _ctx_rasterizer_curve_to (rasterizer,
                           (cx * 2 + rasterizer->x) / 3.0f, (cy * 2 + rasterizer->y) / 3.0f,
                           (cx * 2 + x) / 3.0f,           (cy * 2 + y) / 3.0f,
                           x,                              y);
}

void
ctx_rasterizer_rel_quad_to (CtxRasterizer *rasterizer,
                            float cx, float cy,
                            float x,  float y)
{
  ctx_rasterizer_quad_to (rasterizer, cx + rasterizer->x, cy + rasterizer->y,
                          x  + rasterizer->x, y  + rasterizer->y);
}

static void
ctx_rasterizer_rectangle_reverse (CtxRasterizer *rasterizer,
                                  float x,
                                  float y,
                                  float width,
                                  float height);

#if CTX_STROKE_1PX


// XXX : x and y are expected to be - rasterizer->blit_x
static void
ctx_rasterizer_pset (CtxRasterizer *rasterizer, int x, int y, uint8_t cov)
{
  if ((x <= 0) | (y < 0) | (x >= rasterizer->blit_width) |
      (y >= rasterizer->blit_height))
    { return; }
  uint8_t fg_color[4];
  ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color,
fg_color);

  int blit_stride = rasterizer->blit_stride;
  int pitch = rasterizer->format->bpp / 8;

  uint8_t *dst = ( (uint8_t *) rasterizer->buf) + y * blit_stride + x * pitch;
  rasterizer->apply_coverage (1, dst, rasterizer->color, &cov, rasterizer, x);
}


static inline void
ctx_rasterizer_stroke_1px_segment (CtxRasterizer *rasterizer,
                                   float x0, float y0,
                                   float x1, float y1)
{
  ctx_apply_coverage_fun apply_coverage = rasterizer->apply_coverage;
  uint8_t *rasterizer_src = rasterizer->color;
  int pitch = rasterizer->format->bpp / 8;
  int blit_stride = rasterizer->blit_stride;

  x0 -= rasterizer->blit_x;
  x1 -= rasterizer->blit_x;
  y0 -= rasterizer->blit_y;
  y1 -= rasterizer->blit_y;

  x1 += 0.5f;
  x0 += 0.5f;

  y1 += 0.5f;
  y0 += 0.5f;

  float dxf = (x1 - x0);
  float dyf = (y1 - y0);
  int tx = (int)((x0)* 65536);
  int ty = (int)((y0)* 65536);

  int blit_width = rasterizer->blit_width;
  int blit_height = rasterizer->blit_height;

  if (dxf*dxf>dyf*dyf)
  {
    int length = abs((int)dxf);
    int dy = (int)((dyf * 65536)/(length));
    int x = tx >> 16;

    if (dxf < 0.0f)
    {
      ty = (int)((y1)* 65536);
      x = (int)x1; 
      dy *= -1;
    }
    int i = 0;
    int sblit_height = blit_height << 16;

    for (; (i < length) & (x < 0); ++i, ++x, ty += dy);
    for (; (i < length) & (x < blit_width) & ((ty<0) | (ty>=sblit_height+1))
         ; ++i, ++x, ty += dy);

    for (; i < length && x < blit_width && (ty<65536 || (ty>=sblit_height))
         ; ++i, ++x, ty += dy)
    {
      int y = ty>>16;
      int ypos = (ty >> 8) & 0xff;

      ctx_rasterizer_pset (rasterizer, x, y-1, 255-ypos);
      ctx_rasterizer_pset (rasterizer, x, y, ypos);
    }

      {
       for (; (i < length) & (x < blit_width) & ((ty>65536) & (ty<sblit_height))
            ; ++i, ++x, ty += dy)
       {
         uint8_t *dst = ( (uint8_t *) rasterizer->buf)
                        + ((ty>>16)-1) * blit_stride + x * pitch;
         uint8_t ypos = (ty >> 8) & 0xff;
         uint8_t rcov=255-ypos;
         apply_coverage (1, dst, rasterizer_src, &rcov, rasterizer, x);
         dst += blit_stride;
         apply_coverage (1, dst, rasterizer_src, &ypos, rasterizer, x);
       }
      }

    {
      int y = ty>>16;
      int ypos = (ty >> 8) & 0xff;
      ctx_rasterizer_pset (rasterizer, x, y-1, 255-ypos);
      ctx_rasterizer_pset (rasterizer, x, y, ypos);
    }

  }
  else
  {
    int length = abs((int)dyf);
    int dx = (int)((dxf * 65536)/(length));
    int y = ty >> 16;

    if (dyf < 0.0f)
    {
      tx = (int)((x1)* 65536);
      y = (int)y1; 
      dx *= -1;
    }
    int i = 0;

    int sblit_width = blit_width << 16;

    for (; (i < length) & (y < 0); ++i, ++y, tx += dx);

    for (; (i < length) & (y < blit_height) & ((tx<0) | (tx>=sblit_width+1))
         ; ++i, ++y, tx += dx);
    for (; (i < length) & (y < blit_height) & ((tx<65536) | (tx>=sblit_width))
         ; ++i, ++y, tx += dx)
    {
      int x = tx>>16;
      int xpos = (tx >> 8) & 0xff;
      ctx_rasterizer_pset (rasterizer, x-1, y, 255-xpos);
      ctx_rasterizer_pset (rasterizer, x, y, xpos);
    }

      {
       for (; (i < length) & (y < blit_height) & ((tx>65536) & (tx<sblit_width))
            ; ++i, ++y, tx += dx)
       {
         int x = tx>>16;
         uint8_t *dst = ( (uint8_t *) rasterizer->buf)
                       + y * blit_stride + (x-1) * pitch;
         int xpos = (tx >> 8) & 0xff;
         uint8_t cov[2]={255-xpos, xpos};
         apply_coverage (2, dst, rasterizer_src, cov, rasterizer, x);
       }
      }
    //for (; i <= length; ++i, ++y, tx += dx)
    { // better do one too many than one too little
      int x = tx>>16;
      int xpos = (tx >> 8) & 0xff;
      ctx_rasterizer_pset (rasterizer, x-1, y, 255-xpos);
      ctx_rasterizer_pset (rasterizer, x, y, xpos);
    }
  }
}

static inline void
ctx_rasterizer_stroke_1px (CtxRasterizer *rasterizer)
{
  int count = rasterizer->edge_list.count;
  CtxSegment *temp = (CtxSegment*)rasterizer->edge_list.entries;
  float prev_x = 0.0f;
  float prev_y = 0.0f;
  int start = 0;
  int end = 0;

  while (start < count)
    {
      int started = 0;
      int i;
      for (i = start; i < count; i++)
        {
          CtxSegment *segment = &temp[i];
          float x, y;
          if (segment->code == CTX_NEW_EDGE)
            {
              if (started)
                {
                  end = i - 1;
                  goto foo;
                }
              prev_x = segment->x0 * 1.0f / CTX_SUBDIV;
              prev_y = segment->y0 * 1.0f / CTX_FULL_AA;
              started = 1;
              start = i;
            }
          x = segment->x1 * 1.0f / CTX_SUBDIV;
          y = segment->y1 * 1.0f / CTX_FULL_AA;
          
          ctx_rasterizer_stroke_1px_segment (rasterizer, prev_x, prev_y, x, y);
          prev_x = x;
          prev_y = y;
        }
      end = i-1;
foo:
      start = end+1;
    }
  _ctx_rasterizer_reset (rasterizer);
}

#endif

#define CTX_MIN_STROKE_LEN  0.2f

static void
ctx_rasterizer_stroke (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  CtxSource source_backup;
  int count = rasterizer->edge_list.count;
  if (count == 0)
    return;
  int preserved = rasterizer->preserve;
  float factor = ctx_matrix_get_scale (&gstate->transform);
  float line_width = gstate->line_width * factor;
  if (gstate->source_stroke.type != CTX_SOURCE_INHERIT_FILL)
  {
    source_backup = gstate->source_fill;
    gstate->source_fill = gstate->source_stroke;
  }

  rasterizer->comp_op = NULL;
  ctx_composite_setup (rasterizer);

#if CTX_STROKE_1PX
  if ((gstate->line_width * factor <= 0.0f) &
      (gstate->line_width * factor > -10.0f) &
      (rasterizer->format->bpp >= 8))
  {
    ctx_rasterizer_stroke_1px (rasterizer);
    if (preserved)
    {
      rasterizer->preserve = 0;
    }
    else
    {
      rasterizer->edge_list.count = 0;
    }
    if (gstate->source_stroke.type != CTX_SOURCE_INHERIT_FILL)
      gstate->source_fill = source_backup;

    return;
  }
#endif

  CtxSegment temp[count]; /* copy of already built up path's poly line  */
  memcpy (temp, rasterizer->edge_list.entries, sizeof (temp) );
#if CTX_FAST_FILL_RECT
#if CTX_FAST_STROKE_RECT
  if (rasterizer->edge_list.count == 5)
    {
      CtxSegment *entry0 = &((CtxSegment*)rasterizer->edge_list.entries)[0];
      CtxSegment *entry1 = &((CtxSegment*)rasterizer->edge_list.entries)[1];
      CtxSegment *entry2 = &((CtxSegment*)rasterizer->edge_list.entries)[2];
      CtxSegment *entry3 = &((CtxSegment*)rasterizer->edge_list.entries)[3];

      if (!rasterizer->state->gstate.clipped &
          (entry0->x1 == entry1->x1) &
          (entry0->y1 == entry3->y1) &
          (entry1->y1 == entry2->y1) &
          (entry2->x1 == entry3->x1)
#if CTX_ENABLE_SHADOW_BLUR
           & (!rasterizer->in_shadow)
#endif
           & (rasterizer->state->gstate.source_fill.type != CTX_SOURCE_TEXTURE)
         )
       {
        float x0 = entry3->x1 * 1.0f / CTX_SUBDIV;
        float y0 = entry3->y1 * 1.0f / CTX_FULL_AA;
        float x1 = entry1->x1 * 1.0f / CTX_SUBDIV;
        float y1 = entry1->y1 * 1.0f / CTX_FULL_AA;

        ctx_composite_stroke_rect (rasterizer, x0, y0, x1, y1, line_width);

        goto done;
       }
    }
#endif
#endif
  
    {
    {
      _ctx_rasterizer_reset (rasterizer); /* then start afresh with our stroked shape  */
      CtxMatrix transform_backup = gstate->transform;
      _ctx_matrix_identity (&gstate->transform);
      _ctx_transform_prime (rasterizer->state);
      float prev_x = 0.0f;
      float prev_y = 0.0f;
      float half_width_x = line_width/2;
      float half_width_y = half_width_x;

      if (CTX_UNLIKELY(line_width <= 0.0f))
        { // makes negative width be 1px in user-space; hairline
          half_width_x = .5f;
          half_width_y = .5f;
        }
      int start = 0;
      int end   = 0;
      while (start < count)
        {
          int started = 0;
          int i;
          for (i = start; i < count; i++)
            {
              CtxSegment *segment= &temp[i];
              float x, y;
              if (segment->code == CTX_NEW_EDGE)
                {
                  if (CTX_LIKELY(started))
                    {
                      end = i - 1;
                      goto foo;
                    }
                  prev_x = segment->x0 * 1.0f / CTX_SUBDIV;
                  prev_y = segment->y0 * 1.0f / CTX_FULL_AA;
                  started = 1;
                  start = i;
                }
              x = segment->x1 * 1.0f / CTX_SUBDIV;
              y = segment->y1 * 1.0f/ CTX_FULL_AA;
              float dx = x - prev_x;
              float dy = y - prev_y;
              float length = ctx_hypotf (dx, dy);
              if ((length>CTX_MIN_STROKE_LEN) | (segment->code == CTX_NEW_EDGE))
                {
                  float recip_length = 1.0f/length;
                  dx = dx * recip_length * half_width_x;
                  dy = dy * recip_length * half_width_y;
                  if (segment->code == CTX_NEW_EDGE)
                    {
                      _ctx_rasterizer_close_path (rasterizer);
                      _ctx_rasterizer_move_to (rasterizer, prev_x+dy, prev_y-dx);
                    }
                  _ctx_rasterizer_line_to (rasterizer, prev_x-dy, prev_y+dx);
                  
                  _ctx_rasterizer_line_to (rasterizer, x-dy, y+dx);
                }
                  prev_x = x;
                  prev_y = y;
            }
          end = i-1;
foo:
          for (int i = end; i >= start; i--)
            {
              CtxSegment *segment = &temp[i];
              float x, y, dx, dy;
              x = segment->x1 * 1.0f / CTX_SUBDIV;
              y = segment->y1 * 1.0f / CTX_FULL_AA;
              dx = x - prev_x;
              dy = y - prev_y;
              float length = ctx_hypotf (dx, dy);
              if (length>CTX_MIN_STROKE_LEN)
                {
                  float recip_length = 1.0f/length;
                  dx = dx * recip_length * half_width_x;
                  dy = dy * recip_length * half_width_y;
                  _ctx_rasterizer_line_to (rasterizer, prev_x-dy, prev_y+dx);

                  // XXX possible miter line-to
             //   ctx_rasterizer_line_to (rasterizer, prev_x-dy+10, prev_y+dx+10);
                  ctx_rasterizer_line_to (rasterizer, x-dy,      y+dx);
                  prev_x = x;
                  prev_y = y;
                }
              if (CTX_UNLIKELY(segment->code == CTX_NEW_EDGE))
                {
                  x = segment->x0 * 1.0f / CTX_SUBDIV;
                  y = segment->y0 * 1.0f / CTX_FULL_AA;
                  dx = x - prev_x;
                  dy = y - prev_y;
                  length = ctx_hypotf (dx, dy);
                  if (CTX_LIKELY(length>CTX_MIN_STROKE_LEN))
                    {
                      float recip_length = 1.0f/length;
                      dx = dx * recip_length * half_width_x;
                      dy = dy * recip_length * half_width_y;
                      _ctx_rasterizer_line_to (rasterizer, prev_x-dy, prev_y+dx);
                      _ctx_rasterizer_line_to (rasterizer, x-dy, y+dx);
                    }
                  prev_x = x;
                  prev_y = y;
                }
            }
          start = end+1;
        }
      _ctx_rasterizer_close_path (rasterizer);
      switch (gstate->line_cap)
        {
          case CTX_CAP_SQUARE: // XXX: incorrect - if rectangles were in
                               //                  reverse order - rotation would be off
                               //                  better implement correct here
            {
              float x = 0, y = 0;
              int has_prev = 0;
              for (int i = 0; i < count; i++)
                {
                  CtxSegment *segment = &temp[i];
                  if (CTX_UNLIKELY(segment->code == CTX_NEW_EDGE))
                    {
                      if (has_prev)
                        {
                          ctx_rasterizer_rectangle_reverse (rasterizer, x - half_width_x, y - half_width_y, half_width_x, half_width_y);
                          _ctx_rasterizer_close_path (rasterizer);
                        }
                      x = segment->x0 * 1.0f / CTX_SUBDIV;
                      y = segment->y0 * 1.0f / CTX_FULL_AA;
                      ctx_rasterizer_rectangle_reverse (rasterizer, x - half_width_x, y - half_width_y, half_width_x * 2, half_width_y * 2);
                      _ctx_rasterizer_close_path (rasterizer);
                    }
                  x = segment->x1 * 1.0f / CTX_SUBDIV;
                  y = segment->y1 * 1.0f / CTX_FULL_AA;
                  has_prev = 1;
                }
              ctx_rasterizer_rectangle_reverse (rasterizer, x - half_width_x, y - half_width_y, half_width_x * 2, half_width_y * 2);
              _ctx_rasterizer_close_path (rasterizer);
            }
            break;
          case CTX_CAP_NONE: /* nothing to do */
            break;
          case CTX_CAP_ROUND:
            {
              float x = 0, y = 0;
              int has_prev = 0;
              for (int i = 0; i < count; i++)
                {
                  CtxSegment *segment = &temp[i];
                  if (CTX_UNLIKELY(segment->code == CTX_NEW_EDGE))
                    {
                      if (has_prev)
                        {
                          ctx_rasterizer_arc (rasterizer, x, y, half_width_x, CTX_PI*3, 0, 1);
                          _ctx_rasterizer_close_path (rasterizer);
                        }
                      x = segment->x0 * 1.0f / CTX_SUBDIV;
                      y = segment->y0 * 1.0f / CTX_FULL_AA;
                      ctx_rasterizer_arc (rasterizer, x, y, half_width_x, CTX_PI*2, 0, 1);
                      _ctx_rasterizer_close_path (rasterizer);
                    }
                  x = segment->x1 * 1.0f / CTX_SUBDIV;
                  y = segment->y1 * 1.0f / CTX_FULL_AA;
                  has_prev = 1;
                }
              _ctx_rasterizer_move_to (rasterizer, x, y);
              ctx_rasterizer_arc (rasterizer, x, y, half_width_x, CTX_PI*2, 0, 1);
              _ctx_rasterizer_close_path (rasterizer);
              break;
            }
        }
      switch (gstate->line_join)
        {
          case CTX_JOIN_BEVEL:
          case CTX_JOIN_MITER:
            break;
          case CTX_JOIN_ROUND:
            {
              float x = 0, y = 0;
              for (int i = 0; i < count-1; i++)
                {
                  CtxSegment *segment = &temp[i];
                  x = segment->x1 * 1.0f / CTX_SUBDIV;
                  y = segment->y1 * 1.0f / CTX_FULL_AA;
                  if (CTX_UNLIKELY(segment[1].code == CTX_EDGE))
                    {
                      ctx_rasterizer_arc (rasterizer, x, y, half_width_x, CTX_PI*2, 0, 1);
                      _ctx_rasterizer_close_path (rasterizer);
                    }
                }
              break;
            }
        }
      CtxFillRule rule_backup = gstate->fill_rule;
      gstate->fill_rule = CTX_FILL_RULE_WINDING;
      rasterizer->preserve = 0; // so fill isn't tripped
      int aa = rasterizer->aa;
      rasterizer->aa = 3 + (aa>5)*2;
      ctx_rasterizer_fill (rasterizer);
      rasterizer->aa = aa;
      gstate->fill_rule = rule_backup;
      gstate->transform = transform_backup;
      _ctx_transform_prime (rasterizer->state);
    }
  }
#if CTX_FAST_FILL_RECT
#if CTX_FAST_STROKE_RECT
  done:
#endif
#endif
  if (preserved)
    {
      memcpy (rasterizer->edge_list.entries, temp, sizeof (temp) );
      rasterizer->edge_list.count = count;
      rasterizer->preserve = 0;
    }
  if (gstate->source_stroke.type != CTX_SOURCE_INHERIT_FILL)
  {
    gstate->source_fill = source_backup;
    rasterizer->comp_op = NULL;
    rasterizer->fragment = NULL;
  }
}

#if CTX_1BIT_CLIP
#define CTX_CLIP_FORMAT CTX_FORMAT_GRAY1
#else
#define CTX_CLIP_FORMAT CTX_FORMAT_GRAY8
#endif


static void
ctx_rasterizer_clip_reset (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
#if CTX_ENABLE_CLIP
  if (rasterizer->clip_buffer)
   ctx_buffer_destroy (rasterizer->clip_buffer);
  rasterizer->clip_buffer = NULL;
#endif
  gstate->clip_min_x = rasterizer->blit_x;
  gstate->clip_min_y = rasterizer->blit_y;

  gstate->clip_max_x = rasterizer->blit_x + rasterizer->blit_width - 1;
  gstate->clip_max_y = rasterizer->blit_y + rasterizer->blit_height - 1;
}

static void
ctx_rasterizer_clip_apply (CtxRasterizer *rasterizer,
                           CtxSegment    *edges)
{
  unsigned int count = edges[0].u32[0];
  CtxGState *gstate = &rasterizer->state->gstate;

  int minx = 5000;
  int miny = 5000;
  int maxx = -5000;
  int maxy = -5000;
  int prev_x = 0;
  int prev_y = 0;
#if CTX_ENABLE_CLIP
  int blit_width = rasterizer->blit_width;
  int blit_height = rasterizer->blit_height;
#endif

  float coords[6][2];

  for (unsigned int i = 0; i < count; i++)
    {
      CtxSegment *segment = &edges[i+1];
      float x, y;
      if (segment->code == CTX_NEW_EDGE)
        {
          prev_x = segment->x0 / CTX_SUBDIV;
          prev_y = segment->y0 / CTX_FULL_AA;
          if (prev_x < minx) { minx = prev_x; }
          if (prev_y < miny) { miny = prev_y; }
          if (prev_x > maxx) { maxx = prev_x; }
          if (prev_y > maxy) { maxy = prev_y; }
        }
      x = segment->x1 * 1.0f / CTX_SUBDIV;
      y = segment->y1 * 1.0f / CTX_FULL_AA;
      if (x < minx) { minx = (int)x; }
      if (y < miny) { miny = (int)y; }
      if (x > maxx) { maxx = (int)x; }
      if (y > maxy) { maxy = (int)y; }

      if (i < 6)
      {
        coords[i][0] = x;
        coords[i][1] = y;
      }
    }

#if CTX_ENABLE_CLIP

  if (((rasterizer->clip_rectangle==1) | (!rasterizer->clip_buffer))
      )
  {
    if (count == 5)
    {
      if ((coords[0][0] == coords[1][0]) &
          (coords[0][1] == coords[3][1]) &
          (coords[1][1] == coords[2][1]) &
          (coords[2][0] == coords[3][0])
          )
      {
#if 0
        printf ("%d,%d %dx%d\n", minx, miny,
                                       maxx-minx+1, maxy-miny+1);
#endif

         gstate->clip_min_x =
            ctx_maxi (minx, gstate->clip_min_x);
         gstate->clip_min_y =
            ctx_maxi (miny, gstate->clip_min_y);
         gstate->clip_max_x =
            ctx_mini (maxx, gstate->clip_max_x);
         gstate->clip_max_y =
            ctx_mini (maxy, gstate->clip_max_y);

         rasterizer->clip_rectangle = 1;

#if 0
         if (!rasterizer->clip_buffer)
           rasterizer->clip_buffer = ctx_buffer_new (blit_width,
                                                     blit_height,
                                                     CTX_CLIP_FORMAT);

         memset (rasterizer->clip_buffer->data, 0, blit_width * blit_height);
         int i = 0;
         for (int y = gstate->clip_min_y;
                  y <= gstate->clip_max_y;
                  y++)
         for (int x = gstate->clip_min_x;
                  x <= gstate->clip_max_x;
                  x++, i++)
         {
           ((uint8_t*)(rasterizer->clip_buffer->data))[i] = 255;
         }
#endif

         return;
      }
#if 0
      else
      {
        printf ("%d,%d %dx%d  0,0:%.2f 0,1:%.2f 1,0:%.2f 11:%.2f 20:%.2f 21:%2.f 30:%.2f 31:%.2f 40:%.2f 41:%.2f\n", minx, miny,
                                       maxx-minx+1, maxy-miny+1
                                       
         ,coords[0][0] ,  coords[0][1]
         ,coords[1][0] ,  coords[1][1]
         ,coords[2][0] ,  coords[2][1]
         ,coords[3][0] ,  coords[3][1]
         ,coords[4][0] ,  coords[4][1]
         );
      }
#endif
    }
  }
  rasterizer->clip_rectangle = 0;

  if ((minx == maxx) | (miny == maxy) || count < 2) // XXX : reset hack
  {
    ctx_rasterizer_clip_reset (rasterizer);
    return;
  }

  int we_made_it = 0;
  CtxBuffer *clip_buffer;

  if (!rasterizer->clip_buffer)
  {
    rasterizer->clip_buffer = ctx_buffer_new (blit_width,
                                              blit_height,
                                              CTX_CLIP_FORMAT);
    clip_buffer = rasterizer->clip_buffer;
    we_made_it = 1;
    if (CTX_CLIP_FORMAT == CTX_FORMAT_GRAY1)
      memset (rasterizer->clip_buffer->data, 0, blit_width * blit_height/8);
    else
      memset (rasterizer->clip_buffer->data, 0, blit_width * blit_height);
  }
  else
  {
    clip_buffer = ctx_buffer_new (blit_width, blit_height,
                                  CTX_CLIP_FORMAT);
  }

  {

  float prev_x = 0;
  float prev_y = 0;

    Ctx *ctx = ctx_new_for_framebuffer (clip_buffer->data, blit_width, blit_height,
       blit_width,
       CTX_CLIP_FORMAT);

  for (unsigned int i = 0; i < count; i++)
    {
      CtxSegment *segment = &edges[i+1];
      float x, y;
      if (segment->code == CTX_NEW_EDGE)
        {
          prev_x = segment->x0 * 1.0f / CTX_SUBDIV;
          prev_y = segment->y0 * 1.0f / CTX_FULL_AA;
          ctx_move_to (ctx, prev_x, prev_y);
        }
      x = segment->x1 * 1.0f / CTX_SUBDIV;
      y = segment->y1 * 1.0f / CTX_FULL_AA;
      ctx_line_to (ctx, x, y);
    }
    ctx_gray (ctx, 1.0f);
    ctx_fill (ctx);
    ctx_destroy (ctx);
  }

  int maybe_rect = 1;
  rasterizer->clip_rectangle = 0;

  if (CTX_CLIP_FORMAT == CTX_FORMAT_GRAY1)
  {
    unsigned int count = blit_width * blit_height / 8;
    for (unsigned int i = 0; i < count; i++)
    {
      ((uint8_t*)rasterizer->clip_buffer->data)[i] =
      (((uint8_t*)rasterizer->clip_buffer->data)[i] &
      ((uint8_t*)clip_buffer->data)[i]);
    }
  }
  else
  {
    int count = blit_width * blit_height;


    int i;
    int x0 = 0;
    int y0 = 0;
    int width = -1;
    int next_stage = 0;
    uint8_t *p_data = (uint8_t*)rasterizer->clip_buffer->data;
    uint8_t *data = (uint8_t*)clip_buffer->data;

    i=0;
    /* find upper left */
    for (; (i < count) & maybe_rect & (!next_stage); i++)
    {
      uint8_t val = (p_data[i] * data[i])/255;
      data[i] = val;
      switch (val)
      {
        case 255:
          x0 = i % blit_width;
          y0 = i / blit_width;
          next_stage = 1;
          break;
        case 0: break;
        default:
          maybe_rect = 0;
          break;
      }
    }

    next_stage = 0;
    /* figure out with */
    for (; (i < count) & (!next_stage) & maybe_rect; i++)
    {
      int x = i % blit_width;
      int y = i / blit_width;
      uint8_t val = (p_data[i] * data[i])/255;
      data[i] = val;

      if (y == y0)
      {
        switch (val)
        {
          case 255:
            width = x - x0 + 1;
            break;
          case 0:
            next_stage = 1;
            break;
          default:
            maybe_rect = 0;
            break;
        }
        if (x % blit_width == blit_width - 1) next_stage = 1;
      }
      else next_stage = 1;
    }

    next_stage = 0;
    /* body */
    for (; (i < count) & maybe_rect & (!next_stage); i++)
    {
      int x = i % blit_width;
      uint8_t val = (p_data[i] * data[i])/255;
      data[i] = val;

      if (x < x0)
      {
        if (val != 0){ maybe_rect = 0; next_stage = 1; }
      } else if (x < x0 + width)
      {
        if (val != 255){ if (val != 0) maybe_rect = 0; next_stage = 1; }
      } else {
        if (val != 0){ maybe_rect = 0; next_stage = 1; }
      }
    }

    next_stage = 0;
    /* foot */
    for (; (i < count) & maybe_rect & (!next_stage); i++)
    {
      uint8_t val = (p_data[i] * data[i])/255;
      data[i] = val;

      if (val != 0){ maybe_rect = 0; next_stage = 1; }
    }


    for (; i < count; i++)
    {
      uint8_t val = (p_data[i] * data[i])/255;
      data[i] = val;
    }

    if (maybe_rect)
       rasterizer->clip_rectangle = 1;
  }
  if (!we_made_it)
   ctx_buffer_destroy (clip_buffer);
#else
  if (coords[0][0]){};
#endif
  
  gstate->clip_min_x = ctx_maxi (minx,
                                         gstate->clip_min_x);
  gstate->clip_min_y = ctx_maxi (miny,
                                         gstate->clip_min_y);
  gstate->clip_max_x = ctx_mini (maxx,
                                         gstate->clip_max_x);
  gstate->clip_max_y = ctx_mini (maxy,
                                         gstate->clip_max_y);
}


static void
_ctx_rasterizer_clip (CtxRasterizer *rasterizer)
{
  int count = rasterizer->edge_list.count;
  CtxSegment temp[count+1]; /* copy of already built up path's poly line  */
  rasterizer->state->has_clipped=1;
  rasterizer->state->gstate.clipped=1;
  //if (rasterizer->preserve)
    { memcpy (temp + 1, rasterizer->edge_list.entries, sizeof (temp) - sizeof (temp[0]));
      temp[0].code = CTX_NOP;
      temp[0].u32[0] = count;
      ctx_state_set_blob (rasterizer->state, SQZ_clip, (char*)temp, sizeof(temp));
    }
  ctx_rasterizer_clip_apply (rasterizer, temp);
  _ctx_rasterizer_reset (rasterizer);
  if (rasterizer->preserve)
    {
      memcpy (rasterizer->edge_list.entries, temp + 1, sizeof (temp) - sizeof(temp[0]));
      rasterizer->edge_list.count = count;
      rasterizer->preserve = 0;
    }
}

void
ctx_rasterizer_clip (CtxRasterizer *rasterizer)
{
  _ctx_rasterizer_clip (rasterizer);
}

#if 0
static void
ctx_rasterizer_load_image (CtxRasterizer *rasterizer,
                           const char  *path,
                           float x,
                           float y)
{
  // decode PNG, put it in image is slot 1,
  // magic width height stride format data
  ctx_buffer_load_png (&rasterizer->backend.ctx->texture[0], path);
  ctx_rasterizer_set_texture (rasterizer, 0, x, y);
}
#endif

static void
ctx_rasterizer_rectangle_reverse (CtxRasterizer *rasterizer,
                                  float x,
                                  float y,
                                  float width,
                                  float height)
{
  _ctx_rasterizer_move_to (rasterizer, x, y);
  _ctx_rasterizer_rel_line_to (rasterizer, 0, height);
  _ctx_rasterizer_rel_line_to (rasterizer, width, 0);
  _ctx_rasterizer_rel_line_to (rasterizer, 0, -height);
  _ctx_rasterizer_rel_line_to (rasterizer, -width, 0);
  _ctx_rasterizer_close_path (rasterizer);
}

static void
_ctx_rasterizer_rectangle (CtxRasterizer *rasterizer,
                          float x,
                          float y,
                          float width,
                          float height)
{
  _ctx_rasterizer_move_to (rasterizer, x, y);
  _ctx_rasterizer_rel_line_to (rasterizer, width, 0);
  _ctx_rasterizer_rel_line_to (rasterizer, 0, height);
  _ctx_rasterizer_rel_line_to (rasterizer, -width, 0);
  _ctx_rasterizer_close_path (rasterizer);
}
void
ctx_rasterizer_rectangle (CtxRasterizer *rasterizer,
                          float x,
                          float y,
                          float width,
                          float height)
{
  _ctx_rasterizer_rectangle (rasterizer, x, y, width, height);
}                          

void
ctx_rasterizer_set_pixel (CtxRasterizer *rasterizer,
                          uint16_t x,
                          uint16_t y,
                          uint8_t r,
                          uint8_t g,
                          uint8_t b,
                          uint8_t a)
{
  rasterizer->state->gstate.source_fill.type = CTX_SOURCE_COLOR;
  ctx_color_set_RGBA8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color, r, g, b, a);
  rasterizer->comp_op = NULL;
#if 0
  // XXX : doesn't take transforms into account - and has
  // received less testing than code paths part of protocol,
  // using rectangle properly will trigger the fillrect fastpath
  ctx_rasterizer_pset (rasterizer, x, y, 255);
#else
  _ctx_rasterizer_rectangle (rasterizer, x, y, 1.0f, 1.0f);
  ctx_rasterizer_fill (rasterizer);
#endif
}

static void
_ctx_rasterizer_round_rectangle (CtxRasterizer *rasterizer, float x, float y, float width, float height, float corner_radius)
{
  float aspect  = 1.0f;
  float radius  = corner_radius / aspect;
  float degrees = CTX_PI / 180.0f;

  if (radius > width*0.5f) radius = width/2;
  if (radius > height*0.5f) radius = height/2;

  _ctx_rasterizer_close_path (rasterizer);
  ctx_rasterizer_arc (rasterizer, x + width - radius, y + radius, radius, -90 * degrees, 0 * degrees, 0);
  ctx_rasterizer_arc (rasterizer, x + width - radius, y + height - radius, radius, 0 * degrees, 90 * degrees, 0);
  ctx_rasterizer_arc (rasterizer, x + radius, y + height - radius, radius, 90 * degrees, 180 * degrees, 0);
  ctx_rasterizer_arc (rasterizer, x + radius, y + radius, radius, 180 * degrees, 270 * degrees, 0);

  _ctx_rasterizer_close_path (rasterizer);
}

void
ctx_rasterizer_round_rectangle (CtxRasterizer *rasterizer, float x, float y, float width, float height, float corner_radius)
{
  _ctx_rasterizer_round_rectangle (rasterizer, x, y, width, height, corner_radius);
}


#if CTX_COMPOSITING_GROUPS
static void
ctx_rasterizer_start_group (CtxRasterizer *rasterizer) /* add a radius? */
{
  CtxEntry save_command = ctx_void(CTX_SAVE);
  // allocate buffer, and set it as temporary target
  int no;
  if (rasterizer->group[0] == NULL) // first group
  {
    rasterizer->saved_buf = rasterizer->buf;
  }
  for (no = 0; rasterizer->group[no] && no < CTX_GROUP_MAX; no++);

  if (no >= CTX_GROUP_MAX)
     return;
  rasterizer->group[no] = ctx_buffer_new (rasterizer->blit_width,
                                          rasterizer->blit_height,
                                          rasterizer->format->composite_format);
  rasterizer->buf = rasterizer->group[no]->data;
  ctx_rasterizer_process (rasterizer->backend.ctx, (CtxCommand*)&save_command);
}

static void
ctx_rasterizer_end_group (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  CtxEntry restore_command = ctx_void(CTX_RESTORE);
  CtxEntry save_command = ctx_void(CTX_SAVE);
  int no = 0;
  for (no = 0; rasterizer->group[no] && no < CTX_GROUP_MAX; no++);
  no--;

  if (no < 0)
    return;

  Ctx *ctx = rasterizer->backend.ctx;

  CtxCompositingMode comp = gstate->compositing_mode;
  CtxBlend blend = gstate->blend_mode;
  CtxExtend extend = gstate->extend;
  float global_alpha = gstate->global_alpha_f;
  // fetch compositing, blending, global alpha
  ctx_rasterizer_process (ctx, (CtxCommand*)&restore_command);
  ctx_rasterizer_process (ctx, (CtxCommand*)&save_command);
  CtxEntry set_state[4]=
  {
    ctx_u32 (CTX_COMPOSITING_MODE, comp,  0),
    ctx_u32 (CTX_BLEND_MODE,       blend, 0),
    ctx_u32 (CTX_EXTEND,          extend, 0),
    ctx_f  (CTX_GLOBAL_ALPHA,     global_alpha, 0.0)
  };
  ctx_rasterizer_process (ctx, (CtxCommand*)&set_state[0]);
  ctx_rasterizer_process (ctx, (CtxCommand*)&set_state[1]);
  ctx_rasterizer_process (ctx, (CtxCommand*)&set_state[2]);
  ctx_rasterizer_process (ctx, (CtxCommand*)&set_state[3]);
  if (no == 0)
  {
    rasterizer->buf = rasterizer->saved_buf;
  }
  else
  {
    rasterizer->buf = rasterizer->group[no-1]->data;
  }
  // XXX use texture_source ?
   ctx_texture_init (ctx, ".ctx-group", 
                  rasterizer->blit_width, 
                  rasterizer->blit_height,
                                         
                  rasterizer->blit_width * rasterizer->format->bpp/8,
                  rasterizer->format->pixel_format,
                  NULL, // space
                  (uint8_t*)rasterizer->group[no]->data,
                  NULL, NULL);
  {
     const char *eid = ".ctx-group";
     int   eid_len = ctx_strlen (eid);

     CtxEntry commands[4] =
      {
       ctx_f   (CTX_TEXTURE, rasterizer->blit_x, rasterizer->blit_y), 
       ctx_u32 (CTX_DATA, eid_len, eid_len/9+1),
       ctx_u32 (CTX_CONT, 0,0),
       ctx_u32 (CTX_CONT, 0,0)
      };
     memcpy( (char *) &commands[2].data.u8[0], eid, eid_len);
     ( (char *) (&commands[2].data.u8[0]) ) [eid_len]=0;

     ctx_rasterizer_process (ctx, (CtxCommand*)commands);
  }
  {
    CtxEntry commands[2]=
    {
      ctx_f (CTX_RECTANGLE, rasterizer->blit_x, rasterizer->blit_y),
      ctx_f (CTX_CONT,      rasterizer->blit_width, rasterizer->blit_height)
    };
    ctx_rasterizer_process (ctx, (CtxCommand*)commands);
  }
  {
    CtxEntry commands[1] = { ctx_void (CTX_FILL) };
    ctx_rasterizer_process (ctx, (CtxCommand*)commands);
  }
  //ctx_texture_release (rasterizer->backend.ctx, ".ctx-group");
  ctx_buffer_destroy (rasterizer->group[no]);
  rasterizer->group[no] = 0;
  ctx_rasterizer_process (ctx, (CtxCommand*)&restore_command);
}
#endif

#if CTX_ENABLE_SHADOW_BLUR
static void
ctx_rasterizer_shadow_stroke (CtxRasterizer *rasterizer)
{
  CtxColor color;
  CtxEntry save_command = ctx_void(CTX_SAVE);
  Ctx *ctx = rasterizer->backend.ctx;

  float rgba[4] = {0, 0, 0, 1.0};
  if (ctx_get_color (rasterizer->backend.ctx, SQZ_shadowColor, &color) == 0)
    ctx_color_get_rgba (rasterizer->state, &color, rgba);

  CtxEntry set_color_command [3]=
  {
    ctx_f (CTX_COLOR, CTX_RGBA, rgba[0]),
    ctx_f (CTX_CONT, rgba[1], rgba[2]),
    ctx_f (CTX_CONT, rgba[3], 0.0f)
  };
  CtxEntry restore_command = ctx_void(CTX_RESTORE);
  ctx_rasterizer_process (ctx, (CtxCommand*)&save_command);
    ctx_rasterizer_process (ctx, (CtxCommand*)&set_color_command[0]);
    rasterizer->in_shadow = 1;
  {
  float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
  rasterizer->feather_x = rasterizer->state->gstate.shadow_offset_x * factor;
  rasterizer->feather_y = rasterizer->state->gstate.shadow_offset_y * factor;
  rasterizer->feather   = rasterizer->state->gstate.shadow_blur * factor;
  }
    rasterizer->preserve = 1;
    ctx_rasterizer_stroke (rasterizer);
    rasterizer->in_shadow = 0;
  ctx_rasterizer_process (ctx, (CtxCommand*)&restore_command);
}

static void
ctx_rasterizer_shadow_text (CtxRasterizer *rasterizer, const char *str)
{
  float x = rasterizer->state->x;
  float y = rasterizer->state->y;
  CtxColor color;
  CtxEntry save_command = ctx_void(CTX_SAVE);
  Ctx *ctx = rasterizer->backend.ctx;

  float rgba[4] = {0, 0, 0, 1.0};
  if (ctx_get_color (rasterizer->backend.ctx, SQZ_shadowColor, &color) == 0)
    ctx_color_get_rgba (rasterizer->state, &color, rgba);

  CtxEntry set_color_command [3]=
  {
    ctx_f (CTX_COLOR, CTX_RGBA, rgba[0]),
    ctx_f (CTX_CONT, rgba[1], rgba[2]),
    ctx_f (CTX_CONT, rgba[3], 0)
  };
  CtxEntry move_to_command [1]=
  {
    ctx_f (CTX_MOVE_TO, x, y),
  };
  CtxEntry restore_command = ctx_void(CTX_RESTORE);
  ctx_rasterizer_process (ctx, (CtxCommand*)&save_command);

  {
      {
        move_to_command[0].data.f[0] = x;
        move_to_command[0].data.f[1] = y;
        set_color_command[2].data.f[0] = rgba[3];
        ctx_rasterizer_process (ctx, (CtxCommand*)&set_color_command);
        ctx_rasterizer_process (ctx, (CtxCommand*)&move_to_command);
        rasterizer->in_shadow=1;
  {
  float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
  rasterizer->feather_x = rasterizer->state->gstate.shadow_offset_x * factor;
  rasterizer->feather_y = rasterizer->state->gstate.shadow_offset_y * factor;
  rasterizer->feather   = rasterizer->state->gstate.shadow_blur * factor;
  }
        ctx_rasterizer_text (rasterizer, str, 0);
        rasterizer->in_shadow=0;
      }
  }
  ctx_rasterizer_process (ctx, (CtxCommand*)&restore_command);
  move_to_command[0].data.f[0] = x;
  move_to_command[0].data.f[1] = y;
  ctx_rasterizer_process (ctx, (CtxCommand*)&move_to_command);
}

static void
ctx_rasterizer_shadow_fill (CtxRasterizer *rasterizer)
{
  CtxColor color;
  Ctx *ctx = rasterizer->backend.ctx;
  CtxEntry save_command = ctx_void(CTX_SAVE);

  float rgba[4] = {0, 0, 0, 1.0};
  if (ctx_get_color (rasterizer->backend.ctx, SQZ_shadowColor, &color) == 0)
    ctx_color_get_rgba (rasterizer->state, &color, rgba);

  CtxEntry set_color_command [3]=
  {
    ctx_f (CTX_COLOR, CTX_RGBA, rgba[0]),
    ctx_f (CTX_CONT, rgba[1], rgba[2]),
    ctx_f (CTX_CONT, rgba[3], 1.0f)
  };
  CtxEntry restore_command = ctx_void(CTX_RESTORE);
  ctx_rasterizer_process (ctx, (CtxCommand*)&save_command);

  ctx_rasterizer_process (ctx, (CtxCommand*)&set_color_command);
  rasterizer->preserve = 1;
  rasterizer->in_shadow = 1;
  {
  float factor = ctx_matrix_get_scale (&rasterizer->state->gstate.transform);
  if (rasterizer->in_text)
    factor /= rasterizer->state->gstate.font_size / CTX_BAKE_FONT_SIZE;
  rasterizer->feather_x = rasterizer->state->gstate.shadow_offset_x * factor;
  rasterizer->feather_y = rasterizer->state->gstate.shadow_offset_y * factor;
  rasterizer->feather   = rasterizer->state->gstate.shadow_blur * factor;
  }
  ctx_rasterizer_fill (rasterizer);
  ctx_rasterizer_reset_soft (rasterizer);
  if (!rasterizer->in_text)
    rasterizer->in_shadow = 0;
  ctx_rasterizer_process (ctx, (CtxCommand*)&restore_command);
}
#endif

static void
ctx_rasterizer_line_dash (CtxRasterizer *rasterizer, unsigned int count, const float *dashes)
{
  if (!dashes)
  {
    rasterizer->state->gstate.n_dashes = 0;
    return;
  }
  count = CTX_MIN(count, CTX_MAX_DASHES);
  rasterizer->state->gstate.n_dashes = count;
  memcpy(&rasterizer->state->gstate.dashes[0], dashes, count * sizeof(float));
  for (unsigned int i = 0; i < count; i ++)
  {
    if (rasterizer->state->gstate.dashes[i] < 0.0001f)
      rasterizer->state->gstate.dashes[i] = 0.0001f; // hang protection
  }
}


void
ctx_rasterizer_process (Ctx *ctx, const CtxCommand *c)
{
  const CtxEntry *entry      = &c->entry;
  CtxRasterizer  *rasterizer = (CtxRasterizer *) ctx->backend;
  CtxState       *state      = rasterizer->state;
  int             clear_clip = 0;

  switch (c->code)
    {
      case CTX_LINE_HEIGHT:
      case CTX_WRAP_LEFT:
      case CTX_WRAP_RIGHT:
      case CTX_LINE_DASH_OFFSET:
      case CTX_STROKE_POS:
      case CTX_FEATHER:
      case CTX_LINE_WIDTH:
      case CTX_SHADOW_BLUR:
      case CTX_SHADOW_OFFSET_X:
      case CTX_SHADOW_OFFSET_Y:
      case CTX_LINE_CAP:
      case CTX_FILL_RULE:
      case CTX_LINE_JOIN:
      case CTX_TEXT_ALIGN:
      case CTX_TEXT_BASELINE:
      case CTX_TEXT_DIRECTION:
      case CTX_GLOBAL_ALPHA:
      case CTX_FONT_SIZE:
      case CTX_MITER_LIMIT:
      case CTX_COLOR_SPACE:
      case CTX_STROKE_SOURCE:
        ctx_interpret_style (state, entry, NULL);
        break;
#if CTX_ENABLE_SHADOW_BLUR
      case CTX_SHADOW_COLOR:
        {
          CtxColor  col;
          CtxColor *color = &col;
          //state->gstate.source_fill.type = CTX_SOURCE_COLOR;
          switch ((int)c->rgba.model)
            {
              case CTX_RGB:
                ctx_color_set_rgba (state, color, c->rgba.r, c->rgba.g, c->rgba.b, 1.0f);
                break;
              case CTX_RGBA:
                //ctx_color_set_rgba (state, color, c->rgba.r, c->rgba.g, c->rgba.b, c->rgba.a);
                ctx_color_set_rgba (state, color, c->rgba.r, c->rgba.g, c->rgba.b, c->rgba.a);
                break;
              case CTX_DRGBA:
                ctx_color_set_drgba (state, color, c->rgba.r, c->rgba.g, c->rgba.b, c->rgba.a);
                break;
#if CTX_ENABLE_CMYK
              case CTX_CMYKA:
                ctx_color_set_cmyka (state, color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, c->cmyka.a);
                break;
              case CTX_CMYK:
                ctx_color_set_cmyka (state, color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, 1.0f);
                break;
              case CTX_DCMYKA:
                ctx_color_set_dcmyka (state, color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, c->cmyka.a);
                break;
              case CTX_DCMYK:
                ctx_color_set_dcmyka (state, color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, 1.0f);
                break;
#endif
              case CTX_GRAYA:
                ctx_color_set_graya (state, color, c->graya.g, c->graya.a);
                break;
              case CTX_GRAY:
                ctx_color_set_graya (state, color, c->graya.g, 1.0f);
                break;
            }
          ctx_set_color (rasterizer->backend.ctx, SQZ_shadowColor, color);
        }
        break;
#endif
      case CTX_LINE_DASH:
        if (c->line_dash.count)
          {
            ctx_rasterizer_line_dash (rasterizer, c->line_dash.count, c->line_dash.data);
          }
        else
        ctx_rasterizer_line_dash (rasterizer, 0, NULL);
        break;


      case CTX_LINE_TO:
        if (ctx->bail) break;
        _ctx_rasterizer_line_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_REL_LINE_TO:
        if (ctx->bail) break;
        _ctx_rasterizer_rel_line_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_MOVE_TO:
        if (ctx->bail) break;
        _ctx_rasterizer_move_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_REL_MOVE_TO:
        if (ctx->bail) break;
        _ctx_rasterizer_rel_move_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_CURVE_TO:
        if (ctx->bail) break;
        _ctx_rasterizer_curve_to (rasterizer, c->c.x0, c->c.y0,
                                  c->c.x1, c->c.y1,
                                  c->c.x2, c->c.y2);
        break;
      case CTX_REL_CURVE_TO:
        if (ctx->bail) break;
        _ctx_rasterizer_rel_curve_to (rasterizer, c->c.x0, c->c.y0,
                                      c->c.x1, c->c.y1,
                                      c->c.x2, c->c.y2);
        break;
      case CTX_QUAD_TO:
        if (ctx->bail) break;
        ctx_rasterizer_quad_to (rasterizer, c->c.x0, c->c.y0, c->c.x1, c->c.y1);
        break;
      case CTX_REL_QUAD_TO:
        if (ctx->bail) break;
        ctx_rasterizer_rel_quad_to (rasterizer, c->c.x0, c->c.y0, c->c.x1, c->c.y1);
        break;
      case CTX_ARC:
        if (ctx->bail) break;
        ctx_rasterizer_arc (rasterizer, c->arc.x, c->arc.y, c->arc.radius, c->arc.angle1, c->arc.angle2, (int)c->arc.direction);
        break;
      case CTX_RECTANGLE:
        if (ctx->bail) break;
        _ctx_rasterizer_rectangle (rasterizer, c->rectangle.x, c->rectangle.y,
                                   c->rectangle.width, c->rectangle.height);
        break;
      case CTX_ROUND_RECTANGLE:
        if (ctx->bail) break;
        ctx_rasterizer_round_rectangle (rasterizer, c->rectangle.x, c->rectangle.y,
                                        c->rectangle.width, c->rectangle.height,
                                        c->rectangle.radius);
        break;
      case CTX_SET_PIXEL:
        ctx_rasterizer_set_pixel (rasterizer, c->set_pixel.x, c->set_pixel.y,
                                  c->set_pixel.rgba[0],
                                  c->set_pixel.rgba[1],
                                  c->set_pixel.rgba[2],
                                  c->set_pixel.rgba[3]);
        break;
      case CTX_DEFINE_TEXTURE:
        {
          uint8_t *pixel_data = ctx_define_texture_pixel_data (entry);

          ctx_rasterizer_define_texture (rasterizer, c->define_texture.eid,
                                         c->define_texture.width, c->define_texture.height,
                                         c->define_texture.format,
                                         pixel_data, 0);
          rasterizer->comp_op = NULL;
          rasterizer->fragment = NULL;
        }
        break;
      case CTX_TEXTURE:
        ctx_rasterizer_set_texture (rasterizer, c->texture.eid,
                                    c->texture.x, c->texture.y);
        rasterizer->comp_op = NULL;
        rasterizer->fragment = NULL;
        break;
      case CTX_SOURCE_TRANSFORM:
        ctx_matrix_set (&state->gstate.source_fill.set_transform,
                        ctx_arg_float (0), ctx_arg_float (1),
                        ctx_arg_float (2), ctx_arg_float (3),
                        ctx_arg_float (4), ctx_arg_float (5),
                        ctx_arg_float (6), ctx_arg_float (7),
                        ctx_arg_float (8));
        rasterizer->comp_op = NULL;
        break;
#if 0
      case CTX_LOAD_IMAGE:
        ctx_rasterizer_load_image (rasterizer, ctx_arg_string(),
                                   ctx_arg_float (0), ctx_arg_float (1) );
        break;
#endif
#if CTX_GRADIENTS
      case CTX_GRADIENT_STOP:
        {
          float rgba[4]= {ctx_u8_to_float (ctx_arg_u8 (4) ),
                          ctx_u8_to_float (ctx_arg_u8 (4+1) ),
                          ctx_u8_to_float (ctx_arg_u8 (4+2) ),
                          ctx_u8_to_float (ctx_arg_u8 (4+3) )
                         };
          ctx_rasterizer_gradient_add_stop (rasterizer,
                                            ctx_arg_float (0), rgba);
          rasterizer->comp_op = NULL;
        }
        break;
      case CTX_CONIC_GRADIENT:
      case CTX_LINEAR_GRADIENT:
      case CTX_RADIAL_GRADIENT:
        ctx_interpret_style (state, entry, NULL);
        ctx_state_gradient_clear_stops (state);
#if CTX_GRADIENT_CACHE
        rasterizer->gradient_cache_valid = 0;
#endif
        rasterizer->comp_op = NULL;
        break;
#endif
      case CTX_PRESERVE:
        rasterizer->preserve = 1;
        break;
      case CTX_COLOR:
      case CTX_COMPOSITING_MODE:
      case CTX_BLEND_MODE:
      case CTX_EXTEND:
      case CTX_SET_RGBA_U8:
        ctx_interpret_style (state, entry, NULL);
        rasterizer->comp_op = NULL;
        break;
#if CTX_COMPOSITING_GROUPS
      case CTX_START_GROUP:
        ctx_rasterizer_start_group (rasterizer);
        break;
      case CTX_END_GROUP:
        ctx_rasterizer_end_group (rasterizer);
        break;
#endif

      case CTX_RESTORE:
        for (unsigned int i = state->gstate_no?state->gstate_stack[state->gstate_no-1].keydb_pos:0;
             i < state->gstate.keydb_pos; i++)
        {
          if (state->keydb[i].key == SQZ_clip)
          {
            clear_clip = 1;
          }
        }
        /* FALLTHROUGH */
      case CTX_ROTATE:
      case CTX_SCALE:
      case CTX_APPLY_TRANSFORM:
      case CTX_TRANSLATE:
      case CTX_IDENTITY:
        /* FALLTHROUGH */
      case CTX_SAVE:
        rasterizer->comp_op = NULL;
        ctx_interpret_transforms (state, entry, NULL);
        if (clear_clip)
        {
          ctx_rasterizer_clip_reset (rasterizer);
          for (unsigned int i = state->gstate_no?state->gstate_stack[state->gstate_no-1].keydb_pos:0;
             i < state->gstate.keydb_pos; i++)
        {
          if (state->keydb[i].key == SQZ_clip)
          {
            int idx = ctx_float_to_string_index (state->keydb[i].value);
            if (idx >=0)
            {
              CtxSegment *edges = (CtxSegment*)&state->stringpool[idx];
              ctx_rasterizer_clip_apply (rasterizer, edges);
            }
          }
        }
        }
        break;
      case CTX_STROKE:
          if (rasterizer->edge_list.count == 0)break;
#if CTX_ENABLE_SHADOW_BLUR
        if ((state->gstate.shadow_blur > 0.0f) & (!rasterizer->in_text))
          ctx_rasterizer_shadow_stroke (rasterizer);
#endif
        {
        int count = rasterizer->edge_list.count;
        if (state->gstate.n_dashes)
        {
          int n_dashes = state->gstate.n_dashes;
          float *dashes = state->gstate.dashes;
          float factor = ctx_matrix_get_scale (&state->gstate.transform);

          CtxSegment temp[count]; /* copy of already built up path's poly line  */
          memcpy (temp, rasterizer->edge_list.entries, sizeof (temp));
          int start = 0;
          int end   = 0;
      CtxMatrix transform_backup = state->gstate.transform;
      _ctx_matrix_identity (&state->gstate.transform);
      _ctx_transform_prime (state);
      _ctx_rasterizer_reset (rasterizer); /* for dashing we create
                                            a dashed path to stroke */
      float prev_x = 0.0f;
      float prev_y = 0.0f;
      //float pos = 0.0;

      int   dash_no  = 0.0;
      float dash_lpos = state->gstate.line_dash_offset * factor;
      int   is_down = 0;
      float lr = state->gstate.line_width * factor / 2;

          while (start < count)
          {
            int started = 0;
            int i;
            is_down = 0;

            if (!is_down)
            {
              CtxSegment *segment = &temp[0];
              prev_x = segment->x0 * 1.0f / CTX_SUBDIV;
              prev_y = segment->y0 * 1.0f / CTX_FULL_AA;
              ctx_rasterizer_move_to (rasterizer, prev_x, prev_y);
              is_down = 1;
            }

            for (i = start; i < count; i++)
            {
              CtxSegment *segment = &temp[i];
              float x, y;
              if (segment->code == CTX_NEW_EDGE)
                {
                  if (started)
                    {
                      end = i - 1;
                      dash_no = 0;
                      dash_lpos = 0.0;
                      goto foo;
                    }
                  prev_x = segment->x0 * 1.0f / CTX_SUBDIV;
                  prev_y = segment->y0 * 1.0f / CTX_FULL_AA;
                  started = 1;
                  start = i;
                  is_down = 1;
                  ctx_rasterizer_move_to (rasterizer, prev_x, prev_y);
                }
   int max_again = 40;
again:
   max_again--;
              x = segment->x1 * 1.0f / CTX_SUBDIV;
              y = segment->y1 * 1.0f / CTX_FULL_AA;
              float dx = x - prev_x;
              float dy = y - prev_y;
              float length = ctx_hypotf (dx, dy);

              if (dash_lpos + length >= dashes[dash_no] * factor)
              {
                float p = (dashes[dash_no] * factor - dash_lpos) / length;
                float splitx = x * p + (1.0f - p) * prev_x;
                float splity = y * p + (1.0f - p) * prev_y;

                /* TODO : check for intersection rather than just end points being in raster-rect */
                if ( ((splitx - lr >= rasterizer->blit_x) &
                      (prev_x - lr >= rasterizer->blit_x) &
                      (splity - lr >= rasterizer->blit_y) &
                      (prev_y - lr >= rasterizer->blit_y)) |

                     ((splitx + lr < rasterizer->blit_x + rasterizer->blit_width) &
                      (prev_x + lr < rasterizer->blit_x + rasterizer->blit_width) &
                      (splity + lr < rasterizer->blit_y + rasterizer->blit_height) &
                      (prev_y + lr < rasterizer->blit_y + rasterizer->blit_height)))
                {
                  if (is_down)
                  {
                    ctx_rasterizer_line_to (rasterizer, splitx, splity);
                    is_down = 0;
                  }
                  else
                  {
                    _ctx_rasterizer_move_to (rasterizer, splitx, splity);
                    is_down = 1;
                  }
                }
                prev_x = splitx;
                prev_y = splity;
                dash_no++;
                dash_lpos=0;
                if (dash_no >= n_dashes) dash_no = 0;
                if (max_again > 0)
                  goto again;
              }
              else
              {
                //pos += length;
                dash_lpos += length;
                {
                  if (is_down)
                    ctx_rasterizer_line_to (rasterizer, x, y);
                }
              }
              prev_x = x;
              prev_y = y;
            }
          end = i-1;
foo:
          start = end+1;
        }
        state->gstate.transform = transform_backup;
        _ctx_transform_prime (state);
        }
        ctx_rasterizer_stroke (rasterizer);
        }
        _ctx_rasterizer_reset (rasterizer);

        break;
      case CTX_FONT:
        ctx_interpret_style (state, entry, NULL);
        ctx_rasterizer_set_font (rasterizer, ctx_arg_string() );
        break;
      case CTX_TEXT:
        if (ctx->bail)
        {
          _ctx_text (rasterizer->backend.ctx, ctx_arg_string(), 0, 0);
          break;
        }

        rasterizer->in_text++;
#if CTX_ENABLE_SHADOW_BLUR
        if (state->gstate.shadow_blur > 0.0)
          ctx_rasterizer_shadow_text (rasterizer, ctx_arg_string ());
#endif
        ctx_rasterizer_text (rasterizer, ctx_arg_string(), 0);
        rasterizer->in_text--;
        _ctx_rasterizer_reset (rasterizer);
#if CONFIG_IDF_TARGET_ESP32C3
        taskYIELD();
#endif
        break;
      case CTX_GLYPH:
        if (ctx->bail) break;
        {
        uint32_t unichar = entry[0].data.u32[0];
        uint32_t stroke = unichar &  ((uint32_t)1<<31);
        if (stroke) unichar -= stroke;
        ctx_rasterizer_glyph (rasterizer, entry[0].data.u32[0], stroke);
        }
#if CONFIG_IDF_TARGET_ESP32C3
        taskYIELD();
#endif
        break;
      case CTX_PAINT:
        // XXX simplify this with a special case
        _ctx_rasterizer_rectangle (rasterizer, -1000.0, -1000.0, 11000, 11000);
        ctx_rasterizer_fill (rasterizer);
        _ctx_rasterizer_reset (rasterizer);
#if CONFIG_IDF_TARGET_ESP32C3
        taskYIELD();
#endif
        break;
      case CTX_FILL:
        if (!ctx->bail)
        {
          if (rasterizer->edge_list.count == 0)break;
          int preserve = rasterizer->preserve;
#if CTX_ENABLE_SHADOW_BLUR
        if ((state->gstate.shadow_blur > 0.0f) & (!rasterizer->in_text) & (!rasterizer->in_shadow))
        {
          ctx_rasterizer_shadow_fill (rasterizer);
        }
#endif
        ctx_rasterizer_fill (rasterizer);
        if (preserve)
          ctx_rasterizer_reset_soft (rasterizer);
        else
          _ctx_rasterizer_reset (rasterizer);
#if CONFIG_IDF_TARGET_ESP32C3
        taskYIELD();
#endif
        }
        break;
      case CTX_START_FRAME:
      case CTX_RESET_PATH:
        _ctx_rasterizer_reset (rasterizer);
        break;
      case CTX_CLIP:
        _ctx_rasterizer_clip (rasterizer);
#if CONFIG_IDF_TARGET_ESP32C3
        taskYIELD();
#endif
        break;
      case CTX_CLOSE_PATH:
        _ctx_rasterizer_close_path (rasterizer);
        break;
      case CTX_IMAGE_SMOOTHING:
        ctx_interpret_style (state, entry, NULL);
        rasterizer->comp_op = NULL;
        break;
      case CTX_VIEW_BOX:
        { // XXX : this can screw with transforms if one is not careful
           float x = ctx_arg_float(0),
                       y = ctx_arg_float(1),
                       width = ctx_arg_float(2),
                       height = ctx_arg_float(3);
           float factor = ctx_width (ctx)/width;
           float factorh = ctx_height (ctx)/height;

           if (factorh <= factor) factor = factorh;

           ctx_translate (ctx, -x, -y);
           ctx_scale (ctx, factor, factor);
        }
        break;
    }
  ctx_interpret_pos_bare (state, entry, NULL);
}


//static CtxFont *ctx_fonts;
void
ctx_rasterizer_deinit (CtxRasterizer *rasterizer)
{
  //rasterizer->fonts = ctx_fonts;
  ctx_drawlist_deinit (&rasterizer->edge_list);
#if CTX_ENABLE_CLIP
  if (rasterizer->clip_buffer)
  {
    ctx_buffer_destroy (rasterizer->clip_buffer);
    rasterizer->clip_buffer = NULL;
  }
#endif
}

void
ctx_rasterizer_destroy (void *r)
{
  CtxRasterizer *rasterizer = (CtxRasterizer*)r;
  ctx_rasterizer_deinit (rasterizer);
  ctx_free (rasterizer);
}

CtxAntialias ctx_get_antialias (Ctx *ctx)
{
  if (ctx_backend_type (ctx) != CTX_BACKEND_RASTERIZER) return CTX_ANTIALIAS_DEFAULT;

  switch (((CtxRasterizer*)(ctx->backend))->aa)
  {
    case 0: 
    case 1:
        return CTX_ANTIALIAS_NONE;
    case 3:
        return CTX_ANTIALIAS_FAST;
    case 5:
        return CTX_ANTIALIAS_GOOD;
    default:
    case 15:
        return CTX_ANTIALIAS_FULL;
  }
}

static int _ctx_antialias_to_aa (CtxAntialias antialias)
{
  switch (antialias)
  {
    case CTX_ANTIALIAS_NONE: return 1;
    case CTX_ANTIALIAS_FAST: return 3;
    case CTX_ANTIALIAS_GOOD: return 5;
    case CTX_ANTIALIAS_FULL: return 15;
    default:
    case CTX_ANTIALIAS_DEFAULT: return CTX_RASTERIZER_AA;
  }
}

void
ctx_set_antialias (Ctx *ctx, CtxAntialias antialias)
{
  if (ctx_backend_type (ctx) != CTX_BACKEND_RASTERIZER) return;

  ((CtxRasterizer*)(ctx->backend))->aa = 
     _ctx_antialias_to_aa (antialias);
}

CtxRasterizer *
ctx_rasterizer_init (CtxRasterizer *rasterizer, Ctx *ctx, Ctx *texture_source, CtxState *state, void *data, int x, int y, int width, int height, int stride, CtxPixelFormat pixel_format, CtxAntialias antialias)
{
#if CTX_ENABLE_CLIP
  if (rasterizer->clip_buffer)
    ctx_buffer_destroy (rasterizer->clip_buffer);
#endif
  if (rasterizer->edge_list.size)
    ctx_drawlist_deinit (&rasterizer->edge_list);
  memset (rasterizer, 0, sizeof (CtxRasterizer));
  CtxBackend *backend = (CtxBackend*)rasterizer;
  backend->type = CTX_BACKEND_RASTERIZER;
  backend->process = ctx_rasterizer_process;
  backend->destroy = (CtxDestroyNotify)ctx_rasterizer_destroy;
  backend->ctx     = ctx;
  rasterizer->edge_list.flags |= CTX_DRAWLIST_EDGE_LIST;
  rasterizer->state       = state;
  rasterizer->texture_source = texture_source?texture_source:ctx;

  ctx_state_init (rasterizer->state);
  rasterizer->buf         = data;
  rasterizer->blit_x      = x;
  rasterizer->blit_y      = y;
  rasterizer->blit_width  = width;
  rasterizer->blit_height = height;
  rasterizer->state->gstate.clip_min_x  = x;
  rasterizer->state->gstate.clip_min_y  = y;
  rasterizer->state->gstate.clip_max_x  = x + width - 1;
  rasterizer->state->gstate.clip_max_y  = y + height - 1;
  rasterizer->blit_stride = stride;
  rasterizer->scan_min    = 5000;
  rasterizer->scan_max    = -5000;

  if (pixel_format == CTX_FORMAT_BGRA8)
  {
    pixel_format = CTX_FORMAT_RGBA8;
    rasterizer->swap_red_green = 1;
  }
  else if (pixel_format == CTX_FORMAT_BGR8)
  {
    pixel_format = CTX_FORMAT_RGB8;
    rasterizer->swap_red_green = 1;
  }

  rasterizer->format = ctx_pixel_format_info (pixel_format);

#if CTX_GRADIENTS
#if CTX_GRADIENT_CACHE
  rasterizer->gradient_cache_elements = CTX_GRADIENT_CACHE_ELEMENTS;
  rasterizer->gradient_cache_valid = 0;
#endif
#endif

#if static_OPAQUE
  memset (rasterizer->opaque, 255, sizeof (rasterizer->opaque));
#endif

  return rasterizer;
}

void
ctx_rasterizer_reinit (Ctx *ctx,
                       void *fb,
                       int x,
                       int y,
                       int width,
                       int height,
                       int stride,
                       CtxPixelFormat pixel_format)
{
  CtxBackend *backend = (CtxBackend*)ctx_get_backend (ctx);
  CtxRasterizer *rasterizer = (CtxRasterizer*)backend;
  if (!backend) return;
#if 0
  // this is a more proper reinit than the below, which should be a lot faster..
  ctx_rasterizer_init (rasterizer, ctx, rasterizer->texture_source, &ctx->state, fb, x, y, width, height, stride, pixel_format, CTX_ANTIALIAS_DEFAULT);
#else

  ctx_state_init (rasterizer->state);
  rasterizer->buf         = fb;
  rasterizer->blit_x      = x;
  rasterizer->blit_y      = y;
  rasterizer->blit_width  = width;
  rasterizer->blit_height = height;
  rasterizer->state->gstate.clip_min_x  = x;
  rasterizer->state->gstate.clip_min_y  = y;
  rasterizer->state->gstate.clip_max_x  = x + width - 1;
  rasterizer->state->gstate.clip_max_y  = y + height - 1;
  rasterizer->blit_stride = stride;
  rasterizer->scan_min    = 5000;
  rasterizer->scan_max    = -5000;
#if CTX_GRADIENT_CACHE
  rasterizer->gradient_cache_valid = 0;
#endif

  if (pixel_format == CTX_FORMAT_BGRA8)
  {
    pixel_format = CTX_FORMAT_RGBA8;
    rasterizer->swap_red_green = 1;
  }
  else if (pixel_format == CTX_FORMAT_BGR8)
  {
    pixel_format = CTX_FORMAT_RGB8;
    rasterizer->swap_red_green = 1;
  }

  rasterizer->format = ctx_pixel_format_info (pixel_format);
#endif
}

Ctx *
ctx_new_for_buffer (CtxBuffer *buffer)
{
  Ctx *ctx = ctx_new_drawlist (buffer->width, buffer->height);
  ctx_set_backend (ctx,
                    ctx_rasterizer_init ( (CtxRasterizer *) ctx_calloc (1, sizeof (CtxRasterizer)),
                                          ctx, NULL, &ctx->state,
                                          buffer->data, 0, 0, buffer->width, buffer->height,
                                          buffer->stride, buffer->format->pixel_format,
                                          CTX_ANTIALIAS_DEFAULT));
  return ctx;
}


Ctx *
ctx_new_for_framebuffer (void *data, int width, int height,
                         int stride,
                         CtxPixelFormat pixel_format)
{
  Ctx *ctx = ctx_new_drawlist (width, height);
  CtxRasterizer *r = ctx_rasterizer_init ( (CtxRasterizer *) ctx_calloc (1, sizeof (CtxRasterizer)),
                                          ctx, NULL, &ctx->state, data, 0, 0, width, height,
                                          stride, pixel_format, CTX_ANTIALIAS_DEFAULT);
  ctx_set_backend (ctx, r);
  if (pixel_format == CTX_FORMAT_GRAY1) // XXX we get some bugs without it..
  {                                     //     something is going amiss with offsets
    ctx_set_antialias (ctx, CTX_ANTIALIAS_NONE);
  }
  return ctx;
}

// ctx_new_for_stream (FILE *stream);

#if 0
CtxRasterizer *ctx_rasterizer_new (void *data, int x, int y, int width, int height,
                                   int stride, CtxPixelFormat pixel_format)
{
  CtxState    *state    = (CtxState *) ctx_malloc (sizeof (CtxState) );
  CtxRasterizer *rasterizer = (CtxRasterizer *) ctx_malloc (sizeof (CtxBackend) );
  ctx_rasterizer_init (rasterizer, state, data, x, y, width, height,
                       stride, pixel_format, CTX_ANTIALIAS_DEFAULT);
}
#endif

#else

#endif


static void
ctx_state_gradient_clear_stops (CtxState *state)
{
  state->gradient.n_stops = 0;
}


#ifndef __clang__
#if CTX_RASTERIZER_O3
#pragma GCC pop_options
#endif
#if CTX_RASTERIZER_O2
#pragma GCC pop_options
#endif
#endif

void
ctx_rasterizer_reset (CtxRasterizer *rasterizer)
{
  _ctx_rasterizer_reset (rasterizer);
}

#endif

#if CTX_IMPLEMENTATION



/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API's */

mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
{
    mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
    size_t block_len = buf_len % 5552;
    if (!ptr)
        return MZ_ADLER32_INIT;
    while (buf_len)
    {
        for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
        {
            s1 += ptr[0], s2 += s1;
            s1 += ptr[1], s2 += s1;
            s1 += ptr[2], s2 += s1;
            s1 += ptr[3], s2 += s1;
            s1 += ptr[4], s2 += s1;
            s1 += ptr[5], s2 += s1;
            s1 += ptr[6], s2 += s1;
            s1 += ptr[7], s2 += s1;
        }
        for (; i < block_len; ++i)
            s1 += *ptr++, s2 += s1;
        s1 %= 65521U, s2 %= 65521U;
        buf_len -= block_len;
        block_len = 5552;
    }
    return (s2 << 16) + s1;
}

/* Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/ */
#if 0
    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
    {
        static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
                                               0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
        mz_uint32 crcu32 = (mz_uint32)crc;
        if (!ptr)
            return MZ_CRC32_INIT;
        crcu32 = ~crcu32;
        while (buf_len--)
        {
            mz_uint8 b = *ptr++;
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
        }
        return ~crcu32;
    }
#elif defined(USE_EXTERNAL_MZCRC)
/* If USE_EXTERNAL_CRC is defined, an external module will export the
 * mz_crc32() symbol for us to use, e.g. an SSE-accelerated version.
 * Depending on the impl, it may be necessary to ~ the input/output crc values.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len);
#else
/* Faster, but larger CPU cache footprint.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
{
    static const mz_uint32 s_crc_table[256] =
        {
          0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535,
          0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD,
          0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D,
          0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
          0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
          0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
          0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC,
          0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
          0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
          0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
          0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB,
          0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
          0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA,
          0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
          0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
          0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
          0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409,
          0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
          0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739,
          0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
          0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268,
          0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
          0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8,
          0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
          0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
          0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
          0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
          0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
          0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE,
          0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
          0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6,
          0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
          0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D,
          0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
          0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
          0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
          0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
        };

    mz_uint32 crc32 = (mz_uint32)crc ^ 0xFFFFFFFF;
    const mz_uint8 *pByte_buf = (const mz_uint8 *)ptr;

    while (buf_len >= 4)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[1]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[2]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[3]) & 0xFF];
        pByte_buf += 4;
        buf_len -= 4;
    }

    while (buf_len)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        ++pByte_buf;
        --buf_len;
    }

    return ~crc32;
}
#endif

void mz_free(void *p)
{
    MZ_FREE(p);
}

MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size)
{
    (void)opaque, (void)items, (void)size;
    return MZ_MALLOC(items * size);
}
MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address)
{
    (void)opaque, (void)address;
    MZ_FREE(address);
}
MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size)
{
    (void)opaque, (void)address, (void)items, (void)size;
    return MZ_REALLOC(address, items * size);
}

const char *mz_version(void)
{
    return MZ_VERSION;
}

#ifndef MINIZ_NO_ZLIB_APIS

#ifndef MINIZ_NO_DEFLATE_APIS

int mz_deflateInit(mz_streamp pStream, int level)
{
    return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
}

int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
{
    tdefl_compressor *pComp;
    mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

    if (!pStream)
        return MZ_STREAM_ERROR;
    if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
        return MZ_PARAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = MZ_ADLER32_INIT;
    pStream->msg = NULL;
    pStream->reserved = 0;
    pStream->total_in = 0;
    pStream->total_out = 0;
    if (!pStream->zalloc)
        pStream->zalloc = miniz_def_alloc_func;
    if (!pStream->zfree)
        pStream->zfree = miniz_def_free_func;

    pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
    if (!pComp)
        return MZ_MEM_ERROR;

    pStream->state = (struct mz_internal_state *)pComp;

    if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
    {
        mz_deflateEnd(pStream);
        return MZ_PARAM_ERROR;
    }

    return MZ_OK;
}

int mz_deflateReset(mz_streamp pStream)
{
    if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree))
        return MZ_STREAM_ERROR;
    pStream->total_in = pStream->total_out = 0;
    tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags);
    return MZ_OK;
}

int mz_deflate(mz_streamp pStream, int flush)
{
    size_t in_bytes, out_bytes;
    mz_ulong orig_total_in, orig_total_out;
    int mz_status = MZ_OK;

    if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))
        return MZ_STREAM_ERROR;
    if (!pStream->avail_out)
        return MZ_BUF_ERROR;

    if (flush == MZ_PARTIAL_FLUSH)
        flush = MZ_SYNC_FLUSH;

    if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
        return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

    orig_total_in = pStream->total_in;
    orig_total_out = pStream->total_out;
    for (;;)
    {
        tdefl_status defl_status;
        in_bytes = pStream->avail_in;
        out_bytes = pStream->avail_out;

        defl_status = tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);

        pStream->next_out += (mz_uint)out_bytes;
        pStream->avail_out -= (mz_uint)out_bytes;
        pStream->total_out += (mz_uint)out_bytes;

        if (defl_status < 0)
        {
            mz_status = MZ_STREAM_ERROR;
            break;
        }
        else if (defl_status == TDEFL_STATUS_DONE)
        {
            mz_status = MZ_STREAM_END;
            break;
        }
        else if (!pStream->avail_out)
            break;
        else if ((!pStream->avail_in) && (flush != MZ_FINISH))
        {
            if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
                break;
            return MZ_BUF_ERROR; /* Can't make forward progress without some input.
 */
        }
    }
    return mz_status;
}

int mz_deflateEnd(mz_streamp pStream)
{
    if (!pStream)
        return MZ_STREAM_ERROR;
    if (pStream->state)
    {
        pStream->zfree(pStream->opaque, pStream->state);
        pStream->state = NULL;
    }
    return MZ_OK;
}

mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
{
    (void)pStream;
    /* This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) */
    return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
}

int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
{
    int status;
    mz_stream stream;
    memset(&stream, 0, sizeof(stream));

    /* In case mz_ulong is 64-bits (argh I hate longs). */
    if ((mz_uint64)(source_len | *pDest_len) > 0xFFFFFFFFU)
        return MZ_PARAM_ERROR;

    stream.next_in = pSource;
    stream.avail_in = (mz_uint32)source_len;
    stream.next_out = pDest;
    stream.avail_out = (mz_uint32)*pDest_len;

    status = mz_deflateInit(&stream, level);
    if (status != MZ_OK)
        return status;

    status = mz_deflate(&stream, MZ_FINISH);
    if (status != MZ_STREAM_END)
    {
        mz_deflateEnd(&stream);
        return (status == MZ_OK) ? MZ_BUF_ERROR : status;
    }

    *pDest_len = stream.total_out;
    return mz_deflateEnd(&stream);
}

int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
    return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
}

mz_ulong mz_compressBound(mz_ulong source_len)
{
    return mz_deflateBound(NULL, source_len);
}

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

typedef struct
{
    tinfl_decompressor m_decomp;
    mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
    int m_window_bits;
    mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
    tinfl_status m_last_status;
} inflate_state;

int mz_inflateInit2(mz_streamp pStream, int window_bits)
{
    inflate_state *pDecomp;
    if (!pStream)
        return MZ_STREAM_ERROR;
    if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))
        return MZ_PARAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = 0;
    pStream->msg = NULL;
    pStream->total_in = 0;
    pStream->total_out = 0;
    pStream->reserved = 0;
    if (!pStream->zalloc)
        pStream->zalloc = miniz_def_alloc_func;
    if (!pStream->zfree)
        pStream->zfree = miniz_def_free_func;

    pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
    if (!pDecomp)
        return MZ_MEM_ERROR;

    pStream->state = (struct mz_internal_state *)pDecomp;

    tinfl_init(&pDecomp->m_decomp);
    pDecomp->m_dict_ofs = 0;
    pDecomp->m_dict_avail = 0;
    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    pDecomp->m_first_call = 1;
    pDecomp->m_has_flushed = 0;
    pDecomp->m_window_bits = window_bits;

    return MZ_OK;
}

int mz_inflateInit(mz_streamp pStream)
{
    return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
}

int mz_inflateReset(mz_streamp pStream)
{
    inflate_state *pDecomp;
    if (!pStream)
        return MZ_STREAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = 0;
    pStream->msg = NULL;
    pStream->total_in = 0;
    pStream->total_out = 0;
    pStream->reserved = 0;

    pDecomp = (inflate_state *)pStream->state;

    tinfl_init(&pDecomp->m_decomp);
    pDecomp->m_dict_ofs = 0;
    pDecomp->m_dict_avail = 0;
    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    pDecomp->m_first_call = 1;
    pDecomp->m_has_flushed = 0;
    /* pDecomp->m_window_bits = window_bits */;

    return MZ_OK;
}

int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
    if (flush == MZ_PARTIAL_FLUSH)
        flush = MZ_SYNC_FLUSH;
    if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
        return MZ_STREAM_ERROR;

    pState = (inflate_state *)pStream->state;
    if (pState->m_window_bits > 0)
        decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
    orig_avail_in = pStream->avail_in;

    first_call = pState->m_first_call;
    pState->m_first_call = 0;
    if (pState->m_last_status < 0)
        return MZ_DATA_ERROR;

    if (pState->m_has_flushed && (flush != MZ_FINISH))
        return MZ_STREAM_ERROR;
    pState->m_has_flushed |= (flush == MZ_FINISH);

    if ((flush == MZ_FINISH) && (first_call))
    {
        /* MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file. */
        decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
        in_bytes = pStream->avail_in;
        out_bytes = pStream->avail_out;
        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
        pState->m_last_status = status;
        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
        pStream->next_out += (mz_uint)out_bytes;
        pStream->avail_out -= (mz_uint)out_bytes;
        pStream->total_out += (mz_uint)out_bytes;

        if (status < 0)
            return MZ_DATA_ERROR;
        else if (status != TINFL_STATUS_DONE)
        {
            pState->m_last_status = TINFL_STATUS_FAILED;
            return MZ_BUF_ERROR;
        }
        return MZ_STREAM_END;
    }
    /* flush != MZ_FINISH then we must assume there's more input. */
    if (flush != MZ_FINISH)
        decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

    if (pState->m_dict_avail)
    {
        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
        pStream->next_out += n;
        pStream->avail_out -= n;
        pStream->total_out += n;
        pState->m_dict_avail -= n;
        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
        return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
    }

    for (;;)
    {
        in_bytes = pStream->avail_in;
        out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
        pState->m_last_status = status;

        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tinfl_get_adler32(&pState->m_decomp);

        pState->m_dict_avail = (mz_uint)out_bytes;

        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
        pStream->next_out += n;
        pStream->avail_out -= n;
        pStream->total_out += n;
        pState->m_dict_avail -= n;
        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

        if (status < 0)
            return MZ_DATA_ERROR; /* Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well). */
        else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
            return MZ_BUF_ERROR; /* Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH. */
        else if (flush == MZ_FINISH)
        {
            /* The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH. */
            if (status == TINFL_STATUS_DONE)
                return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
            /* status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong. */
            else if (!pStream->avail_out)
                return MZ_BUF_ERROR;
        }
        else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
            break;
    }

    return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
}

int mz_inflateEnd(mz_streamp pStream)
{
    if (!pStream)
        return MZ_STREAM_ERROR;
    if (pStream->state)
    {
        pStream->zfree(pStream->opaque, pStream->state);
        pStream->state = NULL;
    }
    return MZ_OK;
}
int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len)
{
    mz_stream stream;
    int status;
    memset(&stream, 0, sizeof(stream));

    /* In case mz_ulong is 64-bits (argh I hate longs). */
    if ((mz_uint64)(*pSource_len | *pDest_len) > 0xFFFFFFFFU)
        return MZ_PARAM_ERROR;

    stream.next_in = pSource;
    stream.avail_in = (mz_uint32)*pSource_len;
    stream.next_out = pDest;
    stream.avail_out = (mz_uint32)*pDest_len;

    status = mz_inflateInit(&stream);
    if (status != MZ_OK)
        return status;

    status = mz_inflate(&stream, MZ_FINISH);
    *pSource_len = *pSource_len - stream.avail_in;
    if (status != MZ_STREAM_END)
    {
        mz_inflateEnd(&stream);
        return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
    }
    *pDest_len = stream.total_out;

    return mz_inflateEnd(&stream);
}

int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
    return mz_uncompress2(pDest, pDest_len, pSource, &source_len);
}

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

const char *mz_error(int err)
{
    static struct
    {
        int m_err;
        const char *m_pDesc;
    } s_error_descs[] =
        {
          { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" }, { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
        };
    mz_uint i;
    for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
        if (s_error_descs[i].m_err == err)
            return s_error_descs[i].m_pDesc;
    return NULL;
}

#endif /*MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- Low-level Compression (independent from all decompression API's) */

/* Purposely making these tables static for faster init and thread safety. */
static const mz_uint16 s_tdefl_len_sym[256] =
    {
      257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,
      273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,
      277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
      279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,
      281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
      282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
      283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
      284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285
    };

static const mz_uint8 s_tdefl_len_extra[256] =
    {
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0
    };

static const mz_uint8 s_tdefl_small_dist_sym[512] =
    {
      0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17
    };

static const mz_uint8 s_tdefl_small_dist_extra[512] =
    {
      0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7
    };

static const mz_uint8 s_tdefl_large_dist_sym[128] =
    {
      0, 0, 18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
      26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
    };

static const mz_uint8 s_tdefl_large_dist_extra[128] =
    {
      0, 0, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
    };

/* Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values. */
typedef struct
{
    mz_uint16 m_key, m_sym_index;
} tdefl_sym_freq;
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq *pSyms0, tdefl_sym_freq *pSyms1)
{
    mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
    tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
    MZ_CLEAR_ARR(hist);
    for (i = 0; i < num_syms; i++)
    {
        mz_uint freq = pSyms0[i].m_key;
        hist[freq & 0xFF]++;
        hist[256 + ((freq >> 8) & 0xFF)]++;
    }
    while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
        total_passes--;
    for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
    {
        const mz_uint32 *pHist = &hist[pass << 8];
        mz_uint offsets[256], cur_ofs = 0;
        for (i = 0; i < 256; i++)
        {
            offsets[i] = cur_ofs;
            cur_ofs += pHist[i];
        }
        for (i = 0; i < num_syms; i++)
            pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
        {
            tdefl_sym_freq *t = pCur_syms;
            pCur_syms = pNew_syms;
            pNew_syms = t;
        }
    }
    return pCur_syms;
}

/* tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. */
static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
    int root, leaf, next, avbl, used, dpth;
    if (n == 0)
        return;
    else if (n == 1)
    {
        A[0].m_key = 1;
        return;
    }
    A[0].m_key += A[1].m_key;
    root = 0;
    leaf = 2;
    for (next = 1; next < n - 1; next++)
    {
        if (leaf >= n || A[root].m_key < A[leaf].m_key)
        {
            A[next].m_key = A[root].m_key;
            A[root++].m_key = (mz_uint16)next;
        }
        else
            A[next].m_key = A[leaf++].m_key;
        if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))
        {
            A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
            A[root++].m_key = (mz_uint16)next;
        }
        else
            A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
    }
    A[n - 2].m_key = 0;
    for (next = n - 3; next >= 0; next--)
        A[next].m_key = A[A[next].m_key].m_key + 1;
    avbl = 1;
    used = dpth = 0;
    root = n - 2;
    next = n - 1;
    while (avbl > 0)
    {
        while (root >= 0 && (int)A[root].m_key == dpth)
        {
            used++;
            root--;
        }
        while (avbl > used)
        {
            A[next--].m_key = (mz_uint16)(dpth);
            avbl--;
        }
        avbl = 2 * used;
        dpth++;
        used = 0;
    }
}

/* Limits canonical Huffman code table's max code size. */
enum
{
    TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
};
static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
    int i;
    mz_uint32 total = 0;
    if (code_list_len <= 1)
        return;
    for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
        pNum_codes[max_code_size] += pNum_codes[i];
    for (i = max_code_size; i > 0; i--)
        total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
    while (total != (1UL << max_code_size))
    {
        pNum_codes[max_code_size]--;
        for (i = max_code_size - 1; i > 0; i--)
            if (pNum_codes[i])
            {
                pNum_codes[i]--;
                pNum_codes[i + 1] += 2;
                break;
            }
        total--;
    }
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)
{
    int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
    mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
    MZ_CLEAR_ARR(num_codes);
    if (static_table)
    {
        for (i = 0; i < table_len; i++)
            num_codes[d->m_huff_code_sizes[table_num][i]]++;
    }
    else
    {
        tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
        int num_used_syms = 0;
        const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
        for (i = 0; i < table_len; i++)
            if (pSym_count[i])
            {
                syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
                syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
            }

        pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
        tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

        for (i = 0; i < num_used_syms; i++)
            num_codes[pSyms[i].m_key]++;

        tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

        MZ_CLEAR_ARR(d->m_huff_code_sizes[table_num]);
        MZ_CLEAR_ARR(d->m_huff_codes[table_num]);
        for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
            for (l = num_codes[i]; l > 0; l--)
                d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
    }

    next_code[1] = 0;
    for (j = 0, i = 2; i <= code_size_limit; i++)
        next_code[i] = j = ((j + num_codes[i - 1]) << 1);

    for (i = 0; i < table_len; i++)
    {
        mz_uint rev_code = 0, code, code_size;
        if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0)
            continue;
        code = next_code[code_size]++;
        for (l = code_size; l > 0; l--, code >>= 1)
            rev_code = (rev_code << 1) | (code & 1);
        d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    }
}

#define TDEFL_PUT_BITS(b, l)                                       \
    do                                                             \
    {                                                              \
        mz_uint bits = b;                                          \
        mz_uint len = l;                                           \
        MZ_ASSERT(bits <= ((1U << len) - 1U));                     \
        d->m_bit_buffer |= (bits << d->m_bits_in);                 \
        d->m_bits_in += len;                                       \
        while (d->m_bits_in >= 8)                                  \
        {                                                          \
            if (d->m_pOutput_buf < d->m_pOutput_buf_end)           \
                *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
            d->m_bit_buffer >>= 8;                                 \
            d->m_bits_in -= 8;                                     \
        }                                                          \
    }                                                              \
    MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
    {                                                                                                                    \
        if (rle_repeat_count)                                                                                            \
        {                                                                                                                \
            if (rle_repeat_count < 3)                                                                                    \
            {                                                                                                            \
                d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
                while (rle_repeat_count--)                                                                               \
                    packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
            }                                                                                                            \
            else                                                                                                         \
            {                                                                                                            \
                d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
                packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
            }                                                                                                            \
            rle_repeat_count = 0;                                                                                        \
        }                                                                                                                \
    }

#define TDEFL_RLE_ZERO_CODE_SIZE()                                                         \
    {                                                                                      \
        if (rle_z_count)                                                                   \
        {                                                                                  \
            if (rle_z_count < 3)                                                           \
            {                                                                              \
                d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);  \
                while (rle_z_count--)                                                      \
                    packed_code_sizes[num_packed_code_sizes++] = 0;                        \
            }                                                                              \
            else if (rle_z_count <= 10)                                                    \
            {                                                                              \
                d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 17;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3);  \
            }                                                                              \
            else                                                                           \
            {                                                                              \
                d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 18;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
            }                                                                              \
            rle_z_count = 0;                                                               \
        }                                                                                  \
    }

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
    int num_lit_codes, num_dist_codes, num_bit_lengths;
    mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
    mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

    d->m_huff_count[0][256] = 1;

    tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
    tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

    for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
        if (d->m_huff_code_sizes[0][num_lit_codes - 1])
            break;
    for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
        if (d->m_huff_code_sizes[1][num_dist_codes - 1])
            break;

    memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
    memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
    total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
    num_packed_code_sizes = 0;
    rle_z_count = 0;
    rle_repeat_count = 0;

    memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
    for (i = 0; i < total_code_sizes_to_pack; i++)
    {
        mz_uint8 code_size = code_sizes_to_pack[i];
        if (!code_size)
        {
            TDEFL_RLE_PREV_CODE_SIZE();
            if (++rle_z_count == 138)
            {
                TDEFL_RLE_ZERO_CODE_SIZE();
            }
        }
        else
        {
            TDEFL_RLE_ZERO_CODE_SIZE();
            if (code_size != prev_code_size)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
                d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1);
                packed_code_sizes[num_packed_code_sizes++] = code_size;
            }
            else if (++rle_repeat_count == 6)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
            }
        }
        prev_code_size = code_size;
    }
    if (rle_repeat_count)
    {
        TDEFL_RLE_PREV_CODE_SIZE();
    }
    else
    {
        TDEFL_RLE_ZERO_CODE_SIZE();
    }

    tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

    TDEFL_PUT_BITS(2, 2);

    TDEFL_PUT_BITS(num_lit_codes - 257, 5);
    TDEFL_PUT_BITS(num_dist_codes - 1, 5);

    for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
        if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])
            break;
    num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
    TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
    for (i = 0; (int)i < num_bit_lengths; i++)
        TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

    for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes;)
    {
        mz_uint code = packed_code_sizes[packed_code_sizes_index++];
        MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
        TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
        if (code >= 16)
            TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
    }
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
    mz_uint i;
    mz_uint8 *p = &d->m_huff_code_sizes[0][0];

    for (i = 0; i <= 143; ++i)
        *p++ = 8;
    for (; i <= 255; ++i)
        *p++ = 9;
    for (; i <= 279; ++i)
        *p++ = 7;
    for (; i <= 287; ++i)
        *p++ = 8;

    memset(d->m_huff_code_sizes[1], 5, 32);

    tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
    tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

    TDEFL_PUT_BITS(1, 2);
}

static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;
    mz_uint8 *pOutput_buf = d->m_pOutput_buf;
    mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
    mz_uint64 bit_buffer = d->m_bit_buffer;
    mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l)                    \
    {                                                \
        bit_buffer |= (((mz_uint64)(b)) << bits_in); \
        bits_in += (l);                              \
    }

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;

        if (flags & 1)
        {
            mz_uint s0, s1, n0, n1, sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0];
            match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            /* This sequence coaxes MSVC into using cmov's vs. jmp's. */
            s0 = s_tdefl_small_dist_sym[match_dist & 511];
            n0 = s_tdefl_small_dist_extra[match_dist & 511];
            s1 = s_tdefl_large_dist_sym[match_dist >> 8];
            n1 = s_tdefl_large_dist_extra[match_dist >> 8];
            sym = (match_dist < 512) ? s0 : s1;
            num_extra_bits = (match_dist < 512) ? n0 : n1;

            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

            if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
            {
                flags >>= 1;
                lit = *pLZ_codes++;
                MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

                if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
                {
                    flags >>= 1;
                    lit = *pLZ_codes++;
                    MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                    TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
                }
            }
        }

        if (pOutput_buf >= d->m_pOutput_buf_end)
            return MZ_FALSE;

        memcpy(pOutput_buf, &bit_buffer, sizeof(mz_uint64));
        pOutput_buf += (bits_in >> 3);
        bit_buffer >>= (bits_in & ~7);
        bits_in &= 7;
    }

#undef TDEFL_PUT_BITS_FAST

    d->m_pOutput_buf = pOutput_buf;
    d->m_bits_in = 0;
    d->m_bit_buffer = 0;

    while (bits_in)
    {
        mz_uint32 n = MZ_MIN(bits_in, 16);
        TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
        bit_buffer >>= n;
        bits_in -= n;
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;
        if (flags & 1)
        {
            mz_uint sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            if (match_dist < 512)
            {
                sym = s_tdefl_small_dist_sym[match_dist];
                num_extra_bits = s_tdefl_small_dist_extra[match_dist];
            }
            else
            {
                sym = s_tdefl_large_dist_sym[match_dist >> 8];
                num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
            }
            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
        }
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS */

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
    if (static_block)
        tdefl_start_static_block(d);
    else
        tdefl_start_dynamic_block(d);
    return tdefl_compress_lz_codes(d);
}

static const mz_uint s_tdefl_num_probes[11];

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
    mz_uint saved_bit_buf, saved_bits_in;
    mz_uint8 *pSaved_output_buf;
    mz_bool comp_block_succeeded = MZ_FALSE;
    int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
    mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;

    d->m_pOutput_buf = pOutput_buf_start;
    d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

    MZ_ASSERT(!d->m_output_flush_remaining);
    d->m_output_flush_ofs = 0;
    d->m_output_flush_remaining = 0;

    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
    d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

    if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
    {
        const mz_uint8 cmf = 0x78;
        mz_uint8 flg, flevel = 3;
        mz_uint header, i, n = sizeof(s_tdefl_num_probes) / sizeof(mz_uint);

        /* Determine compression level by reversing the process in tdefl_create_comp_flags_from_zip_params() */
        for (i = 0; i < n; i++)
            if (s_tdefl_num_probes[i] == (d->m_flags & 0xFFF)) break;

        if (i < 2)
            flevel = 0;
        else if (i < 6)
            flevel = 1;
        else if (i == 6)
            flevel = 2;

        header = cmf << 8 | (flevel << 6);
        header += 31 - (header % 31);
        flg = header & 0xFF;

        TDEFL_PUT_BITS(cmf, 8);
        TDEFL_PUT_BITS(flg, 8);
    }

    TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

    pSaved_output_buf = d->m_pOutput_buf;
    saved_bit_buf = d->m_bit_buffer;
    saved_bits_in = d->m_bits_in;

    if (!use_raw_block)
        comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));

    /* If the block gets expanded, forget the current contents of the output buffer and send a raw block instead. */
    if (((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
        ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size))
    {
        mz_uint i;
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
        TDEFL_PUT_BITS(0, 2);
        if (d->m_bits_in)
        {
            TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
        }
        for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
        {
            TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
        }
        for (i = 0; i < d->m_total_lz_bytes; ++i)
        {
            TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
        }
    }
    /* Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes. */
    else if (!comp_block_succeeded)
    {
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
        tdefl_compress_block(d, MZ_TRUE);
    }

    if (flush)
    {
        if (flush == TDEFL_FINISH)
        {
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER)
            {
                mz_uint i, a = d->m_adler32;
                for (i = 0; i < 4; i++)
                {
                    TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
                    a <<= 8;
                }
            }
        }
        else
        {
            mz_uint i, z = 0;
            TDEFL_PUT_BITS(0, 3);
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            for (i = 2; i; --i, z ^= 0xFFFF)
            {
                TDEFL_PUT_BITS(z & 0xFFFF, 16);
            }
        }
    }

    MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

    memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

    d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    d->m_pLZ_flags = d->m_lz_code_buf;
    d->m_num_flags_left = 8;
    d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
    d->m_total_lz_bytes = 0;
    d->m_block_index++;

    if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
    {
        if (d->m_pPut_buf_func)
        {
            *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
            if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
                return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
        }
        else if (pOutput_buf_start == d->m_output_buf)
        {
            int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
            memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
            d->m_out_buf_ofs += bytes_to_copy;
            if ((n -= bytes_to_copy) != 0)
            {
                d->m_output_flush_ofs = bytes_to_copy;
                d->m_output_flush_remaining = n;
            }
        }
        else
        {
            d->m_out_buf_ofs += n;
        }
    }

    return d->m_output_flush_remaining;
}

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
static mz_uint16 TDEFL_READ_UNALIGNED_WORD(const mz_uint8* p)
{
	mz_uint16 ret;
	memcpy(&ret, p, sizeof(mz_uint16));
	return ret;
}
static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(const mz_uint16* p)
{
	mz_uint16 ret;
	memcpy(&ret, p, sizeof(mz_uint16));
	return ret;
}
#else
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)
#define TDEFL_READ_UNALIGNED_WORD2(p) *(const mz_uint16 *)(p)
#endif
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
    mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD2(s);
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                             \
    next_probe_pos = d->m_next[probe_pos];                                                      \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) \
        return;                                                                                 \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                       \
    if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01)                \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        q = (const mz_uint16 *)(d->m_dict + probe_pos);
        if (TDEFL_READ_UNALIGNED_WORD2(q) != s01)
            continue;
        p = s;
        probe_len = 32;
        do
        {
        } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                 (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
        if (!probe_len)
        {
            *pMatch_dist = dist;
            *pMatch_len = MZ_MIN(max_match_len, (mz_uint)TDEFL_MAX_MATCH_LEN);
            break;
        }
        else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q)) > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len)
                break;
            c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
        }
    }
}
#else
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint8 *s = d->m_dict + pos, *p, *q;
    mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                               \
    next_probe_pos = d->m_next[probe_pos];                                                        \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))   \
        return;                                                                                   \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                         \
    if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        p = s;
        q = d->m_dict + probe_pos;
        for (probe_len = 0; probe_len < max_match_len; probe_len++)
            if (*p++ != *q++)
                break;
        if (probe_len > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = probe_len) == max_match_len)
                return;
            c0 = d->m_dict[pos + match_len];
            c1 = d->m_dict[pos + match_len - 1];
        }
    }
}
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES */

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(const mz_uint8* p)
{
	mz_uint32 ret;
	memcpy(&ret, p, sizeof(mz_uint32));
	return ret;
}
#else
#define TDEFL_READ_UNALIGNED_WORD32(p) *(const mz_uint32 *)(p)
#endif
static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
    /* Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. */
    mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
    mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
    mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

    while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
    {
        const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
        mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
        mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
        d->m_src_buf_left -= num_bytes_to_process;
        lookahead_size += num_bytes_to_process;

        while (num_bytes_to_process)
        {
            mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
            memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
            if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
            d->m_pSrc += n;
            dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
            num_bytes_to_process -= n;
        }

        dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
        if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
            break;

        while (lookahead_size >= 4)
        {
            mz_uint cur_match_dist, cur_match_len = 1;
            mz_uint8 *pCur_dict = d->m_dict + cur_pos;
            mz_uint first_trigram = TDEFL_READ_UNALIGNED_WORD32(pCur_dict) & 0xFFFFFF;
            mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
            mz_uint probe_pos = d->m_hash[hash];
            d->m_hash[hash] = (mz_uint16)lookahead_pos;

            if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((TDEFL_READ_UNALIGNED_WORD32(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
            {
                const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
                const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
                mz_uint32 probe_len = 32;
                do
                {
                } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                         (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
                cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
                if (!probe_len)
                    cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

                if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)))
                {
                    cur_match_len = 1;
                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
                }
                else
                {
                    mz_uint32 s0, s1;
                    cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

                    MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));

                    cur_match_dist--;

                    pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
					memcpy(&pLZ_code_buf[1], &cur_match_dist, sizeof(cur_match_dist));
#else
                    *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
#endif
                    pLZ_code_buf += 3;
                    *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

                    s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
                    s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
                    d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

                    d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
                }
            }
            else
            {
                *pLZ_code_buf++ = (mz_uint8)first_trigram;
                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                d->m_huff_count[0][(mz_uint8)first_trigram]++;
            }

            if (--num_flags_left == 0)
            {
                num_flags_left = 8;
                pLZ_flags = pLZ_code_buf++;
            }

            total_lz_bytes += cur_match_len;
            lookahead_pos += cur_match_len;
            dict_size = MZ_MIN(dict_size + cur_match_len, (mz_uint)TDEFL_LZ_DICT_SIZE);
            cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
            MZ_ASSERT(lookahead_size >= cur_match_len);
            lookahead_size -= cur_match_len;

            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
            {
                int n;
                d->m_lookahead_pos = lookahead_pos;
                d->m_lookahead_size = lookahead_size;
                d->m_dict_size = dict_size;
                d->m_total_lz_bytes = total_lz_bytes;
                d->m_pLZ_code_buf = pLZ_code_buf;
                d->m_pLZ_flags = pLZ_flags;
                d->m_num_flags_left = num_flags_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
                total_lz_bytes = d->m_total_lz_bytes;
                pLZ_code_buf = d->m_pLZ_code_buf;
                pLZ_flags = d->m_pLZ_flags;
                num_flags_left = d->m_num_flags_left;
            }
        }

        while (lookahead_size)
        {
            mz_uint8 lit = d->m_dict[cur_pos];

            total_lz_bytes++;
            *pLZ_code_buf++ = lit;
            *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
            if (--num_flags_left == 0)
            {
                num_flags_left = 8;
                pLZ_flags = pLZ_code_buf++;
            }

            d->m_huff_count[0][lit]++;

            lookahead_pos++;
            dict_size = MZ_MIN(dict_size + 1, (mz_uint)TDEFL_LZ_DICT_SIZE);
            cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
            lookahead_size--;

            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
            {
                int n;
                d->m_lookahead_pos = lookahead_pos;
                d->m_lookahead_size = lookahead_size;
                d->m_dict_size = dict_size;
                d->m_total_lz_bytes = total_lz_bytes;
                d->m_pLZ_code_buf = pLZ_code_buf;
                d->m_pLZ_flags = pLZ_flags;
                d->m_num_flags_left = num_flags_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
                total_lz_bytes = d->m_total_lz_bytes;
                pLZ_code_buf = d->m_pLZ_code_buf;
                pLZ_flags = d->m_pLZ_flags;
                num_flags_left = d->m_num_flags_left;
            }
        }
    }

    d->m_lookahead_pos = lookahead_pos;
    d->m_lookahead_size = lookahead_size;
    d->m_dict_size = dict_size;
    d->m_total_lz_bytes = total_lz_bytes;
    d->m_pLZ_code_buf = pLZ_code_buf;
    d->m_pLZ_flags = pLZ_flags;
    d->m_num_flags_left = num_flags_left;
    return MZ_TRUE;
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */

static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
{
    d->m_total_lz_bytes++;
    *d->m_pLZ_code_buf++ = lit;
    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
    if (--d->m_num_flags_left == 0)
    {
        d->m_num_flags_left = 8;
        d->m_pLZ_flags = d->m_pLZ_code_buf++;
    }
    d->m_huff_count[0][lit]++;
}

static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
    mz_uint32 s0, s1;

    MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));

    d->m_total_lz_bytes += match_len;

    d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

    match_dist -= 1;
    d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
    d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
    d->m_pLZ_code_buf += 3;

    *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
    if (--d->m_num_flags_left == 0)
    {
        d->m_num_flags_left = 8;
        d->m_pLZ_flags = d->m_pLZ_code_buf++;
    }

    s0 = s_tdefl_small_dist_sym[match_dist & 511];
    s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
    d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
    d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
    const mz_uint8 *pSrc = d->m_pSrc;
    size_t src_buf_left = d->m_src_buf_left;
    tdefl_flush flush = d->m_flush;

    while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
    {
        mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
        /* Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN. */
        if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
        {
            mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
            mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
            mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
            const mz_uint8 *pSrc_end = pSrc ? pSrc + num_bytes_to_process : NULL;
            src_buf_left -= num_bytes_to_process;
            d->m_lookahead_size += num_bytes_to_process;
            while (pSrc != pSrc_end)
            {
                mz_uint8 c = *pSrc++;
                d->m_dict[dst_pos] = c;
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                d->m_hash[hash] = (mz_uint16)(ins_pos);
                dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
                ins_pos++;
            }
        }
        else
        {
            while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
            {
                mz_uint8 c = *pSrc++;
                mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
                src_buf_left--;
                d->m_dict[dst_pos] = c;
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
                {
                    mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
                    mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                    d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                    d->m_hash[hash] = (mz_uint16)(ins_pos);
                }
            }
        }
        d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
        if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
            break;

        /* Simple lazy/greedy parsing state machine. */
        len_to_move = 1;
        cur_match_dist = 0;
        cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
        cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
        if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
        {
            if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
            {
                mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
                cur_match_len = 0;
                while (cur_match_len < d->m_lookahead_size)
                {
                    if (d->m_dict[cur_pos + cur_match_len] != c)
                        break;
                    cur_match_len++;
                }
                if (cur_match_len < TDEFL_MIN_MATCH_LEN)
                    cur_match_len = 0;
                else
                    cur_match_dist = 1;
            }
        }
        else
        {
            tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
        }
        if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
        {
            cur_match_dist = cur_match_len = 0;
        }
        if (d->m_saved_match_len)
        {
            if (cur_match_len > d->m_saved_match_len)
            {
                tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
                if (cur_match_len >= 128)
                {
                    tdefl_record_match(d, cur_match_len, cur_match_dist);
                    d->m_saved_match_len = 0;
                    len_to_move = cur_match_len;
                }
                else
                {
                    d->m_saved_lit = d->m_dict[cur_pos];
                    d->m_saved_match_dist = cur_match_dist;
                    d->m_saved_match_len = cur_match_len;
                }
            }
            else
            {
                tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
                len_to_move = d->m_saved_match_len - 1;
                d->m_saved_match_len = 0;
            }
        }
        else if (!cur_match_dist)
            tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
        else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
        {
            tdefl_record_match(d, cur_match_len, cur_match_dist);
            len_to_move = cur_match_len;
        }
        else
        {
            d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
            d->m_saved_match_dist = cur_match_dist;
            d->m_saved_match_len = cur_match_len;
        }
        /* Move the lookahead forward by len_to_move bytes. */
        d->m_lookahead_pos += len_to_move;
        MZ_ASSERT(d->m_lookahead_size >= len_to_move);
        d->m_lookahead_size -= len_to_move;
        d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);
        /* Check if it's time to flush the current LZ codes to the internal output buffer. */
        if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
            ((d->m_total_lz_bytes > 31 * 1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))))
        {
            int n;
            d->m_pSrc = pSrc;
            d->m_src_buf_left = src_buf_left;
            if ((n = tdefl_flush_block(d, 0)) != 0)
                return (n < 0) ? MZ_FALSE : MZ_TRUE;
        }
    }

    d->m_pSrc = pSrc;
    d->m_src_buf_left = src_buf_left;
    return MZ_TRUE;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
    if (d->m_pIn_buf_size)
    {
        *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
    }

    if (d->m_pOut_buf_size)
    {
        size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
        memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
        d->m_output_flush_ofs += (mz_uint)n;
        d->m_output_flush_remaining -= (mz_uint)n;
        d->m_out_buf_ofs += n;

        *d->m_pOut_buf_size = d->m_out_buf_ofs;
    }

    return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
    if (!d)
    {
        if (pIn_buf_size)
            *pIn_buf_size = 0;
        if (pOut_buf_size)
            *pOut_buf_size = 0;
        return TDEFL_STATUS_BAD_PARAM;
    }

    d->m_pIn_buf = pIn_buf;
    d->m_pIn_buf_size = pIn_buf_size;
    d->m_pOut_buf = pOut_buf;
    d->m_pOut_buf_size = pOut_buf_size;
    d->m_pSrc = (const mz_uint8 *)(pIn_buf);
    d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
    d->m_out_buf_ofs = 0;
    d->m_flush = flush;

    if (((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf))
    {
        if (pIn_buf_size)
            *pIn_buf_size = 0;
        if (pOut_buf_size)
            *pOut_buf_size = 0;
        return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
    }
    d->m_wants_to_finish |= (flush == TDEFL_FINISH);

    if ((d->m_output_flush_remaining) || (d->m_finished))
        return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
    if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
        ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
        ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
    {
        if (!tdefl_compress_fast(d))
            return d->m_prev_return_status;
    }
    else
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
    {
        if (!tdefl_compress_normal(d))
            return d->m_prev_return_status;
    }

    if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
        d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);

    if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
    {
        if (tdefl_flush_block(d, flush) < 0)
            return d->m_prev_return_status;
        d->m_finished = (flush == TDEFL_FINISH);
        if (flush == TDEFL_FULL_FLUSH)
        {
            MZ_CLEAR_ARR(d->m_hash);
            MZ_CLEAR_ARR(d->m_next);
            d->m_dict_size = 0;
        }
    }

    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
}

tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
{
    MZ_ASSERT(d->m_pPut_buf_func);
    return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
}

tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    d->m_pPut_buf_func = pPut_buf_func;
    d->m_pPut_buf_user = pPut_buf_user;
    d->m_flags = (mz_uint)(flags);
    d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
    d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
    d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
    if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
        MZ_CLEAR_ARR(d->m_hash);
    d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
    d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
    d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    d->m_pLZ_flags = d->m_lz_code_buf;
    *d->m_pLZ_flags = 0;
    d->m_num_flags_left = 8;
    d->m_pOutput_buf = d->m_output_buf;
    d->m_pOutput_buf_end = d->m_output_buf;
    d->m_prev_return_status = TDEFL_STATUS_OKAY;
    d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
    d->m_adler32 = 1;
    d->m_pIn_buf = NULL;
    d->m_pOut_buf = NULL;
    d->m_pIn_buf_size = NULL;
    d->m_pOut_buf_size = NULL;
    d->m_flush = TDEFL_NO_FLUSH;
    d->m_pSrc = NULL;
    d->m_src_buf_left = 0;
    d->m_out_buf_ofs = 0;
    if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
        MZ_CLEAR_ARR(d->m_dict);
    memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
    return TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
{
    return d->m_prev_return_status;
}

mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
{
    return d->m_adler32;
}

mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    tdefl_compressor *pComp;
    mz_bool succeeded;
    if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
        return MZ_FALSE;
    pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    if (!pComp)
        return MZ_FALSE;
    succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
    succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
    MZ_FREE(pComp);
    return succeeded;
}

typedef struct
{
    size_t m_size, m_capacity;
    mz_uint8 *m_pBuf;
    mz_bool m_expandable;
} tdefl_output_buffer;

static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
{
    tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
    size_t new_size = p->m_size + len;
    if (new_size > p->m_capacity)
    {
        size_t new_capacity = p->m_capacity;
        mz_uint8 *pNew_buf;
        if (!p->m_expandable)
            return MZ_FALSE;
        do
        {
            new_capacity = MZ_MAX(128U, new_capacity << 1U);
        } while (new_size > new_capacity);
        pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
        if (!pNew_buf)
            return MZ_FALSE;
        p->m_pBuf = pNew_buf;
        p->m_capacity = new_capacity;
    }
    memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
    p->m_size = new_size;
    return MZ_TRUE;
}

void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
    tdefl_output_buffer out_buf;
    MZ_CLEAR_OBJ(out_buf);
    if (!pOut_len)
        return MZ_FALSE;
    else
        *pOut_len = 0;
    out_buf.m_expandable = MZ_TRUE;
    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        return NULL;
    *pOut_len = out_buf.m_size;
    return out_buf.m_pBuf;
}

size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
    tdefl_output_buffer out_buf;
    MZ_CLEAR_OBJ(out_buf);
    if (!pOut_buf)
        return 0;
    out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
    out_buf.m_capacity = out_buf_len;
    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        return 0;
    return out_buf.m_size;
}

static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };

/* level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). */
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
{
    mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
    if (window_bits > 0)
        comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

    if (!level)
        comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
    else if (strategy == MZ_FILTERED)
        comp_flags |= TDEFL_FILTER_MATCHES;
    else if (strategy == MZ_HUFFMAN_ONLY)
        comp_flags &= ~TDEFL_MAX_PROBES_MASK;
    else if (strategy == MZ_FIXED)
        comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
    else if (strategy == MZ_RLE)
        comp_flags |= TDEFL_RLE_MATCHES;

    return comp_flags;
}

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4204) /* nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal) */
#endif

/* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
 http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
 This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
{
    /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */
    static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
    tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    tdefl_output_buffer out_buf;
    int i, bpl = w * num_chans, y, z;
    mz_uint32 c;
    *pLen_out = 0;
    if (!pComp)
        return NULL;
    MZ_CLEAR_OBJ(out_buf);
    out_buf.m_expandable = MZ_TRUE;
    out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
    if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))
    {
        MZ_FREE(pComp);
        return NULL;
    }
    /* write dummy header */
    for (z = 41; z; --z)
        tdefl_output_buffer_putter(&z, 1, &out_buf);
    /* compress image data */
    tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
    for (y = 0; y < h; ++y)
    {
        tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
        tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
    }
    if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)
    {
        MZ_FREE(pComp);
        MZ_FREE(out_buf.m_pBuf);
        return NULL;
    }
    /* write real header */
    *pLen_out = out_buf.m_size - 41;
    {
        static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
        mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,
                                0x0a, 0x1a, 0x0a, 0x00, 0x00,
                                0x00, 0x0d, 0x49, 0x48, 0x44,
                                0x52, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x08,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x49, 0x44, 0x41,
                                0x54 };
        pnghdr[18] = (mz_uint8)(w >> 8);
        pnghdr[19] = (mz_uint8)w;
        pnghdr[22] = (mz_uint8)(h >> 8);
        pnghdr[23] = (mz_uint8)h;
        pnghdr[25] = chans[num_chans];
        pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
        pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
        pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
        pnghdr[36] = (mz_uint8)*pLen_out;
        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
        for (i = 0; i < 4; ++i, c <<= 8)
            ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
        memcpy(out_buf.m_pBuf, pnghdr, 41);
    }
    /* write footer (IDAT CRC-32, followed by IEND chunk) */
    if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf))
    {
        *pLen_out = 0;
        MZ_FREE(pComp);
        MZ_FREE(out_buf.m_pBuf);
        return NULL;
    }
    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
    for (i = 0; i < 4; ++i, c <<= 8)
        (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
    /* compute final size of file, grab compressed data buffer and return */
    *pLen_out += 57;
    MZ_FREE(pComp);
    return out_buf.m_pBuf;
}
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
    /* Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out) */
    return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
}

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor and tinfl_decompressor structures in C so that */
/* non-C language bindings to tdefL_ and tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
tdefl_compressor *tdefl_compressor_alloc(void)
{
    return (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
}

void tdefl_compressor_free(tdefl_compressor *pComp)
{
    MZ_FREE(pComp);
}
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
 /**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- Low-level Decompression (completely independent from all compression API's) */

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN  \
    switch (r->m_state) \
    {                   \
        case 0:
#define TINFL_CR_RETURN(state_index, result) \
    do                                       \
    {                                        \
        status = result;                     \
        r->m_state = state_index;            \
        goto common_exit;                    \
        case state_index:;                   \
    }                                        \
    MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result) \
    do                                               \
    {                                                \
        for (;;)                                     \
        {                                            \
            TINFL_CR_RETURN(state_index, result);    \
        }                                            \
    }                                                \
    MZ_MACRO_END
#define TINFL_CR_FINISH }

#define TINFL_GET_BYTE(state_index, c)                                                                                                                           \
    do                                                                                                                                                           \
    {                                                                                                                                                            \
        while (pIn_buf_cur >= pIn_buf_end)                                                                                                                       \
        {                                                                                                                                                        \
            TINFL_CR_RETURN(state_index, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS); \
        }                                                                                                                                                        \
        c = *pIn_buf_cur++;                                                                                                                                      \
    }                                                                                                                                                            \
    MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n)                \
    do                                                 \
    {                                                  \
        mz_uint c;                                     \
        TINFL_GET_BYTE(state_index, c);                \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \
        num_bits += 8;                                 \
    } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n)      \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n)    \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        b = bit_buf & ((1 << (n)) - 1);      \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END

/* TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2. */
/* It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a */
/* Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the */
/* bit buffer contains >=15 bits (deflate's max. Huffman code size). */
#define TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree)                    \
    do                                                                         \
    {                                                                          \
        temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];                \
        if (temp >= 0)                                                         \
        {                                                                      \
            code_len = temp >> 9;                                              \
            if ((code_len) && (num_bits >= code_len))                          \
                break;                                                         \
        }                                                                      \
        else if (num_bits > TINFL_FAST_LOOKUP_BITS)                            \
        {                                                                      \
            code_len = TINFL_FAST_LOOKUP_BITS;                                 \
            do                                                                 \
            {                                                                  \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];           \
            } while ((temp < 0) && (num_bits >= (code_len + 1)));              \
            if (temp >= 0)                                                     \
                break;                                                         \
        }                                                                      \
        TINFL_GET_BYTE(state_index, c);                                        \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                         \
        num_bits += 8;                                                         \
    } while (num_bits < 15);

/* TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read */
/* beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully */
/* decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32. */
/* The slow path is only executed at the very end of the input buffer. */
/* v1.16: The original macro handled the case at the very end of the passed-in input buffer, but we also need to handle the case where the user passes in 1+zillion bytes */
/* following the deflate data and our non-conservative read-ahead path won't kick in here on this code. This is much trickier. */
#define TINFL_HUFF_DECODE(state_index, sym, pLookUp, pTree)                                                                         \
    do                                                                                                                              \
    {                                                                                                                               \
        int temp;                                                                                                                   \
        mz_uint code_len, c;                                                                                                        \
        if (num_bits < 15)                                                                                                          \
        {                                                                                                                           \
            if ((pIn_buf_end - pIn_buf_cur) < 2)                                                                                    \
            {                                                                                                                       \
                TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree);                                                                \
            }                                                                                                                       \
            else                                                                                                                    \
            {                                                                                                                       \
                bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); \
                pIn_buf_cur += 2;                                                                                                   \
                num_bits += 16;                                                                                                     \
            }                                                                                                                       \
        }                                                                                                                           \
        if ((temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)                                                          \
            code_len = temp >> 9, temp &= 511;                                                                                      \
        else                                                                                                                        \
        {                                                                                                                           \
            code_len = TINFL_FAST_LOOKUP_BITS;                                                                                      \
            do                                                                                                                      \
            {                                                                                                                       \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];                                                                \
            } while (temp < 0);                                                                                                     \
        }                                                                                                                           \
        sym = temp;                                                                                                                 \
        bit_buf >>= code_len;                                                                                                       \
        num_bits -= code_len;                                                                                                       \
    }                                                                                                                               \
    MZ_MACRO_END

static void tinfl_clear_tree(tinfl_decompressor *r)
{
    if (r->m_type == 0)
        MZ_CLEAR_ARR(r->m_tree_0);
    else if (r->m_type == 1)
        MZ_CLEAR_ARR(r->m_tree_1);
    else
        MZ_CLEAR_ARR(r->m_tree_2);
}

tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
{
    static const mz_uint16 s_length_base[31] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };
    static const mz_uint8 s_length_extra[31] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };
    static const mz_uint16 s_dist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };
    static const mz_uint8 s_dist_extra[32] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
    static const mz_uint8 s_length_dezigzag[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
    static const mz_uint16 s_min_table_sizes[3] = { 257, 1, 4 };

    mz_int16 *pTrees[3];
    mz_uint8 *pCode_sizes[3];

    tinfl_status status = TINFL_STATUS_FAILED;
    mz_uint32 num_bits, dist, counter, num_extra;
    tinfl_bit_buf_t bit_buf;
    const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
    mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next ? pOut_buf_next + *pOut_buf_size : NULL;
    size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;

    /* Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter). */
    if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start))
    {
        *pIn_buf_size = *pOut_buf_size = 0;
        return TINFL_STATUS_BAD_PARAM;
    }

    pTrees[0] = r->m_tree_0;
    pTrees[1] = r->m_tree_1;
    pTrees[2] = r->m_tree_2;
    pCode_sizes[0] = r->m_code_size_0;
    pCode_sizes[1] = r->m_code_size_1;
    pCode_sizes[2] = r->m_code_size_2;

    num_bits = r->m_num_bits;
    bit_buf = r->m_bit_buf;
    dist = r->m_dist;
    counter = r->m_counter;
    num_extra = r->m_num_extra;
    dist_from_out_buf_start = r->m_dist_from_out_buf_start;
    TINFL_CR_BEGIN

    bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
    r->m_z_adler32 = r->m_check_adler32 = 1;
    if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
    {
        TINFL_GET_BYTE(1, r->m_zhdr0);
        TINFL_GET_BYTE(2, r->m_zhdr1);
        counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
        if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
            counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
        if (counter)
        {
            TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
        }
    }

    do
    {
        TINFL_GET_BITS(3, r->m_final, 3);
        r->m_type = r->m_final >> 1;
        if (r->m_type == 0)
        {
            TINFL_SKIP_BITS(5, num_bits & 7);
            for (counter = 0; counter < 4; ++counter)
            {
                if (num_bits)
                    TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
                else
                    TINFL_GET_BYTE(7, r->m_raw_header[counter]);
            }
            if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8))))
            {
                TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
            }
            while ((counter) && (num_bits))
            {
                TINFL_GET_BITS(51, dist, 8);
                while (pOut_buf_cur >= pOut_buf_end)
                {
                    TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
                }
                *pOut_buf_cur++ = (mz_uint8)dist;
                counter--;
            }
            while (counter)
            {
                size_t n;
                while (pOut_buf_cur >= pOut_buf_end)
                {
                    TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
                }
                while (pIn_buf_cur >= pIn_buf_end)
                {
                    TINFL_CR_RETURN(38, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS);
                }
                n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
                TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
                pIn_buf_cur += n;
                pOut_buf_cur += n;
                counter -= (mz_uint)n;
            }
        }
        else if (r->m_type == 3)
        {
            TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
        }
        else
        {
            if (r->m_type == 1)
            {
                mz_uint8 *p = r->m_code_size_0;
                mz_uint i;
                r->m_table_sizes[0] = 288;
                r->m_table_sizes[1] = 32;
                TINFL_MEMSET(r->m_code_size_1, 5, 32);
                for (i = 0; i <= 143; ++i)
                    *p++ = 8;
                for (; i <= 255; ++i)
                    *p++ = 9;
                for (; i <= 279; ++i)
                    *p++ = 7;
                for (; i <= 287; ++i)
                    *p++ = 8;
            }
            else
            {
                for (counter = 0; counter < 3; counter++)
                {
                    TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
                    r->m_table_sizes[counter] += s_min_table_sizes[counter];
                }
                MZ_CLEAR_ARR(r->m_code_size_2);
                for (counter = 0; counter < r->m_table_sizes[2]; counter++)
                {
                    mz_uint s;
                    TINFL_GET_BITS(14, s, 3);
                    r->m_code_size_2[s_length_dezigzag[counter]] = (mz_uint8)s;
                }
                r->m_table_sizes[2] = 19;
            }
            for (; (int)r->m_type >= 0; r->m_type--)
            {
                int tree_next, tree_cur;
                mz_int16 *pLookUp;
                mz_int16 *pTree;
                mz_uint8 *pCode_size;
                mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16];
                pLookUp = r->m_look_up[r->m_type];
                pTree = pTrees[r->m_type];
                pCode_size = pCode_sizes[r->m_type];
                MZ_CLEAR_ARR(total_syms);
                TINFL_MEMSET(pLookUp, 0, sizeof(r->m_look_up[0]));
                tinfl_clear_tree(r);
                for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
                    total_syms[pCode_size[i]]++;
                used_syms = 0, total = 0;
                next_code[0] = next_code[1] = 0;
                for (i = 1; i <= 15; ++i)
                {
                    used_syms += total_syms[i];
                    next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
                }
                if ((65536 != total) && (used_syms > 1))
                {
                    TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
                }
                for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
                {
                    mz_uint rev_code = 0, l, cur_code, code_size = pCode_size[sym_index];
                    if (!code_size)
                        continue;
                    cur_code = next_code[code_size]++;
                    for (l = code_size; l > 0; l--, cur_code >>= 1)
                        rev_code = (rev_code << 1) | (cur_code & 1);
                    if (code_size <= TINFL_FAST_LOOKUP_BITS)
                    {
                        mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                        while (rev_code < TINFL_FAST_LOOKUP_SIZE)
                        {
                            pLookUp[rev_code] = k;
                            rev_code += (1 << code_size);
                        }
                        continue;
                    }
                    if (0 == (tree_cur = pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)]))
                    {
                        pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                        tree_cur = tree_next;
                        tree_next -= 2;
                    }
                    rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
                    for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
                    {
                        tree_cur -= ((rev_code >>= 1) & 1);
                        if (!pTree[-tree_cur - 1])
                        {
                            pTree[-tree_cur - 1] = (mz_int16)tree_next;
                            tree_cur = tree_next;
                            tree_next -= 2;
                        }
                        else
                            tree_cur = pTree[-tree_cur - 1];
                    }
                    tree_cur -= ((rev_code >>= 1) & 1);
                    pTree[-tree_cur - 1] = (mz_int16)sym_index;
                }
                if (r->m_type == 2)
                {
                    for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);)
                    {
                        mz_uint s;
                        TINFL_HUFF_DECODE(16, dist, r->m_look_up[2], r->m_tree_2);
                        if (dist < 16)
                        {
                            r->m_len_codes[counter++] = (mz_uint8)dist;
                            continue;
                        }
                        if ((dist == 16) && (!counter))
                        {
                            TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
                        }
                        num_extra = "\02\03\07"[dist - 16];
                        TINFL_GET_BITS(18, s, num_extra);
                        s += "\03\03\013"[dist - 16];
                        TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
                        counter += s;
                    }
                    if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
                    {
                        TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
                    }
                    TINFL_MEMCPY(r->m_code_size_0, r->m_len_codes, r->m_table_sizes[0]);
                    TINFL_MEMCPY(r->m_code_size_1, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
                }
            }
            for (;;)
            {
                mz_uint8 *pSrc;
                for (;;)
                {
                    if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
                    {
                        TINFL_HUFF_DECODE(23, counter, r->m_look_up[0], r->m_tree_0);
                        if (counter >= 256)
                            break;
                        while (pOut_buf_cur >= pOut_buf_end)
                        {
                            TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
                        }
                        *pOut_buf_cur++ = (mz_uint8)counter;
                    }
                    else
                    {
                        int sym2;
                        mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
                        if (num_bits < 30)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 4;
                            num_bits += 32;
                        }
#else
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                        if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                            code_len = sym2 >> 9;
                        else
                        {
                            code_len = TINFL_FAST_LOOKUP_BITS;
                            do
                            {
                                sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                            } while (sym2 < 0);
                        }
                        counter = sym2;
                        bit_buf >>= code_len;
                        num_bits -= code_len;
                        if (counter & 256)
                            break;

#if !TINFL_USE_64BIT_BITBUF
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                        if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                            code_len = sym2 >> 9;
                        else
                        {
                            code_len = TINFL_FAST_LOOKUP_BITS;
                            do
                            {
                                sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                            } while (sym2 < 0);
                        }
                        bit_buf >>= code_len;
                        num_bits -= code_len;

                        pOut_buf_cur[0] = (mz_uint8)counter;
                        if (sym2 & 256)
                        {
                            pOut_buf_cur++;
                            counter = sym2;
                            break;
                        }
                        pOut_buf_cur[1] = (mz_uint8)sym2;
                        pOut_buf_cur += 2;
                    }
                }
                if ((counter &= 511) == 256)
                    break;

                num_extra = s_length_extra[counter - 257];
                counter = s_length_base[counter - 257];
                if (num_extra)
                {
                    mz_uint extra_bits;
                    TINFL_GET_BITS(25, extra_bits, num_extra);
                    counter += extra_bits;
                }

                TINFL_HUFF_DECODE(26, dist, r->m_look_up[1], r->m_tree_1);
                num_extra = s_dist_extra[dist];
                dist = s_dist_base[dist];
                if (num_extra)
                {
                    mz_uint extra_bits;
                    TINFL_GET_BITS(27, extra_bits, num_extra);
                    dist += extra_bits;
                }

                dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
                if ((dist == 0 || dist > dist_from_out_buf_start || dist_from_out_buf_start == 0) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
                {
                    TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
                }

                pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);

                if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
                {
                    while (counter--)
                    {
                        while (pOut_buf_cur >= pOut_buf_end)
                        {
                            TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
                        }
                        *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
                    }
                    continue;
                }
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
                else if ((counter >= 9) && (counter <= dist))
                {
                    const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
                    do
                    {
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
						memcpy(pOut_buf_cur, pSrc, sizeof(mz_uint32)*2);
#else
                        ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
                        ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
#endif
                        pOut_buf_cur += 8;
                    } while ((pSrc += 8) < pSrc_end);
                    if ((counter &= 7) < 3)
                    {
                        if (counter)
                        {
                            pOut_buf_cur[0] = pSrc[0];
                            if (counter > 1)
                                pOut_buf_cur[1] = pSrc[1];
                            pOut_buf_cur += counter;
                        }
                        continue;
                    }
                }
#endif
                while(counter>2)
                {
                    pOut_buf_cur[0] = pSrc[0];
                    pOut_buf_cur[1] = pSrc[1];
                    pOut_buf_cur[2] = pSrc[2];
                    pOut_buf_cur += 3;
                    pSrc += 3;
					counter -= 3;
                }
                if (counter > 0)
                {
                    pOut_buf_cur[0] = pSrc[0];
                    if (counter > 1)
                        pOut_buf_cur[1] = pSrc[1];
                    pOut_buf_cur += counter;
                }
            }
        }
    } while (!(r->m_final & 1));

    /* Ensure byte alignment and put back any bytes from the bitbuf if we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
    /* I'm being super conservative here. A number of simplifications can be made to the byte alignment part, and the Adler32 check shouldn't ever need to worry about reading from the bitbuf now. */
    TINFL_SKIP_BITS(32, num_bits & 7);
    while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
    {
        --pIn_buf_cur;
        num_bits -= 8;
    }
    bit_buf &= ~(~(tinfl_bit_buf_t)0 << num_bits);
    MZ_ASSERT(!num_bits); /* if this assert fires then we've read beyond the end of non-deflate/zlib streams with following data (such as gzip streams). */

    if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
    {
        for (counter = 0; counter < 4; ++counter)
        {
            mz_uint s;
            if (num_bits)
                TINFL_GET_BITS(41, s, 8);
            else
                TINFL_GET_BYTE(42, s);
            r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
        }
    }
    TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);

    TINFL_CR_FINISH

common_exit:
    /* As long as we aren't telling the caller that we NEED more input to make forward progress: */
    /* Put back any bytes from the bitbuf in case we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
    /* We need to be very careful here to NOT push back any bytes we definitely know we need to make forward progress, though, or we'll lock the caller up into an inf loop. */
    if ((status != TINFL_STATUS_NEEDS_MORE_INPUT) && (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS))
    {
        while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
        {
            --pIn_buf_cur;
            num_bits -= 8;
        }
    }
    r->m_num_bits = num_bits;
    r->m_bit_buf = bit_buf & ~(~(tinfl_bit_buf_t)0 << num_bits);
    r->m_dist = dist;
    r->m_counter = counter;
    r->m_num_extra = num_extra;
    r->m_dist_from_out_buf_start = dist_from_out_buf_start;
    *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
    *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
    if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
    {
        const mz_uint8 *ptr = pOut_buf_next;
        size_t buf_len = *pOut_buf_size;
        mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16;
        size_t block_len = buf_len % 5552;
        while (buf_len)
        {
            for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
            {
                s1 += ptr[0], s2 += s1;
                s1 += ptr[1], s2 += s1;
                s1 += ptr[2], s2 += s1;
                s1 += ptr[3], s2 += s1;
                s1 += ptr[4], s2 += s1;
                s1 += ptr[5], s2 += s1;
                s1 += ptr[6], s2 += s1;
                s1 += ptr[7], s2 += s1;
            }
            for (; i < block_len; ++i)
                s1 += *ptr++, s2 += s1;
            s1 %= 65521U, s2 %= 65521U;
            buf_len -= block_len;
            block_len = 5552;
        }
        r->m_check_adler32 = (s2 << 16) + s1;
        if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32))
            status = TINFL_STATUS_ADLER32_MISMATCH;
    }
    return status;
}

/* Higher level helper functions. */
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
    tinfl_decompressor decomp;
    void *pBuf = NULL, *pNew_buf;
    size_t src_buf_ofs = 0, out_buf_capacity = 0;
    *pOut_len = 0;
    tinfl_init(&decomp);
    for (;;)
    {
        size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,
                                               (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
        if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
        {
            MZ_FREE(pBuf);
            *pOut_len = 0;
            return NULL;
        }
        src_buf_ofs += src_buf_size;
        *pOut_len += dst_buf_size;
        if (status == TINFL_STATUS_DONE)
            break;
        new_out_buf_capacity = out_buf_capacity * 2;
        if (new_out_buf_capacity < 128)
            new_out_buf_capacity = 128;
        pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
        if (!pNew_buf)
        {
            MZ_FREE(pBuf);
            *pOut_len = 0;
            return NULL;
        }
        pBuf = pNew_buf;
        out_buf_capacity = new_out_buf_capacity;
    }
    return pBuf;
}

size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
    tinfl_decompressor decomp;
    tinfl_status status;
    tinfl_init(&decomp);
    status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
    return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
}

int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    int result = 0;
    tinfl_decompressor decomp;
    mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
    size_t in_buf_ofs = 0, dict_ofs = 0;
    if (!pDict)
        return TINFL_STATUS_FAILED;
    memset(pDict,0,TINFL_LZ_DICT_SIZE);
    tinfl_init(&decomp);
    for (;;)
    {
        size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
                                               (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
        in_buf_ofs += in_buf_size;
        if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
            break;
        if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
        {
            result = (status == TINFL_STATUS_DONE);
            break;
        }
        dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
    }
    MZ_FREE(pDict);
    *pIn_buf_size = in_buf_ofs;
    return result;
}

#ifndef MINIZ_NO_MALLOC
tinfl_decompressor *tinfl_decompressor_alloc(void)
{
    tinfl_decompressor *pDecomp = (tinfl_decompressor *)MZ_MALLOC(sizeof(tinfl_decompressor));
    if (pDecomp)
        tinfl_init(pDecomp);
    return pDecomp;
}

void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
{
    MZ_FREE(pDecomp);
}
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/
 /**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * Copyright 2016 Martin Raiber
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/


#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- .ZIP archive reading */

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <sys/stat.h>

#if defined(_MSC_VER) || defined(__MINGW64__)

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

static WCHAR* mz_utf8z_to_widechar(const char* str)
{
  int reqChars = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);
  WCHAR* wStr = (WCHAR*)malloc(reqChars * sizeof(WCHAR));
  MultiByteToWideChar(CP_UTF8, 0, str, -1, wStr, sizeof(WCHAR) * reqChars);
  return wStr;
}

static FILE *mz_fopen(const char *pFilename, const char *pMode)
{
  WCHAR* wFilename = mz_utf8z_to_widechar(pFilename);
  WCHAR* wMode = mz_utf8z_to_widechar(pMode);
  FILE* pFile = NULL;
  errno_t err = _wfopen_s(&pFile, wFilename, wMode);
  free(wFilename);
  free(wMode);
  return err ? NULL : pFile;
}

static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
{
  WCHAR* wPath = mz_utf8z_to_widechar(pPath);
  WCHAR* wMode = mz_utf8z_to_widechar(pMode);
  FILE* pFile = NULL;
  errno_t err = _wfreopen_s(&pFile, wPath, wMode, pStream);
  free(wPath);
  free(wMode);
  return err ? NULL : pFile;
}

static int mz_stat64(const char *path, struct __stat64 *buffer)
{
  WCHAR* wPath = mz_utf8z_to_widechar(path);
  int res = _wstat64(wPath, buffer);
  free(wPath);
  return res;
}

#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN mz_fopen
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT _stat64
#define MZ_FILE_STAT mz_stat64 
#define MZ_FFLUSH fflush
#define MZ_FREOPEN mz_freopen
#define MZ_DELETE_FILE remove

#elif defined(__MINGW32__) || defined(__WATCOMC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__TINYC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__USE_LARGEFILE64) /* gcc, clang */
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen64(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello64
#define MZ_FSEEK64 fseeko64
#define MZ_FILE_STAT_STRUCT stat64
#define MZ_FILE_STAT stat64
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__APPLE__) || defined(__FreeBSD__)
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen(p, m, s)
#define MZ_DELETE_FILE remove

#else
//#pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#ifdef __STRICT_ANSI__
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#else
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#endif
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#endif /* #ifdef _MSC_VER */
#endif /* #ifdef MINIZ_NO_STDIO */

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

/* Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. */
enum
{
    /* ZIP archive identifiers and record sizes */
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,

    /* ZIP64 archive identifier and record sizes */
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
    MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
    MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
    MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
    MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,

    /* Central directory header record offsets */
    MZ_ZIP_CDH_SIG_OFS = 0,
    MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
    MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
    MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
    MZ_ZIP_CDH_METHOD_OFS = 10,
    MZ_ZIP_CDH_FILE_TIME_OFS = 12,
    MZ_ZIP_CDH_FILE_DATE_OFS = 14,
    MZ_ZIP_CDH_CRC32_OFS = 16,
    MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
    MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
    MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
    MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
    MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
    MZ_ZIP_CDH_DISK_START_OFS = 34,
    MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
    MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
    MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,

    /* Local directory header offsets */
    MZ_ZIP_LDH_SIG_OFS = 0,
    MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
    MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
    MZ_ZIP_LDH_METHOD_OFS = 8,
    MZ_ZIP_LDH_FILE_TIME_OFS = 10,
    MZ_ZIP_LDH_FILE_DATE_OFS = 12,
    MZ_ZIP_LDH_CRC32_OFS = 14,
    MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
    MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
    MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
    MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
    MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,

    /* End of central directory offsets */
    MZ_ZIP_ECDH_SIG_OFS = 0,
    MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
    MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
    MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
    MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
    MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
    MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
    MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,

    /* ZIP64 End of central directory locator offsets */
    MZ_ZIP64_ECDL_SIG_OFS = 0,                    /* 4 bytes */
    MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,          /* 4 bytes */
    MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,  /* 8 bytes */
    MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16, /* 4 bytes */

    /* ZIP64 End of central directory header offsets */
    MZ_ZIP64_ECDH_SIG_OFS = 0,                       /* 4 bytes */
    MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,            /* 8 bytes */
    MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,          /* 2 bytes */
    MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,           /* 2 bytes */
    MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,            /* 4 bytes */
    MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,            /* 4 bytes */
    MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24, /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,       /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,                /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,                 /* 8 bytes */
    MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
    MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
};

typedef struct
{
    void *m_p;
    size_t m_size, m_capacity;
    mz_uint m_element_size;
} mz_zip_array;

struct mz_zip_internal_state_tag
{
    mz_zip_array m_central_dir;
    mz_zip_array m_central_dir_offsets;
    mz_zip_array m_sorted_central_dir_offsets;

    /* The flags passed in when the archive is initially opened. */
    mz_uint32 m_init_flags;

    /* MZ_TRUE if the archive has a zip64 end of central directory headers, etc. */
    mz_bool m_zip64;

    /* MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) */
    mz_bool m_zip64_has_extended_info_fields;

    /* These fields are used by the file, FILE, memory, and memory/heap read/write helpers. */
    MZ_FILE *m_pFile;
    mz_uint64 m_file_archive_start_ofs;

    void *m_pMem;
    size_t m_mem_size;
    size_t m_mem_capacity;
};

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size

#if defined(DEBUG) || defined(_DEBUG)
static MZ_FORCEINLINE mz_uint mz_zip_array_range_check(const mz_zip_array *pArray, mz_uint index)
{
    MZ_ASSERT(index < pArray->m_size);
    return index;
}
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[mz_zip_array_range_check(array_ptr, index)]
#else
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
#endif

static MZ_FORCEINLINE void mz_zip_array_init(mz_zip_array *pArray, mz_uint32 element_size)
{
    memset(pArray, 0, sizeof(mz_zip_array));
    pArray->m_element_size = element_size;
}

static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
{
    pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
    memset(pArray, 0, sizeof(mz_zip_array));
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
{
    void *pNew_p;
    size_t new_capacity = min_new_capacity;
    MZ_ASSERT(pArray->m_element_size);
    if (pArray->m_capacity >= min_new_capacity)
        return MZ_TRUE;
    if (growing)
    {
        new_capacity = MZ_MAX(1, pArray->m_capacity);
        while (new_capacity < min_new_capacity)
            new_capacity *= 2;
    }
    if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity)))
        return MZ_FALSE;
    pArray->m_p = pNew_p;
    pArray->m_capacity = new_capacity;
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
{
    if (new_capacity > pArray->m_capacity)
    {
        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
            return MZ_FALSE;
    }
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
{
    if (new_size > pArray->m_capacity)
    {
        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
            return MZ_FALSE;
    }
    pArray->m_size = new_size;
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
{
    return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
}

static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
{
    size_t orig_size = pArray->m_size;
    if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
        return MZ_FALSE;
    if (n > 0)
        memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
    return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
{
    struct tm tm;
    memset(&tm, 0, sizeof(tm));
    tm.tm_isdst = -1;
    tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
    tm.tm_mon = ((dos_date >> 5) & 15) - 1;
    tm.tm_mday = dos_date & 31;
    tm.tm_hour = (dos_time >> 11) & 31;
    tm.tm_min = (dos_time >> 5) & 63;
    tm.tm_sec = (dos_time << 1) & 62;
    return mktime(&tm);
}

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
static void mz_zip_time_t_to_dos_time(MZ_TIME_T time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef _MSC_VER
    struct tm tm_struct;
    struct tm *tm = &tm_struct;
    errno_t err = localtime_s(tm, &time);
    if (err)
    {
        *pDOS_date = 0;
        *pDOS_time = 0;
        return;
    }
#else
    struct tm *tm = localtime(&time);
#endif /* #ifdef _MSC_VER */

    *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
    *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
}
#endif /* MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifndef MINIZ_NO_STDIO
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
static mz_bool mz_zip_get_file_modified_time(const char *pFilename, MZ_TIME_T *pTime)
{
    struct MZ_FILE_STAT_STRUCT file_stat;

    /* On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. */
    if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
        return MZ_FALSE;

    *pTime = file_stat.st_mtime;

    return MZ_TRUE;
}
#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS*/

static mz_bool mz_zip_set_file_times(const char *pFilename, MZ_TIME_T access_time, MZ_TIME_T modified_time)
{
    struct utimbuf t;

    memset(&t, 0, sizeof(t));
    t.actime = access_time;
    t.modtime = modified_time;

    return !utime(pFilename, &t);
}
#endif /* #ifndef MINIZ_NO_STDIO */
#endif /* #ifndef MINIZ_NO_TIME */

static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)
{
    if (pZip)
        pZip->m_last_error = err_num;
    return MZ_FALSE;
}

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint flags)
{
    (void)flags;
    if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!pZip->m_pAlloc)
        pZip->m_pAlloc = miniz_def_alloc_func;
    if (!pZip->m_pFree)
        pZip->m_pFree = miniz_def_free_func;
    if (!pZip->m_pRealloc)
        pZip->m_pRealloc = miniz_def_realloc_func;

    pZip->m_archive_size = 0;
    pZip->m_central_directory_file_ofs = 0;
    pZip->m_total_files = 0;
    pZip->m_last_error = MZ_ZIP_NO_ERROR;

    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
    pZip->m_pState->m_init_flags = flags;
    pZip->m_pState->m_zip64 = MZ_FALSE;
    pZip->m_pState->m_zip64_has_extended_info_fields = MZ_FALSE;

    pZip->m_zip_mode = MZ_ZIP_MODE_READING;

    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
{
    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
    const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    mz_uint8 l = 0, r = 0;
    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pE = pL + MZ_MIN(l_len, r_len);
    while (pL < pE)
    {
        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
            break;
        pL++;
        pR++;
    }
    return (pL == pE) ? (l_len < r_len) : (l < r);
}

#define MZ_SWAP_UINT32(a, b) \
    do                       \
    {                        \
        mz_uint32 t = a;     \
        a = b;               \
        b = t;               \
    }                        \
    MZ_MACRO_END

/* Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.) */
static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
    mz_uint32 *pIndices;
    mz_uint32 start, end;
    const mz_uint32 size = pZip->m_total_files;

    if (size <= 1U)
        return;

    pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);

    start = (size - 2U) >> 1U;
    for (;;)
    {
        mz_uint64 child, root = start;
        for (;;)
        {
            if ((child = (root << 1U) + 1U) >= size)
                break;
            child += (((child + 1U) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U])));
            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                break;
            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
            root = child;
        }
        if (!start)
            break;
        start--;
    }

    end = size - 1;
    while (end > 0)
    {
        mz_uint64 child, root = 0;
        MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
        for (;;)
        {
            if ((child = (root << 1U) + 1U) >= end)
                break;
            child += (((child + 1U) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U]));
            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                break;
            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
            root = child;
        }
        end--;
    }
}

static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip, mz_uint32 record_sig, mz_uint32 record_size, mz_int64 *pOfs)
{
    mz_int64 cur_file_ofs;
    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;

    /* Basic sanity checks - reject files which are too small */
    if (pZip->m_archive_size < record_size)
        return MZ_FALSE;

    /* Find the record by scanning the file from the end towards the beginning. */
    cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
    for (;;)
    {
        int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);

        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
            return MZ_FALSE;

        for (i = n - 4; i >= 0; --i)
        {
            mz_uint s = MZ_READ_LE32(pBuf + i);
            if (s == record_sig)
            {
                if ((pZip->m_archive_size - (cur_file_ofs + i)) >= record_size)
                    break;
            }
        }

        if (i >= 0)
        {
            cur_file_ofs += i;
            break;
        }

        /* Give up if we've searched the entire file, or we've gone back "too far" (~64kb) */
        if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (MZ_UINT16_MAX + record_size)))
            return MZ_FALSE;

        cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
    }

    *pOfs = cur_file_ofs;
    return MZ_TRUE;
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint flags)
{
    mz_uint cdir_size = 0, cdir_entries_on_this_disk = 0, num_this_disk = 0, cdir_disk_index = 0;
    mz_uint64 cdir_ofs = 0;
    mz_int64 cur_file_ofs = 0;
    const mz_uint8 *p;

    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
    mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
    mz_uint32 zip64_end_of_central_dir_locator_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pZip64_locator = (mz_uint8 *)zip64_end_of_central_dir_locator_u32;

    mz_uint32 zip64_end_of_central_dir_header_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pZip64_end_of_central_dir = (mz_uint8 *)zip64_end_of_central_dir_header_u32;

    mz_uint64 zip64_end_of_central_dir_ofs = 0;

    /* Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. */
    if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (!mz_zip_reader_locate_header_sig(pZip, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE, &cur_file_ofs))
        return mz_zip_set_error(pZip, MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);

    /* Read and verify the end of central directory record. */
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (cur_file_ofs >= (MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs - MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE, pZip64_locator, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
        {
            if (MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG)
            {
                zip64_end_of_central_dir_ofs = MZ_READ_LE64(pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS);
                if (zip64_end_of_central_dir_ofs > (pZip->m_archive_size - MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
                    return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

                if (pZip->m_pRead(pZip->m_pIO_opaque, zip64_end_of_central_dir_ofs, pZip64_end_of_central_dir, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
                {
                    if (MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG)
                    {
                        pZip->m_pState->m_zip64 = MZ_TRUE;
                    }
                }
            }
        }
    }

    pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS);
    cdir_entries_on_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
    num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
    cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
    cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS);
    cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);

    if (pZip->m_pState->m_zip64)
    {
        mz_uint32 zip64_total_num_of_disks = MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS);
        mz_uint64 zip64_cdir_total_entries = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS);
        mz_uint64 zip64_cdir_total_entries_on_this_disk = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
        mz_uint64 zip64_size_of_end_of_central_dir_record = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS);
        mz_uint64 zip64_size_of_central_directory = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS);

        if (zip64_size_of_end_of_central_dir_record < (MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if (zip64_total_num_of_disks != 1U)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

        /* Check for miniz's practical limits */
        if (zip64_cdir_total_entries > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;

        if (zip64_cdir_total_entries_on_this_disk > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;

        /* Check for miniz's current practical limits (sorry, this should be enough for millions of files) */
        if (zip64_size_of_central_directory > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        cdir_size = (mz_uint32)zip64_size_of_central_directory;

        num_this_disk = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS);

        cdir_disk_index = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS);

        cdir_ofs = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS);
    }

    if (pZip->m_total_files != cdir_entries_on_this_disk)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

    if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

    if (cdir_size < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    pZip->m_central_directory_file_ofs = cdir_ofs;

    if (pZip->m_total_files)
    {
        mz_uint i, n;
        /* Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. */
        if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
            (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if (sort_central_dir)
        {
            if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        /* Now create an index into the central directory file records, do some basic sanity checking on each record */
        p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
        for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
        {
            mz_uint total_header_size, disk_index, bit_flags, filename_size, ext_data_size;
            mz_uint64 comp_size, decomp_size, local_header_ofs;

            if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);

            if (sort_central_dir)
                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;

            comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
            decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
            local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
            filename_size = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
            ext_data_size = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

            if ((!pZip->m_pState->m_zip64_has_extended_info_fields) &&
                (ext_data_size) &&
                (MZ_MAX(MZ_MAX(comp_size, decomp_size), local_header_ofs) == MZ_UINT32_MAX))
            {
                /* Attempt to find zip64 extended information field in the entry's extra data */
                mz_uint32 extra_size_remaining = ext_data_size;

                if (extra_size_remaining)
                {
					const mz_uint8 *pExtra_data;
					void* buf = NULL;

					if (MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + ext_data_size > n)
					{
						buf = MZ_MALLOC(ext_data_size);
						if(buf==NULL)
							return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

						if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size, buf, ext_data_size) != ext_data_size)
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
						}

						pExtra_data = (mz_uint8*)buf;
					}
					else
					{
						pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size;
					}

                    do
                    {
                        mz_uint32 field_id;
                        mz_uint32 field_data_size;

						if (extra_size_remaining < (sizeof(mz_uint16) * 2))
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
						}

                        field_id = MZ_READ_LE16(pExtra_data);
                        field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

						if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
						}

                        if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                        {
                            /* Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). */
                            pZip->m_pState->m_zip64 = MZ_TRUE;
                            pZip->m_pState->m_zip64_has_extended_info_fields = MZ_TRUE;
                            break;
                        }

                        pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                        extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
                    } while (extra_size_remaining);

					MZ_FREE(buf);
                }
            }

            /* I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh */
            if ((comp_size != MZ_UINT32_MAX) && (decomp_size != MZ_UINT32_MAX))
            {
                if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
            if ((disk_index == MZ_UINT16_MAX) || ((disk_index != num_this_disk) && (disk_index != 1)))
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

            if (comp_size != MZ_UINT32_MAX)
            {
                if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            bit_flags = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
            if (bit_flags & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED)
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

            if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            n -= total_header_size;
            p += total_header_size;
        }
    }

    if (sort_central_dir)
        mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

    return MZ_TRUE;
}

void mz_zip_zero_struct(mz_zip_archive *pZip)
{
    if (pZip)
        MZ_CLEAR_PTR(pZip);
}

static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
{
    mz_bool status = MZ_TRUE;

    if (!pZip)
        return MZ_FALSE;

    if ((!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    {
        if (set_last_error)
            pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;

        return MZ_FALSE;
    }

    if (pZip->m_pState)
    {
        mz_zip_internal_state *pState = pZip->m_pState;
        pZip->m_pState = NULL;

        mz_zip_array_clear(pZip, &pState->m_central_dir);
        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
        if (pState->m_pFile)
        {
            if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
            {
                if (MZ_FCLOSE(pState->m_pFile) == EOF)
                {
                    if (set_last_error)
                        pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
                    status = MZ_FALSE;
                }
            }
            pState->m_pFile = NULL;
        }
#endif /* #ifndef MINIZ_NO_STDIO */

        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
    }
    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

    return status;
}

mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
{
    return mz_zip_reader_end_internal(pZip, MZ_TRUE);
}
mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
{
    if ((!pZip) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
    pZip->m_archive_size = size;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}

mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags)
{
    if (!pMem)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
    pZip->m_archive_size = size;
    pZip->m_pRead = mz_zip_mem_read_func;
    pZip->m_pIO_opaque = pZip;
    pZip->m_pNeeds_keepalive = NULL;

#ifdef __cplusplus
    pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
    pZip->m_pState->m_pMem = (void *)pMem;
#endif

    pZip->m_pState->m_mem_size = size;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

    file_ofs += pZip->m_pState->m_file_archive_start_ofs;

    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
        return 0;

    return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
{
    return mz_zip_reader_init_file_v2(pZip, pFilename, flags, 0, 0);
}

mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size)
{
    mz_uint64 file_size;
    MZ_FILE *pFile;

    if ((!pZip) || (!pFilename) || ((archive_size) && (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pFile = MZ_FOPEN(pFilename, "rb");
    if (!pFile)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    file_size = archive_size;
    if (!file_size)
    {
        if (MZ_FSEEK64(pFile, 0, SEEK_END))
        {
            MZ_FCLOSE(pFile);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
        }

        file_size = MZ_FTELL64(pFile);
    }

    /* TODO: Better sanity check archive_size and the # of actual remaining bytes */

    if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    {
	MZ_FCLOSE(pFile);
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
    }

    if (!mz_zip_reader_init_internal(pZip, flags))
    {
        MZ_FCLOSE(pFile);
        return MZ_FALSE;
    }

    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
    pZip->m_pRead = mz_zip_file_read_func;
    pZip->m_pIO_opaque = pZip;
    pZip->m_pState->m_pFile = pFile;
    pZip->m_archive_size = file_size;
    pZip->m_pState->m_file_archive_start_ofs = file_start_ofs;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags)
{
    mz_uint64 cur_file_ofs;

    if ((!pZip) || (!pFile))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    cur_file_ofs = MZ_FTELL64(pFile);

    if (!archive_size)
    {
        if (MZ_FSEEK64(pFile, 0, SEEK_END))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);

        archive_size = MZ_FTELL64(pFile) - cur_file_ofs;

        if (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
    }

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
    pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;
    pZip->m_pState->m_pFile = pFile;
    pZip->m_archive_size = archive_size;
    pZip->m_pState->m_file_archive_start_ofs = cur_file_ofs;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

#endif /* #ifndef MINIZ_NO_STDIO */

static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
{
    if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))
        return NULL;
    return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
}

mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint m_bit_flag;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
    return (m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != 0;
}

mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint bit_flag;
    mz_uint method;

    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
    bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);

    if ((method != 0) && (method != MZ_DEFLATED))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
        return MZ_FALSE;
    }

    if (bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
        return MZ_FALSE;
    }

    if (bit_flag & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint filename_len, attribute_mapping_id, external_attr;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    if (filename_len)
    {
        if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
            return MZ_TRUE;
    }

    /* Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct. */
    /* Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field. */
    /* FIXME: Remove this check? Is it necessary - we already check the filename. */
    attribute_mapping_id = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS) >> 8;
    (void)attribute_mapping_id;

    external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
    if ((external_attr & MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != 0)
    {
        return MZ_TRUE;
    }

    return MZ_FALSE;
}

static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_index, const mz_uint8 *pCentral_dir_header, mz_zip_archive_file_stat *pStat, mz_bool *pFound_zip64_extra_data)
{
    mz_uint n;
    const mz_uint8 *p = pCentral_dir_header;

    if (pFound_zip64_extra_data)
        *pFound_zip64_extra_data = MZ_FALSE;

    if ((!p) || (!pStat))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Extract fields from the central directory record. */
    pStat->m_file_index = file_index;
    pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
    pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
    pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
    pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
    pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
    pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
    pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
    pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
    pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
    pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
    pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
    pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

    /* Copy as much of the filename and comment as possible. */
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
    memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pStat->m_filename[n] = '\0';

    n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
    pStat->m_comment_size = n;
    memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
    pStat->m_comment[n] = '\0';

    /* Set some flags for convienance */
    pStat->m_is_directory = mz_zip_reader_is_file_a_directory(pZip, file_index);
    pStat->m_is_encrypted = mz_zip_reader_is_file_encrypted(pZip, file_index);
    pStat->m_is_supported = mz_zip_reader_is_file_supported(pZip, file_index);

    /* See if we need to read any zip64 extended information fields. */
    /* Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). */
    if (MZ_MAX(MZ_MAX(pStat->m_comp_size, pStat->m_uncomp_size), pStat->m_local_header_ofs) == MZ_UINT32_MAX)
    {
        /* Attempt to find zip64 extended information field in the entry's extra data */
        mz_uint32 extra_size_remaining = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

        if (extra_size_remaining)
        {
            const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);

            do
            {
                mz_uint32 field_id;
                mz_uint32 field_data_size;

                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                field_id = MZ_READ_LE16(pExtra_data);
                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

                if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                {
                    const mz_uint8 *pField_data = pExtra_data + sizeof(mz_uint16) * 2;
                    mz_uint32 field_data_remaining = field_data_size;

                    if (pFound_zip64_extra_data)
                        *pFound_zip64_extra_data = MZ_TRUE;

                    if (pStat->m_uncomp_size == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_uncomp_size = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    if (pStat->m_comp_size == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_comp_size = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    if (pStat->m_local_header_ofs == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    break;
                }

                pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
            } while (extra_size_remaining);
        }
    }

    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
{
    mz_uint i;
    if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
        return 0 == memcmp(pA, pB, len);
    for (i = 0; i < len; ++i)
        if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
            return MZ_FALSE;
    return MZ_TRUE;
}

static MZ_FORCEINLINE int mz_zip_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
{
    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    mz_uint8 l = 0, r = 0;
    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pE = pL + MZ_MIN(l_len, r_len);
    while (pL < pE)
    {
        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
            break;
        pL++;
        pR++;
    }
    return (pL == pE) ? (int)(l_len - r_len) : (l - r);
}

static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename, mz_uint32 *pIndex)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
    mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
    const mz_uint32 size = pZip->m_total_files;
    const mz_uint filename_len = (mz_uint)strlen(pFilename);

    if (pIndex)
        *pIndex = 0;

    if (size)
    {
        /* yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and */
        /* honestly the major expense here on 32-bit CPU's will still be the filename compare */
        mz_int64 l = 0, h = (mz_int64)size - 1;

        while (l <= h)
        {
            mz_int64 m = l + ((h - l) >> 1);
            mz_uint32 file_index = pIndices[(mz_uint32)m];

            int comp = mz_zip_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
            if (!comp)
            {
                if (pIndex)
                    *pIndex = file_index;
                return MZ_TRUE;
            }
            else if (comp < 0)
                l = m + 1;
            else
                h = m - 1;
        }
    }

    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
}

int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
{
    mz_uint32 index;
    if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index))
        return -1;
    else
        return (int)index;
}

mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
{
    mz_uint file_index;
    size_t name_len, comment_len;

    if (pIndex)
        *pIndex = 0;

    if ((!pZip) || (!pZip->m_pState) || (!pName))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* See if we can use a binary search */
    if (((pZip->m_pState->m_init_flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0) &&
        (pZip->m_zip_mode == MZ_ZIP_MODE_READING) &&
        ((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
    {
        return mz_zip_locate_file_binary_search(pZip, pName, pIndex);
    }

    /* Locate the entry by scanning the entire central directory */
    name_len = strlen(pName);
    if (name_len > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    comment_len = pComment ? strlen(pComment) : 0;
    if (comment_len > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    for (file_index = 0; file_index < pZip->m_total_files; file_index++)
    {
        const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
        mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        if (filename_len < name_len)
            continue;
        if (comment_len)
        {
            mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
            const char *pFile_comment = pFilename + filename_len + file_extra_len;
            if ((file_comment_len != comment_len) || (!mz_zip_string_equal(pComment, pFile_comment, file_comment_len, flags)))
                continue;
        }
        if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
        {
            int ofs = filename_len - 1;
            do
            {
                if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
                    break;
            } while (--ofs >= 0);
            ofs++;
            pFilename += ofs;
            filename_len -= ofs;
        }
        if ((filename_len == name_len) && (mz_zip_string_equal(pName, pFilename, filename_len, flags)))
        {
            if (pIndex)
                *pIndex = file_index;
            return MZ_TRUE;
        }
    }

    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
}

static
mz_bool mz_zip_reader_extract_to_mem_no_alloc1(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size, const mz_zip_archive_file_stat *st)
{
    int status = TINFL_STATUS_DONE;
    mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    tinfl_decompressor inflator;

    if ((!pZip) || (!pZip->m_pState) || ((buf_size) && (!pBuf)) || ((user_read_buf_size) && (!pUser_read_buf)) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (st) {
        file_stat = *st;
    } else
    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    /* Ensure supplied output buffer is large enough. */
    needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
    if (buf_size < needed_size)
        return mz_zip_set_error(pZip, MZ_ZIP_BUF_TOO_SMALL);

    /* Read and parse the local directory entry. */
    cur_file_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data. */
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) == 0)
        {
            if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
                return mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
        }
#endif

        return MZ_TRUE;
    }

    /* Decompress the file either directly from memory or from a file input buffer. */
    tinfl_init(&inflator);

    if (pZip->m_pState->m_pMem)
    {
        /* Read directly from the archive in memory. */
        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        read_buf_size = read_buf_avail = file_stat.m_comp_size;
        comp_remaining = 0;
    }
    else if (pUser_read_buf)
    {
        /* Use a user provided read buffer. */
        if (!user_read_buf_size)
            return MZ_FALSE;
        pRead_buf = (mz_uint8 *)pUser_read_buf;
        read_buf_size = user_read_buf_size;
        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }
    else
    {
        /* Temporarily allocate a read buffer. */
        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
        if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }

    do
    {
        /* The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above */
        size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
        {
            read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
            {
                status = TINFL_STATUS_FAILED;
                mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                break;
            }
            cur_file_ofs += read_buf_avail;
            comp_remaining -= read_buf_avail;
            read_buf_ofs = 0;
        }
        in_buf_size = (size_t)read_buf_avail;
        status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
        read_buf_avail -= in_buf_size;
        read_buf_ofs += in_buf_size;
        out_buf_ofs += out_buf_size;
    } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

    if (status == TINFL_STATUS_DONE)
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (out_buf_ofs != file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
            status = TINFL_STATUS_FAILED;
        }
#endif
    }

    if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

    return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
}

mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return MZ_FALSE;
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
}

mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
{
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, NULL, 0, NULL);
}

mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
{
    return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
}

void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;
    mz_uint64 alloc_size;
    void *pBuf;

    if (pSize)
        *pSize = 0;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return NULL;

    alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
    if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
    {
        mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
        return NULL;
    }

    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        return NULL;
    }

    if (!mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, (size_t)alloc_size, flags, NULL, 0, &file_stat))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        return NULL;
    }

    if (pSize)
        *pSize = (size_t)alloc_size;
    return pBuf;
}

void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
    {
        if (pSize)
            *pSize = 0;
        return MZ_FALSE;
    }
    return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
}

mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
    int status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint file_crc32 = MZ_CRC32_INIT;
#endif
    mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf = NULL;
    void *pWrite_buf = NULL;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

    if ((!pZip) || (!pZip->m_pState) || (!pCallback) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    /* Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) */
    cur_file_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    /* Decompress the file either directly from memory or from a file input buffer. */
    if (pZip->m_pState->m_pMem)
    {
        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        read_buf_size = read_buf_avail = file_stat.m_comp_size;
        comp_remaining = 0;
    }
    else
    {
        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }

    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data. */
        if (pZip->m_pState->m_pMem)
        {
            if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > MZ_UINT32_MAX))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
            {
                mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                status = TINFL_STATUS_FAILED;
            }
            else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
            {
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
#endif
            }

            cur_file_ofs += file_stat.m_comp_size;
            out_buf_ofs += file_stat.m_comp_size;
            comp_remaining = 0;
        }
        else
        {
            while (comp_remaining)
            {
                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    status = TINFL_STATUS_FAILED;
                    break;
                }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
                {
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
                }
#endif

                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                    status = TINFL_STATUS_FAILED;
                    break;
                }

                cur_file_ofs += read_buf_avail;
                out_buf_ofs += read_buf_avail;
                comp_remaining -= read_buf_avail;
            }
        }
    }
    else
    {
        tinfl_decompressor inflator;
        tinfl_init(&inflator);

        if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            status = TINFL_STATUS_FAILED;
        }
        else
        {
            do
            {
                mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
                {
                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }
                    cur_file_ofs += read_buf_avail;
                    comp_remaining -= read_buf_avail;
                    read_buf_ofs = 0;
                }

                in_buf_size = (size_t)read_buf_avail;
                status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                read_buf_avail -= in_buf_size;
                read_buf_ofs += in_buf_size;

                if (out_buf_size)
                {
                    if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
#endif
                    if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }
                }
            } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
        }
    }

    if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (out_buf_ofs != file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (file_crc32 != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
            status = TINFL_STATUS_FAILED;
        }
#endif
    }

    if (!pZip->m_pState->m_pMem)
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

    if (pWrite_buf)
        pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

    return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
}

mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
    mz_zip_reader_extract_iter_state *pState;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

    /* Argument sanity check */
    if ((!pZip) || (!pZip->m_pState))
        return NULL;

    /* Allocate an iterator status structure */
    pState = (mz_zip_reader_extract_iter_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_reader_extract_iter_state));
    if (!pState)
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        return NULL;
    }

    /* Fetch file details */
    if (!mz_zip_reader_file_stat(pZip, file_index, &pState->file_stat))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Encryption and patch files are not supported. */
    if (pState->file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (pState->file_stat.m_method != 0) && (pState->file_stat.m_method != MZ_DEFLATED))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Init state - save args */
    pState->pZip = pZip;
    pState->flags = flags;

    /* Init state - reset variables to defaults */
    pState->status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    pState->file_crc32 = MZ_CRC32_INIT;
#endif
    pState->read_buf_ofs = 0;
    pState->out_buf_ofs = 0;
    pState->pRead_buf = NULL;
    pState->pWrite_buf = NULL;
    pState->out_blk_remain = 0;

    /* Read and parse the local directory entry. */
    pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, pState->cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    pState->cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((pState->cur_file_ofs + pState->file_stat.m_comp_size) > pZip->m_archive_size)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Decompress the file either directly from memory or from a file input buffer. */
    if (pZip->m_pState->m_pMem)
    {
        pState->pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + pState->cur_file_ofs;
        pState->read_buf_size = pState->read_buf_avail = pState->file_stat.m_comp_size;
        pState->comp_remaining = pState->file_stat.m_comp_size;
    }
    else
    {
        if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
        {
            /* Decompression required, therefore intermediate read buffer required */
            pState->read_buf_size = MZ_MIN(pState->file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
            if (NULL == (pState->pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)pState->read_buf_size)))
            {
                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
                return NULL;
            }
        }
        else
        {
            /* Decompression not required - we will be reading directly into user buffer, no temp buf required */
            pState->read_buf_size = 0;
        }
        pState->read_buf_avail = 0;
        pState->comp_remaining = pState->file_stat.m_comp_size;
    }

    if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
    {
        /* Decompression required, init decompressor */
        tinfl_init( &pState->inflator );

        /* Allocate write buffer */
        if (NULL == (pState->pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            if (pState->pRead_buf)
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState->pRead_buf);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }
    }

    return pState;
}

mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
{
    mz_uint32 file_index;

    /* Locate file index by name */
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return NULL;

    /* Construct iterator */
    return mz_zip_reader_extract_iter_new(pZip, file_index, flags);
}

size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size)
{
    size_t copied_to_caller = 0;

    /* Argument sanity check */
    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState) || (!pvBuf))
        return 0;

    if ((pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data, calc amount to return. */
        copied_to_caller = (size_t)MZ_MIN( buf_size, pState->comp_remaining );

        /* Zip is in memory....or requires reading from a file? */
        if (pState->pZip->m_pState->m_pMem)
        {
            /* Copy data to caller's buffer */
            memcpy( pvBuf, pState->pRead_buf, copied_to_caller );
            pState->pRead_buf = ((mz_uint8*)pState->pRead_buf) + copied_to_caller;
        }
        else
        {
            /* Read directly into caller's buffer */
            if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pvBuf, copied_to_caller) != copied_to_caller)
            {
                /* Failed to read all that was asked for, flag failure and alert user */
                mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                pState->status = TINFL_STATUS_FAILED;
                copied_to_caller = 0;
            }
        }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        /* Compute CRC if not returning compressed data only */
        if (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
            pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, (const mz_uint8 *)pvBuf, copied_to_caller);
#endif

        /* Advance offsets, dec counters */
        pState->cur_file_ofs += copied_to_caller;
        pState->out_buf_ofs += copied_to_caller;
        pState->comp_remaining -= copied_to_caller;
    }
    else
    {
        do
        {
            /* Calc ptr to write buffer - given current output pos and block size */
            mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

            /* Calc max output size - given current output pos and block size */
            size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

            if (!pState->out_blk_remain)
            {
                /* Read more data from file if none available (and reading from file) */
                if ((!pState->read_buf_avail) && (!pState->pZip->m_pState->m_pMem))
                {
                    /* Calc read size */
                    pState->read_buf_avail = MZ_MIN(pState->read_buf_size, pState->comp_remaining);
                    if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pState->pRead_buf, (size_t)pState->read_buf_avail) != pState->read_buf_avail)
                    {
                        mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                        pState->status = TINFL_STATUS_FAILED;
                        break;
                    }

                    /* Advance offsets, dec counters */
                    pState->cur_file_ofs += pState->read_buf_avail;
                    pState->comp_remaining -= pState->read_buf_avail;
                    pState->read_buf_ofs = 0;
                }

                /* Perform decompression */
                in_buf_size = (size_t)pState->read_buf_avail;
                pState->status = tinfl_decompress(&pState->inflator, (const mz_uint8 *)pState->pRead_buf + pState->read_buf_ofs, &in_buf_size, (mz_uint8 *)pState->pWrite_buf, pWrite_buf_cur, &out_buf_size, pState->comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                pState->read_buf_avail -= in_buf_size;
                pState->read_buf_ofs += in_buf_size;

                /* Update current output block size remaining */
                pState->out_blk_remain = out_buf_size;
            }

            if (pState->out_blk_remain)
            {
                /* Calc amount to return. */
                size_t to_copy = MZ_MIN( (buf_size - copied_to_caller), pState->out_blk_remain );

                /* Copy data to caller's buffer */
                memcpy( (mz_uint8*)pvBuf + copied_to_caller, pWrite_buf_cur, to_copy );

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                /* Perform CRC */
                pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, pWrite_buf_cur, to_copy);
#endif

                /* Decrement data consumed from block */
                pState->out_blk_remain -= to_copy;

                /* Inc output offset, while performing sanity check */
                if ((pState->out_buf_ofs += to_copy) > pState->file_stat.m_uncomp_size)
                {
                    mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                    pState->status = TINFL_STATUS_FAILED;
                    break;
                }

                /* Increment counter of data copied to caller */
                copied_to_caller += to_copy;
            }
        } while ( (copied_to_caller < buf_size) && ((pState->status == TINFL_STATUS_NEEDS_MORE_INPUT) || (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)) );
    }

    /* Return how many bytes were copied into user buffer */
    return copied_to_caller;
}

mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState)
{
    int status;

    /* Argument sanity check */
    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState))
        return MZ_FALSE;

    /* Was decompression completed and requested? */
    if ((pState->status == TINFL_STATUS_DONE) && (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pState->pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            pState->status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (pState->file_crc32 != pState->file_stat.m_crc32)
        {
            mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
            pState->status = TINFL_STATUS_FAILED;
        }
#endif
    }

    /* Free buffers */
    if (!pState->pZip->m_pState->m_pMem)
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pRead_buf);
    if (pState->pWrite_buf)
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pWrite_buf);

    /* Save status */
    status = pState->status;

    /* Free context */
    pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState);

    return status == TINFL_STATUS_DONE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
{
    (void)ofs;

    return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
}

mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
{
    mz_bool status;
    mz_zip_archive_file_stat file_stat;
    MZ_FILE *pFile;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    pFile = MZ_FOPEN(pDst_filename, "wb");
    if (!pFile)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);

    if (MZ_FCLOSE(pFile) == EOF)
    {
        if (status)
            mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);

        status = MZ_FALSE;
    }

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
    if (status)
        mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif

    return status;
}

mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
}

mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *pFile, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    return mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
}

mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_cfile(pZip, file_index, pFile, flags);
}
#endif /* #ifndef MINIZ_NO_STDIO */

static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}

mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;
    mz_zip_internal_state *pState;
    const mz_uint8 *pCentral_dir_header;
    mz_bool found_zip64_ext_data_in_cdir = MZ_FALSE;
    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    mz_uint64 local_header_ofs = 0;
    mz_uint32 local_header_filename_len, local_header_extra_len, local_header_crc32;
    mz_uint64 local_header_comp_size, local_header_uncomp_size;
    mz_uint32 uncomp_crc32 = MZ_CRC32_INIT;
    mz_bool has_data_descriptor;
    mz_uint32 local_header_bit_flags;

    mz_zip_array file_data_array;
    mz_zip_array_init(&file_data_array, 1);

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (file_index > pZip->m_total_files)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    pCentral_dir_header = mz_zip_get_cdh(pZip, file_index);

    if (!mz_zip_file_stat_internal(pZip, file_index, pCentral_dir_header, &file_stat, &found_zip64_ext_data_in_cdir))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_uncomp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_is_encrypted)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports stored and deflate. */
    if ((file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    if (!file_stat.m_is_supported)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    /* Read and parse the local directory entry. */
    local_header_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    local_header_filename_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
    local_header_crc32 = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_CRC32_OFS);
    local_header_bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
    has_data_descriptor = (local_header_bit_flags & 8) != 0;

    if (local_header_filename_len != strlen(file_stat.m_filename))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if (!mz_zip_array_resize(pZip, &file_data_array, MZ_MAX(local_header_filename_len, local_header_extra_len), MZ_FALSE))
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        goto handle_failure;
    }

    if (local_header_filename_len)
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE, file_data_array.m_p, local_header_filename_len) != local_header_filename_len)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        /* I've seen 1 archive that had the same pathname, but used backslashes in the local dir and forward slashes in the central dir. Do we care about this? For now, this case will fail validation. */
        if (memcmp(file_stat.m_filename, file_data_array.m_p, local_header_filename_len) != 0)
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }

    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
    {
        mz_uint32 extra_size_remaining = local_header_extra_len;
        const mz_uint8 *pExtra_data = (const mz_uint8 *)file_data_array.m_p;

        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
            {
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
            }

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
            {
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
            }

            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                if (field_data_size < sizeof(mz_uint64) * 2)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                    goto handle_failure;
                }

                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64));

                found_zip64_ext_data_in_ldir = MZ_TRUE;
                break;
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);
    }

    /* TODO: parse local header extra data when local_header_comp_size is 0xFFFFFFFF! (big_descriptor.zip) */
    /* I've seen zips in the wild with the data descriptor bit set, but proper local header values and bogus data descriptors */
    if ((has_data_descriptor) && (!local_header_comp_size) && (!local_header_crc32))
    {
        mz_uint8 descriptor_buf[32];
        mz_bool has_id;
        const mz_uint8 *pSrc;
        mz_uint32 file_crc32;
        mz_uint64 comp_size = 0, uncomp_size = 0;

        mz_uint32 num_descriptor_uint32s = ((pState->m_zip64) || (found_zip64_ext_data_in_ldir)) ? 6 : 4;

        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size, descriptor_buf, sizeof(mz_uint32) * num_descriptor_uint32s) != (sizeof(mz_uint32) * num_descriptor_uint32s))
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        has_id = (MZ_READ_LE32(descriptor_buf) == MZ_ZIP_DATA_DESCRIPTOR_ID);
        pSrc = has_id ? (descriptor_buf + sizeof(mz_uint32)) : descriptor_buf;

        file_crc32 = MZ_READ_LE32(pSrc);

        if ((pState->m_zip64) || (found_zip64_ext_data_in_ldir))
        {
            comp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32));
            uncomp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32) + sizeof(mz_uint64));
        }
        else
        {
            comp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32));
            uncomp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32) + sizeof(mz_uint32));
        }

        if ((file_crc32 != file_stat.m_crc32) || (comp_size != file_stat.m_comp_size) || (uncomp_size != file_stat.m_uncomp_size))
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }
    else
    {
        if ((local_header_crc32 != file_stat.m_crc32) || (local_header_comp_size != file_stat.m_comp_size) || (local_header_uncomp_size != file_stat.m_uncomp_size))
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }

    mz_zip_array_clear(pZip, &file_data_array);

    if ((flags & MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY) == 0)
    {
        if (!mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_compute_crc32_callback, &uncomp_crc32, 0))
            return MZ_FALSE;

        /* 1 more check to be sure, although the extract checks too. */
        if (uncomp_crc32 != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            return MZ_FALSE;
        }
    }

    return MZ_TRUE;

handle_failure:
    mz_zip_array_clear(pZip, &file_data_array);
    return MZ_FALSE;
}

mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags)
{
    mz_zip_internal_state *pState;
    mz_uint32 i;

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    /* Basic sanity checks */
    if (!pState->m_zip64)
    {
        if (pZip->m_total_files > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        if (pZip->m_archive_size > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }
    else
    {
        if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }

    for (i = 0; i < pZip->m_total_files; i++)
    {
        if (MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG & flags)
        {
            mz_uint32 found_index;
            mz_zip_archive_file_stat stat;

            if (!mz_zip_reader_file_stat(pZip, i, &stat))
                return MZ_FALSE;

            if (!mz_zip_reader_locate_file_v2(pZip, stat.m_filename, NULL, 0, &found_index))
                return MZ_FALSE;

            /* This check can fail if there are duplicate filenames in the archive (which we don't check for when writing - that's up to the user) */
            if (found_index != i)
                return mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
        }

        if (!mz_zip_validate_file(pZip, i, flags))
            return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr)
{
    mz_bool success = MZ_TRUE;
    mz_zip_archive zip;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    if ((!pMem) || (!size))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    mz_zip_zero_struct(&zip);

    if (!mz_zip_reader_init_mem(&zip, pMem, size, flags))
    {
        if (pErr)
            *pErr = zip.m_last_error;
        return MZ_FALSE;
    }

    if (!mz_zip_validate_archive(&zip, flags))
    {
        actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (!mz_zip_reader_end_internal(&zip, success))
    {
        if (!actual_err)
            actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (pErr)
        *pErr = actual_err;

    return success;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr)
{
    mz_bool success = MZ_TRUE;
    mz_zip_archive zip;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    if (!pFilename)
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    mz_zip_zero_struct(&zip);

    if (!mz_zip_reader_init_file_v2(&zip, pFilename, flags, 0, 0))
    {
        if (pErr)
            *pErr = zip.m_last_error;
        return MZ_FALSE;
    }

    if (!mz_zip_validate_archive(&zip, flags))
    {
        actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (!mz_zip_reader_end_internal(&zip, success))
    {
        if (!actual_err)
            actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (pErr)
        *pErr = actual_err;

    return success;
}
#endif /* #ifndef MINIZ_NO_STDIO */

/* ------------------- .ZIP archive writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

static MZ_FORCEINLINE void mz_write_le16(mz_uint8 *p, mz_uint16 v)
{
    p[0] = (mz_uint8)v;
    p[1] = (mz_uint8)(v >> 8);
}
static MZ_FORCEINLINE void mz_write_le32(mz_uint8 *p, mz_uint32 v)
{
    p[0] = (mz_uint8)v;
    p[1] = (mz_uint8)(v >> 8);
    p[2] = (mz_uint8)(v >> 16);
    p[3] = (mz_uint8)(v >> 24);
}
static MZ_FORCEINLINE void mz_write_le64(mz_uint8 *p, mz_uint64 v)
{
    mz_write_le32(p, (mz_uint32)v);
    mz_write_le32(p + sizeof(mz_uint32), (mz_uint32)(v >> 32));
}

#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
#define MZ_WRITE_LE64(p, v) mz_write_le64((mz_uint8 *)(p), (mz_uint64)(v))

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_zip_internal_state *pState = pZip->m_pState;
    mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);

    if (!n)
        return 0;

    /* An allocation this big is likely to just fail on 32-bit systems, so don't even go there. */
    if ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
        return 0;
    }

    if (new_size > pState->m_mem_capacity)
    {
        void *pNew_block;
        size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);

        while (new_capacity < new_size)
            new_capacity *= 2;

        if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            return 0;
        }

        pState->m_pMem = pNew_block;
        pState->m_mem_capacity = new_capacity;
    }
    memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
    pState->m_mem_size = (size_t)new_size;
    return n;
}

static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
{
    mz_zip_internal_state *pState;
    mz_bool status = MZ_TRUE;

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
    {
        if (set_last_error)
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    pState = pZip->m_pState;
    pZip->m_pState = NULL;
    mz_zip_array_clear(pZip, &pState->m_central_dir);
    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
    if (pState->m_pFile)
    {
        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
        {
            if (MZ_FCLOSE(pState->m_pFile) == EOF)
            {
                if (set_last_error)
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
                status = MZ_FALSE;
            }
        }

        pState->m_pFile = NULL;
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
        pState->m_pMem = NULL;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
    return status;
}

mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
{
    mz_bool zip64 = (flags & MZ_ZIP_FLAG_WRITE_ZIP64) != 0;

    if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
    {
        if (!pZip->m_pRead)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    if (pZip->m_file_offset_alignment)
    {
        /* Ensure user specified file offset alignment is a power of 2. */
        if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    if (!pZip->m_pAlloc)
        pZip->m_pAlloc = miniz_def_alloc_func;
    if (!pZip->m_pFree)
        pZip->m_pFree = miniz_def_free_func;
    if (!pZip->m_pRealloc)
        pZip->m_pRealloc = miniz_def_realloc_func;

    pZip->m_archive_size = existing_size;
    pZip->m_central_directory_file_ofs = 0;
    pZip->m_total_files = 0;

    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));

    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));

    pZip->m_pState->m_zip64 = zip64;
    pZip->m_pState->m_zip64_has_extended_info_fields = zip64;

    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
{
    return mz_zip_writer_init_v2(pZip, existing_size, 0);
}

mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags)
{
    pZip->m_pWrite = mz_zip_heap_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_mem_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;

    if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
    {
        if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
        {
            mz_zip_writer_end_internal(pZip, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }
        pZip->m_pState->m_mem_capacity = initial_allocation_size;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
{
    return mz_zip_writer_init_heap_v2(pZip, size_to_reserve_at_beginning, initial_allocation_size, 0);
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

    file_ofs += pZip->m_pState->m_file_archive_start_ofs;

    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
        return 0;
    }

    return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
{
    return mz_zip_writer_init_file_v2(pZip, pFilename, size_to_reserve_at_beginning, 0);
}

mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
{
    MZ_FILE *pFile;

    pZip->m_pWrite = mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
        return MZ_FALSE;

    if (NULL == (pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING) ? "w+b" : "wb")))
    {
        mz_zip_writer_end(pZip);
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
    }

    pZip->m_pState->m_pFile = pFile;
    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;

    if (size_to_reserve_at_beginning)
    {
        mz_uint64 cur_ofs = 0;
        char buf[4096];

        MZ_CLEAR_ARR(buf);

        do
        {
            size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
            {
                mz_zip_writer_end(pZip);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }
            cur_ofs += n;
            size_to_reserve_at_beginning -= n;
        } while (size_to_reserve_at_beginning);
    }

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags)
{
    pZip->m_pWrite = mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, 0, flags))
        return MZ_FALSE;

    pZip->m_pState->m_pFile = pFile;
    pZip->m_pState->m_file_archive_start_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;

    return MZ_TRUE;
}
#endif /* #ifndef MINIZ_NO_STDIO */

mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
{
    mz_zip_internal_state *pState;

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)
    {
        /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */
        if (!pZip->m_pState->m_zip64)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    /* No sense in trying to write to an archive that's already at the support max size */
    if (pZip->m_pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
    }

    pState = pZip->m_pState;

    if (pState->m_pFile)
    {
#ifdef MINIZ_NO_STDIO
        (void)pFilename;
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
#else
        if (pZip->m_pIO_opaque != pZip)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
        {
            if (!pFilename)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

            /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */
            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
            {
                /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */
                mz_zip_reader_end_internal(pZip, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
            }
        }

        pZip->m_pWrite = mz_zip_file_write_func;
        pZip->m_pNeeds_keepalive = NULL;
#endif /* #ifdef MINIZ_NO_STDIO */
    }
    else if (pState->m_pMem)
    {
        /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */
        if (pZip->m_pIO_opaque != pZip)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState->m_mem_capacity = pState->m_mem_size;
        pZip->m_pWrite = mz_zip_heap_write_func;
        pZip->m_pNeeds_keepalive = NULL;
    }
    /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */
    else if (!pZip->m_pWrite)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Start writing new files at the archive's current central directory location. */
    /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */
    pZip->m_archive_size = pZip->m_central_directory_file_ofs;
    pZip->m_central_directory_file_ofs = 0;

    /* Clear the sorted central dir offsets, they aren't useful or maintained now. */
    /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */
    /* TODO: We could easily maintain the sorted central directory offsets. */
    mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);

    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
{
    return mz_zip_writer_init_from_reader_v2(pZip, pFilename, 0);
}

/* TODO: pArchive_name is a terrible name here! */
mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
{
    return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
}

typedef struct
{
    mz_zip_archive *m_pZip;
    mz_uint64 m_cur_archive_file_ofs;
    mz_uint64 m_comp_size;
} mz_zip_writer_add_state;

static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)
{
    mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
    if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
        return MZ_FALSE;

    pState->m_cur_archive_file_ofs += len;
    pState->m_comp_size += len;
    return MZ_TRUE;
}

#define MZ_ZIP64_MAX_LOCAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 2)
#define MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 3)
static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf, mz_uint64 *pUncomp_size, mz_uint64 *pComp_size, mz_uint64 *pLocal_header_ofs)
{
    mz_uint8 *pDst = pBuf;
    mz_uint32 field_size = 0;

    MZ_WRITE_LE16(pDst + 0, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
    MZ_WRITE_LE16(pDst + 2, 0);
    pDst += sizeof(mz_uint16) * 2;

    if (pUncomp_size)
    {
        MZ_WRITE_LE64(pDst, *pUncomp_size);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    if (pComp_size)
    {
        MZ_WRITE_LE64(pDst, *pComp_size);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    if (pLocal_header_ofs)
    {
        MZ_WRITE_LE64(pDst, *pLocal_header_ofs);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    MZ_WRITE_LE16(pBuf + 2, field_size);

    return (mz_uint32)(pDst - pBuf);
}

static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
{
    (void)pZip;
    memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
    return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst,
                                                       mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size,
                                                       mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                       mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                       mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
    (void)pZip;
    memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_MIN(local_header_ofs, MZ_UINT32_MAX));
    return MZ_TRUE;
}

static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
                                                const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size,
                                                mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                mz_uint64 local_header_ofs, mz_uint32 ext_attributes,
                                                const char *user_extra_data, mz_uint user_extra_data_len)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
    size_t orig_central_dir_size = pState->m_central_dir.m_size;
    mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

    if (!pZip->m_pState->m_zip64)
    {
        if (local_header_ofs > 0xFFFFFFFF)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
    }

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + user_extra_data_len + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, (mz_uint16)(extra_size + user_extra_data_len), comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
        return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

    if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, user_extra_data, user_extra_data_len)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
    {
        /* Try to resize the central directory array back into its original state. */
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    return MZ_TRUE;
}

static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
{
    /* Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. */
    if (*pArchive_name == '/')
        return MZ_FALSE;

    /* Making sure the name does not contain drive letters or DOS style backward slashes is the responsibility of the program using miniz*/

    return MZ_TRUE;
}

static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
{
    mz_uint32 n;
    if (!pZip->m_file_offset_alignment)
        return 0;
    n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
    return (mz_uint)((pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1));
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
{
    char buf[4096];
    memset(buf, 0, MZ_MIN(sizeof(buf), n));
    while (n)
    {
        mz_uint32 s = MZ_MIN(sizeof(buf), n);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_file_ofs += s;
        n -= s;
    }
    return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
{
    return mz_zip_writer_add_mem_ex_v2(pZip, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, uncomp_size, uncomp_crc32, NULL, NULL, 0, NULL, 0);
}

mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size,
                                    mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
                                    const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
    mz_uint16 method = 0, dos_time = 0, dos_date = 0;
    mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
    mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
    size_t archive_name_size;
    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
    tdefl_compressor *pComp = NULL;
    mz_bool store_data_uncompressed;
    mz_zip_internal_state *pState;
    mz_uint8 *pExtra_data = NULL;
    mz_uint32 extra_size = 0;
    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
    mz_uint16 bit_flags = 0;

    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;

    if (uncomp_size || (buf_size && !(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
        bit_flags |= MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
        bit_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

    level = level_and_flags & 0xF;
    store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if (pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
        }
        if (((mz_uint64)buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

    if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

#ifndef MINIZ_NO_TIME
    if (last_modified != NULL)
    {
        mz_zip_time_t_to_dos_time(*last_modified, &dos_time, &dos_date);
    }
    else
    {
        MZ_TIME_T cur_time;
        time(&cur_time);
        mz_zip_time_t_to_dos_time(cur_time, &dos_time, &dos_date);
    }
#endif /* #ifndef MINIZ_NO_TIME */

	if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
	{
		uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
		uncomp_size = buf_size;
		if (uncomp_size <= 3)
		{
			level = 0;
			store_data_uncompressed = MZ_TRUE;
		}
	}

    archive_name_size = strlen(pArchive_name);
    if (archive_name_size > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!pState->m_zip64)
    {
        /* Bail early if the archive would obviously become too large */
        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size
			+ MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len +
			pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + user_extra_data_central_len
			+ MZ_ZIP_DATA_DESCRIPTER_SIZE32) > 0xFFFFFFFF)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

    if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
    {
        /* Set DOS Subdirectory attribute bit. */
        ext_attributes |= MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;

        /* Subdirectories cannot contain data. */
        if ((buf_size) || (uncomp_size))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    /* Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) */
    if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + (pState->m_zip64 ? MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE : 0))) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    if ((!store_data_uncompressed) && (buf_size))
    {
        if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        return MZ_FALSE;
    }

    local_dir_header_ofs += num_alignment_padding_bytes;
    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }
    cur_archive_file_ofs += num_alignment_padding_bytes;

    MZ_CLEAR_ARR(local_dir_header);

    if (!store_data_uncompressed || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
    {
        method = MZ_DEFLATED;
    }

    if (pState->m_zip64)
    {
        if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
        {
            pExtra_data = extra_data;
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, bit_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_archive_file_ofs += archive_name_size;

        if (pExtra_data != NULL)
        {
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += extra_size;
        }
    }
    else
    {
        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_archive_file_ofs += archive_name_size;
    }

	if (user_extra_data_len > 0)
	{
		if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
			return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

		cur_archive_file_ofs += user_extra_data_len;
	}

    if (store_data_uncompressed)
    {
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += buf_size;
        comp_size = buf_size;
    }
    else if (buf_size)
    {
        mz_zip_writer_add_state state;

        state.m_pZip = pZip;
        state.m_cur_archive_file_ofs = cur_archive_file_ofs;
        state.m_comp_size = 0;

        if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
            (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
        }

        comp_size = state.m_comp_size;
        cur_archive_file_ofs = state.m_cur_archive_file_ofs;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    pComp = NULL;

    if (uncomp_size)
    {
        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

        MZ_ASSERT(bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);

        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
        if (pExtra_data == NULL)
        {
            if (comp_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
        }
        else
        {
            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
            return MZ_FALSE;

        cur_archive_file_ofs += local_dir_footer_size;
    }

    if (pExtra_data != NULL)
    {
        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
    }

    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment,
                                          comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                          user_extra_data_central, user_extra_data_central_len))
        return MZ_FALSE;

    pZip->m_total_files++;
    pZip->m_archive_size = cur_archive_file_ofs;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
    mz_uint16 gen_flags;
    mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
    mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
    mz_uint64 local_dir_header_ofs, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
    size_t archive_name_size;
    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
    mz_uint8 *pExtra_data = NULL;
    mz_uint32 extra_size = 0;
    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
    mz_zip_internal_state *pState;
    mz_uint64 file_ofs = 0, cur_archive_header_file_ofs;

    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;
    level = level_and_flags & 0xF;

    gen_flags = (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE) ? 0 : MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
        gen_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

    /* Sanity checks */
    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if ((!pState->m_zip64) && (max_size > MZ_UINT32_MAX))
    {
        /* Source file is too large for non-zip64 */
        /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        pState->m_zip64 = MZ_TRUE;
    }

    /* We could support this, but why? */
    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    if (pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
        }
    }

    archive_name_size = strlen(pArchive_name);
    if (archive_name_size > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!pState->m_zip64)
    {
        /* Bail early if the archive would obviously become too large */
        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE
			+ archive_name_size + comment_size + user_extra_data_len + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 1024
			+ MZ_ZIP_DATA_DESCRIPTER_SIZE32 + user_extra_data_central_len) > 0xFFFFFFFF)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

#ifndef MINIZ_NO_TIME
    if (pFile_time)
    {
        mz_zip_time_t_to_dos_time(*pFile_time, &dos_time, &dos_date);
    }
#endif

    if (max_size <= 3)
        level = 0;

    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
    {
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
    }

    cur_archive_file_ofs += num_alignment_padding_bytes;
    local_dir_header_ofs = cur_archive_file_ofs;

    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }

    if (max_size && level)
    {
        method = MZ_DEFLATED;
    }

    MZ_CLEAR_ARR(local_dir_header);
    if (pState->m_zip64)
    {
        if (max_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
        {
            pExtra_data = extra_data;
            if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL,
                                                                (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
            else
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, NULL,
                                                                   NULL,
                                                                   (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += archive_name_size;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += extra_size;
    }
    else
    {
        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += archive_name_size;
    }

    if (user_extra_data_len > 0)
    {
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += user_extra_data_len;
    }

    if (max_size)
    {
        void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
        if (!pRead_buf)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!level)
        {
            while (1)
            {
                size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                if (n == 0)
                    break;

                if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                }
                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
                }
                file_ofs += n;
                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
                cur_archive_file_ofs += n;
            }
            uncomp_size = file_ofs;
            comp_size = uncomp_size;
        }
        else
        {
            mz_bool result = MZ_FALSE;
            mz_zip_writer_add_state state;
            tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
            if (!pComp)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            state.m_pZip = pZip;
            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
            state.m_comp_size = 0;

            if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
            }

            for (;;)
            {
                tdefl_status status;
                tdefl_flush flush = TDEFL_NO_FLUSH;

                size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                {
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    break;
                }

                file_ofs += n;
                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);

                if (pZip->m_pNeeds_keepalive != NULL && pZip->m_pNeeds_keepalive(pZip->m_pIO_opaque))
                    flush = TDEFL_FULL_FLUSH;

                if (n == 0)
                    flush = TDEFL_FINISH;

                status = tdefl_compress_buffer(pComp, pRead_buf, n, flush);
                if (status == TDEFL_STATUS_DONE)
                {
                    result = MZ_TRUE;
                    break;
                }
                else if (status != TDEFL_STATUS_OKAY)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
                    break;
                }
            }

            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

            if (!result)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return MZ_FALSE;
            }

            uncomp_size = file_ofs;
            comp_size = state.m_comp_size;
            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
        }

        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
    }

    if (!(level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE))
    {
        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
        if (pExtra_data == NULL)
        {
            if (comp_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
        }
        else
        {
            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
            return MZ_FALSE;

        cur_archive_file_ofs += local_dir_footer_size;
    }

    if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
    {
        if (pExtra_data != NULL)
        {
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header,
                                                   (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len),
                                                   (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : uncomp_size, 
                                                    (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : comp_size,
                                                   uncomp_crc32, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        cur_archive_header_file_ofs = local_dir_header_ofs;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        if (pExtra_data != NULL)
        {
            cur_archive_header_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_archive_header_file_ofs += archive_name_size;

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_header_file_ofs += extra_size;
        }
    }

    if (pExtra_data != NULL)
    {
        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
    }

    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment, comment_size,
                                          uncomp_size, comp_size, uncomp_crc32, method, gen_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                          user_extra_data_central, user_extra_data_central_len))
        return MZ_FALSE;

    pZip->m_total_files++;
    pZip->m_archive_size = cur_archive_file_ofs;

    return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO

static size_t mz_file_read_func_stdio(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
	MZ_FILE *pSrc_file = (MZ_FILE *)pOpaque;
	mz_int64 cur_ofs = MZ_FTELL64(pSrc_file);

	if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pSrc_file, (mz_int64)file_ofs, SEEK_SET))))
		return 0;

	return MZ_FREAD(pBuf, 1, n, pSrc_file);
}

mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
	const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
	return mz_zip_writer_add_read_buf_callback(pZip, pArchive_name, mz_file_read_func_stdio, pSrc_file, max_size, pFile_time, pComment, comment_size, level_and_flags,
		user_extra_data, user_extra_data_len, user_extra_data_central, user_extra_data_central_len);
}

mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
    MZ_FILE *pSrc_file = NULL;
    mz_uint64 uncomp_size = 0;
    MZ_TIME_T file_modified_time;
    MZ_TIME_T *pFile_time = NULL;
    mz_bool status;

    memset(&file_modified_time, 0, sizeof(file_modified_time));

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
    pFile_time = &file_modified_time;
    if (!mz_zip_get_file_modified_time(pSrc_filename, &file_modified_time))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_STAT_FAILED);
#endif

    pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
    if (!pSrc_file)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    MZ_FSEEK64(pSrc_file, 0, SEEK_END);
    uncomp_size = MZ_FTELL64(pSrc_file);
    MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

    status = mz_zip_writer_add_cfile(pZip, pArchive_name, pSrc_file, uncomp_size, pFile_time, pComment, comment_size, level_and_flags, NULL, 0, NULL, 0);

    MZ_FCLOSE(pSrc_file);

    return status;
}
#endif /* #ifndef MINIZ_NO_STDIO */

static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext, mz_zip_archive *pZip, const mz_uint8 *pExt, mz_uint32 ext_len, mz_uint64 *pComp_size, mz_uint64 *pUncomp_size, mz_uint64 *pLocal_header_ofs, mz_uint32 *pDisk_start)
{
    /* + 64 should be enough for any new zip64 data */
    if (!mz_zip_array_reserve(pZip, pNew_ext, ext_len + 64, MZ_FALSE))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    mz_zip_array_resize(pZip, pNew_ext, 0, MZ_FALSE);

    if ((pUncomp_size) || (pComp_size) || (pLocal_header_ofs) || (pDisk_start))
    {
        mz_uint8 new_ext_block[64];
        mz_uint8 *pDst = new_ext_block;
        mz_write_le16(pDst, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
        mz_write_le16(pDst + sizeof(mz_uint16), 0);
        pDst += sizeof(mz_uint16) * 2;

        if (pUncomp_size)
        {
            mz_write_le64(pDst, *pUncomp_size);
            pDst += sizeof(mz_uint64);
        }

        if (pComp_size)
        {
            mz_write_le64(pDst, *pComp_size);
            pDst += sizeof(mz_uint64);
        }

        if (pLocal_header_ofs)
        {
            mz_write_le64(pDst, *pLocal_header_ofs);
            pDst += sizeof(mz_uint64);
        }

        if (pDisk_start)
        {
            mz_write_le32(pDst, *pDisk_start);
            pDst += sizeof(mz_uint32);
        }

        mz_write_le16(new_ext_block + sizeof(mz_uint16), (mz_uint16)((pDst - new_ext_block) - sizeof(mz_uint16) * 2));

        if (!mz_zip_array_push_back(pZip, pNew_ext, new_ext_block, pDst - new_ext_block))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    if ((pExt) && (ext_len))
    {
        mz_uint32 extra_size_remaining = ext_len;
        const mz_uint8 *pExtra_data = pExt;

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            if (field_id != MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                if (!mz_zip_array_push_back(pZip, pNew_ext, pExtra_data, field_total_size))
                    return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);
    }

    return MZ_TRUE;
}

/* TODO: This func is now pretty freakin complex due to zip64, split it up? */
mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)
{
    mz_uint n, bit_flags, num_alignment_padding_bytes, src_central_dir_following_data_size;
    mz_uint64 src_archive_bytes_remaining, local_dir_header_ofs;
    mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
    size_t orig_central_dir_size;
    mz_zip_internal_state *pState;
    void *pBuf;
    const mz_uint8 *pSrc_central_header;
    mz_zip_archive_file_stat src_file_stat;
    mz_uint32 src_filename_len, src_comment_len, src_ext_len;
    mz_uint32 local_header_filename_size, local_header_extra_len;
    mz_uint64 local_header_comp_size, local_header_uncomp_size;
    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;

    /* Sanity checks */
    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pSource_zip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    /* Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible */
    if ((pSource_zip->m_pState->m_zip64) && (!pZip->m_pState->m_zip64))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Get pointer to the source central dir header and crack it */
    if (NULL == (pSrc_central_header = mz_zip_get_cdh(pSource_zip, src_file_index)))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    src_filename_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    src_comment_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
    src_ext_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS);
    src_central_dir_following_data_size = src_filename_len + src_ext_len + src_comment_len;

    /* TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) */
    if ((pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + 32) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    if (!pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        /* TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. */
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }

    if (!mz_zip_file_stat_internal(pSource_zip, src_file_index, pSrc_central_header, &src_file_stat, NULL))
        return MZ_FALSE;

    cur_src_file_ofs = src_file_stat.m_local_header_ofs;
    cur_dst_file_ofs = pZip->m_archive_size;

    /* Read the source archive's local dir header */
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

    /* Compute the total size we need to copy (filename+extra data+compressed data) */
    local_header_filename_size = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
    src_archive_bytes_remaining = local_header_filename_size + local_header_extra_len + src_file_stat.m_comp_size;

    /* Try to find a zip64 extended information field */
    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
    {
        mz_zip_array file_data_array;
        const mz_uint8 *pExtra_data;
        mz_uint32 extra_size_remaining = local_header_extra_len;

        mz_zip_array_init(&file_data_array, 1);
        if (!mz_zip_array_resize(pZip, &file_data_array, local_header_extra_len, MZ_FALSE))
        {
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, src_file_stat.m_local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_size, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
        {
            mz_zip_array_clear(pZip, &file_data_array);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        }

        pExtra_data = (const mz_uint8 *)file_data_array.m_p;

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                if (field_data_size < sizeof(mz_uint64) * 2)
                {
                    mz_zip_array_clear(pZip, &file_data_array);
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */

                found_zip64_ext_data_in_ldir = MZ_TRUE;
                break;
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);

        mz_zip_array_clear(pZip, &file_data_array);
    }

    if (!pState->m_zip64)
    {
        /* Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). */
        /* We also check when the archive is finalized so this doesn't need to be perfect. */
        mz_uint64 approx_new_archive_size = cur_dst_file_ofs + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + src_archive_bytes_remaining + (sizeof(mz_uint32) * 4) +
                                            pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 64;

        if (approx_new_archive_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }

    /* Write dest archive padding */
    if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
        return MZ_FALSE;

    cur_dst_file_ofs += num_alignment_padding_bytes;

    local_dir_header_ofs = cur_dst_file_ofs;
    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }

    /* The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip */
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

    cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

    /* Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor */
    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(32U, MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining)))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    while (src_archive_bytes_remaining)
    {
        n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining);
        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        }
        cur_src_file_ofs += n;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_dst_file_ofs += n;

        src_archive_bytes_remaining -= n;
    }

    /* Now deal with the optional data descriptor */
    bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
    if (bit_flags & 8)
    {
        /* Copy data descriptor */
        if ((pSource_zip->m_pState->m_zip64) || (found_zip64_ext_data_in_ldir))
        {
            /* src is zip64, dest must be zip64 */

            /* name			uint32_t's */
            /* id				1 (optional in zip64?) */
            /* crc			1 */
            /* comp_size	2 */
            /* uncomp_size 2 */
            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, (sizeof(mz_uint32) * 6)) != (sizeof(mz_uint32) * 6))
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID) ? 6 : 5);
        }
        else
        {
            /* src is NOT zip64 */
            mz_bool has_id;

            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            has_id = (MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID);

            if (pZip->m_pState->m_zip64)
            {
                /* dest is zip64, so upgrade the data descriptor */
                const mz_uint8 *pSrc_descriptor = (const mz_uint8 *)pBuf + (has_id ? sizeof(mz_uint32) : 0);
                const mz_uint32 src_crc32 = MZ_READ_LE32(pSrc_descriptor);
                const mz_uint64 src_comp_size = MZ_READ_LE32(pSrc_descriptor + sizeof(mz_uint32));
                const mz_uint64 src_uncomp_size = MZ_READ_LE32(pSrc_descriptor + 2*sizeof(mz_uint32));

                mz_write_le32((mz_uint8 *)pBuf, MZ_ZIP_DATA_DESCRIPTOR_ID);
                mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * 1, src_crc32);
                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 2, src_comp_size);
                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 4, src_uncomp_size);

                n = sizeof(mz_uint32) * 6;
            }
            else
            {
                /* dest is NOT zip64, just copy it as-is */
                n = sizeof(mz_uint32) * (has_id ? 4 : 3);
            }
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_src_file_ofs += n;
        cur_dst_file_ofs += n;
    }
    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

    /* Finally, add the new central dir header */
    orig_central_dir_size = pState->m_central_dir.m_size;

    memcpy(new_central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);

    if (pState->m_zip64)
    {
        /* This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. */
        const mz_uint8 *pSrc_ext = pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len;
        mz_zip_array new_ext_block;

        mz_zip_array_init(&new_ext_block, sizeof(mz_uint8));

        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_UINT32_MAX);

        if (!mz_zip_writer_update_zip64_extension_block(&new_ext_block, pZip, pSrc_ext, src_ext_len, &src_file_stat.m_comp_size, &src_file_stat.m_uncomp_size, &local_dir_header_ofs, NULL))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            return MZ_FALSE;
        }

        MZ_WRITE_LE16(new_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS, new_ext_block.m_size);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_filename_len))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_ext_block.m_p, new_ext_block.m_size))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len + src_ext_len, src_comment_len))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        mz_zip_array_clear(pZip, &new_ext_block);
    }
    else
    {
        /* sanity checks */
        if (cur_dst_file_ofs > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        if (local_dir_header_ofs >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_central_dir_following_data_size))
        {
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }
    }

    /* This shouldn't trigger unless we screwed up during the initial sanity checks */
    if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
    {
        /* TODO: Support central dirs >= 32-bits in size */
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    }

    n = (mz_uint32)orig_central_dir_size;
    if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
    {
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    pZip->m_total_files++;
    pZip->m_archive_size = cur_dst_file_ofs;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
{
    mz_zip_internal_state *pState;
    mz_uint64 central_dir_ofs, central_dir_size;
    mz_uint8 hdr[256];

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if (pState->m_zip64)
    {
        if ((mz_uint64)pState->m_central_dir.m_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if ((pZip->m_total_files > MZ_UINT16_MAX) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }

    central_dir_ofs = 0;
    central_dir_size = 0;
    if (pZip->m_total_files)
    {
        /* Write central directory */
        central_dir_ofs = pZip->m_archive_size;
        central_dir_size = pState->m_central_dir.m_size;
        pZip->m_central_directory_file_ofs = central_dir_ofs;
        if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += central_dir_size;
    }

    if (pState->m_zip64)
    {
        /* Write zip64 end of central directory header */
        mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;

        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDH_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32) - sizeof(mz_uint64));
        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS, 0x031E); /* TODO: always Unix */
        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_NEEDED_OFS, 0x002D);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_SIZE_OFS, central_dir_size);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_OFS_OFS, central_dir_ofs);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;

        /* Write zip64 end of central directory locator */
        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS, rel_ofs_to_zip64_ecdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS, 1);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
    }

    /* Write end of central directory record */
    MZ_CLEAR_ARR(hdr);
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_size));
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_ofs));

    if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

#ifndef MINIZ_NO_STDIO
    if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
#endif /* #ifndef MINIZ_NO_STDIO */

    pZip->m_archive_size += MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;

    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
    return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
{
    if ((!ppBuf) || (!pSize))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    *ppBuf = NULL;
    *pSize = 0;

    if ((!pZip) || (!pZip->m_pState))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (pZip->m_pWrite != mz_zip_heap_write_func)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_finalize_archive(pZip))
        return MZ_FALSE;

    *ppBuf = pZip->m_pState->m_pMem;
    *pSize = pZip->m_pState->m_mem_size;
    pZip->m_pState->m_pMem = NULL;
    pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
{
    return mz_zip_writer_end_internal(pZip, MZ_TRUE);
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
    return mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, NULL);
}

mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr)
{
    mz_bool status, created_new_archive = MZ_FALSE;
    mz_zip_archive zip_archive;
    struct MZ_FILE_STAT_STRUCT file_stat;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    mz_zip_zero_struct(&zip_archive);
    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;

    if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_FILENAME;
        return MZ_FALSE;
    }

    /* Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. */
    /* So be sure to compile with _LARGEFILE64_SOURCE 1 */
    if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
    {
        /* Create a new archive. */
        if (!mz_zip_writer_init_file_v2(&zip_archive, pZip_filename, 0, level_and_flags))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;
            return MZ_FALSE;
        }

        created_new_archive = MZ_TRUE;
    }
    else
    {
        /* Append to an existing archive. */
        if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;
            return MZ_FALSE;
        }

        if (!mz_zip_writer_init_from_reader_v2(&zip_archive, pZip_filename, level_and_flags))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;

            mz_zip_reader_end_internal(&zip_archive, MZ_FALSE);

            return MZ_FALSE;
        }
    }

    status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
    actual_err = zip_archive.m_last_error;

    /* Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) */
    if (!mz_zip_writer_finalize_archive(&zip_archive))
    {
        if (!actual_err)
            actual_err = zip_archive.m_last_error;

        status = MZ_FALSE;
    }

    if (!mz_zip_writer_end_internal(&zip_archive, status))
    {
        if (!actual_err)
            actual_err = zip_archive.m_last_error;

        status = MZ_FALSE;
    }

    if ((!status) && (created_new_archive))
    {
        /* It's a new archive and something went wrong, so just delete it. */
        int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
        (void)ignoredStatus;
    }

    if (pErr)
        *pErr = actual_err;

    return status;
}

void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr)
{
    mz_uint32 file_index;
    mz_zip_archive zip_archive;
    void *p = NULL;

    if (pSize)
        *pSize = 0;

    if ((!pZip_filename) || (!pArchive_name))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;

        return NULL;
    }

    mz_zip_zero_struct(&zip_archive);
    if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
    {
        if (pErr)
            *pErr = zip_archive.m_last_error;

        return NULL;
    }

    if (mz_zip_reader_locate_file_v2(&zip_archive, pArchive_name, pComment, flags, &file_index))
    {
        p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
    }

    mz_zip_reader_end_internal(&zip_archive, p != NULL);

    if (pErr)
        *pErr = zip_archive.m_last_error;

    return p;
}

void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
{
    return mz_zip_extract_archive_file_to_heap_v2(pZip_filename, pArchive_name, NULL, pSize, flags, NULL);
}

#endif /* #ifndef MINIZ_NO_STDIO */

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

/* ------------------- Misc utils */

mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_zip_mode : MZ_ZIP_MODE_INVALID;
}

mz_zip_type mz_zip_get_type(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_zip_type : MZ_ZIP_TYPE_INVALID;
}

mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num)
{
    mz_zip_error prev_err;

    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    prev_err = pZip->m_last_error;

    pZip->m_last_error = err_num;
    return prev_err;
}

mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip)
{
    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    return pZip->m_last_error;
}

mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip)
{
    return mz_zip_set_last_error(pZip, MZ_ZIP_NO_ERROR);
}

mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip)
{
    mz_zip_error prev_err;

    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    prev_err = pZip->m_last_error;

    pZip->m_last_error = MZ_ZIP_NO_ERROR;
    return prev_err;
}

const char *mz_zip_get_error_string(mz_zip_error mz_err)
{
    switch (mz_err)
    {
        case MZ_ZIP_NO_ERROR:
            return "no error";
        case MZ_ZIP_UNDEFINED_ERROR:
            return "undefined error";
        case MZ_ZIP_TOO_MANY_FILES:
            return "too many files";
        case MZ_ZIP_FILE_TOO_LARGE:
            return "file too large";
        case MZ_ZIP_UNSUPPORTED_METHOD:
            return "unsupported method";
        case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
            return "unsupported encryption";
        case MZ_ZIP_UNSUPPORTED_FEATURE:
            return "unsupported feature";
        case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
            return "failed finding central directory";
        case MZ_ZIP_NOT_AN_ARCHIVE:
            return "not a ZIP archive";
        case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
            return "invalid header or archive is corrupted";
        case MZ_ZIP_UNSUPPORTED_MULTIDISK:
            return "unsupported multidisk archive";
        case MZ_ZIP_DECOMPRESSION_FAILED:
            return "decompression failed or archive is corrupted";
        case MZ_ZIP_COMPRESSION_FAILED:
            return "compression failed";
        case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
            return "unexpected decompressed size";
        case MZ_ZIP_CRC_CHECK_FAILED:
            return "CRC-32 check failed";
        case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
            return "unsupported central directory size";
        case MZ_ZIP_ALLOC_FAILED:
            return "allocation failed";
        case MZ_ZIP_FILE_OPEN_FAILED:
            return "file open failed";
        case MZ_ZIP_FILE_CREATE_FAILED:
            return "file create failed";
        case MZ_ZIP_FILE_WRITE_FAILED:
            return "file write failed";
        case MZ_ZIP_FILE_READ_FAILED:
            return "file read failed";
        case MZ_ZIP_FILE_CLOSE_FAILED:
            return "file close failed";
        case MZ_ZIP_FILE_SEEK_FAILED:
            return "file seek failed";
        case MZ_ZIP_FILE_STAT_FAILED:
            return "file stat failed";
        case MZ_ZIP_INVALID_PARAMETER:
            return "invalid parameter";
        case MZ_ZIP_INVALID_FILENAME:
            return "invalid filename";
        case MZ_ZIP_BUF_TOO_SMALL:
            return "buffer too small";
        case MZ_ZIP_INTERNAL_ERROR:
            return "internal error";
        case MZ_ZIP_FILE_NOT_FOUND:
            return "file not found";
        case MZ_ZIP_ARCHIVE_TOO_LARGE:
            return "archive is too large";
        case MZ_ZIP_VALIDATION_FAILED:
            return "validation failed";
        case MZ_ZIP_WRITE_CALLBACK_FAILED:
            return "write calledback failed";
	case MZ_ZIP_TOTAL_ERRORS:
            return "total errors";
        default:
            break;
    }

    return "unknown error";
}

/* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */
mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return MZ_FALSE;

    return pZip->m_pState->m_zip64;
}

size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;

    return pZip->m_pState->m_central_dir.m_size;
}

mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_total_files : 0;
}

mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip)
{
    if (!pZip)
        return 0;
    return pZip->m_archive_size;
}

mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;
    return pZip->m_pState->m_file_archive_start_ofs;
}

MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;
    return pZip->m_pState->m_pFile;
}

size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    return pZip->m_pRead(pZip->m_pIO_opaque, file_ofs, pBuf, n);
}

mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
{
    mz_uint n;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        if (filename_buf_size)
            pFilename[0] = '\0';
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return 0;
    }
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    if (filename_buf_size)
    {
        n = MZ_MIN(n, filename_buf_size - 1);
        memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
        pFilename[n] = '\0';
    }
    return n + 1;
}

mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
{
    return mz_zip_file_stat_internal(pZip, file_index, mz_zip_get_cdh(pZip, file_index), pStat, NULL);
}

mz_bool mz_zip_end(mz_zip_archive *pZip)
{
    if (!pZip)
        return MZ_FALSE;

    if (pZip->m_zip_mode == MZ_ZIP_MODE_READING)
        return mz_zip_reader_end(pZip);
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
    else if ((pZip->m_zip_mode == MZ_ZIP_MODE_WRITING) || (pZip->m_zip_mode == MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED))
        return mz_zip_writer_end(pZip);
#endif

    return MZ_FALSE;
}

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_ARCHIVE_APIS*/
/* atty - audio interface and driver for terminals
 * Copyright (C) 2020 Øyvind Kolås <pippin@gimp.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>. 
 */

void
ctx_bin2base64 (const void *bin,
                size_t      bin_length,
                char       *ascii);
int
ctx_base642bin (const char    *ascii,
                int           *length,
                unsigned char *bin);

/* atty - audio interface and driver for terminals
 * Copyright (C) 2020 Øyvind Kolås <pippin@gimp.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>. 
 */

static const char *base64_map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static void bin2base64_group (const unsigned char *in, int remaining, char *out)
{
  unsigned char digit[4] = {0,0,64,64};
  int i;
  digit[0] = in[0] >> 2;
  digit[1] = ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4);
  if (remaining > 1)
    {
      digit[2] = ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6);
      if (remaining > 2)
        digit[3] = ((in[2] & 0x3f));
    }
  for (i = 0; i < 4; i++)
    out[i] = base64_map[digit[i]];
}

void
ctx_bin2base64 (const void *bin,
                size_t      bin_length,
                char       *ascii)
{
  /* this allocation is a hack to ensure we always produce the same result,
   * regardless of padding data accidentally taken into account.
   */
  unsigned char *bin2 = (unsigned char*)ctx_calloc (bin_length + 4, 1);
  unsigned const char *p = bin2;
  unsigned int i;
  if (bin_length > 128 * 1024 * 1024) return;
  memcpy (bin2, bin, (size_t)bin_length);
  for (i=0; i*3 < bin_length; i++)
   {
     int remaining = bin_length - i*3;
     bin2base64_group (&p[i*3], remaining, &ascii[i*4]);
   }
  ctx_free (bin2);
  ascii[i*4]=0;
}

static unsigned char base64_revmap[255];
static void base64_revmap_init (void)
{
  static int done = 0;
  if (done)
    return;

  for (int i = 0; i < 255; i ++)
    base64_revmap[i]=255;
  for (int i = 0; i < 64; i ++)
    base64_revmap[((const unsigned char*)base64_map)[i]]=i;
  /* include variants used in URI encodings for decoder,
   * even if that is not how we encode
  */
  base64_revmap['-']=62;
  base64_revmap['_']=63;
  base64_revmap['+']=62;
  base64_revmap['/']=63;

  done = 1;
}


int
ctx_base642bin (const char    *ascii,
                int           *length,
                unsigned char *bin)
{
  int i;
  int charno = 0;
  int outputno = 0;
  int carry = 0;
  base64_revmap_init ();
  for (i = 0; ascii[i]; i++)
    {
      int bits = base64_revmap[((const unsigned char*)ascii)[i]];
      if (length && outputno > *length)
        {
          *length = -1;
          return -1;
        }
      if (bits != 255)
        {
          switch (charno % 4)
            {
              case 0:
                carry = bits;
                break;
              case 1:
                bin[outputno] = (carry << 2) | (bits >> 4);
                outputno++;
                carry = bits & 15;
                break;
              case 2:
                bin[outputno] = (carry << 4) | (bits >> 2);
                outputno++;
                carry = bits & 3;
                break;
              case 3:
                bin[outputno] = (carry << 6) | bits;
                outputno++;
                carry = 0;
                break;
            }
          charno++;
        }
    }
  bin[outputno]=0;
  if (length)
    *length= outputno;
  return outputno;
}


/* the iterator - should decode bitpacked data as well -
 * making the rasterizers simpler, possibly do unpacking
 * all the way to absolute coordinates.. unless mixed
 * relative/not are wanted.
 */
void
ctx_iterator_init (CtxIterator  *iterator,
                   CtxDrawlist  *drawlist,
                   int           start_pos,
                   int           flags)
{
  iterator->drawlist   = drawlist;
  iterator->flags          = flags;
  iterator->bitpack_pos    = 
  iterator->bitpack_length = 0;
  iterator->pos            = start_pos;
  iterator->end_pos        = drawlist->count;
  iterator->first_run      = 1; // -1 is a marker used for first run
  memset (iterator->bitpack_command, 0, sizeof (iterator->bitpack_command) );
}

int ctx_iterator_pos (CtxIterator *iterator)
{
  return iterator->pos;
}

static CTX_INLINE CtxEntry *_ctx_iterator_next (CtxIterator *iterator)
{
  int ret = iterator->pos;
  if (!iterator->drawlist->entries)
    return NULL;
  CtxEntry *entry = &iterator->drawlist->entries[ret];
  if (CTX_UNLIKELY(ret >= iterator->end_pos))
    { return NULL; }

  if (CTX_UNLIKELY(iterator->first_run))
      iterator->first_run = 0;
  else
     iterator->pos += (ctx_conts_for_entry (entry) + 1);

  if (CTX_UNLIKELY(iterator->pos >= iterator->end_pos))
    { return NULL; }
  return &iterator->drawlist->entries[iterator->pos];
}

// 6024x4008
#if CTX_BITPACK
static void
ctx_iterator_expand_s8_args (CtxIterator *iterator, CtxEntry *entry)
{
  int no = 0;
  for (int cno = 0; cno < 4; cno++)
    for (int d = 0; d < 2; d++, no++)
      iterator->bitpack_command[cno].data.f[d] =
        entry->data.s8[no] * 1.0f / CTX_SUBDIV;
  iterator->bitpack_command[0].code =
    iterator->bitpack_command[1].code =
      iterator->bitpack_command[2].code =
        iterator->bitpack_command[3].code = CTX_CONT;
  iterator->bitpack_length = 4;
  iterator->bitpack_pos = 0;
}

static void
ctx_iterator_expand_s16_args (CtxIterator *iterator, CtxEntry *entry)
{
  int no = 0;
  for (int cno = 0; cno < 2; cno++)
    for (int d = 0; d < 2; d++, no++)
      iterator->bitpack_command[cno].data.f[d] = entry->data.s16[no] * 1.0f /
          CTX_SUBDIV;
  iterator->bitpack_command[0].code =
    iterator->bitpack_command[1].code = CTX_CONT;
  iterator->bitpack_length = 2;
  iterator->bitpack_pos    = 0;
}
#endif

CtxCommand *
ctx_iterator_next (CtxIterator *iterator)
{
  CtxEntry *ret;
#if CTX_BITPACK
  int expand_bitpack = (iterator->flags & CTX_ITERATOR_EXPAND_BITPACK)!=0;
again:
  if (CTX_UNLIKELY(expand_bitpack & (iterator->bitpack_length!=0)))
    {
      ret = &iterator->bitpack_command[iterator->bitpack_pos];
      iterator->bitpack_pos += (ctx_conts_for_entry (ret) + 1);
      if (iterator->bitpack_pos >= iterator->bitpack_length)
        {
          iterator->bitpack_length = 0;
        }
      return (CtxCommand *) ret;
    }
#endif
  ret = _ctx_iterator_next (iterator);
#if CTX_BITPACK
  if (CTX_UNLIKELY((ret != NULL) & (expand_bitpack)))
    switch ((CtxCode)(ret->code))
      {
        case CTX_REL_CURVE_TO_REL_LINE_TO:
          ctx_iterator_expand_s8_args (iterator, ret);
          iterator->bitpack_command[0].code = CTX_REL_CURVE_TO;
          iterator->bitpack_command[1].code =
          iterator->bitpack_command[2].code = CTX_CONT;
          iterator->bitpack_command[3].code = CTX_REL_LINE_TO;
          // 0.0 here is a common optimization - so check for it
          if ((ret->data.s8[6]== 0) & (ret->data.s8[7] == 0))
            { iterator->bitpack_length = 3; }
          else
            iterator->bitpack_length          = 4;
          goto again;
        case CTX_REL_LINE_TO_REL_CURVE_TO:
          ctx_iterator_expand_s8_args (iterator, ret);
          iterator->bitpack_command[0].code = CTX_REL_LINE_TO;
          iterator->bitpack_command[1].code = CTX_REL_CURVE_TO;
          iterator->bitpack_length          = 2;
          goto again;
        case CTX_REL_CURVE_TO_REL_MOVE_TO:
          ctx_iterator_expand_s8_args (iterator, ret);
          iterator->bitpack_command[0].code = CTX_REL_CURVE_TO;
          iterator->bitpack_command[3].code = CTX_REL_MOVE_TO;
          iterator->bitpack_length          = 4;
          goto again;
        case CTX_REL_LINE_TO_X4:
          ctx_iterator_expand_s8_args (iterator, ret);
          iterator->bitpack_command[0].code =
          iterator->bitpack_command[1].code =
          iterator->bitpack_command[2].code =
          iterator->bitpack_command[3].code = CTX_REL_LINE_TO;
          iterator->bitpack_length          = 4;
          goto again;
        case CTX_REL_QUAD_TO_S16:
          ctx_iterator_expand_s16_args (iterator, ret);
          iterator->bitpack_command[0].code = CTX_REL_QUAD_TO;
          iterator->bitpack_length          = 1;
          goto again;
        case CTX_REL_QUAD_TO_REL_QUAD_TO:
          ctx_iterator_expand_s8_args (iterator, ret);
          iterator->bitpack_command[0].code =
          iterator->bitpack_command[2].code = CTX_REL_QUAD_TO;
          iterator->bitpack_length          = 3;
          goto again;
        case CTX_REL_LINE_TO_X2:
          ctx_iterator_expand_s16_args (iterator, ret);
          iterator->bitpack_command[0].code =
          iterator->bitpack_command[1].code = CTX_REL_LINE_TO;
          iterator->bitpack_length          = 2;
          goto again;
        case CTX_REL_LINE_TO_REL_MOVE_TO:
          ctx_iterator_expand_s16_args (iterator, ret);
          iterator->bitpack_command[0].code = CTX_REL_LINE_TO;
          iterator->bitpack_command[1].code = CTX_REL_MOVE_TO;
          iterator->bitpack_length          = 2;
          goto again;
        case CTX_MOVE_TO_REL_LINE_TO:
          ctx_iterator_expand_s16_args (iterator, ret);
          iterator->bitpack_command[0].code = CTX_MOVE_TO;
          iterator->bitpack_command[1].code = CTX_REL_MOVE_TO;
          iterator->bitpack_length          = 2;
          goto again;
        case CTX_FILL_MOVE_TO:
          iterator->bitpack_command[1]      = *ret;
          iterator->bitpack_command[0].code = CTX_FILL;
          iterator->bitpack_command[1].code = CTX_MOVE_TO;
          iterator->bitpack_pos             = 0;
          iterator->bitpack_length          = 2;
          goto again;
        case CTX_CONIC_GRADIENT:
        case CTX_LINEAR_GRADIENT:
        case CTX_QUAD_TO:
        case CTX_REL_QUAD_TO:
        case CTX_TEXTURE:
        case CTX_RECTANGLE:
        case CTX_VIEW_BOX:
        case CTX_ARC:
        case CTX_ARC_TO:
        case CTX_REL_ARC_TO:
        case CTX_COLOR:
        case CTX_SHADOW_COLOR:
        case CTX_RADIAL_GRADIENT:
        case CTX_CURVE_TO:
        case CTX_REL_CURVE_TO:
        case CTX_APPLY_TRANSFORM:
        case CTX_SOURCE_TRANSFORM:
        case CTX_ROUND_RECTANGLE:
        case CTX_TEXT:
        case CTX_FONT:
        case CTX_LINE_DASH:
        case CTX_FILL:
        case CTX_PAINT:
        case CTX_NOP:
        case CTX_MOVE_TO:
        case CTX_LINE_TO:
        case CTX_REL_MOVE_TO:
        case CTX_REL_LINE_TO:
        case CTX_VER_LINE_TO:
        case CTX_REL_VER_LINE_TO:
        case CTX_HOR_LINE_TO:
        case CTX_REL_HOR_LINE_TO:
        case CTX_ROTATE:
        case CTX_END_FRAME:
        case CTX_TEXT_ALIGN:
        case CTX_TEXT_BASELINE:
        case CTX_TEXT_DIRECTION:
        case CTX_MITER_LIMIT:
        case CTX_GLOBAL_ALPHA:
        case CTX_COMPOSITING_MODE:
        case CTX_BLEND_MODE:
        case CTX_SHADOW_BLUR:
        case CTX_SHADOW_OFFSET_X:
        case CTX_SHADOW_OFFSET_Y:
        case CTX_START_FRAME:
        case CTX_RESET_PATH:
        case CTX_CLOSE_PATH:
        case CTX_SAVE:
        case CTX_CLIP:
        case CTX_PRESERVE:
        case CTX_DEFINE_FONT:
        case CTX_DEFINE_GLYPH:
        case CTX_IDENTITY:
        case CTX_FONT_SIZE:
        case CTX_START_GROUP:
        case CTX_END_GROUP:
        case CTX_RESTORE:
        case CTX_LINE_WIDTH:
        case CTX_LINE_DASH_OFFSET:
        case CTX_STROKE_POS:
        case CTX_FEATHER:
        case CTX_LINE_HEIGHT:
        case CTX_WRAP_LEFT:
        case CTX_WRAP_RIGHT:
        case CTX_STROKE:
        case CTX_KERNING_PAIR:
        case CTX_SCALE:
        case CTX_GLYPH:
        case CTX_SET_PIXEL:
        case CTX_FILL_RULE:
        case CTX_LINE_CAP:
        case CTX_LINE_JOIN:
        case CTX_NEW_PAGE:
        case CTX_SET_KEY:
        case CTX_TRANSLATE:
        case CTX_DEFINE_TEXTURE:
        case CTX_GRADIENT_STOP:
        case CTX_DATA: // XXX : would be better if we hide the DATAs
        case CTX_CONT: // shouldnt happen
        default:
          iterator->bitpack_length = 0;
#if 0
        default: // XXX remove - and get better warnings
          iterator->bitpack_command[0] = ret[0];
          iterator->bitpack_command[1] = ret[1];
          iterator->bitpack_command[2] = ret[2];
          iterator->bitpack_command[3] = ret[3];
          iterator->bitpack_command[4] = ret[4];
          iterator->bitpack_pos = 0;
          iterator->bitpack_length = 1;
          goto again;
#endif
      }
#endif
  return (CtxCommand *) ret;
}

void ctx_drawlist_compact (CtxDrawlist *drawlist);
void
ctx_drawlist_resize (CtxDrawlist *drawlist, int desired_size)
{
  int flags=drawlist->flags;
#if CTX_DRAWLIST_STATIC
  if (flags & CTX_DRAWLIST_EDGE_LIST)
    {
      static CtxSegment sbuf[CTX_MAX_EDGE_LIST_SIZE];
      drawlist->entries = (CtxEntry*)&sbuf[0];
      drawlist->size = CTX_MAX_EDGE_LIST_SIZE;
    }
  else if (flags & CTX_DRAWLIST_CURRENT_PATH)
    {
      static CtxEntry sbuf[CTX_MAX_EDGE_LIST_SIZE];
      drawlist->entries = &sbuf[0];
      drawlist->size = CTX_MAX_EDGE_LIST_SIZE;
    }
  else
    {
      static CtxEntry sbuf[CTX_MAX_JOURNAL_SIZE];
      drawlist->entries = &sbuf[0];
      drawlist->size = CTX_MAX_JOURNAL_SIZE;
      if(0)ctx_drawlist_compact (drawlist);
    }
#else
  int new_size = desired_size;
  int min_size = CTX_MIN_JOURNAL_SIZE;
  int max_size = CTX_MAX_JOURNAL_SIZE;
  if ((flags & CTX_DRAWLIST_EDGE_LIST))
    {
      min_size = CTX_MIN_EDGE_LIST_SIZE;
      max_size = CTX_MAX_EDGE_LIST_SIZE;
    }
  else if (flags & CTX_DRAWLIST_CURRENT_PATH)
    {
      min_size = CTX_MIN_EDGE_LIST_SIZE;
      max_size = CTX_MAX_EDGE_LIST_SIZE;
    }
  else
    {
#if 0
      ctx_drawlist_compact (drawlist);
#endif
    }

  if (CTX_UNLIKELY(new_size < drawlist->size))
    { return; }
  if (CTX_UNLIKELY(drawlist->size == max_size))
    { return; }
  new_size = ctx_maxi (new_size, min_size);
  //if (new_size < drawlist->count)
  //  { new_size = drawlist->count + 4; }
  new_size = ctx_mini (new_size, max_size);
  if (new_size != drawlist->size)
    {
      int item_size = sizeof (CtxEntry);
      if (flags & CTX_DRAWLIST_EDGE_LIST) item_size = sizeof (CtxSegment);
      //fprintf (stderr, "growing drawlist %p %i to %d from %d\n", drawlist, flags, new_size, drawlist->size);
  if (drawlist->entries)
    {
      //printf ("grow %p to %d from %d\n", drawlist, new_size, drawlist->size);
      CtxEntry *ne =  (CtxEntry *) ctx_malloc (item_size * new_size);
      memcpy (ne, drawlist->entries, drawlist->size * item_size );
      ctx_free (drawlist->entries);
      drawlist->entries = ne;
      //drawlist->entries = (CtxEntry*)ctx_malloc (drawlist->entries, item_size * new_size);
    }
  else
    {
      //fprintf (stderr, "allocating for %p %d\n", drawlist, new_size);
      drawlist->entries = (CtxEntry *) ctx_malloc (item_size * new_size);
    }
  drawlist->size = new_size;
    }
  //fprintf (stderr, "drawlist %p is %d\n", drawlist, drawlist->size);
#endif
}


int
ctx_drawlist_add_single (CtxDrawlist *drawlist, const CtxEntry *entry)
{
  unsigned int max_size = CTX_MAX_JOURNAL_SIZE;
  int ret = drawlist->count;
  int flags = drawlist->flags;
  if (CTX_LIKELY((flags & CTX_DRAWLIST_EDGE_LIST ||
       flags & CTX_DRAWLIST_CURRENT_PATH)))
    {
      max_size = CTX_MAX_EDGE_LIST_SIZE;
    }
  if (CTX_UNLIKELY(flags & CTX_DRAWLIST_DOESNT_OWN_ENTRIES))
    {
      return ret;
    }
  if (CTX_UNLIKELY(ret + 64 >= drawlist->size - 40))
    {
      int new_ = CTX_MAX (drawlist->size * 2, ret + 1024);
      ctx_drawlist_resize (drawlist, new_);
    }

  if (CTX_UNLIKELY(drawlist->count >= max_size - 20))
    {
      return 0;
    }
  if ((flags & CTX_DRAWLIST_EDGE_LIST))
    ((CtxSegment*)(drawlist->entries))[drawlist->count] = *(CtxSegment*)entry;
  else
    drawlist->entries[drawlist->count] = *entry;
  ret = drawlist->count;
  drawlist->count++;
  return ret;
}


static inline int
ctx_add_single (Ctx *ctx, void *entry)
{
  return ctx_drawlist_add_single (&ctx->drawlist, (CtxEntry *) entry);
}

int
ctx_drawlist_add_entry (CtxDrawlist *drawlist, const CtxEntry *entry)
{
  int length = ctx_conts_for_entry (entry) + 1;
  int ret = 0;
  for (int i = 0; i < length; i ++)
    {
      ret = ctx_drawlist_add_single (drawlist, &entry[i]);
    }
  return ret;
}

#if 0
int
ctx_drawlist_insert_entry (CtxDrawlist *drawlist, int pos, CtxEntry *entry)
{
  int length = ctx_conts_for_entry (entry) + 1;
  int tmp_pos = ctx_drawlist_add_entry (drawlist, entry);
  for (int i = 0; i < length; i++)
  {
    for (int j = pos + i + 1; j < tmp_pos; j++)
      drawlist->entries[j] = entry[j-1];
    drawlist->entries[pos + i] = entry[i];
  }
  return pos;
}
#endif
int
ctx_drawlist_insert_entry (CtxDrawlist *drawlist, int pos, CtxEntry *entry)
{
  int length = ctx_conts_for_entry (entry) + 1;
  int tmp_pos = ctx_drawlist_add_entry (drawlist, entry);
#if 1
  for (int i = 0; i < length; i++)
  {
    for (int j = tmp_pos; j > pos + i; j--)
      drawlist->entries[j] = drawlist->entries[j-1];
    drawlist->entries[pos + i] = entry[i];
  }
  return pos;
#endif
  return tmp_pos;
}

int ctx_append_drawlist (Ctx *ctx, void *data, int length)
{
  CtxEntry *entries = (CtxEntry *) data;
  if (length % sizeof (CtxEntry) )
    {
      ctx_log("drawlist not multiple of 9\n");
      return -1;
    }
#if 0
  for (unsigned int i = 0; i < length / sizeof (CtxEntry); i++)
    {
      ctx_drawlist_add_single (&ctx->drawlist, &entries[i]);
    }
#else
  CtxDrawlist dl;
  dl.entries = entries;
  dl.count = length/9;
  dl.size = length;
  dl.flags = CTX_DRAWLIST_DOESNT_OWN_ENTRIES;

  CtxIterator it;
  ctx_iterator_init (&it, &dl, 0, 0);
  CtxCommand *command;
 
  while ((command = ctx_iterator_next (&it)))
  {
     ctx_process (ctx, (CtxEntry*)command);
  }
#endif
  return 0;
}

int ctx_set_drawlist (Ctx *ctx, void *data, int length)
{
  CtxDrawlist *drawlist = &ctx->drawlist;
  if (drawlist->flags & CTX_DRAWLIST_DOESNT_OWN_ENTRIES)
    {
      return -1;
    }
  ctx->drawlist.count = 0;
  if (!data || length == 0)
    return 0;
  if (CTX_UNLIKELY(length % 9)) return -1;
  ctx_drawlist_resize (drawlist, length/9);
  memcpy (drawlist->entries, data, length);
  drawlist->count = length / 9;
  return length;
}

const CtxEntry *ctx_get_drawlist (Ctx *ctx, int *count)
{
  if (count) *count = ctx->drawlist.count;
  return ctx->drawlist.entries;
}

void ctx_drawlist_force_count (Ctx *ctx, int count)
{
   if ((int)ctx->drawlist.count < count)
     return;
   ctx->drawlist.count = count;
}


int
ctx_add_data (Ctx *ctx, void *data, int length)
{
  if (CTX_UNLIKELY(length % sizeof (CtxEntry) ))
    {
      //ctx_log("err\n");
      return -1;
    }
  /* some more input verification might be in order.. like
   * verify that it is well-formed up to length?
   *
   * also - it would be very useful to stop processing
   * upon flush - and do drawlist resizing.
   */
  return ctx_drawlist_add_entry (&ctx->drawlist, (CtxEntry *) data);
}

int ctx_drawlist_add_u32 (CtxDrawlist *drawlist, CtxCode code, uint32_t u32[2])
{
  CtxEntry entry[4];
  entry[0].code = code;
  entry[0].data.u32[0] = u32[0];
  entry[0].data.u32[1] = u32[1];
  return ctx_drawlist_add_single (drawlist, &entry[0]);
}

int ctx_drawlist_add_data (CtxDrawlist *drawlist, const void *data, int length)
{
  CtxEntry entry[4] = {{CTX_DATA, {{0},}}};
  entry[0].data.u32[0] = 0;
  entry[0].data.u32[1] = 0;
  int ret = ctx_drawlist_add_single (drawlist, &entry[0]);
  if (CTX_UNLIKELY(!data)) { return -1; }
  int length_in_blocks;
  if (length <= 0) { length = ctx_strlen ( (char *) data) + 1; }
  length_in_blocks = length / sizeof (CtxEntry);
  length_in_blocks += (length % sizeof (CtxEntry) ) ?1:0;
  if ((signed)drawlist->count + length_in_blocks + 4 > drawlist->size)
    { ctx_drawlist_resize (drawlist, (int)(drawlist->count * 1.2 + length_in_blocks + 32)); }
  if (CTX_UNLIKELY((signed)drawlist->count >= drawlist->size))
    { return -1; }
  drawlist->count += length_in_blocks;
  drawlist->entries[ret].data.u32[0] = length;
  drawlist->entries[ret].data.u32[1] = length_in_blocks;
  memcpy (&drawlist->entries[ret+1], data, length);
  {
    //int reverse = ctx_drawlist_add (drawlist, CTX_DATA_REV);
    CtxEntry entry[4] = {{CTX_DATA_REV, {{0},}}};
    entry[0].data.u32[0] = length;
    entry[0].data.u32[1] = length_in_blocks;
    ctx_drawlist_add_single (drawlist, &entry[0]);

    /* this reverse marker exist to enable more efficient
       front to back traversal, can be ignored in other
       direction, is this needed after string setters as well?
     */
  }
  return ret;
}

#if 0
static CtxEntry
ctx_s32 (CtxCode code, int32_t x, int32_t y)
{
  CtxEntry command = ctx_void (code);
  command.data.s32[0] = x;
  command.data.s32[1] = y;
  return command;
}
#endif

static inline CtxEntry
ctx_s16 (CtxCode code, int x0, int y0, int x1, int y1)
{
  CtxEntry command;
  command.code = code;
  command.data.s16[0] = x0;
  command.data.s16[1] = y0;
  command.data.s16[2] = x1;
  command.data.s16[3] = y1;
  return command;
}


void
ctx_process_cmd_str (Ctx *ctx, CtxCode code, const char *string, uint32_t arg0, uint32_t arg1)
{
  ctx_process_cmd_str_with_len (ctx, code, string, arg0, arg1, ctx_strlen (string));
}

#if CTX_BITPACK_PACKER
static unsigned int
ctx_last_history (CtxDrawlist *drawlist)
{
  unsigned int last_history = 0;
  unsigned int i = 0;
  while (i < drawlist->count)
    {
      CtxEntry *entry = &drawlist->entries[i];
      i += (ctx_conts_for_entry (entry) + 1);
    }
  return last_history;
}
#endif

#if CTX_BITPACK_PACKER

static float
find_max_dev (CtxEntry *entry, int nentrys)
{
  float max_dev = 0.0;
  for (int c = 0; c < nentrys; c++)
    {
      for (int d = 0; d < 2; d++)
        {
          if (entry[c].data.f[d] > max_dev)
            { max_dev = entry[c].data.f[d]; }
          if (entry[c].data.f[d] < -max_dev)
            { max_dev = -entry[c].data.f[d]; }
        }
    }
  return max_dev;
}

static void
pack_s8_args (CtxEntry *entry, int npairs)
{
  for (int c = 0; c < npairs; c++)
    for (int d = 0; d < 2; d++)
      { entry[0].data.s8[c*2+d]=entry[c].data.f[d] * CTX_SUBDIV; }
}

static void
pack_s16_args (CtxEntry *entry, int npairs)
{
  for (int c = 0; c < npairs; c++)
    for (int d = 0; d < 2; d++)
      { entry[0].data.s16[c*2+d]=entry[c].data.f[d] * CTX_SUBDIV; }
}
#endif

#if CTX_BITPACK_PACKER
static void
ctx_drawlist_remove_tiny_curves (CtxDrawlist *drawlist, int start_pos)
{
  CtxIterator iterator;
  if ( (drawlist->flags & CTX_TRANSFORMATION_BITPACK) == 0)
    { return; }
  ctx_iterator_init (&iterator, drawlist, start_pos, CTX_ITERATOR_FLAT);
  iterator.end_pos = drawlist->count - 5;
  CtxCommand *command = NULL;
  while ( (command = ctx_iterator_next (&iterator) ) )
    {
      CtxEntry *entry = &command->entry;
      /* things smaller than this have probably been scaled down
         beyond recognition, bailing for both better packing and less rasterization work
       */
      if (command[0].code == CTX_REL_CURVE_TO)
        {
          float max_dev = find_max_dev (entry, 3);
          if (max_dev < 1.0)
            {
              entry[0].code = CTX_REL_LINE_TO;
              entry[0].data.f[0] = entry[2].data.f[0];
              entry[0].data.f[1] = entry[2].data.f[1];
              entry[1].code = CTX_NOP;
              entry[2].code = CTX_NOP;
            }
        }
    }
}
#endif

#if CTX_BITPACK_PACKER
static void
ctx_drawlist_bitpack (CtxDrawlist *drawlist, unsigned int start_pos)
{
#if CTX_BITPACK
  unsigned int i = 0;
  if ( (drawlist->flags & CTX_TRANSFORMATION_BITPACK) == 0)
    { return; }
  ctx_drawlist_remove_tiny_curves (drawlist, 0);
  i = 0;
  if (start_pos > i)
    { i = start_pos; }
  while (i < drawlist->count - 4) /* the -4 is to avoid looking past
                                    initialized data we're not ready
                                    to bitpack yet*/
    {
      CtxEntry *entry = &drawlist->entries[i];
      if ((int)(entry[0].code == CTX_SET_RGBA_U8) &
          (entry[1].code == CTX_MOVE_TO) &
          (entry[2].code == CTX_REL_LINE_TO) &
          (entry[3].code == CTX_REL_LINE_TO) &
          (entry[4].code == CTX_REL_LINE_TO) &
          (entry[5].code == CTX_REL_LINE_TO) &
          (entry[6].code == CTX_FILL) &
          (ctx_fabsf (entry[2].data.f[0] - 1.0f) < 0.02f) &
          (ctx_fabsf (entry[3].data.f[1] - 1.0f) < 0.02f))
        {
          entry[0].code = CTX_SET_PIXEL;
          entry[0].data.u16[2] = entry[1].data.f[0];
          entry[0].data.u16[3] = entry[1].data.f[1];
          entry[1].code = CTX_NOP;
          entry[2].code = CTX_NOP;
          entry[3].code = CTX_NOP;
          entry[4].code = CTX_NOP;
          entry[5].code = CTX_NOP;
          entry[6].code = CTX_NOP;
        }
#if 1
      else if (entry[0].code == CTX_REL_LINE_TO)
        {
          if ((entry[1].code == CTX_REL_LINE_TO) &
              (entry[2].code == CTX_REL_LINE_TO) &
              (entry[3].code == CTX_REL_LINE_TO))
            {
              float max_dev = find_max_dev (entry, 4);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 4);
                  entry[0].code = CTX_REL_LINE_TO_X4;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                  entry[3].code = CTX_NOP;
                }
            }
          else if (entry[1].code == CTX_REL_CURVE_TO)
            {
              float max_dev = find_max_dev (entry, 4);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 4);
                  entry[0].code = CTX_REL_LINE_TO_REL_CURVE_TO;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                  entry[3].code = CTX_NOP;
                }
            }
          else if ((entry[1].code == CTX_REL_LINE_TO) &
                   (entry[2].code == CTX_REL_LINE_TO) &
                   (entry[3].code == CTX_REL_LINE_TO))
            {
              float max_dev = find_max_dev (entry, 4);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 4);
                  entry[0].code = CTX_REL_LINE_TO_X4;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                  entry[3].code = CTX_NOP;
                }
            }
          else if (entry[1].code == CTX_REL_MOVE_TO)
            {
              float max_dev = find_max_dev (entry, 2);
              if (max_dev < 31000 / CTX_SUBDIV)
                {
                  pack_s16_args (entry, 2);
                  entry[0].code = CTX_REL_LINE_TO_REL_MOVE_TO;
                  entry[1].code = CTX_NOP;
                }
            }
          else if (entry[1].code == CTX_REL_LINE_TO)
            {
              float max_dev = find_max_dev (entry, 2);
              if (max_dev < 31000 / CTX_SUBDIV)
                {
                  pack_s16_args (entry, 2);
                  entry[0].code = CTX_REL_LINE_TO_X2;
                  entry[1].code = CTX_NOP;
                }
            }
        }
#endif
#if 1
      else if (entry[0].code == CTX_REL_CURVE_TO)
        {
          if (entry[3].code == CTX_REL_LINE_TO)
            {
              float max_dev = find_max_dev (entry, 4);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 4);
                  entry[0].code = CTX_REL_CURVE_TO_REL_LINE_TO;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                  entry[3].code = CTX_NOP;
                }
            }
          else if (entry[3].code == CTX_REL_MOVE_TO)
            {
              float max_dev = find_max_dev (entry, 4);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 4);
                  entry[0].code = CTX_REL_CURVE_TO_REL_MOVE_TO;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                  entry[3].code = CTX_NOP;
                }
            }
          else
            {
              float max_dev = find_max_dev (entry, 3);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 3);
                  ctx_arg_s8 (6) =
                    ctx_arg_s8 (7) = 0;
                  entry[0].code = CTX_REL_CURVE_TO_REL_LINE_TO;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                }
            }
        }
#endif
#if 1
      else if (entry[0].code == CTX_REL_QUAD_TO)
        {
          if (entry[2].code == CTX_REL_QUAD_TO)
            {
              float max_dev = find_max_dev (entry, 4);
              if (max_dev < 114 / CTX_SUBDIV)
                {
                  pack_s8_args (entry, 4);
                  entry[0].code = CTX_REL_QUAD_TO_REL_QUAD_TO;
                  entry[1].code = CTX_NOP;
                  entry[2].code = CTX_NOP;
                  entry[3].code = CTX_NOP;
                }
            }
          else
            {
              float max_dev = find_max_dev (entry, 2);
              if (max_dev < 3100 / CTX_SUBDIV)
                {
                  pack_s16_args (entry, 2);
                  entry[0].code = CTX_REL_QUAD_TO_S16;
                  entry[1].code = CTX_NOP;
                }
            }
        }
#endif
#if 1
      else if (entry[0].code == CTX_FILL &&
               entry[1].code == CTX_MOVE_TO)
        {
          entry[0] = entry[1];
          entry[0].code = CTX_FILL_MOVE_TO;
          entry[1].code = CTX_NOP;
        }
#endif
#if 1
      else if (entry[0].code == CTX_MOVE_TO &&
               entry[1].code == CTX_MOVE_TO &&
               entry[2].code == CTX_MOVE_TO)
        {
          entry[0]      = entry[2];
          entry[0].code = CTX_MOVE_TO;
          entry[1].code = CTX_NOP;
          entry[2].code = CTX_NOP;
        }
#endif
#if 1
      else if ( (entry[0].code == CTX_MOVE_TO &&
                 entry[1].code == CTX_MOVE_TO) ||
                (entry[0].code == CTX_REL_MOVE_TO &&
                 entry[1].code == CTX_MOVE_TO) )
        {
          entry[0]      = entry[1];
          entry[0].code = CTX_MOVE_TO;
          entry[1].code = CTX_NOP;
        }
#endif
      i += (ctx_conts_for_entry (entry) + 1);
    }

  unsigned int source = 0;
  unsigned int target = 0;
  int removed = 0;
  /* remove nops that have been inserted as part of shortenings
   */
  while (source < drawlist->count)
    {
      CtxEntry *sentry = &drawlist->entries[source];
      CtxEntry *tentry = &drawlist->entries[target];
      while (sentry->code == CTX_NOP && source < drawlist->count)
        {
          source++;
          sentry = &drawlist->entries[source];
          removed++;
        }
      if (sentry != tentry)
        { *tentry = *sentry; }
      source ++;
      target ++;
    }
  drawlist->count -= removed;
#endif
}

#endif

void
ctx_drawlist_compact (CtxDrawlist *drawlist)
{
#if CTX_BITPACK_PACKER
  unsigned int last_history;
  last_history = ctx_last_history (drawlist);
#else
  if (drawlist) {};
#endif
#if CTX_BITPACK_PACKER
  ctx_drawlist_bitpack (drawlist, last_history);
#endif
}

uint8_t *ctx_define_texture_pixel_data (const CtxEntry *entry)
{
  return (uint8_t*)&entry[2 + 1 + 1 + ctx_conts_for_entry (&entry[2])].data.u8[0];
}

uint32_t ctx_define_texture_pixel_data_length (const CtxEntry *entry)
{
  return entry[2 + 1 + ctx_conts_for_entry (&entry[2])].data.u32[0];
}
#ifndef __CTX_TRANSFORM
#define __CTX_TRANSFORM


static inline void
_ctx_matrix_apply_transform_only_x (const CtxMatrix *m, float *x, float y_in)
{
  //float x_in = *x;
  //*x = ( (x_in * m->m[0][0]) + (y_in * m->m[1][0]) + m->m[2][0]);
  float y_res;
  _ctx_matrix_apply_transform (m, x, &y_res);
}

void
ctx_matrix_apply_transform (const CtxMatrix *m, float *x, float *y)
{
  _ctx_matrix_apply_transform (m, x, y);
}




static inline void
_ctx_matrix_apply_transform_perspective_fixed (const Ctx16f16Matrix *m, int x_in, int y_in,
                int *x_out, int *y_out)
{
  int w  = (((x_in * m->m[2][0] +
               y_in * m->m[2][1])>>TRANSFORM_SHIFT) +
                     (m->m[2][2]));
  int w_recip = w?TRANSFORM_SCALE / w:0;


  *x_out = ((((((x_in * m->m[0][0] +
               y_in * m->m[0][1])>>TRANSFORM_SHIFT) +
                     (m->m[0][2])) * w_recip)>>TRANSFORM_SHIFT) * CTX_SUBDIV) >> TRANSFORM_SHIFT;
  *y_out = ((((((x_in * m->m[1][0] +
               y_in * m->m[1][1])>>TRANSFORM_SHIFT) +
                     (m->m[1][2])) * w_recip)>>TRANSFORM_SHIFT) * CTX_FULL_AA) >> TRANSFORM_SHIFT;

}

static inline void
_ctx_matrix_apply_transform_affine_fixed (const Ctx16f16Matrix *m, int x_in, int y_in,
                int *x_out, int *y_out)
{
  *x_out = ((((x_in * m->m[0][0] +
               y_in * m->m[0][1])>>TRANSFORM_SHIFT) +
                     (m->m[0][2])) * CTX_SUBDIV) >>TRANSFORM_SHIFT;
  *y_out = ((((x_in * m->m[1][0] +
               y_in * m->m[1][1])>>TRANSFORM_SHIFT) +
                     (m->m[1][2])) * CTX_FULL_AA) >>TRANSFORM_SHIFT;
}

static inline void
_ctx_matrix_apply_transform_scale_translate_fixed (const Ctx16f16Matrix *m, int x_in, int y_in, int *x_out, int *y_out)
{
  *x_out = ((((x_in * m->m[0][0])>>TRANSFORM_SHIFT) +
                     (m->m[0][2])) * CTX_SUBDIV) >>TRANSFORM_SHIFT;
  *y_out = ((((y_in * m->m[1][1])>>TRANSFORM_SHIFT) +
                     (m->m[1][2])) * CTX_FULL_AA) >>TRANSFORM_SHIFT;
}

void
_ctx_user_to_device_prepped_fixed (CtxState *state, int x, int y, int *x_out, int *y_out)
{
  switch (state->gstate.transform_type)
  {
    case 0:
      _ctx_transform_prime (state);
      _ctx_user_to_device_prepped_fixed (state, x, y, x_out, y_out);
      break;
    case 1:  // identity
      *x_out = (x * CTX_SUBDIV) >> TRANSFORM_SHIFT;
      *y_out = (y * CTX_FULL_AA) >> TRANSFORM_SHIFT;
      break;
    case 2:  // scale/translate
      _ctx_matrix_apply_transform_scale_translate_fixed (&state->gstate.prepped_transform, x, y, x_out, y_out);
      break;
    case 3:  // affine
      _ctx_matrix_apply_transform_affine_fixed (&state->gstate.prepped_transform, x, y, x_out, y_out);
      break;
    case 4:  // perspective
      _ctx_matrix_apply_transform_perspective_fixed (&state->gstate.prepped_transform, x, y, x_out, y_out);
      break;
  }
}

void
_ctx_user_to_device_prepped (CtxState *state, float x, float y, int *x_out, int *y_out)
{
  int x_in = (int)(x * TRANSFORM_SCALE);
  int y_in = (int)(y * TRANSFORM_SCALE);
  _ctx_user_to_device_prepped_fixed (state, x_in, y_in, x_out, y_out);
}

inline void
_ctx_user_to_device (CtxState *state, float *x, float *y)
{
  _ctx_matrix_apply_transform (&state->gstate.transform, x, y);
}

static inline void
_ctx_matrix_apply_transform_distance (const CtxMatrix *m, float *x, float *y)
{
  float x0 = 0.0f;
  float y0 = 0.0f;
  float x1 = *x;
  float y1 = *y;

  _ctx_matrix_apply_transform (m, &x0, &y0);
  _ctx_matrix_apply_transform (m, &x1, &y1);
  *x = (x1-x0);
  *y = (y1-y0);
}

void
ctx_matrix_apply_transform_distance (const CtxMatrix *m, float *x, float *y)
{
  _ctx_matrix_apply_transform_distance (m, x, y);
}

void
_ctx_user_to_device_distance (CtxState *state, float *x, float *y)
{
  ctx_matrix_apply_transform_distance (&state->gstate.transform, x, y);
}

void ctx_user_to_device          (Ctx *ctx, float *x, float *y)
{
  _ctx_user_to_device (&ctx->state, x, y);
}
void ctx_user_to_device_distance (Ctx *ctx, float *x, float *y)
{
  _ctx_user_to_device_distance (&ctx->state, x, y);
}

static inline void
_ctx_device_to_user (CtxState *state, float *x, float *y)
{
  CtxMatrix m = state->gstate.transform;
  ctx_matrix_invert (&m);
  _ctx_matrix_apply_transform (&m, x, y);
}

void
_ctx_device_to_user_distance (CtxState *state, float *x, float *y)
{
  CtxMatrix m = state->gstate.transform;
  ctx_matrix_invert (&m);
  _ctx_matrix_apply_transform (&m, x, y);
  *x -= m.m[2][0];
  *y -= m.m[2][1];
}

void ctx_device_to_user          (Ctx *ctx, float *x, float *y)
{
  _ctx_device_to_user (&ctx->state, x, y);
}

void ctx_device_to_user_distance (Ctx *ctx, float *x, float *y)
{
  _ctx_device_to_user_distance (&ctx->state, x, y);
}


void
ctx_matrix_identity (CtxMatrix *matrix)
{
  _ctx_matrix_identity (matrix);
}

void
ctx_matrix_multiply (CtxMatrix       *result,
                     const CtxMatrix *t,
                     const CtxMatrix *s)
{
  _ctx_matrix_multiply (result, t, s);
}

void
ctx_matrix_translate (CtxMatrix *matrix, float x, float y)
{
  CtxMatrix transform;
  transform.m[0][0] = 1.0f;
  transform.m[0][1] = 0.0f;
  transform.m[0][2] = x;
  transform.m[1][0] = 0.0f;
  transform.m[1][1] = 1.0f;
  transform.m[1][2] = y;
  transform.m[2][0] = 0.0f;
  transform.m[2][1] = 0.0f;
  transform.m[2][2] = 1.0f;
  _ctx_matrix_multiply (matrix, matrix, &transform);
}

void
ctx_matrix_scale (CtxMatrix *matrix, float x, float y)
{
  CtxMatrix transform;
  transform.m[0][0] = x;
  transform.m[0][1] = 0.0f;
  transform.m[0][2] = 0.0f;
  transform.m[1][0] = 0.0f;
  transform.m[1][1] = y;
  transform.m[1][2] = 0.0f;
  transform.m[2][0] = 0.0f;
  transform.m[2][1] = 0.0f;
  transform.m[2][2] = 1.0;
  _ctx_matrix_multiply (matrix, matrix, &transform);
}


void
ctx_matrix_rotate (CtxMatrix *matrix, float angle)
{
  CtxMatrix transform;
  float val_sin = ctx_sinf (-angle);
  float val_cos = ctx_cosf (-angle);
  transform.m[0][0] = val_cos;
  transform.m[0][1] = val_sin;
  transform.m[0][2] = 0;
  transform.m[1][0] = -val_sin;
  transform.m[1][1] = val_cos;
  transform.m[1][2] = 0;
  transform.m[2][0] = 0.0f;
  transform.m[2][1] = 0.0f;
  transform.m[2][2] = 1.0f;
  _ctx_matrix_multiply (matrix, matrix, &transform);
}

#if 0
static void
ctx_matrix_skew_x (CtxMatrix *matrix, float angle)
{
  CtxMatrix transform;
  float val_tan = ctx_tanf (angle);
  transform.m[0][0] =    1.0f;
  transform.m[0][1] = 0.0f;
  transform.m[1][0] = val_tan;
  transform.m[1][1] = 1.0f;
  transform.m[2][0] =    0.0f;
  transform.m[2][1] = 0.0f;
  _ctx_matrix_multiply (matrix, &transform, matrix);
}

static void
ctx_matrix_skew_y (CtxMatrix *matrix, float angle)
{
  CtxMatrix transform;
  float val_tan = ctx_tanf (angle);
  transform.m[0][0] =    1.0f;
  transform.m[0][1] = val_tan;
  transform.m[1][0] =    0.0f;
  transform.m[1][1] = 1.0f;
  transform.m[2][0] =    0.0f;
  transform.m[2][1] = 0.0f;
  _ctx_matrix_multiply (matrix, &transform, matrix);
}
#endif


void
ctx_identity (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_IDENTITY);
}



void
ctx_apply_transform (Ctx *ctx, float a, float b,
                     float c, float d, 
                     float e, float f, float g, float h, float i)
{
  CtxEntry command[5]=
  {
    ctx_f (CTX_APPLY_TRANSFORM, a, b),
    ctx_f (CTX_CONT,            c, d),
    ctx_f (CTX_CONT,            e, f),
    ctx_f (CTX_CONT,            g, h),
    ctx_f (CTX_CONT,            i, 0)
  };
  ctx_process (ctx, command);
}

void
ctx_get_transform  (Ctx *ctx, float *a, float *b,
                    float *c, float *d,
                    float *e, float *f,
                    float *g, float *h,
                    float *i)
{
  if (a) { *a = ctx->state.gstate.transform.m[0][0]; }
  if (b) { *b = ctx->state.gstate.transform.m[0][1]; }
  if (c) { *c = ctx->state.gstate.transform.m[0][2]; }
  if (d) { *d = ctx->state.gstate.transform.m[1][0]; }
  if (e) { *e = ctx->state.gstate.transform.m[1][1]; }
  if (f) { *f = ctx->state.gstate.transform.m[1][2]; }
  if (g) { *g = ctx->state.gstate.transform.m[2][0]; }
  if (h) { *h = ctx->state.gstate.transform.m[2][1]; }
  if (i) { *i = ctx->state.gstate.transform.m[2][2]; }
}

void
ctx_source_transform (Ctx *ctx, float a, float b,  // hscale, hskew
                      float c, float d,  // vskew,  vscale
                      float e, float f,
                      float g, float h,
                      float i)  // htran,  vtran
{
  CtxEntry command[5]=
  {
    ctx_f (CTX_SOURCE_TRANSFORM, a, b),
    ctx_f (CTX_CONT,             c, d),
    ctx_f (CTX_CONT,             e, f),
    ctx_f (CTX_CONT,             g, h),
    ctx_f (CTX_CONT,             i, 0)
  };
  ctx_process (ctx, command);
}

void
ctx_source_transform_matrix (Ctx *ctx, CtxMatrix *matrix)
{
  ctx_source_transform (ctx,
    matrix->m[0][0], matrix->m[0][1], matrix->m[0][2],
    matrix->m[1][0], matrix->m[1][1], matrix->m[1][2],
    matrix->m[2][0], matrix->m[2][1], matrix->m[2][2]
    
    );
}

void ctx_apply_matrix (Ctx *ctx, CtxMatrix *matrix)
{
  ctx_apply_transform (ctx,
    matrix->m[0][0], matrix->m[0][1], matrix->m[0][2],
    matrix->m[1][0], matrix->m[1][1], matrix->m[1][2],
    matrix->m[2][0], matrix->m[2][1], matrix->m[2][2]);
}

void ctx_get_matrix (Ctx *ctx, CtxMatrix *matrix)
{
  *matrix = ctx->state.gstate.transform;
}

void ctx_set_matrix (Ctx *ctx, CtxMatrix *matrix)
{
  ctx_identity (ctx);
  ctx_apply_matrix (ctx, matrix);
}

void ctx_rotate (Ctx *ctx, float x)
{
  if (x == 0.0f)
    return;
  CTX_PROCESS_F1 (CTX_ROTATE, x);
  if (ctx->transformation & CTX_TRANSFORMATION_SCREEN_SPACE)
    { ctx->drawlist.count--; }
}

void ctx_scale (Ctx *ctx, float x, float y)
{
  if (((x == 1.0f) & (y == 1.0f)) | (x == 0.0f) | (y == 0.0f))
    return;
  CTX_PROCESS_F (CTX_SCALE, x, y);
  if (ctx->transformation & CTX_TRANSFORMATION_SCREEN_SPACE)
    { ctx->drawlist.count--; }
}

void ctx_translate (Ctx *ctx, float x, float y)
{
  if ((x == 0.0f) & (y == 0.0f))
    return;
  CTX_PROCESS_F (CTX_TRANSLATE, x, y);
  if (ctx->transformation & CTX_TRANSFORMATION_SCREEN_SPACE)
    { ctx->drawlist.count--; }
}

static inline float
ctx_matrix_determinant (const CtxMatrix *m)
{
  float det = m->m[0][0] * (m->m[1][1] * m->m[2][2] -
                            m->m[1][2] * m->m[2][1])
              - m->m[0][1] * (m->m[1][0] * m->m[2][2] -
                              m->m [1][2] * m->m [2][0])
              + m->m[0][2] * (m->m[1][0] * m->m[2][1] -
                              m->m[1][1] * m->m[2][0]);
  return det;
}

void
ctx_matrix_invert (CtxMatrix *m)
{
  CtxMatrix t = *m;
  float c = 1.0f / ctx_matrix_determinant (m);

  m->m [0][0] = (t.m [1][1] * t.m [2][2] -
                   t.m [1][2] * t.m [2][1]) * c;
  m->m [1][0] = (t.m [1][2] * t.m [2][0] -
                   t.m [1][0] * t.m [2][2]) * c;
  m->m [2][0] = (t.m [1][0] * t.m [2][1] -
                   t.m [1][1] * t.m [2][0]) * c;

  m->m [0][1] = (t.m [0][2] * t.m [2][1] -
                   t.m [0][1] * t.m [2][2]) * c;
  m->m [1][1] = (t.m [0][0] * t.m [2][2] -
                   t.m [0][2] * t.m [2][0]) * c;
  m->m [2][1] = (t.m [0][1] * t.m [2][0] -
                   t.m [0][0] * t.m [2][1]) * c;

  m->m [0][2] = (t.m [0][1] * t.m [1][2] -
                   t.m [0][2] * t.m [1][1]) * c;
  m->m [1][2] = (t.m [0][2] * t.m [1][0] -
                   t.m [0][0] * t.m [1][2]) * c;
  m->m [2][2] = (t.m [0][0] * t.m [1][1] -
                   t.m [0][1] * t.m [1][0]) * c;
}

#endif
#if CTX_AUDIO

//#include <string.h>
//#include "ctx-internal.h"
//#include "mmm.h"

#if !__COSMOPOLITAN__

#include <pthread.h>
#if CTX_ALSA
#include <alsa/asoundlib.h>
#endif

#endif

#define DESIRED_PERIOD_SIZE 1000

static pthread_mutex_t ctx_audio_mutex;

int ctx_pcm_bytes_per_frame (CtxPCM format)
{
  switch (format)
  {
    case CTX_F32:  return 4;
    case CTX_F32S: return 8;
    case CTX_S16:  return 2;
    case CTX_S16S: return 4;
    default: return 1;
  }
}

static float    ctx_host_freq     = 48000;
static CtxPCM   ctx_host_format   = CTX_S16S;
static float    client_freq   = 48000;
static CtxPCM   ctx_client_format = CTX_S16S;
static int      ctx_pcm_queued    = 0;
static int      ctx_pcm_cur_left  = 0;
static CtxList *ctx_pcm_list;                 /* data is a blob a 32bit uint first, followed by pcm-data */


//static long int ctx_pcm_queued_ticks = 0;  /*  the number of ticks into the future
  //                                      *  we've queued audio for
                                       


int
ctx_pcm_channels (CtxPCM format)
{
  switch (format)
  {
    case CTX_S16:
    case CTX_F32:
      return 1;
    case CTX_S16S:
    case CTX_F32S:
      return 2;
  }
  return 0;
}

/* todo: only start audio thread on first write - enabling dynamic choice
 * of sample-rate? or is it better to keep to opening 48000 as a standard
 * and do better internal resampling for others?
 */

#if CTX_ALSA
static snd_pcm_t *alsa_open (char *dev, int rate, int channels)
{
   snd_pcm_hw_params_t *hwp;
   snd_pcm_sw_params_t *swp;
   snd_pcm_t *h;
   int r;
   int dir;
   snd_pcm_uframes_t period_size_min;
   snd_pcm_uframes_t period_size_max;
   snd_pcm_uframes_t period_size;
   snd_pcm_uframes_t buffer_size;

   if ((r = snd_pcm_open(&h, dev, SND_PCM_STREAM_PLAYBACK, 0) < 0))
           return NULL;

   hwp = (snd_pcm_hw_params_t*)alloca(snd_pcm_hw_params_sizeof());
   memset(hwp, 0, snd_pcm_hw_params_sizeof());
   snd_pcm_hw_params_any(h, hwp);

   snd_pcm_hw_params_set_access(h, hwp, SND_PCM_ACCESS_RW_INTERLEAVED);
   snd_pcm_hw_params_set_format(h, hwp, SND_PCM_FORMAT_S16_LE);
   snd_pcm_hw_params_set_rate(h, hwp, rate, 0);
   snd_pcm_hw_params_set_channels(h, hwp, channels);
   dir = 0;
   snd_pcm_hw_params_get_period_size_min(hwp, &period_size_min, &dir);
   dir = 0;
   snd_pcm_hw_params_get_period_size_max(hwp, &period_size_max, &dir);

   period_size = DESIRED_PERIOD_SIZE;

   dir = 0;
   r = snd_pcm_hw_params_set_period_size_near(h, hwp, &period_size, &dir);
   r = snd_pcm_hw_params_get_period_size(hwp, &period_size, &dir);
   buffer_size = period_size * 4;
   r = snd_pcm_hw_params_set_buffer_size_near(h, hwp, &buffer_size);
   r = snd_pcm_hw_params(h, hwp);
   swp = (snd_pcm_sw_params_t*)alloca(snd_pcm_hw_params_sizeof());
   memset(hwp, 0, snd_pcm_sw_params_sizeof());
   snd_pcm_sw_params_current(h, swp);
   r = snd_pcm_sw_params_set_avail_min(h, swp, period_size);
   snd_pcm_sw_params_set_start_threshold(h, swp, 0);
   r = snd_pcm_sw_params(h, swp);
   r = snd_pcm_prepare(h);

   return h;
}

static  snd_pcm_t *h = NULL;
static void *ctx_alsa_audio_start(Ctx *ctx)
{
  static int16_t pcm_data[81920*8]={0,};
//  Lyd *lyd = aux;
  int c;

  /* The audio handler is implemented as a mixer that adds data on top
   * of 0s, XXX: it should be ensured that minimal work is there is
   * no data available.
   */
  for (;;)
  {
    int client_channels = ctx_pcm_channels (ctx_client_format);
    int is_float = 0;

    if (ctx_client_format == CTX_F32 ||
        ctx_client_format == CTX_F32S)
      is_float = 1;

    c = snd_pcm_wait(h, 1000);

    if (c >= 0)
       c = snd_pcm_avail_update(h);

    if (c > 1000) c = 1000; // should use max mmm buffer sizes

    if (c == -EPIPE)
      snd_pcm_prepare(h);

    if (c > 0)
    {
      int i;
      uint16_t left = 0, right = 0;
      for (i = 0; i < c && ctx_pcm_cur_left; i ++)
      {
        if (ctx_pcm_list && ctx_pcm_cur_left)  //  XXX  this line can be removed
        {
          uint32_t *packet_sizep = (uint32_t*)(ctx_pcm_list->data);
          uint32_t packet_size = *packet_sizep;

          if (is_float)
          {
            float *packet = (float*)(ctx_pcm_list->data);
            packet += 4;
            packet += (packet_size - ctx_pcm_cur_left) * client_channels;
            left = right = packet[0] * (1<<15);
            if (client_channels > 1)
              right = packet[0] * (1<<15);
          }
          else // S16
          {
            uint16_t *packet = (uint16_t*)(ctx_pcm_list->data);
            packet += 8;
            packet += (packet_size - ctx_pcm_cur_left) * client_channels;

            left = right = packet[0];
            if (client_channels > 1)
              right = packet[1];
          }
          pcm_data[i * 2 + 0] = left;
          pcm_data[i * 2 + 1] = right;

          ctx_pcm_cur_left--;
          ctx_pcm_queued --;
          if (ctx_pcm_cur_left == 0)
          {
            void *old = ctx_pcm_list->data;
            pthread_mutex_lock (&ctx_audio_mutex);
            ctx_list_remove (&ctx_pcm_list, old);
            pthread_mutex_unlock (&ctx_audio_mutex);
            ctx_free (old);
            ctx_pcm_cur_left = 0;
            if (ctx_pcm_list)
            {
              uint32_t *packet_sizep = (uint32_t*)(ctx_pcm_list->data);
              uint32_t packet_size = *packet_sizep;
              ctx_pcm_cur_left = packet_size;
            }
          }
        }
      }
      for (;i < c; i ++)
      {
         /* slight click protection in case we were not left at dc */
         pcm_data[i * 2 + 0] = (left *= 0.5f);
         pcm_data[i * 2 + 1] = (right *= 0.5f);
      }


    c = snd_pcm_writei(h, pcm_data, c);
    if (c < 0)
      c = snd_pcm_recover (h, c, 0);
     }else{
      if (getenv("LYD_FATAL_UNDERRUNS"))
        {
          printf ("dying XXxx need to add API for this debug\n");
          //printf ("%i", lyd->active);
          exit(0);
        }
      fprintf (stderr, "ctx alsa underun\n");
      //exit(0);
    }
  }
}
#endif

static const char CtxMuLawCompressTable[256] =
{
   0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
   4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
};

static unsigned char CtxLinearToMuLawSample(int16_t sample)
{
  const int cBias = 0x84;
  const int cClip = 32635;
  int sign = (sample >> 8) & 0x80;

  if (sign)
    sample = (int16_t)-sample;

  if (sample > cClip)
    sample = cClip;

  sample = (int16_t)(sample + cBias);

  int exponent = (int)CtxMuLawCompressTable[(sample>>7) & 0xFF];
  int mantissa = (sample >> (exponent+3)) & 0x0F;

  int compressedByte = ~ (sign | (exponent << 4) | mantissa);

  return (unsigned char)compressedByte;
}

void ctx_ctx_pcm (Ctx *ctx)
{
    int client_channels = ctx_pcm_channels (ctx_client_format);
    int is_float = 0;
    uint8_t data[81920*8]={0,};
    int c;

    if (ctx_client_format == CTX_F32 ||
        ctx_client_format == CTX_F32S)
      is_float = 1;

    c = 2000;

    if (c > 0 && ctx_pcm_list)
    {
      int i;
      for (i = 0; i < c && ctx_pcm_cur_left; i ++)
      {
        if (ctx_pcm_list && ctx_pcm_cur_left)
        {
          uint32_t *packet_sizep = (uint32_t*)(ctx_pcm_list->data);
          uint32_t packet_size = *packet_sizep;
          int left = 0, right = 0;

          if (is_float)
          {
            float *packet = (float*)(ctx_pcm_list->data);
            packet += 4;
            packet += (packet_size - ctx_pcm_cur_left) * client_channels;
            left = right = packet[0] * (1<<15);
            if (client_channels > 1)
              right = packet[1] * (1<<15);
          }
          else // S16
          {
            uint16_t *packet = (uint16_t*)(ctx_pcm_list->data);
            packet += 8;
            packet += (packet_size - ctx_pcm_cur_left) * client_channels;

            left = right = packet[0];
            if (client_channels > 1)
              right = packet[1];
          }
          data[i] = CtxLinearToMuLawSample((left+right)/2);

          ctx_pcm_cur_left--;
          ctx_pcm_queued --;
          if (ctx_pcm_cur_left == 0)
          {
            void *old = ctx_pcm_list->data;
            pthread_mutex_lock (&ctx_audio_mutex);
            ctx_list_remove (&ctx_pcm_list, old);
            pthread_mutex_unlock (&ctx_audio_mutex);
            ctx_free (old);
            ctx_pcm_cur_left = 0;
            if (ctx_pcm_list)
            {
              uint32_t *packet_sizep = (uint32_t*)(ctx_pcm_list->data);
              uint32_t packet_size = *packet_sizep;
              ctx_pcm_cur_left = packet_size;
            }
          }
        }
      }

    char encoded[81920*8]="";

    int encoded_len = ctx_a85enc (data, encoded, i);
    fprintf (stdout, "\033_Af=%i;", i);
    fwrite (encoded, 1, encoded_len, stdout);
    fwrite ("\033\\", 1, 2, stdout);
    fflush (stdout);
    }
}

#if CTX_AUDIO_HOST
int ctx_host_audio_init (int hz, CtxPCM format);
#endif

int ctx_pcm_init (Ctx *ctx)
{
   static int inited = 0;
   if (inited) return 0;

   pthread_mutex_init (&ctx_audio_mutex, NULL);
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    return 0;
  }
  else
#endif
  if (ctx_backend_type (ctx) == CTX_BACKEND_CTX)
  {
     ctx_host_freq = 8000;
     ctx_host_format = CTX_S16;
#if 0
     pthread_t tid;
     pthread_create(&tid, NULL, (void*)ctx_audio_start, ctx);
#endif
  }
  else
  {
#if CTX_AUDIO_HOST
     if (!ctx_host_audio_init (ctx_host_freq, ctx_host_format))
        return -1;
#endif
#if CTX_ALSA
     pthread_t tid;
     h = alsa_open((char*)"default", ctx_host_freq, ctx_pcm_channels (ctx_host_format));
  if (!h) {
    fprintf(stderr, "ctx unable to open ALSA device (%d channels, %f Hz), dying\n",
            ctx_pcm_channels (ctx_host_format), ctx_host_freq);
    return -1;
  }
  pthread_mutex_lock (&ctx_audio_mutex);
  pthread_mutex_unlock (&ctx_audio_mutex);

  pthread_create(&tid, NULL, (void* (*)(void*)) ctx_alsa_audio_start, ctx);
#endif
  }
  inited = 1;
  return 0;
}

int ctx_pcm_queue (Ctx *ctx, const int8_t *data, int frames)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    return mmm_pcm_queue (ctx->backend_data, data, frames);
  }
  else
#endif
  {
    ctx_pcm_init (ctx);
    float factor = client_freq * 1.0 / ctx_host_freq;
    int   scaled_frames = frames / factor;
    int   bpf = ctx_pcm_bytes_per_frame (ctx_client_format);

    uint8_t *packet = (uint8_t*)ctx_malloc (scaled_frames * ctx_pcm_bytes_per_frame (ctx_client_format) + 16);
    *((uint32_t *)packet) = scaled_frames;

    if (factor > 0.999 && factor < 1.0001)
    {
       memcpy (packet + 16, data, frames * bpf);
    }
    else
    {
      /* a crude nearest / sample-and hold resampler */
      int i;
      for (i = 0; i < scaled_frames; i++)
      {
        int source_frame = i * factor;
        memcpy (packet + 16 + bpf * i, data + source_frame * bpf, bpf);
      }
    }
    if (ctx_pcm_list == NULL)     // otherwise it is another frame at front
      ctx_pcm_cur_left = scaled_frames;  // and current cur_left is valid

    pthread_mutex_lock (&ctx_audio_mutex);
    ctx_list_append (&ctx_pcm_list, packet);
    pthread_mutex_unlock (&ctx_audio_mutex);
    ctx_pcm_queued += scaled_frames;

    return frames;
  }
  return 0;
}

static int ctx_pcm_get_queued_frames (Ctx *ctx)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    return mmm_pcm_get_queued_frames (ctx->backend_data);
  }
#endif
  return ctx_pcm_queued;
}

int ctx_pcm_get_queued (Ctx *ctx)
{
  return ctx_pcm_get_queued_frames (ctx);
}

float ctx_pcm_get_queued_length (Ctx *ctx)
{
  return 1.0 * ctx_pcm_get_queued_frames (ctx) / ctx_host_freq;
}

int ctx_pcm_get_frame_chunk (Ctx *ctx)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    return mmm_pcm_get_frame_chunk (ctx->backend_data);
  }
#endif
  if (ctx_backend_type (ctx) == CTX_BACKEND_CTX)
  {
    // 300 stuttering
    // 350 nothing
    // 380 slight buzz
    // 390  buzzing
    // 400 ok - but sometimes falling out
    // 410 buzzing
    // 420 ok - but odd latency
    // 450 buzzing

    if (ctx_pcm_get_queued_frames (ctx) > 400)
      return 0;
    else
      return 400 - ctx_pcm_get_queued_frames (ctx);

  }

  if (ctx_pcm_get_queued_frames (ctx) > 1000)
    return 0;
  else
    return 1000 - ctx_pcm_get_queued_frames (ctx);
}

void ctx_pcm_set_sample_rate (Ctx *ctx, int sample_rate)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    mmm_pcm_set_sample_rate (ctx->backend_data, sample_rate);
  }
  else
#endif
    client_freq = sample_rate;
}

void ctx_pcm_set_format (Ctx *ctx, CtxPCM format)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    mmm_pcm_set_format (ctx->backend_data, format);
  }
  else
#endif
    ctx_client_format = format;
}

CtxPCM ctx_pcm_get_format (Ctx *ctx)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    return mmm_pcm_get_format (ctx->backend_data);
  }
#endif
  return ctx_client_format;
}

int ctx_pcm_get_sample_rate (Ctx *ctx)
{
#if 0
  if (!strcmp (ctx->backend->name, "mmm") ||
      !strcmp (ctx->backend->name, "mmm-client"))
  {
    return mmm_pcm_get_sample_rate (ctx->backend_data);
  }
#endif
  return client_freq;
}

#else

void ctx_pcm_set_format (Ctx *ctx, CtxPCM format) { }
void ctx_pcm_set_sample_rate (Ctx *ctx, int sample_rate) { }
int ctx_pcm_get_sample_rate (Ctx *ctx) { return 48000; }
CtxPCM ctx_pcm_get_format (Ctx *ctx) { return CTX_S16S; }
int  ctx_pcm_queue (Ctx *ctx, const int8_t *data, int frames) { return frames; }
float ctx_pcm_get_queued_length (Ctx *ctx) { return 0.0; }

#endif
 /* Copyright (C) 2020 Øyvind Kolås <pippin@gimp.org>
 */

#if CTX_FORMATTER || CTX_AUDIO

/* returns the maximum string length including terminating \0 */
int ctx_a85enc_len (int input_length)
{
  return (input_length / 4 + 1) * 5;
}

int ctx_a85enc (const void *srcp, char *dst, int count)
{
  const uint8_t *src = (uint8_t*)srcp;
  int out_len = 0;

  int padding = 4-(count % 4);
  if (padding == 4) padding = 0;

  for (int i = 0; i < (count+3)/4; i ++)
  {
    uint32_t input = 0;
    for (int j = 0; j < 4; j++)
    {
      input = (input << 8);
      if (i*4+j<=count)
        input += src[i*4+j];
    }

    int divisor = 85 * 85 * 85 * 85;
#if 0
    if (input == 0)
    {
        dst[out_len++] = 'z';
    }
    /* todo: encode 4 spaces as 'y' */
    else
#endif
    {
      for (int j = 0; j < 5; j++)
      {
        dst[out_len++] = ((input / divisor) % 85) + '!';
        divisor /= 85;
      }
    }
  }
  out_len -= padding;
  dst[out_len]=0;
  return out_len;
}
#endif

#if CTX_PARSER

int ctx_a85dec (const char *src, char *dst, int count)
{
  int out_len = 0;
  uint32_t val = 0;
  int k = 0;
  int i = 0;
  int p = 0;
  for (i = 0; i < count; i ++)
  {
    p = src[i];
    val *= 85;
    if (CTX_UNLIKELY(p == '~'))
    {
      break;
    }
#if 0
    else if (p == 'z')
    {
      for (int j = 0; j < 4; j++)
        dst[out_len++] = 0;
      k = 0;
    }
    else if (p == 'y') /* lets support this extension */
    {
      for (int j = 0; j < 4; j++)
        dst[out_len++] = 32;
      k = 0;
    }
#endif
    else if (CTX_LIKELY(p >= '!' && p <= 'u'))
    {
      val += p-'!';
      if (CTX_UNLIKELY (k % 5 == 4))
      {
         for (int j = 0; j < 4; j++)
         {
           dst[out_len++] = (val & ((unsigned)0xff << 24)) >> 24;
           val <<= 8;
         }
         val = 0;
      }
      k++;
    }
    // we treat all other chars as whitespace
  }
  if (CTX_LIKELY (p != '~'))
  { 
    val *= 85;
  }
  k = k % 5;
  if (k)
  {
    val += 84;
    for (int j = k; j < 4; j++)
    {
      val *= 85;
      val += 84;
    }

    for (int j = 0; j < k-1; j++)
    {
      dst[out_len++] = (val & ((unsigned)0xff << 24)) >> 24;
      val <<= 8;
    }
    val = 0;
  }
  dst[out_len] = 0;
  return out_len;
}

#if 1
int ctx_a85len (const char *src, int count)
{
  int out_len = 0;
  int k = 0;
  for (int i = 0; i < count; i ++)
  {
    if (src[i] == '~')
      break;
    else if (src[i] == 'z')
    {
      for (int j = 0; j < 4; j++)
        out_len++;
      k = 0;
    }
    else if (src[i] >= '!' && src[i] <= 'u')
    {
      if (k % 5 == 4)
        out_len += 4;
      k++;
    }
    // we treat all other chars as whitespace
  }
  k = k % 5;
  if (k)
    out_len += k-1;
  return out_len;
}
#endif

#endif

#if CTX_IMPLEMENTATION

#define SHA1_IMPLEMENTATION
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
 *
 * LibTomCrypt is a library that provides various cryptographic
 * algorithms in a highly modular and flexible manner.
 *
 * The library is free for all purposes without any express
 * guarantee it works.
 *
 * Tom St Denis, tomstdenis@gmail.com, http://libtom.org
 *
 * The plain ANSIC sha1 functionality has been extracted from libtomcrypt,
 * and is included directly in the sources. /Øyvind K. - since libtomcrypt
 * is public domain the adaptations done here to make the sha1 self contained
 * also is public domain.
 */
#ifndef __SHA1_H
#define __SHA1_H
#if !__COSMOPOLITAN__
#include <inttypes.h>
#endif


int ctx_sha1_init(CtxSHA1 * sha1);
CtxSHA1 *ctx_sha1_new (void)
{
  CtxSHA1 *state = (CtxSHA1*)ctx_calloc (sizeof (CtxSHA1), 1);
  ctx_sha1_init (state);
  return state;
}
void ctx_sha1_free (CtxSHA1 *sha1)
{
  ctx_free (sha1);
}

#if 0
          CtxSHA1 sha1;
          ctx_sha1_init (&sha1);
          ctx_sha1_process(&sha1, (unsigned char*)&shape_rect, sizeof (CtxIntRectangle));
          ctx_sha1_done(&sha1, (unsigned char*)ctx_sha1_hash);
#endif

#ifdef SHA1_FF0
#undef SHA1_FF0
#endif
#ifdef SHA1_FF1
#undef SHA1_FF1
#endif

#ifdef SHA1_IMPLEMENTATION
#if !__COSMOPOLITAN__
#include <stdlib.h>
#include <string.h>
#endif

#define STORE64H(x,                                                             y)                                                                     \
   { (y)[0] = (unsigned char)(((x)>>56)&255); (y)[1] = (unsigned                char)(((x)>>48)&255);     \
     (y)[2] = (unsigned char)(((x)>>40)&255); (y)[3] = (unsigned                char)(((x)>>32)&255);     \
     (y)[4] = (unsigned char)(((x)>>24)&255); (y)[5] = (unsigned                char)(((x)>>16)&255);     \
     (y)[6] = (unsigned char)(((x)>>8)&255); (y)[7] = (unsigned char)((x)&255); }

#define STORE32H(x,                                                             y)                                                                     \
     { (y)[0] = (unsigned char)(((x)>>24)&255); (y)[1] = (unsigned              char)(((x)>>16)&255);   \
       (y)[2] = (unsigned char)(((x)>>8)&255); (y)[3] = (unsigned               char)((x)&255); }

#define LOAD32H(x, y)                            \
     { x = ((unsigned long)((y)[0] & 255)<<24) | \
           ((unsigned long)((y)[1] & 255)<<16) | \
           ((unsigned long)((y)[2] & 255)<<8)  | \
           ((unsigned long)((y)[3] & 255)); }

/* rotates the hard way */
#define ROL(x, y)  ((((unsigned long)(x)<<(unsigned long)((y)&31)) | (((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)
#define ROLc(x, y) ROL(x,y)

#define CRYPT_OK     0
#define CRYPT_ERROR  1
#define CRYPT_NOP    2

#ifndef MAX
   #define MAX(x, y) ( ((x)>(y))?(x):(y) )
#endif
#ifndef MIN
   #define MIN(x, y) ( ((x)<(y))?(x):(y) )
#endif

/* a simple macro for making hash "process" functions */
#define HASH_PROCESS(func_name, compress_name, state_var, block_size)               \
int func_name (CtxSHA1 *sha1, const unsigned char *in, unsigned long inlen)      \
{                                                                                   \
    unsigned long n;                                                                \
    int           err;                                                              \
    assert (sha1 != NULL);                                                          \
    assert (in != NULL);                                                            \
    if (sha1->curlen > sizeof(sha1->buf)) {                                         \
       return -1;                                                                   \
    }                                                                               \
    while (inlen > 0) {                                                             \
        if (sha1->curlen == 0 && inlen >= block_size) {                             \
           if ((err = compress_name (sha1, (unsigned char *)in)) != CRYPT_OK) {     \
              return err;                                                           \
           }                                                                        \
           sha1->length += block_size * 8;                                          \
           in             += block_size;                                            \
           inlen          -= block_size;                                            \
        } else {                                                                    \
           n = MIN(inlen, (block_size - sha1->curlen));                             \
           memcpy(sha1->buf + sha1->curlen, in, (size_t)n);                         \
           sha1->curlen += n;                                                       \
           in             += n;                                                     \
           inlen          -= n;                                                     \
           if (sha1->curlen == block_size) {                                        \
              if ((err = compress_name (sha1, sha1->buf)) != CRYPT_OK) {            \
                 return err;                                                        \
              }                                                                     \
              sha1->length += 8*block_size;                                         \
              sha1->curlen = 0;                                                     \
           }                                                                        \
       }                                                                            \
    }                                                                               \
    return CRYPT_OK;                                                                \
}

/**********************/

#define F0(x,y,z)  (z ^ (x & (y ^ z)))
#define F1(x,y,z)  (x ^ y ^ z)
#define F2(x,y,z)  ((x & y) | (z & (x | y)))
#define F3(x,y,z)  (x ^ y ^ z)

static int  ctx_sha1_compress(CtxSHA1 *sha1, unsigned char *buf)
{
    uint32_t a,b,c,d,e,W[80],i;

    /* copy the state into 512-bits into W[0..15] */
    for (i = 0; i < 16; i++) {
        LOAD32H(W[i], buf + (4*i));
    }

    /* copy state */
    a = sha1->state[0];
    b = sha1->state[1];
    c = sha1->state[2];
    d = sha1->state[3];
    e = sha1->state[4];

    /* expand it */
    for (i = 16; i < 80; i++) {
        W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1); 
    }

    /* compress */
    /* round one */
    #define SHA1_FF0(a,b,c,d,e,i) e = (ROLc(a, 5) + F0(b,c,d) + e + W[i] + 0x5a827999UL); b = ROLc(b, 30);
    #define SHA1_FF1(a,b,c,d,e,i) e = (ROLc(a, 5) + F1(b,c,d) + e + W[i] + 0x6ed9eba1UL); b = ROLc(b, 30);
    #define SHA1_FF2(a,b,c,d,e,i) e = (ROLc(a, 5) + F2(b,c,d) + e + W[i] + 0x8f1bbcdcUL); b = ROLc(b, 30);
    #define SHA1_FF3(a,b,c,d,e,i) e = (ROLc(a, 5) + F3(b,c,d) + e + W[i] + 0xca62c1d6UL); b = ROLc(b, 30);
 
    for (i = 0; i < 20; ) {
       SHA1_FF0(a,b,c,d,e,i++);
       SHA1_FF0(e,a,b,c,d,i++);
       SHA1_FF0(d,e,a,b,c,i++);
       SHA1_FF0(c,d,e,a,b,i++);
       SHA1_FF0(b,c,d,e,a,i++);
    }

    /* round two */
    for (; i < 40; )  { 
       SHA1_FF1(a,b,c,d,e,i++);
       SHA1_FF1(e,a,b,c,d,i++);
       SHA1_FF1(d,e,a,b,c,i++);
       SHA1_FF1(c,d,e,a,b,i++);
       SHA1_FF1(b,c,d,e,a,i++);
    }

    /* round three */
    for (; i < 60; )  { 
       SHA1_FF2(a,b,c,d,e,i++);
       SHA1_FF2(e,a,b,c,d,i++);
       SHA1_FF2(d,e,a,b,c,i++);
       SHA1_FF2(c,d,e,a,b,i++);
       SHA1_FF2(b,c,d,e,a,i++);
    }

    /* round four */
    for (; i < 80; )  { 
       SHA1_FF3(a,b,c,d,e,i++);
       SHA1_FF3(e,a,b,c,d,i++);
       SHA1_FF3(d,e,a,b,c,i++);
       SHA1_FF3(c,d,e,a,b,i++);
       SHA1_FF3(b,c,d,e,a,i++);
    }

    #undef SHA1_FF0
    #undef SHA1_FF1
    #undef SHA1_FF2
    #undef SHA1_FF3

    /* store */
    sha1->state[0] = sha1->state[0] + a;
    sha1->state[1] = sha1->state[1] + b;
    sha1->state[2] = sha1->state[2] + c;
    sha1->state[3] = sha1->state[3] + d;
    sha1->state[4] = sha1->state[4] + e;

    return CRYPT_OK;
}

/**
   Initialize the hash state
   @param md   The hash state you wish to initialize
   @return CRYPT_OK if successful
*/
int ctx_sha1_init(CtxSHA1 * sha1)
{
   assert(sha1 != NULL);
   sha1->state[0] = 0x67452301UL;
   sha1->state[1] = 0xefcdab89UL;
   sha1->state[2] = 0x98badcfeUL;
   sha1->state[3] = 0x10325476UL;
   sha1->state[4] = 0xc3d2e1f0UL;
   sha1->curlen = 0;
   sha1->length = 0;
   return CRYPT_OK;
}

/**
   Process a block of memory though the hash
   @param md     The hash state
   @param in     The data to hash
   @param inlen  The length of the data (octets)
   @return CRYPT_OK if successful
*/
HASH_PROCESS(ctx_sha1_process, ctx_sha1_compress, sha1, 64)

/**
   Terminate the hash to get the digest
   @param md  The hash state
   @param out [out] The destination of the hash (20 bytes)
   @return CRYPT_OK if successful
*/
int ctx_sha1_done(CtxSHA1 * sha1, unsigned char *out)
{
    int i;

    assert(sha1 != NULL);
    assert(out != NULL);

    if (sha1->curlen >= sizeof(sha1->buf)) {
       return -1;
    }

    /* increase the length of the message */
    sha1->length += sha1->curlen * 8;

    /* append the '1' bit */
    sha1->buf[sha1->curlen++] = (unsigned char)0x80;

    /* if the length is currently above 56 bytes we append zeros
     * then compress.  Then we can fall back to padding zeros and length
     * encoding like normal.
     */
    if (sha1->curlen > 56) {
        while (sha1->curlen < 64) {
            sha1->buf[sha1->curlen++] = (unsigned char)0;
        }
        ctx_sha1_compress(sha1, sha1->buf);
        sha1->curlen = 0;
    }

    /* pad upto 56 bytes of zeroes */
    while (sha1->curlen < 56) {
        sha1->buf[sha1->curlen++] = (unsigned char)0;
    }

    /* store length */
    STORE64H(sha1->length, sha1->buf+56);
    ctx_sha1_compress(sha1, sha1->buf);

    /* copy output */
    for (i = 0; i < 5; i++) {
        STORE32H(sha1->state[i], out+(4*i));
    }
    return CRYPT_OK;
}
#endif

#endif
#endif

#ifdef CTX_X86_64

enum
{
  ARCH_X86_INTEL_FEATURE_MMX      = 1 << 23,
  ARCH_X86_INTEL_FEATURE_XMM      = 1 << 25,
  ARCH_X86_INTEL_FEATURE_XMM2     = 1 << 26,
};

enum
{
  ARCH_X86_INTEL_FEATURE_PNI      = 1 << 0,
  ARCH_X86_INTEL_FEATURE_SSSE3    = 1 << 9,
  ARCH_X86_INTEL_FEATURE_FMA      = 1 << 12,
  ARCH_X86_INTEL_FEATURE_SSE4_1   = 1 << 19,
  ARCH_X86_INTEL_FEATURE_SSE4_2   = 1 << 20,
  ARCH_X86_INTEL_FEATURE_MOVBE    = 1 << 22,
  ARCH_X86_INTEL_FEATURE_POPCNT   = 1 << 23,
  ARCH_X86_INTEL_FEATURE_XSAVE    = 1 << 26,
  ARCH_X86_INTEL_FEATURE_OSXSAVE  = 1 << 27,
  ARCH_X86_INTEL_FEATURE_AVX      = 1 << 28,
  ARCH_X86_INTEL_FEATURE_F16C     = 1 << 29
};

enum
{
  ARCH_X86_INTEL_FEATURE_BMI1     = 1 << 3,
  ARCH_X86_INTEL_FEATURE_BMI2     = 1 << 8,
  ARCH_X86_INTEL_FEATURE_AVX2     = 1 << 5,
};

#define cpuid(a,b,eax,ebx,ecx,edx)                     \
  __asm__("cpuid"                                           \
           : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) \
           : "0" (a), "2" (b)  )

/* returns x86_64 microarchitecture level
 *   0
 */
int
ctx_x86_64_level (void)
{
  int level = 0;
  uint32_t eax, ebx, ecx, edx;
  cpuid (1, 0, eax, ebx, ecx, edx);

  if ((edx & ARCH_X86_INTEL_FEATURE_MMX) == 0)   return level;
  if ((edx & ARCH_X86_INTEL_FEATURE_XMM) == 0)   return level;
  level = 1;

  if ((ecx & ARCH_X86_INTEL_FEATURE_SSSE3)==0)   return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_SSE4_1)==0)  return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_SSE4_2)==0)  return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_POPCNT)==0)  return level;
  level = 2;

  if ((ecx & ARCH_X86_INTEL_FEATURE_AVX)==0)     return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_OSXSAVE)==0) return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_XSAVE)==0)   return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_FMA)==0)     return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_F16C)==0)    return level;
  if ((ecx & ARCH_X86_INTEL_FEATURE_MOVBE)==0)   return level;

  cpuid (0, 0, eax, ebx, ecx, edx);
  if (eax >= 7)
  {
    cpuid (2, 0, eax, ebx, ecx, edx);
    if ((ebx & ARCH_X86_INTEL_FEATURE_AVX2)==0)  return level;
    if ((ebx & ARCH_X86_INTEL_FEATURE_BMI1)==0)  return level;
    if ((ebx & ARCH_X86_INTEL_FEATURE_BMI2)==0)  return level;
    level = 3; 
  }
  return level;
}

#endif

#ifdef CTX_ARMV7L

#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <elf.h>


int ctx_arm_has_neon (int *armv)
{
  /* TODO : add or hardcode the other ways it can be on arm, where
   *        this info comes from the system and not from running cpu
   *        instructions
   */
  int has_neon = 0;
  int arm_level = 5;
  int fd = open ("/proc/self/auxv", O_RDONLY);
  Elf32_auxv_t auxv;
  if (fd >= 0)
  {
    while (read (fd, &auxv, sizeof (Elf32_auxv_t)) == sizeof (Elf32_auxv_t))
    {
      if (auxv.a_type == AT_HWCAP)
      {
        if (auxv.a_un.a_val & 4096)
          has_neon = 1;
      }
      else if (auxv.a_type == AT_PLATFORM)
      {
        if (!strncmp ((const char*)auxv.a_un.a_val, "v6l", 3))
          arm_level = 6;
        else if (!strncmp ((const char*)auxv.a_un.a_val, "v7l", 3))
          arm_level = 7;
        else if (!strncmp ((const char*)auxv.a_un.a_val, "v8l", 3))
          arm_level = 8;
      }
    }
    close (fd);
  }
  if (armv) *armv = arm_level;
  return has_neon;
}
#endif
#include <stdio.h>
#include <string.h>

#if CTX_FORMATTER

int ctx_yenc (const char *src, char *dst, int count)
{
  int out_len = 0;
  for (int i = 0; i < count; i ++)
  {
    int o = (src[i] + 42) % 256;
    switch (o)
    {
      case 0x00: //null
      case 0x20: //space// but better safe
      case 0x0A: //lf   // than sorry
      case 0x0D: //cr
      case 0x09: //tab  // not really needed
      case 0x10: //datalink escape (used by ctx for compression)
      case 26: // used by ctx for compression
      case 0x11: //xoff
      case 0x13: //xon
      case 0x1b: //
      case 0xff: //
      case 0x3D: //=
        dst[out_len++] = '=';
        o = (o + 64) % 256;
        /* FALLTHROUGH */
      default:
        dst[out_len++] = o;
        break;
    }
  }
  dst[out_len]=0;
  return out_len;
}
#endif

#if CTX_PARSER
int ctx_ydec (const char *tmp_src, char *dst, int count)
{
  const char *src = tmp_src;
#if 0
  if (tmp_src == dst)
  {
    src = ctx_malloc (count);
    memcpy (src, tmp_src, count);
  }
#endif
  int out_len = 0;
  for (int i = 0; i < count; i ++)
  {
    int o = src[i];
    switch (o)
    {
      case '=':
        i++;
        o = src[i];
        if (o == 'y')
        {
          dst[out_len]=0;
#if 0
          if (tmp_src == dst) ctx_free (src);
#endif
          return out_len;
        }
        o = (o-42-64) % 256;
        dst[out_len++] = o;
        break;
      case '\n':
      case '\033':
      case '\r':
      case '\0':
        break;
      default:
        o = (o-42) % 256;
        dst[out_len++] = o;
        break;
    }
  }
  dst[out_len]=0;
#if 0
  if (tmp_src == dst) ctx_free (src);
#endif
  return out_len;
}
#endif

#if 0
int main (){
  char *input="this is a testæøåÅØ'''\"!:_asdac\n\r";
  char  encoded[256]="";
  char  decoded[256]="";
  int   in_len = ctx_strlen (input);
  int   out_len;
  int   dec_len;

  printf ("input: %s\n", input);

  out_len = ctx_yenc (input, encoded, in_len);
  printf ("encoded: %s\n", encoded);

  dec_len = ydec (encoded, encoded, out_len);

  printf ("decoded: %s\n", encoded);

  return 0;
}
#endif
#ifndef __CTX_UTIL_H
#define __CTX_UTIL_H


static int ctx_str_is_number (const char *str)
{
  int got_digit = 0;
  for (int i = 0; str[i]; i++)
  {
    if (str[i] >= '0' && str[i] <= '9')
    {
       got_digit ++;
    }
    else if (str[i] == '.')
    {
    }
    else
      return 0;
  }
  if (got_digit)
    return 1;
  return 0;
}

#if CTX_GET_CONTENTS

typedef struct CtxFileContent
{
  char *path;
  unsigned char *contents;
  long  length;
  int   free_data;
} CtxFileContent;

// eeek - duplication in generated code
static void
ctx_register_contents (const char *path,
                       const unsigned char *contents,
                       long length,
                       int  free_data)
{
  // if (path[0] != '/') && strchr(path, ':')) 
  //   with this check regular use is faster, but we lose
  //   generic filesystem overrides..
  for (CtxList *l = registered_contents; l; l = l->next)
  {
    CtxFileContent *c = (CtxFileContent*)l->data;
    if (!ctx_strcmp (c->path, path))
    {
       if (c->free_data)
       {
         ctx_free (c->contents);
       }
       c->free_data = free_data;
       c->contents = (unsigned char*)contents;
       c->length = length;
       return;
    }
  }
  CtxFileContent *c = (CtxFileContent*)ctx_calloc (sizeof (CtxFileContent), 1);
  c->free_data = free_data;
  c->contents = (unsigned char*)contents;
  c->length    = length;
  ctx_list_append (&registered_contents, c);
}

static void
_ctx_file_set_contents (const char     *path,
                        const unsigned char  *contents,
                        long            length)
{
  FILE *file;
  file = fopen (path, "wb");
  if (!file)
    { return; }
  if (length < 0) length = ctx_strlen ((const char*)contents);
  fwrite (contents, 1, length, file);
  fclose (file);
}

static int
___ctx_file_get_contents (const char     *path,
                          unsigned char **contents,
                          long           *length,
                          long            max_len)
{
  FILE *file;
  long  size;
  long  remaining;
  char *buffer;
  file = fopen (path, "rb");
  if (!file)
    { return -1; }
  fseek (file, 0, SEEK_END);
  size = remaining = ftell (file);

  if (size > max_len)
  {
     size = remaining = max_len;
  }

  if (length)
    { *length =size; }
  rewind (file);
  buffer = (char*)ctx_malloc (size + 8);
  if (!buffer)
    {
      fclose (file);
      return -1;
    }
  remaining -= fread (buffer, 1, remaining, file);
  if (remaining)
    {
      fclose (file);
      ctx_free (buffer);
      return -1;
    }
  fclose (file);
  *contents = (unsigned char*) buffer;
  buffer[size] = 0;
  return 0;
}

static int
__ctx_file_get_contents (const char     *path,
                        unsigned char **contents,
                        long           *length)
{
  return ___ctx_file_get_contents (path, contents, length, 1024*1024*1024);
}

#if !__COSMOPOLITAN__
#include <limits.h>
#endif




#endif


#endif


float ctx_state_get (CtxState *state, uint32_t hash)
{
  for (int i = state->gstate.keydb_pos-1; i>=0; i--)
    {
      if (state->keydb[i].key == hash)
        { return state->keydb[i].value; }
    }
  return -0.0;
}

void ctx_state_set (CtxState *state, uint32_t key, float value)
{
  if (key != SQZ_newState)
    {
      if (ctx_state_get (state, key) == value)
        { return; }
      for (int i = state->gstate.keydb_pos-1;
           i >= 0 && state->keydb[i].key != SQZ_newState;
           i--)
        {
          if (state->keydb[i].key == key)
            {
              state->keydb[i].value = value;
              return;
            }
        }
    }
  if (state->gstate.keydb_pos >= CTX_MAX_KEYDB)
    { return; }
  state->keydb[state->gstate.keydb_pos].key = key;
  state->keydb[state->gstate.keydb_pos].value = value;
  state->gstate.keydb_pos++;
}


#define CTX_KEYDB_STRING_START (-90000.0f)
// XXX : hard-coded as 32kb - breaking above, used to be set from hardcoded
// limits with static stringpool size
#define CTX_KEYDB_STRING_END   (CTX_KEYDB_STRING_START + 32000)

static int ctx_float_is_string (float val)
{
  return (int)(val) >= CTX_KEYDB_STRING_START && ((int)val) <= CTX_KEYDB_STRING_END;
}

int ctx_float_to_string_index (float val)
{
  int idx = -1;
  if (ctx_float_is_string (val))
  {
    idx = (int)(val - CTX_KEYDB_STRING_START);
  }
  return idx;
}

static float ctx_string_index_to_float (int index)
{
  return CTX_KEYDB_STRING_START + index;
}

static char ctx_kv_num[8][32];
static int ctx_num_idx = 0;

void *ctx_state_get_blob (CtxState *state, uint32_t key)
{
  float stored = ctx_state_get (state, key);
  int idx = ctx_float_to_string_index (stored);
  if (idx >= 0)
  {
     // can we know length?
     return &state->stringpool[idx];
  }

  if (-stored == 0.0f) return NULL;//"";

  ctx_num_idx ++;
  if (ctx_num_idx >=8) ctx_num_idx = 0;
  snprintf (&ctx_kv_num[ctx_num_idx][0], 31, "%.6f", stored);

  return ctx_kv_num[ctx_num_idx];
}

static const char *ctx_state_get_string (CtxState *state, uint32_t key)
{
  const char *ret = (char*)ctx_state_get_blob (state, key);
  if (ret && ret[0] == 127)
    return NULL;
  return ret;
}


void ctx_state_set_blob (CtxState *state, uint32_t key, const void *data, int len)
{
  int idx = state->gstate.stringpool_pos;

  if (idx + len + 1 >= state->stringpool_size - 512)
  {
    int desired = idx + len + 1 + 1024;
   // ctx_log ("blowing varpool size [%c..]\n", data[0]);
    void *copy = ctx_malloc (desired);
    if (!copy) return;
    if (state->stringpool)
    {
      memcpy (copy, state->stringpool, state->gstate.stringpool_pos);
      ctx_free (state->stringpool);
    }
    state->stringpool = (char*)copy;
    state->stringpool_size = desired;
  }

  memcpy (&state->stringpool[idx], data, len);
  state->gstate.stringpool_pos+=len;
  state->stringpool[state->gstate.stringpool_pos++]=0;
  ctx_state_set (state, key, ctx_string_index_to_float (idx));
}

static void ctx_state_set_string (CtxState *state, uint32_t key, const char *string)
{
  float old_val = ctx_state_get (state, key);
  int   old_idx = ctx_float_to_string_index (old_val);

  if (old_idx >= 0)
  {
    const char *old_string = ctx_state_get_string (state, key);
    if (old_string && !ctx_strcmp (old_string, string))
      return;
  }

  if (ctx_str_is_number (string))
  {
    ctx_state_set (state, key, _ctx_parse_float (string, NULL));
    return;
  }
  // should do same with color
 
  // XXX should special case when the string modified is at the
  //     end of the stringpool.
  //
  //     for clips the behavior is howevre ideal, since
  //     we can have more than one clip per save/restore level
  ctx_state_set_blob (state, key, (void*)string, ctx_strlen(string));
}

static int ctx_state_get_color (CtxState *state, uint32_t key, CtxColor *color)
{
  CtxColor *stored = (CtxColor*)ctx_state_get_blob (state, key);
  CtxColor  copy;
  if (stored)
  {
    // we make a copy to ensure alignment
    memcpy (&copy, stored, sizeof (CtxColor));
    if (copy.magic == 127)
    {
      *color = copy;
      return 0;
    }
  }
  return -1;
}

static void ctx_state_set_color (CtxState *state, uint32_t key, CtxColor *color)
{
  CtxColor mod_color;
  CtxColor old_color;
  mod_color = *color;
  mod_color.magic = 127;
  if (ctx_state_get_color (state, key, &old_color)==0)
  {
    if (!memcmp (&mod_color, &old_color, sizeof (mod_color)))
      return;
  }
  ctx_state_set_blob (state, key, &mod_color, sizeof (CtxColor));
}

const char *ctx_get_string (Ctx *ctx, uint32_t hash)
{
  return ctx_state_get_string (&ctx->state, hash);
}
float ctx_get_float (Ctx *ctx, uint32_t hash)
{
  return ctx_state_get (&ctx->state, hash);
}
int ctx_get_int (Ctx *ctx, uint32_t hash)
{
  return (int)ctx_state_get (&ctx->state, hash);
}
void ctx_set_float (Ctx *ctx, uint32_t hash, float value)
{
  ctx_state_set (&ctx->state, hash, value);
}
void ctx_set_blob (Ctx *ctx, uint32_t hash, const void*value, int length)
{
  ctx_state_set_blob (&ctx->state, hash, value, length);
}
void ctx_set_string (Ctx *ctx, uint32_t hash, const char *value)
{
  ctx_state_set_string (&ctx->state, hash, value);
}
void ctx_set_color (Ctx *ctx, uint32_t hash, CtxColor *color)
{
  ctx_state_set_color (&ctx->state, hash, color);
}
int  ctx_get_color (Ctx *ctx, uint32_t hash, CtxColor *color)
{
  return ctx_state_get_color (&ctx->state, hash, color);
}
int ctx_is_set (Ctx *ctx, uint32_t hash)
{
  return ctx_get_float (ctx, hash) != -0.0f;
}
int ctx_is_set_now (Ctx *ctx, uint32_t hash)
{
  return ctx_is_set (ctx, hash);
}
#ifndef __CTX_COLOR
#define __CTX_COLOR

int ctx_color_model_get_components (CtxColorModel model)
{
  switch (model)
    {
      case CTX_GRAY:
        return 1;
      case CTX_GRAYA:
      case CTX_GRAYA_A:
        return 2;
      case CTX_RGB:
      case CTX_LAB:
      case CTX_LCH:
      case CTX_DRGB:
        return 3;
      case CTX_CMYK:
      case CTX_DCMYK:
      case CTX_LABA:
      case CTX_LCHA:
      case CTX_RGBA:
      case CTX_DRGBA:
      case CTX_RGBA_A:
      case CTX_RGBA_A_DEVICE:
        return 4;
      case CTX_DCMYKA:
      case CTX_CMYKA:
      case CTX_CMYKA_A:
      case CTX_DCMYKA_A:
        return 5;
    }
  return 0;
}

#if CTX_U8_TO_FLOAT_LUT
float ctx_u8_float[256];
#endif

CtxColor *ctx_color_new (void)
{
  CtxColor *color = (CtxColor*)ctx_calloc (1, sizeof (CtxColor));
  return color;
}

int ctx_color_is_transparent (CtxColor *color)
{
  return color->alpha <= 0.001f;
}


void ctx_color_free (CtxColor *color)
{
  ctx_free (color);
}

void ctx_color_set_RGBA8 (CtxState *state, CtxColor *color, uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
  color->original = color->valid = CTX_VALID_RGBA_U8;
  color->rgba[0] = r;
  color->rgba[1] = g;
  color->rgba[2] = b;
  color->rgba[3] = a;
#if CTX_ENABLE_CM
  color->space = state->gstate.device_space;
#endif
}

#if 0
static void ctx_color_set_RGBA8_ (CtxColor *color, const uint8_t *in)
{
  ctx_color_set_RGBA8 (color, in[0], in[1], in[2], in[3]);
}
#endif

void ctx_color_set_graya (CtxState *state, CtxColor *color, float gray, float alpha)
{
  color->original = color->valid = CTX_VALID_GRAYA;
  color->l = gray;
  color->alpha = alpha;
}
#if 0
static void ctx_color_set_graya_ (CtxColor *color, const float *in)
{
  return ctx_color_set_graya (color, in[0], in[1]);
}
#endif

void ctx_color_set_rgba (CtxState *state, CtxColor *color, float r, float g, float b, float a)
{
#if CTX_ENABLE_CM
  color->original = color->valid = CTX_VALID_RGBA;
  color->red      = r;
  color->green    = g;
  color->blue     = b;
  color->space    = state->gstate.rgb_space;
#else
  color->original     = color->valid = CTX_VALID_RGBA_DEVICE;
  color->device_red   = r;
  color->device_green = g;
  color->device_blue  = b;
#endif
  color->alpha        = a;
}

void ctx_color_set_drgba (CtxState *state, CtxColor *color, float r, float g, float b, float a)
{
#if CTX_ENABLE_CM
  color->original     = color->valid = CTX_VALID_RGBA_DEVICE;
  color->device_red   = r;
  color->device_green = g;
  color->device_blue  = b;
  color->alpha        = a;
  color->space        = state->gstate.device_space;
#else
  ctx_color_set_rgba (state, color, r, g, b, a);
#endif
}

#if 0
static void ctx_color_set_rgba_ (CtxState *state, CtxColor *color, const float *in)
{
  ctx_color_set_rgba (color, in[0], in[1], in[2], in[3]);
}
#endif

/* the baseline conversions we have whether CMYK support is enabled or not,
 * providing an effort at right rendering
 */
void ctx_cmyk_to_rgb (float c, float m, float y, float k, float *r, float *g, float *b)
{
  *r = (1.0f-c) * (1.0f-k);
  *g = (1.0f-m) * (1.0f-k);
  *b = (1.0f-y) * (1.0f-k);
}

void ctx_rgb_to_cmyk (float r, float g, float b,
                      float *c_out, float *m_out, float *y_out, float *k_out)
{
  float c = 1.0f - r;
  float m = 1.0f - g;
  float y = 1.0f - b;
  float k = ctx_minf (c, ctx_minf (y, m) );
  if (k < 1.0f)
    {
      c = (c - k) / (1.0f - k);
      m = (m - k) / (1.0f - k);
      y = (y - k) / (1.0f - k);
    }
  else
    {
      c = m = y = 0.0f;
    }
  *c_out = c;
  *m_out = m;
  *y_out = y;
  *k_out = k;
}

#if CTX_ENABLE_CMYK
void ctx_color_set_cmyka (CtxState *state, CtxColor *color, float c, float m, float y, float k, float a)
{
  color->original = color->valid = CTX_VALID_CMYKA;
  color->cyan     = c;
  color->magenta  = m;
  color->yellow   = y;
  color->key      = k;
  color->alpha    = a;
#if CTX_ENABLE_CM
  color->space    = state->gstate.cmyk_space;
#endif
}

void ctx_color_set_dcmyka (CtxState *state, CtxColor *color, float c, float m, float y, float k, float a)
{
  color->original       = color->valid = CTX_VALID_DCMYKA;
  color->device_cyan    = c;
  color->device_magenta = m;
  color->device_yellow  = y;
  color->device_key     = k;
  color->alpha          = a;
#if CTX_ENABLE_CM
  color->space = state->gstate.device_space;
#endif
}

#endif

#if CTX_ENABLE_CM

static void ctx_rgb_user_to_device (CtxState *state, float rin, float gin, float bin,
                                    float *rout, float *gout, float *bout)
{
#if CTX_BABL
#if 0
  fprintf (stderr, "-[%p %p\n",
    state->gstate.fish_rgbaf_user_to_device,
    state->gstate.fish_rgbaf_device_to_user);
#endif
  if (state->gstate.fish_rgbaf_user_to_device)
  {
    float rgbaf[4]={rin,gin,bin,1.0};
    float rgbafo[4];
    babl_process (state->gstate.fish_rgbaf_user_to_device,
                  rgbaf, rgbafo, 1);

    *rout = rgbafo[0];
    *gout = rgbafo[1];
    *bout = rgbafo[2];
    return;
  }
#endif
  *rout = rin;
  *gout = gin;
  *bout = bin;
}

static void ctx_rgb_device_to_user (CtxState *state, float rin, float gin, float bin,
                                    float *rout, float *gout, float *bout)
{
#if CTX_BABL
#if 0
  fprintf (stderr, "=[%p %p\n",
    state->gstate.fish_rgbaf_user_to_device,
    state->gstate.fish_rgbaf_device_to_user);
#endif
  if (state->gstate.fish_rgbaf_device_to_user)
  {
    float rgbaf[4]={rin,gin,bin,1.0};
    float rgbafo[4];
    babl_process (state->gstate.fish_rgbaf_device_to_user,
                  rgbaf, rgbafo, 1);

    *rout = rgbafo[0];
    *gout = rgbafo[1];
    *bout = rgbafo[2];
    return;
  }
#endif
  *rout = rin;
  *gout = gin;
  *bout = bin;
}
#endif

static inline void ctx_color_get_drgba (CtxState *state, CtxColor *color, float *out)
{
  if (! (color->valid & CTX_VALID_RGBA_DEVICE) )
    {
#if CTX_ENABLE_CM
      if (color->valid & CTX_VALID_RGBA)
        {
          ctx_rgb_user_to_device (state, color->red, color->green, color->blue,
                                  & (color->device_red), & (color->device_green), & (color->device_blue) );
        }
      else
#endif
        if (color->valid & CTX_VALID_RGBA_U8)
          {
            float red = ctx_u8_to_float (color->rgba[0]);
            float green = ctx_u8_to_float (color->rgba[1]);
            float blue = ctx_u8_to_float (color->rgba[2]);
#if CTX_ENABLE_CM
            ctx_rgb_user_to_device (state, red, green, blue,
                                  & (color->device_red), & (color->device_green), & (color->device_blue) );
#else
            color->device_red = red;
            color->device_green = green;
            color->device_blue = blue;
#endif
            color->alpha        = ctx_u8_to_float (color->rgba[3]);
          }
#if CTX_ENABLE_CMYK
        else if (color->valid & CTX_VALID_CMYKA)
          {
            ctx_cmyk_to_rgb (color->cyan, color->magenta, color->yellow, color->key,
                             &color->device_red,
                             &color->device_green,
                             &color->device_blue);
          }
#endif
        else if (color->valid & CTX_VALID_GRAYA)
          {
            color->device_red   =
              color->device_green =
                color->device_blue  = color->l;
          }
      color->valid |= CTX_VALID_RGBA_DEVICE;
    }
  out[0] = color->device_red;
  out[1] = color->device_green;
  out[2] = color->device_blue;
  out[3] = color->alpha;
}


static inline void
_ctx_color_get_rgba (CtxState *state, CtxColor *color, float *out)
{
#if CTX_ENABLE_CM
  if (! (color->valid & CTX_VALID_RGBA) )
    {
      ctx_color_get_drgba (state, color, out);
      if (color->valid & CTX_VALID_RGBA_DEVICE)
        {
          ctx_rgb_device_to_user (state, color->device_red, color->device_green, color->device_blue,
                                  & (color->red), & (color->green), & (color->blue) );
        }
      color->valid |= CTX_VALID_RGBA;
    }
  out[0] = color->red;
  out[1] = color->green;
  out[2] = color->blue;
  out[3] = color->alpha;
#else
  ctx_color_get_drgba (state, color, out);
#endif
}

void ctx_color_get_rgba (CtxState *state, CtxColor *color, float *out)
{
  _ctx_color_get_rgba (state, color, out);
}



float ctx_float_color_rgb_to_gray (CtxState *state, const float *rgb)
{
        // XXX todo replace with correct according to primaries
  return CTX_CSS_RGB_TO_LUMINANCE(rgb);
}
uint8_t ctx_u8_color_rgb_to_gray (CtxState *state, const uint8_t *rgb)
{
        // XXX todo replace with correct according to primaries
  return (uint8_t)(CTX_CSS_RGB_TO_LUMINANCE(rgb));
}

void ctx_color_get_graya (CtxState *state, CtxColor *color, float *out)
{
  if (! (color->valid & CTX_VALID_GRAYA) )
    {
      float rgba[4];
      ctx_color_get_drgba (state, color, rgba);
      color->l = ctx_float_color_rgb_to_gray (state, rgba);
      color->valid |= CTX_VALID_GRAYA;
    }
  out[0] = color->l;
  out[1] = color->alpha;
}

#if CTX_ENABLE_CMYK
void ctx_color_get_cmyka (CtxState *state, CtxColor *color, float *out)
{
  if (! (color->valid & CTX_VALID_CMYKA) )
    {
      if (color->valid & CTX_VALID_GRAYA)
        {
          color->cyan = color->magenta = color->yellow = 0.0;
          color->key = color->l;
        }
      else
        {
          float rgba[4];
          ctx_color_get_rgba (state, color, rgba);
          ctx_rgb_to_cmyk (rgba[0], rgba[1], rgba[2],
                           &color->cyan, &color->magenta, &color->yellow, &color->key);
          color->alpha = rgba[3];
        }
      color->valid |= CTX_VALID_CMYKA;
    }
  out[0] = color->cyan;
  out[1] = color->magenta;
  out[2] = color->yellow;
  out[3] = color->key;
  out[4] = color->alpha;
}

#if 0
static void ctx_color_get_cmyka_u8 (CtxState *state, CtxColor *color, uint8_t *out)
{
  if (! (color->valid & CTX_VALID_CMYKA_U8) )
    {
      float cmyka[5];
      ctx_color_get_cmyka (color, cmyka);
      for (int i = 0; i < 5; i ++)
        { color->cmyka[i] = ctx_float_to_u8 (cmyka[i]); }
      color->valid |= CTX_VALID_CMYKA_U8;
    }
  out[0] = color->cmyka[0];
  out[1] = color->cmyka[1];
  out[2] = color->cmyka[2];
  out[3] = color->cmyka[3];
}
#endif
#endif

static CTX_INLINE void
_ctx_color_get_rgba8 (CtxState *state, CtxColor *color, uint8_t *out)
{
  if (! (color->valid & CTX_VALID_RGBA_U8) )
    {
      float rgba[4];
      ctx_color_get_drgba (state, color, rgba);
      for (unsigned int i = 0; i < 4; i ++)
        { color->rgba[i] = ctx_float_to_u8 (rgba[i]); }
      color->valid |= CTX_VALID_RGBA_U8;
    }
  out[0] = color->rgba[0];
  out[1] = color->rgba[1];
  out[2] = color->rgba[2];
  out[3] = color->rgba[3];
}

void
ctx_color_get_rgba8 (CtxState *state, CtxColor *color, uint8_t *out)
{
  _ctx_color_get_rgba8 (state, color, out);
}

void ctx_color_get_graya_u8 (CtxState *state, CtxColor *color, uint8_t *out)
{
  if (! (color->valid & CTX_VALID_GRAYA_U8) )
    {
      float graya[2];
      ctx_color_get_graya (state, color, graya);
      color->l_u8 = ctx_float_to_u8 (graya[0]);
      color->rgba[3] = ctx_float_to_u8 (graya[1]);
      color->valid |= CTX_VALID_GRAYA_U8;
    }
  out[0] = color->l_u8;
  out[1] = color->rgba[3];
}

#if 0
void
ctx_get_rgba (Ctx *ctx, float *rgba)
{
  ctx_color_get_rgba (& (ctx->state), &ctx->state.gstate.source.color, rgba);
}

void
ctx_get_drgba (Ctx *ctx, float *rgba)
{
  ctx_color_get_drgba (& (ctx->state), &ctx->state.gstate.source.color, rgba);
}
#endif


#if CTX_ENABLE_CMYK
#if 0
void
ctx_get_cmyka (Ctx *ctx, float *cmyka)
{
  ctx_color_get_cmyka (& (ctx->state), &ctx->state.gstate.source.color, cmyka);
}
#endif
#endif
#if 0
void
ctx_get_graya (Ctx *ctx, float *ya)
{
  ctx_color_get_graya (& (ctx->state), &ctx->state.gstate.source.color, ya);
}
#endif

void ctx_stroke_source (Ctx *ctx)
{
  CtxEntry set_stroke = ctx_void (CTX_STROKE_SOURCE);
  ctx_process (ctx, &set_stroke);
}


void ctx_color_raw (Ctx *ctx, CtxColorModel model, float *components, int stroke)
{
#if 0
  CtxSource *source = stroke?
          &ctx->state.gstate.source_stroke:
          &ctx->state.gstate.source_fill;

  if (model == CTX_RGB || model == CTX_RGBA)
  {
    float rgba[4];
  // XXX it should be possible to disable this, to get a more accurate record
  // when it is intentional
    float a = 1.0f;
    if (model == CTX_RGBA) a = components[3];
    ctx_color_get_rgba (&ctx->state, &source->color, rgba);
    if (rgba[0] == components[0] && rgba[1] == components[1] && rgba[2] == components[2] && rgba[3] == a)
     return;
  }
#endif

  if (stroke)
  {
    ctx_stroke_source (ctx);
  }

  CtxEntry command[3]= {
  ctx_f (CTX_COLOR, model, 0)
  };
  switch (model)
  {
    case CTX_RGBA:
    case CTX_RGBA_A:
    case CTX_RGBA_A_DEVICE:
    case CTX_DRGBA:
    case CTX_LABA:
    case CTX_LCHA:
      command[2].data.f[0]=components[3];
      /*FALLTHROUGH*/
    case CTX_RGB:
    case CTX_LAB:
    case CTX_LCH:
    case CTX_DRGB:
      command[0].data.f[1]=components[0];
      command[1].data.f[0]=components[1];
      command[1].data.f[1]=components[2];
      break;
    case CTX_DCMYKA:
    case CTX_CMYKA:
    case CTX_DCMYKA_A:
    case CTX_CMYKA_A:
      command[2].data.f[1]=components[4];
      /*FALLTHROUGH*/
    case CTX_CMYK:
    case CTX_DCMYK:
      command[0].data.f[1]=components[0];
      command[1].data.f[0]=components[1];
      command[1].data.f[1]=components[2];
      command[2].data.f[0]=components[3];
      break;
    case CTX_GRAYA:
    case CTX_GRAYA_A:
      command[1].data.f[0]=components[1];
      /*FALLTHROUGH*/
    case CTX_GRAY:
      command[0].data.f[1]=components[0];
      break;
  }
  ctx_process (ctx, command);
}

void ctx_rgba (Ctx *ctx, float r, float g, float b, float a)
{
#if CTX_PROTOCOL_U8_COLOR
  uint8_t ru, gu, bu, au;
  if (r < 0) ru = 0;
  else if ( r > 1.0f) ru = 255;
  else ru = (uint8_t)(r * 255);
  if (g < 0) gu = 0;
  else if ( g > 1.0f) gu = 255;
  else gu = (uint8_t)(g * 255);
  if (b < 0) bu = 0;
  else if ( b > 1.0f) bu = 255;
  else bu = (uint8_t)(b * 255);
  if (a < 0) au = 0;
  else if ( a > 1.0f) au = 255;
  else au = (uint8_t)(a * 255);

  CtxEntry command = ctx_u8 (CTX_SET_RGBA_U8, ru,gu,bu,au, 0, 0, 0, 0);
#if 0
  uint8_t rgba[4];
  ctx_color_get_rgba8 (&ctx->state, &ctx->state.gstate.source_fill.color, rgba);
  if (rgba[0] == ru && rgba[1] == gu && rgba[2] == bu && rgba[3] == au)
     return;
#endif
  ctx_process (ctx, &command);
#else
  float components[4]={r,g,b,a};
  ctx_color_raw (ctx, CTX_RGBA, components, 0);
#endif
}

void ctx_rgba_stroke (Ctx *ctx, float r, float g, float b, float a)
{
  float components[4]={r,g,b,a};
  ctx_color_raw (ctx, CTX_RGBA, components, 1);
}

void ctx_rgb (Ctx *ctx, float   r, float   g, float   b)
{
  ctx_rgba (ctx, r, g, b, 1.0f);
}

void ctx_rgb_stroke (Ctx *ctx, float   r, float   g, float   b)
{
  ctx_rgba_stroke (ctx, r, g, b, 1.0f);
}

void ctx_gray_stroke   (Ctx *ctx, float gray)
{
  ctx_color_raw (ctx, CTX_GRAY, &gray, 1);
}
void ctx_gray (Ctx *ctx, float gray)
{
  ctx_color_raw (ctx, CTX_GRAY, &gray, 0);
}

void ctx_drgba_stroke (Ctx *ctx, float r, float g, float b, float a)
{
  float components[4]={r,g,b,a};
  ctx_color_raw (ctx, CTX_DRGBA, components, 1);
}
void ctx_drgba (Ctx *ctx, float r, float g, float b, float a)
{
  float components[4]={r,g,b,a};
  ctx_color_raw (ctx, CTX_DRGBA, components, 0);
}

#if CTX_ENABLE_CMYK

void ctx_cmyka_stroke (Ctx *ctx, float c, float m, float y, float k, float a)
{
  float components[5]={c,m,y,k,a};
  ctx_color_raw (ctx, CTX_CMYKA, components, 1);
}
void ctx_cmyka (Ctx *ctx, float c, float m, float y, float k, float a)
{
  float components[5]={c,m,y,k,a};
  ctx_color_raw (ctx, CTX_CMYKA, components, 0);
}
void ctx_cmyk_stroke   (Ctx *ctx, float c, float m, float y, float k)
{
  float components[4]={c,m,y,k};
  ctx_color_raw (ctx, CTX_CMYK, components, 1);
}
void ctx_cmyk (Ctx *ctx, float c, float m, float y, float k)
{
  float components[4]={c,m,y,k};
  ctx_color_raw (ctx, CTX_CMYK, components, 0);
}

#if 0
static void ctx_dcmyk_raw (Ctx *ctx, float c, float m, float y, float k, int stroke)
{
  float components[5]={c,m,y,k,1.0f};
  ctx_color_raw (ctx, CTX_DCMYKA, components, stroke);
}

static void ctx_dcmyka_raw (Ctx *ctx, float c, float m, float y, float k, float a, int stroke)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_COLOR, CTX_DCMYKA + 512 * stroke, c),
    ctx_f (CTX_CONT, m, y),
    ctx_f (CTX_CONT, k, a)
  };
  ctx_process (ctx, command);
}
#endif

void ctx_dcmyk_stroke   (Ctx *ctx, float c, float m, float y, float k)
{
  float components[5]={c,m,y,k,1.0f};
  ctx_color_raw (ctx, CTX_DCMYK, components, 1);
}
void ctx_dcmyk (Ctx *ctx, float c, float m, float y, float k)
{
  float components[5]={c,m,y,k,1.0f};
  ctx_color_raw (ctx, CTX_DCMYK, components, 0);
}

void ctx_dcmyka_stroke   (Ctx *ctx, float c, float m, float y, float k, float a)
{
  float components[5]={c,m,y,k,a};
  ctx_color_raw (ctx, CTX_DCMYKA, components, 1);
}
void ctx_dcmyka (Ctx *ctx, float c, float m, float y, float k, float a)
{
  float components[5]={c,m,y,k,a};
  ctx_color_raw (ctx, CTX_DCMYKA, components, 0);
}

#endif

/* XXX: missing CSS1:
 *
 *   EM { color: rgb(110%, 0%, 0%) }  // clipped to 100% 
 *
 *
 *   :first-letter
 *   :first-list
 *   :link :visited :active
 *
 */

typedef struct ColorDef {
  uint64_t name;
  float r;
  float g;
  float b;
  float a;
} ColorDef;

static const ColorDef _ctx_colors[]={
  {SQZ_black,    0, 0, 0, 1},
  {SQZ_red,      1, 0, 0, 1},
  {SQZ_green,    0, 1, 0, 1},
  {SQZ_yellow,   1, 1, 0, 1},
  {SQZ_blue,     0, 0, 1, 1},
  {SQZ_fuchsia,  1, 0, 1, 1},
  {SQZ_cyan,     0, 1, 1, 1},
  {SQZ_white,    1, 1, 1, 1},
  {SQZ_silver,   0.75294f, 0.75294f, 0.75294f, 1},
  {SQZ_gray,     0.50196f, 0.50196f, 0.50196f, 1},
  {SQZ_magenta,  0.50196f, 0, 0.50196f, 1},
  {SQZ_maroon,   0.50196f, 0, 0, 1},
  {SQZ_purple,   0.50196f, 0, 0.50196f, 1},
  {SQZ_green,    0, 0.50196f, 0, 1},
  {SQZ_lime,     0, 1, 0, 1},
  {SQZ_olive,    0.50196f, 0.50196f, 0, 1},
  {SQZ_navy,     0, 0,      0.50196f, 1},
  {SQZ_teal,     0, 0.50196f, 0.50196f, 1},
  {SQZ_aqua,     0, 1, 1, 1},
  {SQZ_transparent, 0, 0, 0, 0},
  {SQZ_none,     0, 0, 0, 0},
};

static int xdigit_value(const char xdigit)
{
  if (xdigit >= '0' && xdigit <= '9')
   return xdigit - '0';
  switch (xdigit)
  {
    case 'A':case 'a': return 10;
    case 'B':case 'b': return 11;
    case 'C':case 'c': return 12;
    case 'D':case 'd': return 13;
    case 'E':case 'e': return 14;
    case 'F':case 'f': return 15;
  }
  return 0;
}

static int
ctx_color_parse_rgb (CtxState *ctxstate, CtxColor *color, const char *color_string)
{
  float dcolor[4] = {0,0,0,1};
  while (*color_string && *color_string != '(')
    color_string++;
  if (*color_string) color_string++;

  {
    int n_floats = 0;
    char *p =    (char*)color_string;
    char *prev = (char*)NULL;
    for (; p && n_floats < 4 && p != prev && *p; )
    {
      float val;
      prev = p;
      val = _ctx_parse_float (p, &p);
      if (p != prev)
      {
        if (n_floats < 3)
          dcolor[n_floats++] = val/255.0f;
        else
          dcolor[n_floats++] = val;

        while (*p == ' ' || *p == ',')
        {
          p++;
          prev++;
        }
      }
    }
  }
  ctx_color_set_rgba (ctxstate, color, dcolor[0], dcolor[1],dcolor[2],dcolor[3]);
  return 0;
}

static int ctx_isxdigit (uint8_t ch)
{
  if (ch >= '0' && ch <= '9') return 1;
  if (ch >= 'a' && ch <= 'f') return 1;
  if (ch >= 'A' && ch <= 'F') return 1;
  return 0;
}

static int
mrg_color_parse_hex (CtxState *ctxstate, CtxColor *color, const char *color_string)
{
  float dcolor[4]={0,0,0,1};
  int string_length = ctx_strlen (color_string);
  int i;
  dcolor[3] = 1.0;

  if (string_length == 7 ||  /* #rrggbb   */
      string_length == 9)    /* #rrggbbaa */
    {
      int num_iterations = (string_length - 1) / 2;
  
      for (i = 0; i < num_iterations; ++i)
        {
          if (ctx_isxdigit (color_string[2 * i + 1]) &&
              ctx_isxdigit (color_string[2 * i + 2]))
            {
              dcolor[i] = (xdigit_value (color_string[2 * i + 1]) << 4 |
                           xdigit_value (color_string[2 * i + 2])) / 255.f;
            }
          else
            {
              return 0;
            }
        }
      /* Successful #rrggbb(aa) parsing! */
      ctx_color_set_rgba (ctxstate, color, dcolor[0], dcolor[1],dcolor[2],dcolor[3]);
      return 1;
    }
  else if (string_length == 4 ||  /* #rgb  */
           string_length == 5)    /* #rgba */
    {
      int num_iterations = string_length - 1;
      for (i = 0; i < num_iterations; ++i)
        {
          if (ctx_isxdigit (color_string[i + 1]))
            {
              dcolor[i] = (xdigit_value (color_string[i + 1]) << 4 |
                           xdigit_value (color_string[i + 1])) / 255.f;
            }
          else
            {
              return 0;
            }
        }
      ctx_color_set_rgba (ctxstate, color, dcolor[0], dcolor[1],dcolor[2],dcolor[3]);
      /* Successful #rgb(a) parsing! */
      return 0;
    }
  /* String was of unsupported length. */
  return 1;
}

int ctx_color_set_from_string (Ctx *ctx, CtxColor *color, const char *string)
{
  int i;
  uint32_t hash = ctx_strhash (string);
//  ctx_color_set_rgba (&(ctx->state), color, 0.4,0.1,0.9,1.0);
//  return 0;
    //rgba[0], rgba[1], rgba[2], rgba[3]);

  if (hash == SQZ_currentColor)
  {
    float rgba[4];
    CtxColor ccolor;
    memset (&ccolor, 0, sizeof (CtxColor));
    ctx_get_color (ctx, SQZ_color, &ccolor);
    ctx_color_get_rgba (&(ctx->state), &ccolor, rgba);
    ctx_color_set_rgba (&(ctx->state), color, rgba[0], rgba[1], rgba[2], rgba[3]);
    return 0;
  }

  for (i = (sizeof(_ctx_colors)/sizeof(_ctx_colors[0]))-1; i>=0; i--)
  {
    if (hash == _ctx_colors[i].name)
    {
      ctx_color_set_rgba (&(ctx->state), color,
       _ctx_colors[i].r, _ctx_colors[i].g, _ctx_colors[i].b, _ctx_colors[i].a);
      return 0;
    }
  }

  if (string[0] == '#')
    mrg_color_parse_hex (&(ctx->state), color, string);
  else if (string[0] == 'r' &&
      string[1] == 'g' &&
      string[2] == 'b'
      )
    ctx_color_parse_rgb (&(ctx->state), color, string);

  return 0;
}

int ctx_color (Ctx *ctx, const char *string)
{
  CtxColor color = {0,};
  ctx_color_set_from_string (ctx, &color, string);
  float rgba[4];
  ctx_color_get_rgba (&(ctx->state), &color, rgba);
  ctx_color_raw (ctx, CTX_RGBA, rgba, 0);
  return 0;
}

void
ctx_rgba8 (Ctx *ctx, uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
#if 1
  CtxEntry command = ctx_u8 (CTX_SET_RGBA_U8, r, g, b, a, 0, 0, 0, 0);
#if 0
  uint8_t rgba[4];
  ctx_color_get_rgba8 (&ctx->state, &ctx->state.gstate.source.color, rgba);
  if (rgba[0] == r && rgba[1] == g && rgba[2] == b && rgba[3] == a)
     return;
#endif
  ctx_process (ctx, &command);
#else
  ctx_rgba (ctx, r/255.0f, g/255.0f, b/255.0f, a/255.0f);
#endif
}

void ctx_rgba8_stroke (Ctx *ctx, uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
  ctx_rgba_stroke (ctx, r/255.0f, g/255.0f, b/255.0f, a/255.0f);
}


#endif 

#if CTX_BABL
void ctx_rasterizer_colorspace_babl (CtxState      *state,
                                     CtxColorSpace  space_slot,
                                     const Babl    *space)
{
  switch (space_slot)
  {
    case CTX_COLOR_SPACE_DEVICE_RGB:
      state->gstate.device_space = space;
      break;
    case CTX_COLOR_SPACE_DEVICE_CMYK:
      state->gstate.device_space = space;
      break;
    case CTX_COLOR_SPACE_USER_RGB:
      state->gstate.rgb_space = space;
      break;
    case CTX_COLOR_SPACE_USER_CMYK:
      state->gstate.cmyk_space = space;
      break;
    case CTX_COLOR_SPACE_TEXTURE:
      state->gstate.texture_space = space;
      break;
  }

  const Babl *srgb = babl_space ("sRGB");
  if (!state->gstate.texture_space) 
       state->gstate.texture_space = srgb;
  if (!state->gstate.device_space) 
       state->gstate.device_space = srgb;
  if (!state->gstate.rgb_space) 
       state->gstate.rgb_space = srgb;

  //fprintf (stderr, "%s\n", babl_get_name (state->gstate.device_space));

  state->gstate.fish_rgbaf_device_to_user = babl_fish (
       babl_format_with_space ("R'G'B'A float", state->gstate.device_space),
       babl_format_with_space ("R'G'B'A float", state->gstate.rgb_space));
  state->gstate.fish_rgbaf_user_to_device = babl_fish (
       babl_format_with_space ("R'G'B'A float", state->gstate.rgb_space),
       babl_format_with_space ("R'G'B'A float", state->gstate.device_space));
  state->gstate.fish_rgbaf_texture_to_device = babl_fish (
       babl_format_with_space ("R'G'B'A float", state->gstate.texture_space),
       babl_format_with_space ("R'G'B'A float", state->gstate.device_space));
}
#endif

void ctx_rasterizer_colorspace_icc (CtxState            *state,
                                    CtxColorSpace        space_slot,
                                    const unsigned char *icc_data,
                                    int                  icc_length)
{
#if CTX_BABL
   const char *error = NULL;
   const Babl *space = NULL;

   if (icc_data == NULL) space = babl_space ("sRGB");
   else if (icc_length < 32)
   {
      if (icc_data[0] == '0' && icc_data[1] == 'x')
        sscanf ((char*)icc_data, "%p", &space);
      else
      {
        char tmp[24];
        int i;
        for (i = 0; i < icc_length; i++)
          tmp[i]= (icc_data[i]>='A' && icc_data[i]<='Z')?icc_data[i]+('a'-'A'):icc_data[i];
        tmp[icc_length]=0;
        if (!ctx_strcmp (tmp, "srgb"))            space = babl_space ("sRGB");
        else if (!ctx_strcmp (tmp, "scrgb"))      space = babl_space ("scRGB");
        else if (!ctx_strcmp (tmp, "acescg"))     space = babl_space ("ACEScg");
        else if (!ctx_strcmp (tmp, "adobe"))      space = babl_space ("Adobe");
        else if (!ctx_strcmp (tmp, "apple"))      space = babl_space ("Apple");
        else if (!ctx_strcmp (tmp, "rec2020"))    space = babl_space ("Rec2020");
        else if (!ctx_strcmp (tmp, "aces2065-1")) space = babl_space ("ACES2065-1");
      }
   }

   if (!space)
   {
     space = babl_space_from_icc ((char*)icc_data, icc_length, BABL_ICC_INTENT_RELATIVE_COLORIMETRIC, &error);
   }
   if (space)
   {
     ctx_rasterizer_colorspace_babl (state, space_slot, space);
   }
#endif
}

void ctx_colorspace (Ctx                 *ctx,
                     CtxColorSpace        space_slot,
                     const unsigned char *data,
                     int                  data_length)
{
  if (data)
  {
    if (data_length <= 0) data_length = (int)ctx_strlen ((char*)data);
    ctx_process_cmd_str_with_len (ctx, CTX_COLOR_SPACE, (char*)data, space_slot, 0, data_length);
  }
  else
  {
    ctx_process_cmd_str_with_len (ctx, CTX_COLOR_SPACE, "sRGB", space_slot, 0, 4);
  }
}

void ctx_gradient_add_stop_u8
(Ctx *ctx, float pos, uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
  CtxEntry entry = ctx_f (CTX_GRADIENT_STOP, pos, 0);
  entry.data.u8[4+0] = r;
  entry.data.u8[4+1] = g;
  entry.data.u8[4+2] = b;
  entry.data.u8[4+3] = a;
  ctx_process (ctx, &entry);
}

void ctx_gradient_add_stop_rgba
(Ctx *ctx, float pos, float r, float g, float b, float a)
{
  int ir =(int)(r * 255);
  int ig =(int)(g * 255);
  int ib =(int)(b * 255);
  int ia =(int)(a * 255);
  ir = CTX_CLAMP (ir, 0,255);
  ig = CTX_CLAMP (ig, 0,255);
  ib = CTX_CLAMP (ib, 0,255);
  ia = CTX_CLAMP (ia, 0,255);
  ctx_gradient_add_stop_u8 (ctx, pos, ir, ig, ib, ia);
}

void ctx_gradient_add_stop_string
(Ctx *ctx, float pos, const char *string)
{
  CtxColor color = {0,};
  ctx_color_set_from_string (ctx, &color, string);
  float rgba[4];
  ctx_color_get_rgba (&(ctx->state), &color, rgba);
  ctx_gradient_add_stop_rgba (ctx, pos, rgba[0], rgba[1], rgba[2], rgba[3]);
}

//  deviceRGB .. settable when creating an RGB image surface..
//               queryable when running in terminal - is it really needed?
//               though it is settable ; and functional for changing this state at runtime..
//
//  userRGB - settable at any time, stored in save|restore 
//  texture - set as the space of data on subsequent 

CtxBuffer *ctx_buffer_new_bare (void)
{
  CtxBuffer *buffer = (CtxBuffer *) ctx_calloc (sizeof (CtxBuffer), 1);
  return buffer;
}

void ctx_buffer_set_data (CtxBuffer *buffer,
                          void *data, int width, int height,
                          int stride,
                          CtxPixelFormat pixel_format,
                          void (*freefunc) (void *pixels, void *user_data),
                          void *user_data)
{
  if (buffer->freefunc)
    { buffer->freefunc (buffer->data, buffer->user_data); }
  if (stride <= 0)
    stride = ctx_pixel_format_get_stride (pixel_format, width);
  buffer->data      = data;
  buffer->width     = width;
  buffer->height    = height;
  buffer->stride    = stride;
  buffer->format    = ctx_pixel_format_info (pixel_format);
  buffer->freefunc = freefunc;
  buffer->user_data = user_data;
#if CTX_ENABLE_CM
  buffer->color_managed = NULL;
#endif
}

CtxBuffer *ctx_buffer_new_for_data (void *data, int width, int height,
                                    int stride,
                                    CtxPixelFormat pixel_format,
                                    void (*freefunc) (void *pixels, void *user_data),
                                    void *user_data)
{
  CtxBuffer *buffer = ctx_buffer_new_bare ();
  ctx_buffer_set_data (buffer, data, width, height, stride, pixel_format,
                       freefunc, user_data);
  return buffer;
}

void ctx_buffer_pixels_free (void *pixels, void *userdata)
{
  ctx_free (pixels);
}

CtxBuffer *ctx_buffer_new (int width, int height,
                           CtxPixelFormat pixel_format)
{
  //CtxPixelFormatInfo *info = ctx_pixel_format_info (pixel_format);
  CtxBuffer *buffer = ctx_buffer_new_bare ();
  int stride = ctx_pixel_format_get_stride (pixel_format, width);
  int data_len = stride * height;
  if (pixel_format == CTX_FORMAT_YUV420)
    data_len = width * height + ((width/2) * (height/2)) * 2;

  uint8_t *pixels = (uint8_t*)ctx_calloc (data_len, 1);

  ctx_buffer_set_data (buffer, pixels, width, height, stride, pixel_format,
                       ctx_buffer_pixels_free, NULL);
  return buffer;
}

void ctx_buffer_deinit (CtxBuffer *buffer)
{
  if (buffer->freefunc)
    buffer->freefunc (buffer->data, buffer->user_data);
  if (buffer->eid)
  {
    ctx_free (buffer->eid);
  }
  buffer->eid = NULL;
  buffer->data = NULL;
  buffer->freefunc = NULL;
  buffer->user_data  = NULL;
#if CTX_ENABLE_CM
  if (buffer->color_managed)
  {
    if (buffer->color_managed != buffer)
      ctx_buffer_destroy (buffer->color_managed);
    buffer->color_managed = NULL;
  }
#endif
}

void ctx_buffer_destroy (CtxBuffer *buffer)
{
  ctx_buffer_deinit (buffer);
  ctx_free (buffer);
}

#if 0
static int
ctx_texture_check_eid (Ctx *ctx, const char *eid, int *tw, int *th)
{
  for (int i = 0; i <  CTX_MAX_TEXTURES; i++)
  {
    if (ctx->texture[i].data &&
        ctx->texture[i].eid  &&
        !ctx_strcmp (ctx->texture[i].eid, eid))
    {
      if (tw) *tw = ctx->texture[i].width;
      if (th) *th = ctx->texture[i].height;
      ctx->texture[i].frame = ctx->texture_cache->frame;
      return i;
    }
  }
  return -1;
}
#endif

const char* ctx_texture_init (Ctx           *ctx,
                              const char    *eid,
                              int            width,
                              int            height,
                              int            stride,
                              CtxPixelFormat format,
                              void          *space,
                              uint8_t       *pixels,
                              void (*freefunc) (void *pixels, void *user_data),
                              void          *user_data)
{
  int id = 0;
  if (eid)
  {
    for (int i = 0; i <  CTX_MAX_TEXTURES; i++)
    {
      if (ctx->texture[i].data &&
          ctx->texture[i].eid &&
          !ctx_strcmp (ctx->texture[i].eid, eid))
      {
        ctx->texture[i].frame = ctx->texture_cache->frame;
        if (freefunc && user_data != (void*)23)
          freefunc (pixels, user_data);
        return ctx->texture[i].eid;
      }
      if (ctx->texture[i].data == NULL 
          ||   (ctx->texture_cache->frame - ctx->texture[i].frame >= 1))
        id = i;
    }
  } else
  {
    for (int i = 0; i <  CTX_MAX_TEXTURES; i++)
    {
      if (ctx->texture[i].data == NULL 
          || (ctx->texture_cache->frame - ctx->texture[i].frame > 1) ||
          ctx->texture[i].eid[0]=='?')
      {
        id = i;
        break;
      }
    }
  }
  //int bpp = ctx_pixel_format_bits_per_pixel (format);
  ctx_buffer_deinit (&ctx->texture[id]);

  if (stride<=0)
  {
    stride = ctx_pixel_format_get_stride ((CtxPixelFormat)format, width);
  }

  int data_len = stride * height;
  if (format == CTX_FORMAT_YUV420)
          data_len = width * height +
                  2 * ((width/2)*(height/2));

  if (freefunc == ctx_buffer_pixels_free && user_data == (void*)23)
  {
     uint8_t *tmp = (uint8_t*)ctx_malloc (data_len + 8); // XXX : padding should not be needed
     memcpy (tmp, pixels, data_len);
     pixels = tmp;
  }

  ctx_buffer_set_data (&ctx->texture[id],
                       pixels, width, height,
                       stride, format,
                       freefunc, user_data);
#if CTX_ENABLE_CM
  ctx->texture[id].space = space;
#endif
  ctx->texture[id].frame = ctx->texture_cache->frame;
  if (eid)
  {
    /* we got an eid, this is the fast path */
    ctx->texture[id].eid = ctx_strdup (eid);
  }
  else
  {
    uint8_t hash[20];
    char ascii[41];

    CtxSHA1 *sha1 = ctx_sha1_new ();
    ctx_sha1_process (sha1, pixels, stride * height);
    ctx_sha1_done (sha1, hash);
    ctx_sha1_free (sha1);
    const char *hex="0123456789abcdef";
    for (int i = 0; i < 20; i ++)
    {
       ascii[i*2]=hex[hash[i]/16];
       ascii[i*2+1]=hex[hash[i]%16];
    }
    ascii[40]=0;
    ctx->texture[id].eid = ctx_strdup (ascii);
  }
  return ctx->texture[id].eid;
}

void
_ctx_texture_prepare_color_management (CtxState      *state,
                                       CtxBuffer     *buffer)
{
#if CTX_ENABLE_CM
   _ctx_texture_lock ();
   switch (buffer->format->pixel_format)
   {
#if CTX_BABL
     case CTX_FORMAT_RGBA8:
       if (buffer->space == state->gstate.device_space)
       {
         buffer->color_managed = buffer;
       }
       else
       {
          CtxBuffer *color_managed = ctx_buffer_new (buffer->width, buffer->height,
                                                  CTX_FORMAT_RGBA8);
          babl_process (
             babl_fish (babl_format_with_space ("Ra'Ga'Ba'A u8", buffer->space),
                        babl_format_with_space ("Ra'Ga'Ba'A u8", state->gstate.device_space)),
             buffer->data, color_managed->data,
             buffer->width * buffer->height
             );
          buffer->color_managed = color_managed;
       }
       break;
     case CTX_FORMAT_RGB8:
       if (buffer->space == state->gstate.device_space)
       {
         buffer->color_managed = buffer;
       }
       else
       {
         CtxBuffer *color_managed = ctx_buffer_new (buffer->width, buffer->height,
                                               CTX_FORMAT_RGB8);
         babl_process (
            babl_fish (babl_format_with_space ("R'G'B' u8", buffer->space),
                       babl_format_with_space ("R'G'B' u8", state->gstate.device_space)),
            buffer->data, color_managed->data,
            buffer->width * buffer->height
          );
         buffer->color_managed = color_managed;
       }
       break;
#endif
     default:
       buffer->color_managed = buffer;
   }
#endif
    _ctx_texture_unlock ();
}



static inline int _ctx_utf8_len (const unsigned char first_byte)
{
  if      ( (first_byte & 0x80) == 0)
    { return 1; } /* ASCII */
  else if ( (first_byte & 0xE0) == 0xC0)
    { return 2; }
  else if ( (first_byte & 0xF0) == 0xE0)
    { return 3; }
  else if ( (first_byte & 0xF8) == 0xF0)
    { return 4; }
  return 1;
}


static inline const char *_ctx_utf8_skip (const char *s, int utf8_length)
{
  int count;
  if (!s)
    { return NULL; }
  for (count = 0; *s; s++)
    {
      if ( (*s & 0xC0) != 0x80)
        { count++; }
      if (count == utf8_length + 1)
        { return s; }
    }
  return s;
}


static inline int _ctx_utf8_strlen (const char *s)
{
  int count;
  if (!s)
    { return 0; }
  for (count = 0; *s; s++)
    if ( (*s & 0xC0) != 0x80)
      { count++; }
  return count;
}

static inline int
_ctx_unichar_to_utf8 (uint32_t  ch,
                     uint8_t  *dest)
{
  /* http://www.cprogramming.com/tutorial/utf8.c  */
  /*  Basic UTF-8 manipulation routines
    by Jeff Bezanson
    placed in the public domain Fall 2005 ... */
  if (ch < 0x80)
    {
      dest[0] = (char) ch;
      return 1;
    }
  if (ch < 0x800)
    {
      dest[0] = (ch>>6) | 0xC0;
      dest[1] = (ch & 0x3F) | 0x80;
      return 2;
    }
  if (ch < 0x10000)
    {
      dest[0] = (ch>>12) | 0xE0;
      dest[1] = ( (ch>>6) & 0x3F) | 0x80;
      dest[2] = (ch & 0x3F) | 0x80;
      return 3;
    }
  if (ch < 0x110000)
    {
      dest[0] = (ch>>18) | 0xF0;
      dest[1] = ( (ch>>12) & 0x3F) | 0x80;
      dest[2] = ( (ch>>6) & 0x3F) | 0x80;
      dest[3] = (ch & 0x3F) | 0x80;
      return 4;
    }
  return 0;
}


static inline uint32_t
_ctx_utf8_to_unichar (const char *input)
{
  const uint8_t *utf8 = (const uint8_t *) input;
  uint8_t c = utf8[0];
  if ( (c & 0x80) == 0)
    { return c; }
  else if ( (c & 0xE0) == 0xC0)
    return ( (utf8[0] & 0x1F) << 6) |
           (utf8[1] & 0x3F);
  else if ( (c & 0xF0) == 0xE0)
    return ( (utf8[0] & 0xF)  << 12) |
           ( (utf8[1] & 0x3F) << 6) |
           (utf8[2] & 0x3F);
  else if ( (c & 0xF8) == 0xF0)
    return ( (utf8[0] & 0x7)  << 18) |
           ( (utf8[1] & 0x3F) << 12) |
           ( (utf8[2] & 0x3F) << 6) |
           (utf8[3] & 0x3F);
  else if ( (c & 0xFC) == 0xF8)
    return ( (utf8[0] & 0x3)  << 24) |
           ( (utf8[1] & 0x3F) << 18) |
           ( (utf8[2] & 0x3F) << 12) |
           ( (utf8[3] & 0x3F) << 6) |
           (utf8[4] & 0x3F);
  else if ( (c & 0xFE) == 0xFC)
    return ( (utf8[0] & 0x1)  << 30) |
           ( (utf8[1] & 0x3F) << 24) |
           ( (utf8[2] & 0x3F) << 18) |
           ( (utf8[3] & 0x3F) << 12) |
           ( (utf8[4] & 0x3F) << 6) |
           (utf8[5] & 0x3F);
  return 0;
}


int ctx_utf8_len (const unsigned char first_byte)
{
  return _ctx_utf8_len (first_byte);
}

int ctx_utf8_strlen (const char *s)
{
  return _ctx_utf8_strlen (s);
}

const char *ctx_utf8_skip (const char *s, int utf8_length)
{
  return _ctx_utf8_skip (s, utf8_length);
}

int
ctx_unichar_to_utf8 (uint32_t  ch,
                     uint8_t  *dest)
{
  return _ctx_unichar_to_utf8 (ch, dest);
}
uint32_t
ctx_utf8_to_unichar (const char *input)
{
  return _ctx_utf8_to_unichar (input);
}
#if CTX_TERMINAL_EVENTS

#if !__COSMOPOLITAN__

#include <fcntl.h>
#if CTX_PTY
#include <termios.h>
#include <sys/ioctl.h>
#endif
#endif


int ctx_term_raw (int fd);
void ctx_term_noraw (int fd);

void ctx_drain_fd (int fd)
{
  struct timeval tv = {0,0};
  fd_set rfds;
  char buf[1];
  
  FD_ZERO(&rfds);
  FD_SET(fd, &rfds);
  tv.tv_sec = 0;
  tv.tv_usec = 100;
  while (select(fd+1, &rfds, NULL, NULL, &tv)>0)
  {
    read (fd, buf, sizeof(buf));
    tv.tv_sec = 1;
    tv.tv_usec = 100;
    FD_ZERO(&rfds);
    FD_SET(fd, &rfds);
  }
}


void ctx_terminal_dim (int in_fd, int out_fd, int *width, int *height, int rc)
{
  char buf[128];
  ctx_term_raw(in_fd);
//ctx_drain_fd(in_fd);


  if (rc)
  {
    write (out_fd, "\033[18t", 5);
    if (width) *width = 9;
    if (height) *height = 7;
  }
  else
  {
    write (out_fd, "\033[14t", 5);
    if (width) *width = 400;
    if (height) *height = 300;
  }
  sync ();
  int length = 0;
  struct timeval tv = {0,0};
  fd_set rfds;
  
  FD_ZERO(&rfds);
  FD_SET(in_fd, &rfds);
  tv.tv_sec = 0;
  tv.tv_usec = 1000 * 500;
  int ts = 0;
  for (int n = 0; ts < 1 && select(in_fd+1, &rfds, NULL, NULL, &tv) > 0 &&
                  n < 100 
                  ; n++)
  {
    if (read (in_fd, &buf[length], 1) > 0)
    {
      if (buf[length] == 't')
      {
        ts++;
      }
      length++;
    } 
    tv.tv_sec = 0;
    tv.tv_usec = 1000 * 250;
    FD_ZERO(&rfds);
    FD_SET(in_fd, &rfds);
  }
  ctx_term_noraw(in_fd);
  buf[length]=0;
  //fprintf (stderr, "{{{%i %s]%i\n", length, buf+1, ts);
  char *semi = strchr (buf, ';');

  if (semi) {
    if (height) *height = atoi (semi + 1);
    semi++; semi = strchr (semi, ';');}
  if (semi)
  {
    if (width) *width = atoi (semi + 1);
  }

}

int ctx_terminal_width (int in_fd, int out_fd)
{
  int ret; ctx_terminal_dim(in_fd, out_fd, &ret, NULL, 0); return ret;
}

int ctx_terminal_height (int in_fd, int out_fd)
{
  int ret; ctx_terminal_dim(in_fd, out_fd, NULL, &ret, 0); return ret;
}


int ctx_terminal_cols (int in_fd, int out_fd)
{
  int ret; ctx_terminal_dim(in_fd, out_fd, &ret, NULL, 1); return ret;
} 

int ctx_terminal_rows (int in_fd, int out_fd)
{
  int ret; ctx_terminal_dim(in_fd, out_fd, NULL, &ret, 1); return ret;
}


#define DECTCEM_CURSOR_SHOW      "\033[?25h"
#define DECTCEM_CURSOR_HIDE      "\033[?25l"
#define TERMINAL_MOUSE_OFF       "\033[?1000l\033[?1003l"
#define TERMINAL_MOUSE_ON_BASIC  "\033[?1000h"
#define TERMINAL_MOUSE_ON_DRAG   "\033[?1000h\033[?1003h" /* +ON_BASIC for wider */
#define TERMINAL_MOUSE_ON_FULL   "\033[?1000h\033[?1004h" /* compatibility */
#define XTERM_ALTSCREEN_ON       "\033[?47h"
#define XTERM_ALTSCREEN_OFF      "\033[?47l"

/*************************** input handling *************************/

#if !__COSMOPOLITAN__
#if CTX_PTY
#include <termios.h>
#endif
#include <errno.h>
#include <signal.h>
#endif

#define CTX_DELAY_MS  20

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif

static int  size_changed = 0;       /* XXX: global state */
#if CTX_PTY
static int  ctx_term_signal_installed = 0;   /* XXX: global state */
#endif

static const char *mouse_modes[]=
{TERMINAL_MOUSE_OFF,
 TERMINAL_MOUSE_ON_BASIC,
 TERMINAL_MOUSE_ON_DRAG,
 TERMINAL_MOUSE_ON_FULL,
 NULL};

/* note that a nick can have multiple occurences, the labels
 * should be kept the same for all occurences of a combination. */
typedef struct NcKeyCode {
  const char *nick;          /* programmers name for key (combo) */
  const char *label;         /* utf8 label for key */
  const char  sequence[10];  /* terminal sequence */
} NcKeyCode;
static const NcKeyCode keycodes[]={  

  {"up",                  "↑",     "\033[A"},
  {"down",                "↓",     "\033[B"},
  {"right",               "→",     "\033[C"},
  {"left",                "←",     "\033[D"},

  {"shift-up",            "⇧↑",    "\033[1;2A"},
  {"shift-down",          "⇧↓",    "\033[1;2B"},
  {"shift-right",         "⇧→",    "\033[1;2C"},
  {"shift-left",          "⇧←",    "\033[1;2D"},

  {"alt-up",              "^↑",    "\033[1;3A"},
  {"alt-down",            "^↓",    "\033[1;3B"},
  {"alt-right",           "^→",    "\033[1;3C"},
  {"alt-left",            "^←",    "\033[1;3D"},

  {"alt-shift-up",        "alt-s↑", "\033[1;4A"},
  {"alt-shift-down",      "alt-s↓", "\033[1;4B"},
  {"alt-shift-right",     "alt-s→", "\033[1;4C"},
  {"alt-shift-left",      "alt-s←", "\033[1;4D"},

  {"control-up",          "^↑",    "\033[1;5A"},
  {"control-down",        "^↓",    "\033[1;5B"},
  {"control-right",       "^→",    "\033[1;5C"},
  {"control-left",        "^←",    "\033[1;5D"},

  /* putty */
  {"control-up",          "^↑",    "\033OA"},
  {"control-down",        "^↓",    "\033OB"},
  {"control-right",       "^→",    "\033OC"},
  {"control-left",        "^←",    "\033OD"},

  {"control-shift-up",    "^⇧↑",   "\033[1;6A"},
  {"control-shift-down",  "^⇧↓",   "\033[1;6B"},
  {"control-shift-right", "^⇧→",   "\033[1;6C"},
  {"control-shift-left",  "^⇧←",   "\033[1;6D"},

  {"control-up",          "^↑",    "\033Oa"},
  {"control-down",        "^↓",    "\033Ob"},
  {"control-right",       "^→",    "\033Oc"},
  {"control-left",        "^←",    "\033Od"},

  {"shift-up",            "⇧↑",    "\033[a"},
  {"shift-down",          "⇧↓",    "\033[b"},
  {"shift-right",         "⇧→",    "\033[c"},
  {"shift-left",          "⇧←",    "\033[d"},

  {"insert",              "ins",   "\033[2~"},
  {"delete",              "del",   "\033[3~"},
  {"page-up",             "PgUp",  "\033[5~"},
  {"page-down",           "PdDn",  "\033[6~"},
  {"home",                "Home",  "\033OH"},
  {"end",                 "End",   "\033OF"},
  {"home",                "Home",  "\033[H"},
  {"end",                 "End",   "\033[F"},
  {"control-delete",      "^del",  "\033[3;5~"},
  {"shift-delete",        "⇧del",  "\033[3;2~"},
  {"control-shift-delete","^⇧del", "\033[3;6~"},

  {"F1",        "F1",  "\033[10~"},
  {"F2",        "F2",  "\033[11~"},
  {"F3",        "F3",  "\033[12~"},
  {"F4",        "F4",  "\033[13~"},
  {"F1",        "F1",  "\033OP"},
  {"F2",        "F2",  "\033OQ"},
  {"F3",        "F3",  "\033OR"},
  {"F4",        "F4",  "\033OS"},
  {"F5",        "F5",  "\033[15~"},
  {"F6",        "F6",  "\033[16~"},
  {"F7",        "F7",  "\033[17~"},
  {"F8",        "F8",  "\033[18~"},
  {"F9",        "F9",  "\033[19~"},
  {"F9",        "F9",  "\033[20~"},
  {"F10",       "F10", "\033[21~"},
  {"F11",       "F11", "\033[22~"},
  {"F12",       "F12", "\033[23~"},
  {"tab",       "↹",     {9, '\0'}},
  {"shift-tab", "shift+↹",  "\033[Z"},
  {"backspace", "⌫",  {127, '\0'}},
  {"space",     "␣",   " "},
  {"esc",        "␛",  "\033"},
  {"return",    "⏎",  {10,0}},
  {"return",    "⏎",  {13,0}},
  /* this section could be autogenerated by code */
  {"control-a", "^A",  {1,0}},
  {"control-b", "^B",  {2,0}},
  {"control-c", "^C",  {3,0}},
  {"control-d", "^D",  {4,0}},
  {"control-e", "^E",  {5,0}},
  {"control-f", "^F",  {6,0}},
  {"control-g", "^G",  {7,0}},
  {"control-h", "^H",  {8,0}}, /* backspace? */
  {"control-i", "^I",  {9,0}}, /* tab */
  {"control-j", "^J",  {10,0}},
  {"control-k", "^K",  {11,0}},
  {"control-l", "^L",  {12,0}},
  {"control-n", "^N",  {14,0}},
  {"control-o", "^O",  {15,0}},
  {"control-p", "^P",  {16,0}},
  {"control-q", "^Q",  {17,0}},
  {"control-r", "^R",  {18,0}},
  {"control-s", "^S",  {19,0}},
  {"control-t", "^T",  {20,0}},
  {"control-u", "^U",  {21,0}},
  {"control-v", "^V",  {22,0}},
  {"control-w", "^W",  {23,0}},
  {"control-x", "^X",  {24,0}},
  {"control-y", "^Y",  {25,0}},
  {"control-z", "^Z",  {26,0}},
  {"alt-0",     "%0",  "\0330"},
  {"alt-1",     "%1",  "\0331"},
  {"alt-2",     "%2",  "\0332"},
  {"alt-3",     "%3",  "\0333"},
  {"alt-4",     "%4",  "\0334"},
  {"alt-5",     "%5",  "\0335"},
  {"alt-6",     "%6",  "\0336"},
  {"alt-7",     "%7",  "\0337"}, /* backspace? */
  {"alt-8",     "%8",  "\0338"},
  {"alt-9",     "%9",  "\0339"},
  {"alt-+",     "%+",  "\033+"},
  {"alt--",     "%-",  "\033-"},
  {"alt-/",     "%/",  "\033/"},
  {"alt-a",     "%A",  "\033a"},
  {"alt-b",     "%B",  "\033b"},
  {"alt-c",     "%C",  "\033c"},
  {"alt-d",     "%D",  "\033d"},
  {"alt-e",     "%E",  "\033e"},
  {"alt-f",     "%F",  "\033f"},
  {"alt-g",     "%G",  "\033g"},
  {"alt-h",     "%H",  "\033h"}, /* backspace? */
  {"alt-i",     "%I",  "\033i"},
  {"alt-j",     "%J",  "\033j"},
  {"alt-k",     "%K",  "\033k"},
  {"alt-l",     "%L",  "\033l"},
  {"alt-n",     "%N",  "\033m"},
  {"alt-n",     "%N",  "\033n"},
  {"alt-o",     "%O",  "\033o"},
  {"alt-p",     "%P",  "\033p"},
  {"alt-q",     "%Q",  "\033q"},
  {"alt-r",     "%R",  "\033r"},
  {"alt-s",     "%S",  "\033s"},
  {"alt-t",     "%T",  "\033t"},
  {"alt-u",     "%U",  "\033u"},
  {"alt-v",     "%V",  "\033v"},
  {"alt-w",     "%W",  "\033w"},
  {"alt-x",     "%X",  "\033x"},
  {"alt-y",     "%Y",  "\033y"},
  {"alt-z",     "%Z",  "\033z"},
  {"shift-tab", "shift-↹", {27, 9, 0}},
  /* Linux Console  */
  {"home",      "Home", "\033[1~"},
  {"end",       "End",  "\033[4~"},
  {"F1",        "F1",   "\033[[A"},
  {"F2",        "F2",   "\033[[B"},
  {"F3",        "F3",   "\033[[C"},
  {"F4",        "F4",   "\033[[D"},
  {"F5",        "F5",   "\033[[E"},
  {"F6",        "F6",   "\033[[F"},
  {"F7",        "F7",   "\033[[G"},
  {"F8",        "F8",   "\033[[H"},
  {"F9",        "F9",   "\033[[I"},
  {"F10",       "F10",  "\033[[J"},
  {"F11",       "F11",  "\033[[K"},
  {"F12",       "F12",  "\033[[L"}, 
  {"ok",        "",     "\033[0n"},
  {NULL, }
};
#if CTX_PTY
static struct termios orig_attr;    /* in order to restore at exit */
static int    nc_is_raw = 0;
static int    atexit_registered = 0;
#endif
static int    mouse_mode = NC_MOUSE_NONE;

void ctx_term_noraw (int fd)
{
#if CTX_PTY
  if (fd == STDIN_FILENO)
  if (nc_is_raw && tcsetattr (fd, TCSAFLUSH, &orig_attr) != -1)
    nc_is_raw = 0;
#endif
}

void
nc_at_exit (void)
{
  printf (TERMINAL_MOUSE_OFF);
  printf (XTERM_ALTSCREEN_OFF);
  ctx_term_noraw(STDIN_FILENO);
  fprintf (stdout, "\033[?25h");
  //if (ctx_native_events)
  fprintf (stdout, "\033[?201l");
  fprintf (stdout, "\033[?1049l");
}

static const char *mouse_get_event_int (Ctx *n, int *x, int *y)
{
  static int prev_state = 0;
  const char *ret = "pm";
  float relx, rely;
  signed char buf[3];
  read (n->mouse_fd, buf, 3);
  relx = buf[1];
  rely = -buf[2];

  n->mouse_x += (int)(relx * 0.1f);
  n->mouse_y += (int)(rely * 0.1f);

  if (n->mouse_x < 1) n->mouse_x = 1;
  if (n->mouse_y < 1) n->mouse_y = 1;
  if (n->mouse_x >= n->width)  n->mouse_x = n->width;
  if (n->mouse_y >= n->height) n->mouse_y = n->height;

  if (x) *x = n->mouse_x;
  if (y) *y = n->mouse_y;

  if ((prev_state & 1) != (buf[0] & 1))
    {
      if (buf[0] & 1) ret = "pp";
    }
  else if (buf[0] & 1)
    ret = "pd";

  if ((prev_state & 2) != (buf[0] & 2))
    {
      if (buf[0] & 2) ret = "mouse2-press";
    }
  else if (buf[0] & 2)
    ret = "mouse2-drag";

  if ((prev_state & 4) != (buf[0] & 4))
    {
      if (buf[0] & 4) ret = "mouse1-press";
    }
  else if (buf[0] & 4)
    ret = "mouse1-drag";

  prev_state = buf[0];
  return ret;
}

static const char *mev_type = NULL;
static int         mev_x = 0;
static int         mev_y = 0;
static int         mev_q = 0;

static const char *mouse_get_event (Ctx  *n, int *x, int *y)
{
  if (!mev_q)
    return NULL;
  *x = mev_x;
  *y = mev_y;
  mev_q = 0;
  return mev_type;
}

static int mouse_has_event (Ctx *n)
{
  struct timeval tv;
  int retval;

  if (mouse_mode == NC_MOUSE_NONE)
    return 0;

  if (mev_q)
    return 1;

  if (n->mouse_fd == 0)
    return 0;
  return 0;

  {
    fd_set rfds;
    FD_ZERO (&rfds);
    FD_SET(n->mouse_fd, &rfds);
    tv.tv_sec = 0; tv.tv_usec = 0;
    retval = select (n->mouse_fd+1, &rfds, NULL, NULL, &tv);
  }

  if (retval != 0)
    {
      int nx = 0, ny = 0;
      const char *type = mouse_get_event_int (n, &nx, &ny);

      if ((mouse_mode < NC_MOUSE_DRAG && mev_type && !strcmp (mev_type, "drag")) ||
          (mouse_mode < NC_MOUSE_ALL && mev_type && !strcmp (mev_type, "motion")))
        {
          mev_q = 0;
          return mouse_has_event (n);
        }

      if ((mev_type && !strcmp (type, mev_type) && !strcmp (type, "pm")) ||
         (mev_type && !strcmp (type, mev_type) && !strcmp (type, "mouse1-drag")) ||
         (mev_type && !strcmp (type, mev_type) && !strcmp (type, "mouse2-drag")))
        {
          if (nx == mev_x && ny == mev_y)
          {
            mev_q = 0;
            return mouse_has_event (n);
          }
        }
      mev_x = nx;
      mev_y = ny;
      mev_type = type;
      mev_q = 1;
    }
  return retval != 0;
}

#if CTX_PTY
int ctx_term_raw (int fd)
{
  struct termios raw;
  if (!isatty (fd))
    return -1;
  if (!atexit_registered)
    {
      //atexit (nc_at_exit);
      atexit_registered = 1;
    }
  if (fd == STDIN_FILENO && nc_is_raw)
    return 0;
  if (tcgetattr (fd, &orig_attr) == -1)
    return -1;
  raw = orig_attr;  /* modify the original mode */
  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  raw.c_oflag &= ~(OPOST);
  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
  if (tcsetattr (fd, TCSAFLUSH, &raw) < 0)
    return -1;
  if (fd == STDIN_FILENO)
    nc_is_raw = 1;
#if !__COSMOPOLITAN__
  tcdrain(fd);
  tcflush(fd, 1);
#endif
  return 0;
}
#endif

static int match_keycode (const char *buf, int length, const NcKeyCode **ret)
{
  int i;
  int matches = 0;

  if (!strncmp (buf, "\033[M", MIN(length,3)))
    {
      if (length >= 6)
        return 9001;
      return 2342;
    }
  for (i = 0; keycodes[i].nick; i++)
    if (!strncmp (buf, keycodes[i].sequence, length))
      {
        matches ++;
        if ((int)strlen (keycodes[i].sequence) == length && ret)
          {
            *ret = &keycodes[i];
            return 1;
          }
      }
  if (matches != 1 && ret)
    *ret = NULL;
  return matches==1?2:matches;
}

static void nc_resize_term (int  dummy)
{
  size_changed = 1;
}

int ctx_nct_has_event (Ctx  *n, int delay_ms)
{
  struct timeval tv;
  int retval;
  fd_set rfds;

  if (size_changed)
    return 1;
  FD_ZERO (&rfds);
  FD_SET (STDIN_FILENO, &rfds);
  tv.tv_sec = 0; tv.tv_usec = delay_ms * 1000;
  retval = select (1, &rfds, NULL, NULL, &tv);
  if (size_changed)
    return 1;
  return retval == 1;
}

const char *ctx_nct_get_event (Ctx *n, int timeoutms, int *x, int *y)
{
  if (x) *x = -1;
  if (y) *y = -1;
#if CTX_PTY
  unsigned char buf[20];
  int length;
  if (!ctx_term_signal_installed)
  {
    ctx_term_raw (STDIN_FILENO);
    ctx_term_signal_installed = 1;
    signal (SIGWINCH, nc_resize_term);
  }
  if (mouse_mode) // XXX too often to do it all the time!
  {
    printf("%s", mouse_modes[mouse_mode]);
  }

  int got_event = 0;
  {
    int elapsed = 0;
    int bail = 100;

    do {
      if (size_changed)
        {
          size_changed = 0;
          return "size-changed";
        }
      got_event = mouse_has_event (n);
      if (!got_event)
        got_event = ctx_nct_has_event (n, MIN(CTX_DELAY_MS, timeoutms-elapsed));
      if (size_changed)
        {
          size_changed = 0;
          return "size-changed";
        }
      /* only do this if the client has asked for idle events,
       * and perhaps programmed the ms timer?
       */
      elapsed += MIN(CTX_DELAY_MS, timeoutms-elapsed);
      if (!got_event && timeoutms && elapsed >= timeoutms)
      {
        return "idle";
      }
      bail --;
    } while (!got_event && bail > 0);
  }

  if (mouse_has_event (n))
    return mouse_get_event (n, x, y);

  if (!got_event)
    return "idle";
  for (length = 0; length < 10; length ++)
    if (read (STDIN_FILENO, &buf[length], 1) != -1)
      {
        const NcKeyCode *match = NULL;

        /* special case ESC, so that we can use it alone in keybindings */
        if (length == 0 && buf[0] == 27)
          {
            struct timeval tv;
            fd_set rfds;
            FD_ZERO (&rfds);
            FD_SET (STDIN_FILENO, &rfds);
            tv.tv_sec = 0;
            tv.tv_usec = 1000 * CTX_DELAY_MS;
            if (select (1, &rfds, NULL, NULL, &tv) == 0)
              return "esc";
          }

        switch (match_keycode ((const char*)buf, length + 1, &match))
          {
            case 1: /* unique match */
              if (!match)
                return NULL;
              if (!strcmp(match->nick, "ok"))
              {
                ctx_frame_ack = 1;
                return NULL;
              }
              return match->nick;
              break;
            case 9001: /* mouse event */
              if (x) *x = ((unsigned char)buf[4]-32);
              if (y) *y = ((unsigned char)buf[5]-32);
              switch (buf[3])
                {
                        /* XXX : todo reduce this to less string constants */
                  case 32:  return "pp";
                  case 33:  return "mouse1-press";
                  case 34:  return "mouse2-press";
                  case 40:  return "alt-pp";
                  case 41:  return "alt-mouse1-press";
                  case 42:  return "alt-mouse2-press";
                  case 48:  return "control-pp";
                  case 49:  return "control-mouse1-press";
                  case 50:  return "control-mouse2-press";
                  case 56:  return "alt-control-pp";
                  case 57:  return "alt-control-mouse1-press";
                  case 58:  return "alt-control-mouse2-press";
                  case 64:  return "pd";
                  case 65:  return "mouse1-drag";
                  case 66:  return "mouse2-drag";
                  case 71:  return "pm"; /* shift+motion */
                  case 72:  return "alt-pd";
                  case 73:  return "alt-mouse1-drag";
                  case 74:  return "alt-mouse2-drag";
                  case 75:  return "pm"; /* alt+motion */
                  case 80:  return "control-pd";
                  case 81:  return "control-mouse1-drag";
                  case 82:  return "control-mouse2-drag";
                  case 83:  return "pm"; /* ctrl+motion */
                  case 91:  return "pm"; /* ctrl+alt+motion */
                  case 95:  return "pm"; /* ctrl+alt+shift+motion */
                  case 96:  return "scroll-up";
                  case 97:  return "scroll-down";
                  case 100: return "shift-scroll-up";
                  case 101: return "shift-scroll-down";
                  case 104: return "alt-scroll-up";
                  case 105: return "alt-scroll-down";
                  case 112: return "control-scroll-up";
                  case 113: return "control-scroll-down";
                  case 116: return "control-shift-scroll-up";
                  case 117: return "control-shift-scroll-down";
                  case 35: /* (or release) */
                  case 51: /* (or ctrl-release) */
                  case 43: /* (or alt-release) */
                  case 67: return "pm";
                           /* have a separate pd ? */
                  default: {
                             static char rbuf[50];
                             sprintf (rbuf, "mouse (unhandled state: %i)", buf[3]);
                             return rbuf;
                           }
                }
            case 0: /* no matches, bail*/
              { 
                static char ret[256];
                if (length == 0 && ctx_utf8_len (buf[0])>1) /* single unicode
                                                               char */
                  {
                    int n_read = 
                    read (STDIN_FILENO, &buf[length+1], ctx_utf8_len(buf[0])-1);
                    if (n_read)
                    {
                      buf[ctx_utf8_len(buf[0])]=0;
                      strcpy (ret, (const char*)buf);
                    }
                    return ret;
                  }
                if (length == 0) /* ascii */
                  {
                    buf[1]=0;
                    strcpy (ret, (const char*)buf);
                    return ret;
                  }
                sprintf (ret, "unhandled %i:'%c' %i:'%c' %i:'%c' %i:'%c' %i:'%c' %i:'%c' %i:'%c'",
                  length>=0? buf[0]: 0, length>=0? buf[0]>31?buf[0]:'?': ' ', 
                  length>=1? buf[1]: 0, length>=1? buf[1]>31?buf[1]:'?': ' ', 
                  length>=2? buf[2]: 0, length>=2? buf[2]>31?buf[2]:'?': ' ', 
                  length>=3? buf[3]: 0, length>=3? buf[3]>31?buf[3]:'?': ' ',
                  length>=4? buf[4]: 0, length>=4? buf[4]>31?buf[4]:'?': ' ',
                  length>=5? buf[5]: 0, length>=5? buf[5]>31?buf[5]:'?': ' ',
                  length>=6? buf[6]: 0, length>=6? buf[6]>31?buf[6]:'?': ' ');
                return ret;
              }
              return NULL;
            default: /* continue */
              break;
          }
      }
    else
      return "key read eek";
  return "fail";
#else
  return "NYI.";
#endif
}

// this event provider uses regular terminal mouse and key reporting
void ctx_nct_consume_events (Ctx *ctx)
{
  int ix, iy;
  CtxCtx *ctxctx = (CtxCtx*)ctx->backend;
  const char *event = NULL;
  int max_events = 4;
  do {
    float x, y;
    event = ctx_nct_get_event (ctx, 50, &ix, &iy);

    x = (ix - 1.0f + 0.5f) / ctxctx->cols * ctx->width;
    y = (iy - 1.0f)        / ctxctx->rows * ctx->height;

    if (!strcmp (event, "pp"))
    {
      ctx_pointer_press (ctx, x, y, 0, 0);
      ctxctx->was_down = 1;
    } else if (!strcmp (event, "pr"))
    {
      ctx_pointer_release (ctx, x, y, 0, 0);
      ctxctx->was_down = 0;
    } else if (!strcmp (event, "pm"))
    {
      //nct_set_cursor_pos (backend->term, ix, iy);
      //nct_flush (backend->term);
      if (ctxctx->was_down)
      {
        ctx_pointer_release (ctx, x, y, 0, 0);
        ctxctx->was_down = 0;
      }
      ctx_pointer_motion (ctx, x, y, 0, 0);
    } else if (!strcmp (event, "pd"))
    {
      ctx_pointer_motion (ctx, x, y, 0, 0);
    } else if (!strcmp (event, "size-changed"))
    {
#if 0
      int width = nct_sys_terminal_width ();
      int height = nct_sys_terminal_height ();
      nct_set_size (backend->term, width, height);
      width *= CPX;
      height *= CPX;
      ctx_free (mrg->glyphs);
      ctx_free (mrg->styles);
      ctx_free (backend->nct_pixels);
      backend->nct_pixels = ctx_calloc (width * height * 4, 1);
      mrg->glyphs = ctx_calloc ((width/CPX) * (height/CPX) * 4, 1);
      mrg->styles = ctx_calloc ((width/CPX) * (height/CPX) * 1, 1);
      mrg_set_size (mrg, width, height);
      mrg_queue_draw (mrg, NULL);
#endif
      //if (ctx_backend_is_ctx (ctx))
#if 0
      {
        int width = ctx_terminal_width ();
        int height = ctx_terminal_height ();
        ctx_set_size (ctx, width, height);
      }
#endif

    }
    else
    {
      if (!strcmp (event, "esc"))
        ctx_key_press (ctx, 0, "escape", 0);
      else if (!strcmp (event, "space"))
        ctx_key_press (ctx, 0, "space", 0);
      else if (!strcmp (event, "enter"))
        ctx_key_press (ctx, 0, "\n", 0);
      else if (!strcmp (event, "return"))
        ctx_key_press (ctx, 0, "return", 0);
      else if (!strcmp (event, "idle"))
      {
        event = NULL;
      }
      else
      ctx_key_press (ctx, 0, event, 0);
    }
    max_events --;
  }  while (event && max_events > 0);
}

const char *ctx_key_get_label (Ctx  *n, const char *nick)
{
  int j;
  int found = -1;
  for (j = 0; keycodes[j].nick; j++)
    if (found == -1 && !strcmp (keycodes[j].nick, nick))
      return keycodes[j].label;
  return NULL;
}

void _ctx_mouse (Ctx *term, int mode)
{
  //if (term->is_st && mode > 1)
  //  mode = 1;
  if (mode != mouse_mode)
  {
    printf ("%s", mouse_modes[mode]);
    fflush (stdout);
  }
  mouse_mode = mode;
}


#endif

#if !__COSMOPOLITAN__
#include <sys/time.h>
#endif

#ifdef EMSCRIPTEN
#include "emscripten.h"
#endif

#define usecs(time)    ((uint64_t)(time.tv_sec - start_time.tv_sec) * 1000000 + time.     tv_usec)

#if !__COSMOPOLITAN__

#if CTX_PICO

#include "pico/stdlib.h"
#include "pico/time.h"
#include "hardware/timer.h"


#ifdef PICO_BUILD
#define usleep(us)   sleep_us(us)
#endif

static uint64_t pico_get_time(void) {
    // Reading low latches the high value
    uint32_t lo = timer_hw->timelr;
    uint32_t hi = timer_hw->timehr;
    return ((uint64_t) hi << 32u) | lo;
}
static uint64_t start_time;
#else
static struct timeval start_time;
#endif
static void
_ctx_init_ticks (void)
{
  static int done = 0;
  if (done)
    return;
  done = 1;
#if CTX_PICO
  start_time = pico_get_time();
#else
  gettimeofday (&start_time, NULL);
#endif
}

static inline unsigned long
_ctx_ticks (void)
{
#if CTX_PICO
  uint64_t measure_time =  pico_get_time();
  return measure_time - start_time;
#else
  struct timeval measure_time;
  gettimeofday (&measure_time, NULL);
  return usecs (measure_time) - usecs (start_time);
#endif
}

CTX_EXPORT unsigned long
ctx_ticks (void)
{
  _ctx_init_ticks ();
  return _ctx_ticks ();
}

int _ctx_max_threads = 1;
#if CTX_THREADS
static mtx_t _ctx_texture_mtx;
static mtx_t _ctx_events_mtx;
#endif


static inline void _ctx_events_lock (void)
{
#if CTX_THREADS
  mtx_lock (&_ctx_events_mtx);
#endif
}

static inline void _ctx_events_unlock (void)
{
#if CTX_THREADS
  mtx_unlock (&_ctx_events_mtx);
#endif
}

void _ctx_texture_lock (void)
{
#if CTX_THREADS
  mtx_lock (&_ctx_texture_mtx);
#endif
}

void _ctx_texture_unlock (void)
{
#if CTX_THREADS
  mtx_unlock (&_ctx_texture_mtx);
#endif
}

void
ctx_init (int *argc, char ***argv)
{
#if 0
  const char *backend = getenv ("CTX_BACKEND");
  if (!backend || ctx_strcmp (backend, "ctx"))
  {
    int i;
    char *new_argv[*argc+5];
    new_argv[0] = "ctx";
    new_argv[1] = "-e";
    new_argv[2] = "--";
    for (i = 0; i < *argc; i++)
    {
      new_argv[i+3] = *argv[i];
    }
    new_argv[i+3] = NULL;
    execvp (new_argv[0], new_argv);
  }
#endif
}

#if 0
int ctx_count (Ctx *ctx)
{
  return ctx->drawlist.count;
}
#endif

int _ctx_depth = 0;

#if CTX_EVENTS

void ctx_list_backends(void)
{
#if CTX_BAREMETAL==0
    fprintf (stderr, "possible values for CTX_BACKEND:\n");
    fprintf (stderr, " ctx");
#if CTX_SDL
    fprintf (stderr, " sdl ");
    fprintf (stderr, " sdl-cb ");
    fprintf (stderr, " sdl-fb ");
    fprintf (stderr, " sdl-fb-full ");
#endif
#if CTX_KMS
    fprintf (stderr, " kms");
#endif
#if CTX_FB
    fprintf (stderr, " fb");
#endif
#if CTX_TERM
    fprintf (stderr, " term");
#endif
#if CTX_NET
    fprintf (stderr, " tcp:ip:port ");
#endif
    fprintf (stderr, "\n");
#endif
}

uint32_t ctx_ms (Ctx *ctx)
{
  return _ctx_ticks () / 1000;
}


#if CTX_PTY
int ctx_fd_supports_ctx_protocol (int outfd, int infd)
{
  char buf[128];
#if CTX_PTY
  ctx_term_raw(infd);
#endif
#if CTX_RAW_KB_EVENTS
  ctx_drain_fd (infd);
#endif
  char req[]="\033[?200$p";
  write(outfd, req, sizeof(req)-1);
  fsync(outfd);
  int length = 0;
  struct timeval tv = {0,0};
  fd_set rfds;
  

  FD_ZERO(&rfds);
  FD_SET(infd, &rfds);
  tv.tv_sec = 1;
  int ys = 0;
  for (int n = 0; ys < 1 && select(infd+1, &rfds, NULL, NULL, &tv) &&
                  n < 100 
                  ; n++)
  {
    if (read (infd, &buf[length], 1) > 0)
    {
      if (buf[length] == 'y') ys++;
      length++;
    } 
    tv.tv_sec = 1;
    tv.tv_usec = 0;
    FD_ZERO(&rfds);
    FD_SET(infd, &rfds);
  }
#if CTX_PTY
  ctx_term_noraw(infd);
#endif

  buf[length]=0;
  char *semi = strchr (buf, ';');
  if (semi && semi[1]=='2') // has ctx and it is not active
    return 1;
  if (semi && semi[1]=='1') // has ctx and it is active
    return 1;
  return 0;
}

#define CTX_COMBINE_VERSION(major,minor,micro)  \
    ((major) * 10000 + (minor) * 1000 + (micro))

int ctx_fd_ctx_version (int outfd, int infd)
{
  char buf[128];
#if CTX_PTY
  ctx_term_raw(infd);
#endif
#if CTX_RAW_KB_EVENTS
  ctx_drain_fd (infd);
#endif
  char req[]="\033[>0q";
  write(outfd, req, sizeof(req)-1);
  fsync(outfd);
  int length = 0;
  struct timeval tv = {0,0};
  fd_set rfds;
  

  FD_ZERO(&rfds);
  FD_SET(infd, &rfds);
  tv.tv_sec = 1;
  int es = 0;
  int pe = 0;
  for (int n = 0; es <= 2 && pe < 1 && select(infd+1, &rfds, NULL, NULL, &tv) &&
                  n < 100 
                  ; n++)
  {
    if (read (infd, &buf[length], 1) > 0)
    {
      if (buf[length] == '\033') es++;
      if (es >= 2) pe++;
      length++;
    } 
    tv.tv_sec = 1;
    tv.tv_usec = 0;
    FD_ZERO(&rfds);
    FD_SET(infd, &rfds);
  }
#if CTX_PTY
  ctx_term_noraw(infd);
#endif


  buf[length]=0;
  if (strchr (buf + 4, '\e'))
    *strchr (buf + 4, '\e') = 0;
  
  if (strstr (buf, "ctx"))
  {
    int major = 0, minor = 0, micro = 0;
    char *p = strchr (buf, '(');
    if (p)
      major = atoi (p + 1);
    if (p) p = strchr (p + 1, '.');
    if (p) minor = atoi (p + 1);
    if (p) p = strchr (p + 1, '.');
    if (p) micro = atoi (p + 1);

    return CTX_COMBINE_VERSION(major,minor,micro);
  }
  //fprintf (stderr, "got terminal [%s]\n", buf+2+2);

  return ctx_fd_supports_ctx_protocol (outfd, infd);
}
#endif

#if CTX_FB
Ctx *ctx_new_fb_cb (int width, int height, int flags);
#endif
#if CTX_SDL
Ctx *ctx_new_sdl_cb (int width, int height, int flags);
Ctx *ctx_new_sdl_cb_fb (int width, int height, int flags);
Ctx *ctx_new_sdl_cb_fb_full (int width, int height, int flags);
#endif

#if EMSCRIPTEN
CTX_EXPORT
#endif
#if defined(PICO_BUILD) || CTX_ESP || EMSCRIPTEN
Ctx *ctx_host(void);
#endif

Ctx *ctx_new_ui (int width, int height, const char *backend)
{
  static Ctx *ret = NULL;
  if (ret)
  {
    _ctx_depth ++;
    return ret;
  }
#if defined(PICO_BUILD) || CTX_ESP || EMSCRIPTEN
  ret = ctx_host ();
#endif
  if (ret)
  {
    return ret;
  }

#if CTX_THREADS
  if (getenv ("CTX_THREADS"))
  {
    int val = atoi (getenv ("CTX_THREADS"));
    _ctx_max_threads = val;
  }
  else
  {
    _ctx_max_threads = 1;
#if 1
#ifdef _SC_NPROCESSORS_ONLN
    _ctx_max_threads = sysconf (_SC_NPROCESSORS_ONLN) / 2;
#endif
#endif
  }
  
  mtx_init (&_ctx_texture_mtx, mtx_plain);
  mtx_init (&_ctx_events_mtx, mtx_plain);

  if (_ctx_max_threads < 1) _ctx_max_threads = 1;
  if (_ctx_max_threads > CTX_MAX_THREADS) _ctx_max_threads = CTX_MAX_THREADS;
#endif

#if CTX_BAREMETAL==0
  //fprintf (stderr, "ctx using %i threads\n", _ctx_max_threads);
  if (!backend)
    backend = getenv ("CTX_BACKEND");
#endif

  if (backend && !ctx_strcmp (backend, ""))
    backend = NULL;
  if (backend && !ctx_strcmp (backend, "auto"))
    backend = NULL;
  if (backend && !ctx_strcmp (backend, "list"))
  {
    ctx_list_backends ();
    exit (-1);
  }

  int flags = CTX_FLAG_SYNC | CTX_FLAG_COMPRESS;
  if (getenv ("CTX_POINTER"))
  {
    if (atoi(getenv("CTX_POINTER")))
      flags |= CTX_FLAG_POINTER;
    else
      flags &= ~CTX_FLAG_POINTER;
  }
  if (getenv ("CTX_SHOW_FPS"))
  {
    if (atoi(getenv("CTX_SHOW_FPS")))
      flags |= CTX_FLAG_SHOW_FPS;
    else
      flags &= ~CTX_FLAG_SHOW_FPS;
  }
  if (getenv ("CTX_DAMAGE_CONTROL"))
  {
    if (atoi(getenv("CTX_DAMAGE_CONTROL")))
      flags |= CTX_FLAG_DAMAGE_CONTROL;
    else
      flags &= ~CTX_FLAG_DAMAGE_CONTROL;
  }

  if (flags){}

#if CTX_FORMATTER

  if (getenv ("CTX_SYNC"))
  {
    if (atoi(getenv("CTX_SYNC")))
      flags |= CTX_FLAG_SYNC;
    else
      flags &= ~CTX_FLAG_SYNC;
  }

  if (getenv ("CTX_COMPRESS"))
  {
    if (atoi(getenv("CTX_COMPRESS")))
      flags |= CTX_FLAG_COMPRESS;
    else
      flags &= ~CTX_FLAG_COMPRESS;
  }

  /* we do the query on auto but not on directly set ctx
   *
   */
   #if CTX_NET
  if (!ret && (backend && !strncmp(backend, "tcp", 3)))
  {
    char *dup = strdup (backend);
    int port = 6150;
    const char *ip = "127.0.0.1";
    if (strchr(dup, ':') != strrchr (dup, ':'))
      {
        port = atoi(strrchr (dup, ':')+1);
        *strrchr (dup, ':') = 0;
      }
    if (strchr(dup, ':'))
      ip = strchr (dup, ':') + 1;
    ret = ctx_new_net (width, height, flags, ip, port);
    free (dup);
  }
  #endif

#if CTX_NET && CTX_PTY && CTX_FORMATTER && CTX_EVENTS

  int ctx_ver = 0;

  if (!ret && ((backend && !ctx_strcmp(backend, "ctx")) ||
      (backend == NULL && 
       (ctx_ver=ctx_fd_ctx_version (STDOUT_FILENO, STDIN_FILENO)))))
  {
    if (!backend || !ctx_strcmp (backend, "ctx"))
    {
      // full blown stdio ctx protocol - in terminal or standalone

      if (ctx_ver < CTX_COMBINE_VERSION(0,1,3))
      {  // disable compression for older version
        flags &= ~CTX_FLAG_COMPRESS;
      }

      ret = ctx_new_ctx (width, height, flags);
    }
  }

  if (!ret && ((backend && backend[0] == '/')))
  {
    int in_fd = open (backend, O_RDWR);
    int out_fd = in_fd;//open (backend, 0, O_WRONLY);
    if (in_fd > 0)
    {
       ctx_drain_fd (in_fd);
       //if (ctx_fd_supports_ctx (in_fd, out_fd))
       ret = ctx_new_fds (width, height, in_fd, out_fd, flags);
    }

  }
#endif

#endif

#if CTX_SDL
  if (!ret && getenv ("DISPLAY"))
  {
    if ((backend==NULL) || (!ctx_strcmp (backend, "sdl-fb"))
                        || (!ctx_strcmp (backend, "sdl")))
      ret = ctx_new_sdl_cb_fb (width, height, flags);
  }

  if (!ret && getenv ("DISPLAY"))
  {
    if ((backend==NULL) || (!ctx_strcmp (backend, "sdl-cb")))
      ret = ctx_new_sdl_cb (width, height, flags);
  }

  if (!ret && getenv ("DISPLAY"))
  {
    if ((backend==NULL) || (!ctx_strcmp (backend, "sdl-fb-full")))
      ret = ctx_new_sdl_cb_fb_full (width, height, flags);
  }

#endif

#if CTX_FB
  if (!ret && !getenv ("DISPLAY"))
    {
      if ((backend==NULL) ||
          (!ctx_strcmp (backend, "fb") ||
          (!ctx_strcmp (backend, "kms"))))
        ret = ctx_new_fb_cb (width, height, flags);
    }
#endif

#if CTX_TERMINAL_EVENTS
#if CTX_RASTERIZER
  // braille in terminal
#if CTX_TERM
  if (!ret)
  {
    if ((backend==NULL) || (!ctx_strcmp (backend, "term")))
    ret = ctx_new_term (width, height);
  }
#endif
#endif
#endif
  if (!ret)
  {
#if CTX_BAREMETAL==0
    fprintf (stderr, "no interactive ctx backend\n");
#endif
    ctx_list_backends ();
    exit (2);
  }
  ctx_get_event (ret); // enables events
  return ret;
}
#endif
#else
static void _ctx_texture_unlock (void)
{
}
static void _ctx_texture_lock (void)
{
}

#endif
#if CTX_EVENTS
void _ctx_resized (Ctx *ctx, int width, int height, long time);
static int _ctx_delayed_resize(Ctx *ctx, void *d)
{
  _ctx_resized (ctx, ctx->width, ctx->height, 0);
  return 0;
}
#endif

void ctx_set_size (Ctx *ctx, int width, int height)
{
  if (ctx->width != width || ctx->height != height)
  {
    ctx->width = width;
    ctx->height = height;
    switch (ctx_backend_type (ctx))
    {
      case CTX_BACKEND_CTX:
      case CTX_BACKEND_TERM:
        {CtxCtx *ctxctx = (CtxCtx*)ctx->backend;
         ctxctx->width = width;
         ctxctx->height = height;
        }
        break;
      default: break;
    }
#if CTX_EVENTS
    ctx_add_idle (ctx, _ctx_delayed_resize, ctx);
#endif
  }
}

#if CTX_EVENTS


void _ctx_events_init (Ctx *ctx)
{
  CtxEvents *events = &ctx->events;
  _ctx_init_ticks ();
  events->tap_delay_min  = 40;
  events->tap_delay_max  = 800;
  events->tap_delay_max  = 8000000; /* quick reflexes needed making it hard for some is an argument against very short values  */

  events->tap_delay_hold = 1000;
  events->tap_hysteresis = 34;  /* XXX: should be ppi dependent */
  //events->tap_hysteresis = 64;  /* XXX: should be ppi dependent */
}

void _ctx_toggle_in_idle_dispatch (Ctx *ctx)
{
  ctx->events.in_idle_dispatch= !ctx->events.in_idle_dispatch;
  ctx_reset_has_exited (ctx);
}


void _ctx_idle_iteration (Ctx *ctx)
{
  static unsigned long prev_ticks = 0;
  CtxList *l;
  unsigned long ticks = ctx_ticks ();
  long tick_delta = (prev_ticks == 0) ? 0 : ticks - prev_ticks;
  prev_ticks = ticks;


  _ctx_events_lock ();
  if (!ctx->events.idles && !ctx->events.idles_to_add)
  {
#ifndef __EMSCRIPTEN_PTHREADS__
#ifdef EMSCRIPTEN
    emscripten_sleep (10);
#endif
#endif
    _ctx_events_unlock ();
    return;
  }

  ctx->events.in_idle_dispatch=1;

  CtxList *idles_to_remove = ctx->events.idles_to_remove;
  ctx->events.idles_to_remove = NULL;
  CtxList *idles = ctx->events.idles;
  ctx->events.idles = NULL;

  for (l = idles; l; l = l->next)
  {
    CtxIdleCb *item = (CtxIdleCb*)l->data;

    long rem = item->ticks_remaining;
    if (item->ticks_remaining >= 0)
    {
      rem -= tick_delta;

      item->ticks_remaining -= tick_delta / 100;

    if (rem < 0)
    {
      int to_be_removed = 0;
      for (CtxList *l2 = idles_to_remove; l2; l2=l2->next)
      {
        CtxIdleCb *item2 = (CtxIdleCb*)l2->data;
        if (item2 == item) to_be_removed = 1;
      }
      
      if (!to_be_removed)
      {
      if (item->cb (ctx, item->idle_data) == 0)
      {
        ctx_list_prepend (&idles_to_remove, item);
      }
      else
        item->ticks_remaining = item->ticks_full;
      }
    }
    else
        item->ticks_remaining = rem;
    }
    else
    {
      int to_be_removed = 0;
      for (CtxList *l2 = idles_to_remove; l2; l2=l2->next)
      {
        CtxIdleCb *item2 = (CtxIdleCb*)l2->data;
        if (item2 == item) to_be_removed = 1;
      }
      
      if (!to_be_removed)
      {
        if (item->cb (ctx, item->idle_data) == 0)
        {
          ctx_list_prepend (&idles_to_remove, item);
        }
        else
          item->ticks_remaining = item->ticks_full;
      }
    }
  }

  while (ctx->events.idles_to_add)
  {
    CtxIdleCb *item = (CtxIdleCb*)ctx->events.idles_to_add->data;
    ctx_list_prepend (&idles, item);
    ctx_list_remove (&ctx->events.idles_to_add, item);
  }

  while (idles_to_remove)
  {
    CtxIdleCb *item = (CtxIdleCb*)idles_to_remove->data;
    ctx_list_remove (&idles, item);
    ctx_list_remove (&idles_to_remove, item);
    if (item->destroy_notify)
      item->destroy_notify (item->destroy_data);
  }
  ctx->events.idles = idles;
  ctx->events.in_idle_dispatch=0;
  _ctx_events_unlock ();
#ifndef __EMSCRIPTEN_PTHREADS__
#if EMSCRIPTEN
//#ifdef ASYNCIFY
   emscripten_sleep(1);
//#endif
#endif
#endif
}


void ctx_add_key_binding_full (Ctx *ctx,
                           const char *key,
                           const char *action,
                           const char *label,
                           CtxCb       cb,
                           void       *cb_data,
                           CtxDestroyNotify destroy_notify,
                           void       *destroy_data)
{
  CtxEvents *events = &ctx->events;
  if (events->n_bindings +1 >= CTX_MAX_KEYBINDINGS)
  {
#if CTX_BAREMETAL==0
    fprintf (stderr, "warning: binding overflow\n");
#endif
    return;
  }
  events->bindings[events->n_bindings].nick = ctx_strdup (key);
  strcpy (events->bindings[events->n_bindings].nick, key);

  if (action)
    events->bindings[events->n_bindings].command = action ? ctx_strdup (action) : NULL;
  if (label)
    events->bindings[events->n_bindings].label = label ? ctx_strdup (label) : NULL;
  events->bindings[events->n_bindings].cb = cb;
  events->bindings[events->n_bindings].cb_data = cb_data;
  events->bindings[events->n_bindings].destroy_notify = destroy_notify;
  events->bindings[events->n_bindings].destroy_data = destroy_data;
  events->n_bindings++;
}

void ctx_add_key_binding (Ctx *ctx,
                          const char *key,
                          const char *action,
                          const char *label,
                          CtxCb       cb,
                          void       *cb_data)
{
  ctx_add_key_binding_full (ctx, key, action, label, cb, cb_data, NULL, NULL);
}

void ctx_clear_bindings (Ctx *ctx)
{
  CtxEvents *events = &ctx->events;
  int i;
  for (i = 0; events->bindings[i].nick; i ++)
  {
    if (events->bindings[i].destroy_notify)
      events->bindings[i].destroy_notify (events->bindings[i].destroy_data);
    ctx_free (events->bindings[i].nick);
    if (events->bindings[i].command)
      ctx_free (events->bindings[i].command);
    if (events->bindings[i].label)
      ctx_free (events->bindings[i].label);
  }
  memset (&events->bindings, 0, sizeof (events->bindings));
  events->n_bindings = 0;
}

void
ctx_collect_events (CtxEvent *event, void *data, void *data2);


void _ctx_bindings_key_press (CtxEvent *event, void *data1, void *data2)
{
  Ctx *ctx = event->ctx;
  CtxEvents *events = &ctx->events;
  int i;
  int handled = 0;

  for (i = events->n_bindings-1; i>=0; i--)
    if (!ctx_strcmp (events->bindings[i].nick, event->string))
    {
      if (events->bindings[i].cb)
      {
        events->bindings[i].cb (event, events->bindings[i].cb_data, events->bindings[i].command);
        if (event->stop_propagate)
          return;
        handled = 1;
      }
    }
  if (!handled)
  for (i = events->n_bindings-1; i>=0; i--)
    if (!ctx_strcmp (events->bindings[i].nick, "any"))
    {
      if (events->bindings[i].cb)
      {
        events->bindings[i].cb (event, events->bindings[i].cb_data, NULL);
        if (event->stop_propagate)
          return;
      }
    }
  ctx_collect_events (event, data1, data2);
}

CtxBinding *ctx_get_bindings (Ctx *ctx)
{
  return &ctx->events.bindings[0];
}

void ctx_remove_idle (Ctx *ctx, int handle)
{
  CtxList *l;
  //CtxList *to_remove = NULL;

  _ctx_events_lock ();
  if (!ctx->events.idles)
  {
    _ctx_events_unlock ();
    return;
  }

  for (l = ctx->events.idles; l; l = l->next)
  {
    CtxIdleCb *item = (CtxIdleCb*)l->data;
    if (item->id == handle)
    {
      ctx_list_prepend (&ctx->events.idles_to_remove, item);
    }
  }

  if (ctx->events.in_idle_dispatch)
  {
    _ctx_events_unlock ();
    return;
  }

  while (ctx->events.idles_to_remove)
  {
    CtxIdleCb *item = ctx->events.idles_to_remove->data;
    ctx_list_remove (&ctx->events.idles, item);
    ctx_list_remove (&ctx->events.idles_to_remove, item);
    if (item->destroy_notify)
      item->destroy_notify (item->destroy_data);
    ctx_free (item);
  }
  _ctx_events_unlock ();
}

int ctx_add_timeout_full (Ctx *ctx, int ms, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data,
                          void (*destroy_notify)(void *destroy_data), void *destroy_data)
{
  CtxIdleCb *item = (CtxIdleCb*)ctx_calloc (1, sizeof (CtxIdleCb));
  item->cb              = idle_cb;
  item->idle_data       = idle_data;
  item->id              = ++ctx->events.idle_id;
  item->ticks_full      = 
  item->ticks_remaining = ms * 1000;
  item->destroy_notify  = destroy_notify;
  item->destroy_data    = destroy_data;
  _ctx_events_lock ();
  if (ctx->events.in_idle_dispatch)
  ctx_list_append (&ctx->events.idles_to_add, item);
  else
  ctx_list_append (&ctx->events.idles, item);
  _ctx_events_unlock ();
  return item->id;
}

int ctx_add_timeout (Ctx *ctx, int ms, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data)
{
  return ctx_add_timeout_full (ctx, ms, idle_cb, idle_data, NULL, NULL);
}

int ctx_add_idle_full (Ctx *ctx, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data,
                                 void (*destroy_notify)(void *destroy_data), void *destroy_data)
{
  CtxIdleCb *item = (CtxIdleCb*)ctx_calloc (1, sizeof (CtxIdleCb));
  item->cb = idle_cb;
  item->idle_data = idle_data;
  item->ticks_full =
  item->ticks_remaining = -1;
  item->is_idle = 1;
  item->destroy_notify = destroy_notify;
  item->destroy_data = destroy_data;
  _ctx_events_lock ();
  item->id = ++ctx->events.idle_id;
  ctx_list_append (&ctx->events.idles, item);
  _ctx_events_unlock ();
  return item->id;
}

int ctx_add_idle (Ctx *ctx, int (*idle_cb)(Ctx *ctx, void *idle_data), void *idle_data)
{
  return ctx_add_idle_full (ctx, idle_cb, idle_data, NULL, NULL);
}

#endif
/* using bigger primes would be a good idea, this falls apart due to rounding
 * when zoomed in close
 */
static inline double ctx_path_hash (void *path)
{
  double ret = 0;
#if 0
  int i;
  cairo_path_data_t *data;
  if (!path)
    return 0.99999;
  for (i = 0; i <path->num_data; i += path->data[i].header.length)
  {
    data = &path->data[i];
    switch (data->header.type) {
      case CAIRO_PATH_MOVE_TO:
        ret *= 17;
        ret += data[1].point.x;
        ret *= 113;
        ret += data[1].point.y;
        break;
      case CAIRO_PATH_LINE_TO:
        ret *= 121;
        ret += data[1].point.x;
        ret *= 1021;
        ret += data[1].point.y;
        break;
      case CAIRO_PATH_CURVE_TO:
        ret *= 3111;
        ret += data[1].point.x;
        ret *= 23;
        ret += data[1].point.y;
        ret *= 107;
        ret += data[2].point.x;
        ret *= 739;
        ret += data[2].point.y;
        ret *= 3;
        ret += data[3].point.x;
        ret *= 51;
        ret += data[3].point.y;
        break;
      case CAIRO_PATH_CLOSE_PATH:
        ret *= 51;
        break;
    }
  }
#endif
  return ret;
}

#if CTX_EVENTS
void _ctx_item_ref (CtxItem *item)
{
  if (item->ref_count < 0)
  {
#if CTX_BAREMETAL==0
    fprintf (stderr, "EEEEK!\n");
#endif
  }
  item->ref_count++;
}


void _ctx_item_unref (CtxItem *item)
{
  if (item->ref_count <= 0)
  {
#if CTX_BAREMETAL==0
    fprintf (stderr, "EEEEK!\n");
#endif
    return;
  }
  item->ref_count--;
  if (item->ref_count <=0)
  {
    {
      int i;
      for (i = 0; i < item->cb_count; i++)
      {
        if (item->cb[i].finalize)
          item->cb[i].finalize (item->cb[i].data1, item->cb[i].data2,
                                   item->cb[i].finalize_data);
      }
    }
    if (item->path)
    {
      ctx_free (item->path);
      item->path = NULL;
    }
    ctx_free (item);
  }
}


void _ctx_item_unref2 (void *data, void *data2)
{
  CtxItem *item = (CtxItem*)data;
  _ctx_item_unref (item);
}

#if 0
static int
path_equal (void *path,
            void *path2)
{
        return 0;
  CtxDrawlist *a = (CtxDrawlist*)path;
  CtxDrawlist *b = (CtxDrawlist*)path2;
  if (!a && !b) return 1;
  if (!a && b) return 0;
  if (!b && a) return 0;
  if (a->count != b->count)
    return 0;
  return memcmp (a->entries, b->entries, a->count * 9) == 0;
}
#endif

void ctx_listen_set_cursor (Ctx      *ctx,
                            CtxCursor cursor)
{
  if (ctx->events.last_item)
  {
    ctx->events.last_item->cursor = cursor;
  }
}

void ctx_listen_full (Ctx     *ctx,
                      float    x,
                      float    y,
                      float    width,
                      float    height,
                      CtxEventType  types,
                      CtxCb    cb,
                      void    *data1,
                      void    *data2,
                      void   (*finalize)(void *listen_data,
                                         void *listen_data2,
                                         void *finalize_data),
                      void    *finalize_data)
{
  if (!ctx->events.frozen)
  {
    CtxItem *item;

    /* early bail for listeners outside screen  */
    /* XXX: fixme respect clipping */
    {
      float tx = x;
      float ty = y;
      float tw = width;
      float th = height;
      _ctx_user_to_device (&ctx->state, &tx, &ty);
      _ctx_user_to_device_distance (&ctx->state, &tw, &th);
      if (ty > ctx->height * 2 ||
          tx > ctx->width * 2 ||
          tx + tw < 0 ||
          ty + th < 0)
      {
        if (finalize)
          finalize (data1, data2, finalize_data);
        return;
      }
    }

    item = ctx_calloc (1, sizeof (CtxItem));
    item->x0 = x;
    item->y0 = y;
    item->x1 = x + width;
    item->y1 = y + height;
    item->cb[0].types = types;
    item->cb[0].cb = cb;
    item->cb[0].data1 = data1;
    item->cb[0].data2 = data2;
    item->cb[0].finalize = finalize;
    item->cb[0].finalize_data = finalize_data;
    item->cb_count = 1;
    item->types = types;
#if CTX_CURRENT_PATH
    item->path = ctx_current_path (ctx);
    item->path_hash = ctx_path_hash (item->path);
#else
    item->path = NULL;
    item->path_hash = 0;
#endif
    ctx_get_matrix (ctx, &item->inv_matrix);
    ctx_matrix_invert (&item->inv_matrix);

#if 0
    if (ctx->events.items)
    {
      CtxList *l;
      for (l = ctx->events.items; l; l = l->next)
      {
        CtxItem *item2 = l->data;

        /* store multiple callbacks for one entry when the paths
         * are exact matches, reducing per event traversal checks at the
         * cost of a little paint-hit (XXX: is this the right tradeoff,
         * perhaps it is better to spend more time during event processing
         * than during paint?)
         */
        if (item->path_hash == item2->path_hash &&
            path_equal (item->path, item2->path))
        {
          /* found an item, copy over cb data  */
          item2->cb[item2->cb_count] = item->cb[0];
          ctx_free (item);
          item2->cb_count++;
          item2->types |= types;
          return;
        }
      }
    }
#endif
    item->ref_count       = 1;
    ctx->events.last_item = item;
    ctx_list_prepend_full (&ctx->events.items, item, _ctx_item_unref2, NULL);
      return;
  }
}

void ctx_event_stop_propagate (CtxEvent *event)
{
  if (event)
    event->stop_propagate = 1;
}

void ctx_listen (Ctx          *ctx,
                 CtxEventType  types,
                 CtxCb         cb,
                 void*         data1,
                 void*         data2)
{
  float x, y, width, height;
  /* generate bounding box of what to listen for - from current cairo path */
  if (types & CTX_KEY)
  {
    x = 0;
    y = 0;
    width = 0;
    height = 0;
  }
  else
  {
     float ex1,ey1,ex2,ey2;
     ctx_path_extents (ctx, &ex1, &ey1, &ex2, &ey2);
     x = ex1;
     y = ey1;
     width = ex2 - ex1;
     height = ey2 - ey1;
  }

  if (types == CTX_DRAG_MOTION)
    types = (CtxEventType)(CTX_DRAG_MOTION | CTX_DRAG_PRESS);
  ctx_listen_full (ctx, x, y, width, height, types, cb, data1, data2, NULL, NULL);
}

void  ctx_listen_with_finalize (Ctx          *ctx,
                                CtxEventType  types,
                                CtxCb         cb,
                                void*         data1,
                                void*         data2,
                      void   (*finalize)(void *listen_data, void *listen_data2,
                                         void *finalize_data),
                      void    *finalize_data)
{
  float x, y, width, height;
  /* generate bounding box of what to listen for - from current cairo path */
  if (types & CTX_KEY)
  {
    x = 0;
    y = 0;
    width = 0;
    height = 0;
  }
  else
  {
     float ex1,ey1,ex2,ey2;
     ctx_path_extents (ctx, &ex1, &ey1, &ex2, &ey2);
     x = ex1;
     y = ey1;
     width = ex2 - ex1;
     height = ey2 - ey1;
  }

  if (types == CTX_DRAG_MOTION)
    types = (CtxEventType)(CTX_DRAG_MOTION | CTX_DRAG_PRESS);
  ctx_listen_full (ctx, x, y, width, height, types, cb, data1, data2, finalize, finalize_data);
}


static void ctx_report_hit_region (CtxEvent *event,
                       void     *data,
                       void     *data2)
{
#if CTX_BAREMETAL==0
  const char *id = (char*)data;

  fprintf (stderr, "hit region %s\n", id);
#endif
  // XXX: NYI
}

void ctx_add_hit_region (Ctx *ctx, const char *id)
{
  char *id_copy = ctx_strdup (id);
  float x, y, width, height;
  /* generate bounding box of what to listen for - from current cairo path */
  {
     float ex1,ey1,ex2,ey2;
     ctx_path_extents (ctx, &ex1, &ey1, &ex2, &ey2);
     x = ex1;
     y = ey1;
     width = ex2 - ex1;
     height = ey2 - ey1;
  }
  
  ctx_listen_full (ctx, x, y, width, height,
                   CTX_POINTER, ctx_report_hit_region,
                   id_copy, NULL, (void*)ctx_free, NULL);
}

typedef struct _CtxGrab CtxGrab;

struct _CtxGrab
{
  CtxItem *item;
  int      device_no;
  int      timeout_id;
  int      start_time;
  float    x; // for tap and hold
  float    y;
  CtxEventType  type;
};

static void grab_free (Ctx *ctx, CtxGrab *grab)
{
  if (grab->timeout_id)
  {
    ctx_remove_idle (ctx, grab->timeout_id);
    grab->timeout_id = 0;
  }
  _ctx_item_unref (grab->item);
  ctx_free (grab);
}

static void device_remove_grab (Ctx *ctx, CtxGrab *grab)
{
  ctx_list_remove (&ctx->events.grabs, grab);
  grab_free (ctx, grab);
}

static CtxGrab *device_add_grab (Ctx *ctx, int device_no, CtxItem *item, CtxEventType type)
{
  CtxGrab *grab = ctx_calloc (1, sizeof (CtxGrab));
  grab->item = item;
  grab->type = type;
  _ctx_item_ref (item);
  grab->device_no = device_no;
  ctx_list_append (&ctx->events.grabs, grab);
  return grab;
}

static CtxList *_ctx_device_get_grabs (Ctx *ctx, int device_no)
{
  CtxList *ret = NULL;
  CtxList *l;
  for (l = ctx->events.grabs; l; l = l->next)
  {
    CtxGrab *grab = l->data;
    if (grab->device_no == device_no)
      ctx_list_append (&ret, grab);
  }
  return ret;
}

static void _mrg_restore_path (Ctx *ctx, void *path)  //XXX
{
  CtxDrawlist *dl = (CtxDrawlist*)path;
  if (!dl) return;

  ctx_append_drawlist (ctx, dl->entries, dl->count*9);
}

CtxList *_ctx_detect_list (Ctx *ctx, float x, float y, CtxEventType type)
{
  CtxList *a;
  CtxList *ret = NULL;

  if (type == CTX_KEY_DOWN ||
      type == CTX_KEY_UP ||
      type == CTX_KEY_PRESS ||
      type == CTX_MESSAGE ||
      type == (CTX_KEY_DOWN|CTX_MESSAGE) ||
      type == (CTX_KEY_DOWN|CTX_KEY_UP) ||
      type == (CTX_KEY_DOWN|CTX_KEY_UP|CTX_MESSAGE))
  {
    for (a = ctx->events.items; a; a = a->next)
    {
      CtxItem *item = a->data;
      if (item->types & type)
      {
        ctx_list_prepend (&ret, item);
      }
    }
        return ret;
    return NULL;
  }

  for (a = ctx->events.items; a; a = a->next)
  {
    CtxItem *item= a->data;
  
    float u, v;
    u = x;
    v = y;
    _ctx_matrix_apply_transform (&item->inv_matrix, &u, &v);

    if (u >= item->x0 && v >= item->y0 &&
        u <  item->x1 && v <  item->y1 && 
        ((item->types & type) || ((type == CTX_SET_CURSOR) &&
        item->cursor)))
    {
      if (item->path)
      {
        // XXX  - is this done on wrongly transformed coordinates?
        if (ctx_in_fill_path (ctx, u, v, item->path))
        {
          ctx_list_prepend (&ret, item);
        }
      }
      else
      {
        ctx_list_prepend (&ret, item);
      }
    }
  }
  return ret;
}

CtxItem *_ctx_detect (Ctx *ctx, float x, float y, CtxEventType type)
{
  CtxList *l = _ctx_detect_list (ctx, x, y, type);
  if (l)
  {
    ctx_list_reverse (&l);
    CtxItem *ret = l->data;
    ctx_list_free (&l);
    return ret;
  }
  return NULL;
}

static CtxEvent event_copy;

static int
_ctx_emit_cb_item (Ctx *ctx, CtxItem *item, CtxEvent *event, CtxEventType type, float x, float y)
{
  CtxEvent transformed_event;
  int i;

  ctx->events.event_depth++;

  if (!event)
  {
    event = &event_copy;
    event->type = type;
    event->x = x;
    event->y = y;
  }
  event->ctx = ctx;
  transformed_event = *event;
  transformed_event.device_x = event->x;
  transformed_event.device_y = event->y;

  {
    float tx, ty;
    tx = transformed_event.x;
    ty = transformed_event.y;
    _ctx_matrix_apply_transform (&item->inv_matrix, &tx, &ty);
    transformed_event.x = tx;
    transformed_event.y = ty;

    if ((type & CTX_DRAG_PRESS) ||
        (type & CTX_DRAG_MOTION) ||
        (type & CTX_MOTION))   /* probably a worthwhile check for the performance 
                                  benefit
                                */
    {
      tx = transformed_event.start_x;
      ty = transformed_event.start_y;
      _ctx_matrix_apply_transform (&item->inv_matrix, &tx, &ty);
      transformed_event.start_x = tx;
      transformed_event.start_y = ty;
    }


    tx = transformed_event.delta_x;
    ty = transformed_event.delta_y;
    _ctx_matrix_apply_transform (&item->inv_matrix, &tx, &ty);
    transformed_event.delta_x = tx;
    transformed_event.delta_y = ty;
  }

  transformed_event.state = ctx->events.modifier_state;
  transformed_event.type = type;

  for (i = item->cb_count-1; i >= 0; i--)
  {
    if (item->cb[i].types & type)
    {
      item->cb[i].cb (&transformed_event, item->cb[i].data1, item->cb[i].data2);
      event->stop_propagate = transformed_event.stop_propagate; /* copy back the response */
      if (event->stop_propagate)
      {
        ctx->events.event_depth--;
        return event->stop_propagate;
      }
    }
  }
  ctx->events.event_depth--;
  return 0;
}
#endif

#if CTX_EVENTS

//#include <stdatomic.h>

void ctx_consume_events (Ctx *ctx)
{
  CtxBackend *backend = ctx->backend;
  if (backend && backend->consume_events)
    backend->consume_events (ctx);
}


void ctx_get_event_fds (Ctx *ctx, int *fd, int *count)
{
  CtxBackend *backend = ctx->backend;
  if (backend && backend->get_event_fds)
    backend->get_event_fds (ctx, fd, count);
  *count = 0;
}


static CtxEvent *ctx_get_event_full (Ctx *ctx, int internal)
{
  if (ctx->events.events)
    {
      event_copy = *((CtxEvent*)(ctx->events.events->data));
      // XXX : there is leakage of a string here..
      //  we could reduce it to a non-growing leak.. by making a copy
      //  and letting normal free occur..
      ctx_list_remove (&ctx->events.events, ctx->events.events->data);
      return &event_copy;
    }

  _ctx_idle_iteration (ctx);
#if 1
  if (!internal & (ctx->events.ctx_get_event_enabled==0))
  {
    ctx->events.ctx_get_event_enabled = 1;
    ctx_queue_draw (ctx);
  }
#endif

  ctx_consume_events (ctx);

  if (ctx->events.events)
    {
      event_copy = *((CtxEvent*)(ctx->events.events->data));
      ctx_list_remove (&ctx->events.events, ctx->events.events->data);
      return &event_copy;
    }
  return NULL;
}

CtxEvent *ctx_get_event (Ctx *ctx)
{
  return ctx_get_event_full (ctx, 0);
}

static int
_ctx_emit_cb (Ctx *ctx, CtxList *items, CtxEvent *event, CtxEventType type, float x, float y)
{
  CtxList *l;
  event->stop_propagate = 0;
  for (l = items; l; l = l->next)
  {
    _ctx_emit_cb_item (ctx, l->data, event, type, x, y);
    if (event->stop_propagate)
      return event->stop_propagate;
  }
  return 0;
}

/*
 * update what is the currently hovered item and returns it.. and the list of hits
 * a well.
 *
 */
static CtxItem *_ctx_update_item (Ctx *ctx, int device_no, float x, float y, CtxEventType type, CtxList **hitlist)
{
  CtxItem *current = NULL;

  CtxList *l = _ctx_detect_list (ctx, x, y, type);
  if (l)
  {
    ctx_list_reverse (&l);
    current = l->data;
  }
  if (hitlist)
    *hitlist = l;
  else
    ctx_list_free (&l);

  if (ctx->events.prev[device_no] == NULL || current == NULL || (current->path_hash != ctx->events.prev[device_no]->path_hash))
  {
// enter/leave should snapshot chain to root
// and compare with previous snapshotted chain to root
// and emit/enter/leave as appropriate..
//
// leave might be registered for emission on enter..emission?


    //int focus_radius = 2;
    if (current)
      _ctx_item_ref (current);

    if (ctx->events.prev[device_no])
    {
      {
#if 0
        CtxIntRectangle rect = {floor(ctx->events.prev[device_no]->x0-focus_radius),
                             floor(ctx->events.prev[device_no]->y0-focus_radius),
                             ceil(ctx->events.prev[device_no]->x1)-floor(ctx->events.prev[device_no]->x0) + focus_radius * 2,
                             ceil(ctx->events.prev[device_no]->y1)-floor(ctx->events.prev[device_no]->y0) + focus_radius * 2};
        mrg_queue_draw (mrg, &rect);
#endif 
      }

      _ctx_emit_cb_item (ctx, ctx->events.prev[device_no], NULL, CTX_LEAVE, x, y);
      _ctx_item_unref (ctx->events.prev[device_no]);
      ctx->events.prev[device_no] = NULL;
    }
    if (current)
    {
#if 0
      {
        CtxIntRectangle rect = {floor(current->x0-focus_radius),
                             floor(current->y0-focus_radius),
                             ceil(current->x1)-floor(current->x0) + focus_radius * 2,
                             ceil(current->y1)-floor(current->y0) + focus_radius * 2};
        mrg_queue_draw (mrg, &rect);
      }
#endif
      _ctx_emit_cb_item (ctx, current, NULL, CTX_ENTER, x, y);
      ctx->events.prev[device_no] = current;
    }
  }
  current = _ctx_detect (ctx, x, y, type);
  //fprintf (stderr, "%p\n", current);
  return current;
}

static int tap_and_hold_fire (Ctx *ctx, void *data)
{
  CtxGrab *grab = data;
  CtxList *list = NULL;
  ctx_list_prepend (&list, grab->item);
  CtxEvent event = {0, };

  event.ctx = ctx;
  event.time = ctx_ms (ctx);

  event.device_x = 
  event.x = ctx->events.pointer_x[grab->device_no];
  event.device_y = 
  event.y = ctx->events.pointer_y[grab->device_no];

  // XXX: x and y coordinates
  int ret = _ctx_emit_cb (ctx, list, &event, CTX_TAP_AND_HOLD,
      ctx->events.pointer_x[grab->device_no], ctx->events.pointer_y[grab->device_no]);

  ctx_list_free (&list);

  grab->timeout_id = 0;

  return 0;

  return ret;
}

CTX_EXPORT int
ctx_pointer_drop (Ctx *ctx, float x, float y, int device_no, uint32_t time,
                  char *string)
{
  CtxList *l;
  CtxList *hitlist = NULL;

  ctx->events.pointer_x[device_no] = x;
  ctx->events.pointer_y[device_no] = y;
  if (device_no <= 3)
  {
    ctx->events.pointer_x[0] = x;
    ctx->events.pointer_y[0] = y;
  }

  if (device_no < 0) device_no = 0;
  if (device_no >= CTX_MAX_DEVICES) device_no = CTX_MAX_DEVICES-1;
  CtxEvent *event = &ctx->events.drag_event[device_no];

  if (time == 0)
    time = ctx_ms (ctx);

  event->ctx = ctx;
  event->x = x;
  event->y = y;

  event->delta_x = event->delta_y = 0;

  event->device_no = device_no;
  event->string    = string;
  event->time      = time;
  event->stop_propagate = 0;

  _ctx_update_item (ctx, device_no, x, y, CTX_DROP, &hitlist);

  for (l = hitlist; l; l = l?l->next:NULL)
  {
    CtxItem *item = l->data;
    _ctx_emit_cb_item (ctx, item, event, CTX_DROP, x, y);

    if (event->stop_propagate)
    {
      ctx_list_free (&hitlist);
      return 0;
    }
  }

  //mrg_queue_draw (mrg, NULL); /* in case of style change, and more  */
  ctx_list_free (&hitlist);

  return 0;
}

CTX_EXPORT int
ctx_pointer_press (Ctx *ctx, float x, float y, int device_no, uint32_t time)
{
  CtxEvents *events = &ctx->events;
  CtxList *hitlist = NULL;
  events->pointer_x[device_no] = x;
  events->pointer_y[device_no] = y;
  if (device_no <= 3)
  {
    events->pointer_x[0] = x;
    events->pointer_y[0] = y;
  }

  if (device_no < 0) device_no = 0;
  if (device_no >= CTX_MAX_DEVICES) device_no = CTX_MAX_DEVICES-1;
  CtxEvent *event = &events->drag_event[device_no];

  if (time == 0)
    time = ctx_ms (ctx);


  event->x = event->start_x = event->prev_x = x;
  event->y = event->start_y = event->prev_y = y;

  event->delta_x = event->delta_y = 0;

  event->device_no = device_no;
  event->time      = time;
  event->stop_propagate = 0;

  if (events->pointer_down[device_no] == 1)
  {
#if CTX_BAREMETAL==0
    fprintf (stderr, "events thought device %i was already down\n", device_no);
#endif
  }
  /* doing just one of these two should be enough? */
  events->pointer_down[device_no] = 1;

  if (events->last_key_time + CTX_TYPING_POINTER_IGNORE_MS > time)
  {
    return 0;
  }

  switch (device_no)
  {
    case 1:
      events->modifier_state |= CTX_MODIFIER_STATE_BUTTON1;
      break;
    case 2:
      events->modifier_state |= CTX_MODIFIER_STATE_BUTTON2;
      break;
    case 3:
      events->modifier_state |= CTX_MODIFIER_STATE_BUTTON3;
      break;
    default:
      break;
  }

  CtxGrab *grab = NULL;
  CtxList *l;



  _ctx_update_item (ctx, device_no, x, y, 
      CTX_PRESS | CTX_DRAG_PRESS | CTX_TAP | CTX_TAP_AND_HOLD, &hitlist);

  for (l = hitlist; l; l = l?l->next:NULL)
  {
    CtxItem *item = l->data;
    if (item &&
        ((item->types & CTX_DRAG)||
         (item->types & CTX_TAP) ||
         (item->types & CTX_TAP_AND_HOLD)))
    {
      grab = device_add_grab (ctx, device_no, item, item->types);
      grab->start_time = time;

      if (item->types & CTX_TAP_AND_HOLD)
      {
         grab->timeout_id = ctx_add_timeout (ctx, events->tap_delay_hold, tap_and_hold_fire, grab);
      }
    }
    _ctx_emit_cb_item (ctx, item, event, CTX_PRESS, x, y);
    if (!event->stop_propagate)
      _ctx_emit_cb_item (ctx, item, event, CTX_DRAG_PRESS, x, y);

    if (event->stop_propagate)
    {
      ctx_list_free (&hitlist);
      return 0;
    }
  }

  //events_queue_draw (mrg, NULL); /* in case of style change, and more  */
  ctx_list_free (&hitlist);
  return 0;
}

void _ctx_resized (Ctx *ctx, int width, int height, long time)
{
  CtxItem *item = _ctx_detect (ctx, 0, 0, CTX_KEY_PRESS);
  CtxEvent event = {0, };

  if (!time)
    time = ctx_ms (ctx);
  
  event.ctx = ctx;
  event.time = time;
  event.string = "resize-event"; /* gets delivered to clients as a key_down event, maybe message shouldbe used instead? and also transmit the new size instead of clients having to ask
   */

  if (item)
  {
    event.stop_propagate = 0;
    _ctx_emit_cb_item (ctx, item, &event, CTX_KEY_PRESS, 0, 0);
  }

}

CTX_EXPORT int
ctx_pointer_release (Ctx *ctx, float x, float y, int device_no, uint32_t time)
{
  CtxEvents *events = &ctx->events;
  if (time == 0)
    time = ctx_ms (ctx);

  if (device_no < 0)
    device_no = 0;
  if (device_no >= CTX_MAX_DEVICES)
    device_no = CTX_MAX_DEVICES-1;
  CtxEvent *event = &events->drag_event[device_no];

  event->time = time;
  event->x = x;
  event->ctx = ctx;
  event->y = y;
  event->device_no = device_no;
  event->stop_propagate = 0;

  switch (device_no)
  {
    case 1:
      if (events->modifier_state & CTX_MODIFIER_STATE_BUTTON1)
        events->modifier_state -= CTX_MODIFIER_STATE_BUTTON1;
      break;
    case 2:
      if (events->modifier_state & CTX_MODIFIER_STATE_BUTTON2)
        events->modifier_state -= CTX_MODIFIER_STATE_BUTTON2;
      break;
    case 3:
      if (events->modifier_state & CTX_MODIFIER_STATE_BUTTON3)
        events->modifier_state -= CTX_MODIFIER_STATE_BUTTON3;
      break;
    default:
      break;
  }

  //events_queue_draw (mrg, NULL); /* in case of style change */

  if (events->pointer_down[device_no] == 0)
  {
    //fprintf (stderr, "device %i already up\n", device_no);
  }
  events->pointer_down[device_no] = 0;

  events->pointer_x[device_no] = x;
  events->pointer_y[device_no] = y;
  if (device_no <= 3)
  {
    events->pointer_x[0] = x;
    events->pointer_y[0] = y;
  }
  CtxList *hitlist = NULL;
  CtxList *grablist = NULL , *g= NULL;
  CtxGrab *grab;

  _ctx_update_item (ctx, device_no, x, y, CTX_RELEASE | CTX_DRAG_RELEASE, &hitlist);
  grablist = _ctx_device_get_grabs (ctx, device_no);

  for (g = grablist; g; g = g->next)
  {
    grab = g->data;

    if (!event->stop_propagate)
    {
      if (grab->item->types & CTX_TAP)
      {
        long delay = time - grab->start_time;

        if (delay > events->tap_delay_min &&
            delay < events->tap_delay_max &&
            (
              (event->start_x - x) * (event->start_x - x) +
              (event->start_y - y) * (event->start_y - y)) < ctx_pow2(events->tap_hysteresis)
            )
        {
          _ctx_emit_cb_item (ctx, grab->item, event, CTX_TAP, x, y);
        }
      }

      if (!event->stop_propagate && grab->item->types & CTX_DRAG_RELEASE)
      {
        _ctx_emit_cb_item (ctx, grab->item, event, CTX_DRAG_RELEASE, x, y);
      }
    }

    device_remove_grab (ctx, grab);
  }

  if (hitlist)
  {
    if (!event->stop_propagate)
      _ctx_emit_cb (ctx, hitlist, event, CTX_RELEASE, x, y);
    ctx_list_free (&hitlist);
  }
  ctx_list_free (&grablist);
  return 0;
}

/*  for multi-touch, we use a list of active grabs - thus a grab corresponds to
 *  a device id. even during drag-grabs events propagate; to stop that stop
 *  propagation.
 */
CTX_EXPORT int
ctx_pointer_motion (Ctx *ctx, float x, float y, int device_no, uint32_t time)
{
  CtxList *hitlist = NULL;
  CtxList *grablist = NULL, *g;
  CtxGrab *grab;

  if (device_no < 0) device_no = 0;
  if (device_no >= CTX_MAX_DEVICES) device_no = CTX_MAX_DEVICES-1;
  CtxEvent *event = &ctx->events.drag_event[device_no];

  if (time == 0)
    time = ctx_ms (ctx);

  event->ctx       = ctx;
  event->x         = x;
  event->y         = y;
  event->time      = time;
  event->device_no = device_no;
  event->stop_propagate = 0;
  
  ctx->events.pointer_x[device_no] = x;
  ctx->events.pointer_y[device_no] = y;

  if (device_no <= 3)
  {
    ctx->events.pointer_x[0] = x;
    ctx->events.pointer_y[0] = y;
  }

  grablist = _ctx_device_get_grabs (ctx, device_no);
  _ctx_update_item (ctx, device_no, x, y, CTX_MOTION, &hitlist);

  {
    CtxItem  *cursor_item = _ctx_detect (ctx, x, y, CTX_SET_CURSOR);
    if (cursor_item)
    {
      ctx_set_cursor (ctx, cursor_item->cursor);
    }
    else
    {
      ctx_set_cursor (ctx, CTX_CURSOR_ARROW);
    }
    CtxItem  *hovered_item = _ctx_detect (ctx, x, y, CTX_ANY);
    static CtxItem *prev_hovered_item = NULL;
    if (prev_hovered_item != hovered_item)
    {
      ctx_queue_draw (ctx);
    }
    prev_hovered_item = hovered_item;
  }

  event->delta_x = x - event->prev_x;
  event->delta_y = y - event->prev_y;
  event->prev_x  = x;
  event->prev_y  = y;

  CtxList *remove_grabs = NULL;

  for (g = grablist; g; g = g->next)
  {
    grab = g->data;

    if ((grab->type & CTX_TAP) ||
        (grab->type & CTX_TAP_AND_HOLD))
    {
      if (
          (
            (event->start_x - x) * (event->start_x - x) +
            (event->start_y - y) * (event->start_y - y)) >
              ctx_pow2(ctx->events.tap_hysteresis)
         )
      {
        //fprintf (stderr, "-");
        ctx_list_prepend (&remove_grabs, grab);
      }
      else
      {
        //fprintf (stderr, ":");
      }
    }

    if (grab->type & CTX_DRAG_MOTION)
    {
      _ctx_emit_cb_item (ctx, grab->item, event, CTX_DRAG_MOTION, x, y);
      if (event->stop_propagate)
        break;
    }
  }
  if (remove_grabs)
  {
    for (g = remove_grabs; g; g = g->next)
      device_remove_grab (ctx, g->data);
    ctx_list_free (&remove_grabs);
  }
  if (hitlist)
  {
    if (!event->stop_propagate)
      _ctx_emit_cb (ctx, hitlist, event, CTX_MOTION, x, y);
    ctx_list_free (&hitlist);
  }
  ctx_list_free (&grablist);
  return 0;
}

CTX_EXPORT void
ctx_incoming_message (Ctx *ctx, const char *message, long time)
{
  CtxItem *item = _ctx_detect (ctx, 0, 0, CTX_MESSAGE);
  CtxEvent event = {0, };

  if (!time)
    time = ctx_ms (ctx);

  if (item)
  {
    int i;
    event.ctx = ctx;
    event.type = CTX_MESSAGE;
    event.time = time;
    event.string = message;

#if CTX_BAREMETAL==0
    fprintf (stderr, "{%s|\n", message);
#endif

      for (i = 0; i < item->cb_count; i++)
      {
        if (item->cb[i].types & (CTX_MESSAGE))
        {
          event.state = ctx->events.modifier_state;
          item->cb[i].cb (&event, item->cb[i].data1, item->cb[i].data2);
          if (event.stop_propagate)
            return;// event.stop_propagate;
        }
      }
  }
}

CTX_EXPORT int
ctx_scrolled (Ctx *ctx, float x, float y, CtxScrollDirection scroll_direction, uint32_t time)
{
  CtxList *hitlist = NULL;
  CtxList *l;

  int device_no = 0;
  ctx->events.pointer_x[device_no] = x;
  ctx->events.pointer_y[device_no] = y;

  CtxEvent *event = &ctx->events.drag_event[device_no];  /* XXX: might
                                       conflict with other code
                                       create a sibling member
                                       of drag_event?*/
  if (time == 0)
    time = ctx_ms (ctx);

  event->x         = event->start_x = event->prev_x = x;
  event->y         = event->start_y = event->prev_y = y;
  event->delta_x   = event->delta_y = 0;
  event->device_no = device_no;
  event->time      = time;
  event->stop_propagate = 0;
  event->scroll_direction = scroll_direction;

  _ctx_update_item (ctx, device_no, x, y, CTX_SCROLL, &hitlist);

  for (l = hitlist; l; l = l?l->next:NULL)
  {
    CtxItem *item = l->data;

    _ctx_emit_cb_item (ctx, item, event, CTX_SCROLL, x, y);

    if (event->stop_propagate)
      l = NULL;
  }

  //mrg_queue_draw (mrg, NULL); /* in case of style change, and more  */
  ctx_list_free (&hitlist);
  return 0;
}

#if 0
static int ctx_str_has_prefix (const char *string, const char *prefix)
{
  for (int i = 0; prefix[i]; i++)
  {
    if (!string[i]) return 0;
    if (string[i] != prefix[i]) return 0;
  }
  return 0;
}
#endif


static const char *ctx_keycode_to_keyname (CtxModifierState modifier_state,
                                           int keycode)
{
   static char temp[16]=" ";
   const char *str = &temp[0];
   if (keycode >= 65 && keycode <= 90)
   {
     if (modifier_state & CTX_MODIFIER_STATE_SHIFT)
       temp[0]=keycode-65+'A';
     else
       temp[0]=keycode-65+'a';
     temp[1]=0;
   }
   else if (keycode >= 112 && keycode <= 123)
   {
     sprintf (temp, "F%i", keycode-111);
   }
   else
   switch (keycode)
   {
     case 8: str="backspace"; break;
     case 9: str="tab"; break;
     case 13: str="return"; break;
     case 16: str="shift"; break;
     case 17: str="control"; break;
     case 18: str="alt"; break;
     case 27: str="escape"; break;
     case 32: str="space"; break;
     case 33: str="page-up"; break;
     case 34: str="page-down"; break;
     case 35: str="end"; break;
     case 36: str="home"; break;
     case 37: str="left"; break;
     case 38: str="up"; break;
     case 39: str="right"; break;
     case 40: str="down"; break;
     case 45: str="insert"; break;
     case 46: str="delete"; break;
     default:
       if (modifier_state & CTX_MODIFIER_STATE_SHIFT)
       switch (keycode)
       {
         case 173: str="_"; break;
         case 186: str=":"; break;
         case 187: str="+"; break;
         case 188: str="<"; break;
         case 189: str="_"; break;
         case 190: str=">"; break;
         case 191: str="?"; break;
         case 192: str="~"; break;
         case 219: str="{"; break;
         case 221: str="}"; break;
         case 220: str="|"; break;
         case 222: str="\""; break;
         case 48: str=")"; break;
         case 49: str="!"; break;
         case 50: str="@"; break;
         case 51: str="#"; break;
         case 52: str="$"; break;
         case 53: str="%"; break;
         case 54: str="^"; break;
         case 55: str="&"; break;
         case 56: str="*"; break;
         case 57: str="("; break;
         case 59: str=":"; break;
         case 61: str="+"; break;
         default:
#if CTX_BAREMETAL==0
           fprintf (stderr, "unhandled skeycode %i\n", keycode);
#endif
           str="?";
           break;
       }
       else
       switch (keycode)
       {
         case 61: str="="; break;
         case 59: str=";"; break;
         case 173: str="-"; break;
         case 186: str=";"; break;
         case 187: str="="; break;
         case 188: str=","; break;
         case 189: str="-"; break;
         case 190: str="."; break;
         case 191: str="/"; break;
         case 192: str="`"; break;
         case 219: str="["; break;
         case 221: str="]"; break;
         case 220: str="\\"; break;
         case 222: str="'"; break;
         default:
           if (keycode >= 48 && keycode <=66)
           {
             temp[0]=keycode-48+'0';
             temp[1]=0;
           }
           else
           {
#if CTX_BAREMETAL==0
             fprintf (stderr, "unhandled keycode %i\n", keycode);
#endif
             str="?";
           }
           break;
       }
   }
   return str;
}
typedef struct CtxKeyMap {
  const char *us;
  const char *unshifted;
  const char *shifted;
} CtxKeyMap;

static const CtxKeyMap intl_key_map[]=
{
   {"`","`","~"},
   {"1","1","!"},
   {"2","2","@"},
   {"3","3","#"},
   {"4","4","$"},
   {"5","5","%"},
   {"6","6","^"},
   {"7","7","&"},
   {"8","8","*"},
   {"9","9","("},
   {"0","0",")"},
   {"-","-","_"},
   {"=","=","+"},

   {"q","q","Q"},
   {"w","w","W"},
   {"e","e","E"},
   {"r","r","R"},
   {"t","t","T"},
   {"y","y","Y"},
   {"u","u","U"},
   {"i","i","I"},
   {"o","o","O"},
   {"p","p","P"},
   {"[","[","{"},
   {"]","]","}"},
   {"\\","\\","|"},

   {"a","a","A"},
   {"s","s","S"},
   {"d","d","D"},
   {"f","f","F"},
   {"g","g","G"},
   {"h","h","H"},
   {"j","j","J"},
   {"k","k","K"},
   {"l","l","L"},

   {"z","z","Z"},
   {"x","x","X"},
   {"c","c","C"},
   {"v","v","V"},
   {"b","b","B"},
   {"n","n","N"},
   {"m","m","M"},
   {";",";",":"},
   {"'","'","\""},

   {".",".",">"},
   {",",",","<"},
   {"/","/","?"}
};

static const char *keymap_get_shifted (const char *key)
{
  for (unsigned int i = 0; i < sizeof (intl_key_map)/sizeof(intl_key_map[0]);i++)
  {
     if (!strcmp (key, intl_key_map[i].us))
        return intl_key_map[i].shifted;
  }
  return key;
}

static const char *keymap_get_unshifted (const char *key)
{
  for (unsigned int i = 0; i < sizeof (intl_key_map)/sizeof(intl_key_map[0]);i++)
  {
     if (!strcmp (key, intl_key_map[i].us))
        return intl_key_map[i].unshifted;
  }
  return key;
}

CTX_EXPORT int
ctx_key_press (Ctx *ctx, unsigned int keyval,
               const char *string, uint32_t time)
{
  char temp_key[128]="";
  char event_type[128]="";
  float x, y; int b;
  if (!string)
  {
    string = ctx_keycode_to_keyname (ctx->events.modifier_state, keyval);
  }

  if (!ctx_strcmp (string, "shift") ||
      !ctx_strcmp (string, "control") ||
      !ctx_strcmp (string, "alt"))
  {
    return 0;
  }

  {
          // code duplication.. perhaps always do this?
    {
       if (ctx->events.modifier_state & CTX_MODIFIER_STATE_SHIFT)
       {
          if(
             ctx_utf8_strlen (string)>1 ||
           (ctx->events.modifier_state & CTX_MODIFIER_STATE_ALT||
            ctx->events.modifier_state & CTX_MODIFIER_STATE_CONTROL))
          {
            if (strstr (string, "shift-") == NULL ||
                strcmp (strstr (string, "shift-"), "shift-"))
            sprintf (&temp_key[ctx_strlen(temp_key)], "shift-");
          }
          else 
          {
            string = keymap_get_shifted (string);
          }
       }
       else
       {
          if (!(ctx->events.modifier_state & CTX_MODIFIER_STATE_ALT||
                ctx->events.modifier_state & CTX_MODIFIER_STATE_CONTROL))
          {
            string = keymap_get_unshifted (string);
          }
       }

       if ((ctx->events.modifier_state & CTX_MODIFIER_STATE_ALT))
       {
         if (strstr (string, "alt-") == NULL ||
             strcmp (strstr (string, "alt-"), "alt-"))
         sprintf (&temp_key[ctx_strlen(temp_key)], "alt-");
       }
       if ((ctx->events.modifier_state & CTX_MODIFIER_STATE_CONTROL))
       {
         if (strstr (string, "control-") == NULL ||
             strcmp (strstr (string, "control-"), "control-"))
           sprintf (&temp_key[ctx_strlen(temp_key)], "control-");
       }
       sprintf (&temp_key[ctx_strlen(temp_key)], "%s", string);
       string = temp_key;
    }
  }

  int i = 0;
  for (i = 0; string[i] && string[i] != ' '; i++)
  {
    event_type[i] = string[i];
  }
  event_type[i]=0;
  char *pos = (char*)&string[i] + 1;
  while (*pos==' ')pos++;
  x = _ctx_parse_float (pos, &pos);
  while (*pos==' ')pos++;
  y = _ctx_parse_float (pos, &pos);
  while (*pos==' ')pos++;
  b = atoi(pos);

  if (!ctx_strcmp (event_type, "pm") ||
      !ctx_strcmp (event_type, "pd"))
    return ctx_pointer_motion (ctx, x, y, b, 0);
  else if (!ctx_strcmp (event_type, "pp"))
    return ctx_pointer_press (ctx, x, y, b, 0);
  else if (!ctx_strcmp (event_type, "pr"))
    return ctx_pointer_release (ctx, x, y, b, 0);
  //else if (!ctx_strcmp (event_type, "keydown"))
  //  return ctx_key_down (ctx, keyval, string + 8, time);
  //else if (!ctx_strcmp (event_type, "keyup"))
  //  return ctx_key_up (ctx, keyval, string + 6, time);

  CtxItem *item = _ctx_detect (ctx, 0, 0, CTX_KEY_PRESS);
  CtxEvent event = {0,};

  if (time == 0)
    time = ctx_ms (ctx);
  if (item)
  {
    int i;
    event.ctx = ctx;
    event.type = CTX_KEY_PRESS;
    event.unicode = keyval; 
#ifdef EMSCRIPTEN
    if (string)
      event.string = strdup(string);
    else
      event.string = strdup("--");
#else
    if (string)
      event.string = ctx_strdup(string);
    else
      event.string = ctx_strdup("--");
#endif
    event.stop_propagate = 0;
    event.time = time;

    for (i = 0; i < item->cb_count; i++)
    {
      if (ctx->events.event_depth == 0)
      {
         // it is a real key-press , not a synthetic / on-screen one
         ctx->events.last_key_time = time;
      }
      if (item->cb[i].types & (CTX_KEY_PRESS))
      {
        event.state = ctx->events.modifier_state;
        item->cb[i].cb (&event, item->cb[i].data1, item->cb[i].data2);
        if (event.stop_propagate)
        {
#ifdef EMSCRIPTEN
          free ((void*)event.string);
#else
          ctx_free ((void*)event.string);
#endif
          return event.stop_propagate;
        }
      }
    }
#ifdef EMSCRIPTEN
    free ((void*)event.string);
#else
    ctx_free ((void*)event.string);
#endif
  }
  return 0;
}

CTX_EXPORT int
ctx_key_down (Ctx *ctx, unsigned int keyval,
              const char *string, uint32_t time)
{
  CtxItem *item = _ctx_detect (ctx, 0, 0, CTX_KEY_DOWN);
  CtxEvent event = {0,};
  if (!string)
    string = ctx_keycode_to_keyname (0, keyval);

  if (!ctx_strcmp (string, "shift"))
  {
    ctx->events.modifier_state |= CTX_MODIFIER_STATE_SHIFT;
  }
  else if (!ctx_strcmp (string, "control"))
  {
    ctx->events.modifier_state |= CTX_MODIFIER_STATE_CONTROL;
  }
  else if (!ctx_strcmp (string, "alt"))
  {
    ctx->events.modifier_state |= CTX_MODIFIER_STATE_ALT;
  }

  if (time == 0)
    time = ctx_ms (ctx);
  if (item)
  {
    int i;
    event.ctx     = ctx;
    event.type    = CTX_KEY_DOWN;
    event.unicode = keyval; 
    event.string  = ctx_strdup(string);
    event.stop_propagate = 0;
    event.time    = time;

    for (i = 0; i < item->cb_count; i++)
    {
      if (item->cb[i].types & (CTX_KEY_DOWN))
      {
        event.state = ctx->events.modifier_state;
        item->cb[i].cb (&event, item->cb[i].data1, item->cb[i].data2);
        if (event.stop_propagate)
        {
          ctx_free ((void*)event.string);
          return event.stop_propagate;
        }
      }
    }
    ctx_free ((void*)event.string);
  }
  return 0;
}

CTX_EXPORT int
ctx_key_up (Ctx *ctx, unsigned int keyval,
            const char *string, uint32_t time)
{
  CtxItem *item = _ctx_detect (ctx, 0, 0, CTX_KEY_UP);
  CtxEvent event = {0,};
  if (!string)
    string = ctx_keycode_to_keyname (0, keyval);

  if (!ctx_strcmp (string, "shift"))
  {
    ctx->events.modifier_state &= ~(CTX_MODIFIER_STATE_SHIFT);
  }
  else if (!ctx_strcmp (string, "control"))
  {
    ctx->events.modifier_state &= ~(CTX_MODIFIER_STATE_CONTROL);
  }
  else if (!ctx_strcmp (string, "alt"))
  {
    ctx->events.modifier_state &= ~(CTX_MODIFIER_STATE_ALT);
  }

  if (time == 0)
    time = ctx_ms (ctx);
  if (item)
  {
    int i;
    event.ctx = ctx;
    event.type = CTX_KEY_UP;
    event.unicode = keyval; 
    event.string = ctx_strdup(string);
    event.stop_propagate = 0;
    event.time = time;

    for (i = 0; i < item->cb_count; i++)
    {
      if (item->cb[i].types & (CTX_KEY_UP))
      {
        event.state = ctx->events.modifier_state;
        item->cb[i].cb (&event, item->cb[i].data1, item->cb[i].data2);
        if (event.stop_propagate)
        {
          ctx_free ((void*)event.string);
          return event.stop_propagate;
        }
      }
    }
    ctx_free ((void*)event.string);
  }
  return 0;
}

void ctx_freeze           (Ctx *ctx)
{
  ctx->events.frozen ++;
}

void ctx_thaw             (Ctx *ctx)
{
  ctx->events.frozen --;
}
int ctx_events_frozen (Ctx *ctx)
{
  return ctx && ctx->events.frozen;
}
void ctx_events_clear_items (Ctx *ctx)
{
  ctx_list_free (&ctx->events.items);
}

float ctx_pointer_x (Ctx *ctx)
{
  return ctx->events.pointer_x[0];
}

float ctx_pointer_y (Ctx *ctx)
{
  return ctx->events.pointer_y[0];
}

int ctx_pointer_is_down (Ctx *ctx, int no)
{
  if (no < 0 || no > CTX_MAX_DEVICES) return 0;
  return ctx->events.pointer_down[no];
}

void _ctx_debug_overlays (Ctx *ctx)
{
  CtxList *a;
  ctx_save (ctx);

  ctx_line_width (ctx, 2);
  ctx_rgba (ctx, 0,0,0.8f,0.5f);
  for (a = ctx->events.items; a; a = a->next)
  {
    float current_x = ctx_pointer_x (ctx);
    float current_y = ctx_pointer_y (ctx);
    CtxItem *item = a->data;
    CtxMatrix matrix = item->inv_matrix;

    _ctx_matrix_apply_transform (&matrix, &current_x, &current_y);

    if (current_x >= item->x0 && current_x < item->x1 &&
        current_y >= item->y0 && current_y < item->y1)
    {
      ctx_matrix_invert (&matrix);
      ctx_set_matrix (ctx, &matrix);
      _mrg_restore_path (ctx, item->path);
      ctx_stroke (ctx);
    }
  }
  ctx_restore (ctx);
}

#if CTX_THREADS
void ctx_set_render_threads   (Ctx *ctx, int n_threads)
{
  // XXX
}
int ctx_get_render_threads   (Ctx *ctx)
{
  return _ctx_max_threads;
}
#else
void ctx_set_render_threads   (Ctx *ctx, int n_threads)
{
}
int ctx_get_render_threads   (Ctx *ctx)
{
  return 1;
}
#endif

int ctx_need_redraw (Ctx *ctx)
{
  return (ctx->dirty != 0)
#if CTX_VT
    || ctx_clients_need_redraw (ctx)
#endif
    ;
}


/*
 * centralized global API for managing file descriptors that
 * wake us up, this to remove sleeping and polling
 */


static int _ctx_listen_fd[CTX_MAX_LISTEN_FDS];
static int _ctx_listen_fds    = 0;
static int _ctx_listen_max_fd = 0;

void _ctx_add_listen_fd (int fd)
{
  _ctx_listen_fd[_ctx_listen_fds++]=fd;
  if (fd > _ctx_listen_max_fd)
    _ctx_listen_max_fd = fd;
}

void _ctx_remove_listen_fd (int fd)
{
  for (int i = 0; i < _ctx_listen_fds; i++)
  {
    if (_ctx_listen_fd[i] == fd)
    {
      _ctx_listen_fd[i] = _ctx_listen_fd[_ctx_listen_fds-1];
      _ctx_listen_fds--;
      return;
    }
  }
}
#ifdef EMSCRIPTEN
extern int em_in_len;
#endif
#if CTX_VT
extern int ctx_dummy_in_len;
#endif

int ctx_input_pending (Ctx *ctx, int timeout)
{
  int retval = 0;
#if CTX_PTY
  struct timeval tv;
  fd_set fdset;
  FD_ZERO (&fdset);
  for (int i = 0; i < _ctx_listen_fds; i++)
  {
    FD_SET (_ctx_listen_fd[i], &fdset);
  }
  int input_fds[5];
  int n_fds;
  ctx_get_event_fds (ctx, input_fds, &n_fds);
  for (int i = 0; i < n_fds; i++)
  {
    FD_SET (input_fds[i], &fdset);
  }
  tv.tv_sec = 0;
  tv.tv_usec = timeout;
  tv.tv_sec = timeout / 1000000;
  tv.tv_usec = timeout % 1000000;
  retval = select (_ctx_listen_max_fd + 1, &fdset, NULL, NULL, &tv);
  if (retval == -1)
  {
#if CTX_BAREMETAL==0
    perror ("select");
#endif
    return 0;
  }
#endif
#ifdef EMSCRIPTEN
  retval += em_in_len;
#endif
#if CTX_VT
  retval += ctx_dummy_in_len;
#endif
  return retval;
}

void ctx_handle_events (Ctx *ctx)
{
#if CTX_VT
  ctx_clients_handle_events (ctx);
#endif
  while (ctx_get_event_full (ctx, 1)){}
}


void ctx_events_deinit (Ctx *ctx)
{
  ctx_list_free (&ctx->events.items);
  ctx->events.last_item = NULL;

  while (ctx->events.idles)
  {
    CtxIdleCb *item = ctx->events.idles->data;
    ctx_list_remove (&ctx->events.idles, item);
    if (item->destroy_notify)
      item->destroy_notify (item->destroy_data);
  }
}


#if CTX_TERMINAL_EVENTS

#if CTX_PTY
static int mice_has_event (void);
static char *mice_get_event (void);
static void mice_destroy (void);
static int mice_get_fd (EvSource *ev_source);
static void mice_set_coord (EvSource *ev_source, double x, double y);

static EvSource ctx_ev_src_mice = {
  NULL,
  (void*)mice_has_event,
  (void*)mice_get_event,
  (void*)mice_destroy,
  mice_get_fd,
  mice_set_coord
};

typedef struct Mice
{
  int     fd;
  double  x;
  double  y;
  int     button;
  int     prev_state;
} Mice;

Mice *_mrg_evsrc_coord = NULL;
int _ctx_mice_fd = 0;

static Mice  mice;
static Mice* mrg_mice_this = &mice;

static int mmm_ctx_evsource_mice_init ()
{
  const unsigned char reset[]={0xff};
  /* need to detect which event */

  mrg_mice_this->prev_state = 0;
  mrg_mice_this->fd = open ("/dev/input/mice", O_RDONLY | O_NONBLOCK);
  if (mrg_mice_this->fd == -1)
  {
    fprintf (stderr, "error opening /dev/input/mice device, maybe add user to input group if such group exist, or otherwise make the rights be satisfied.\n");
    return -1;
  }
  if (write (mrg_mice_this->fd, reset, 1) == -1)
  {
    // might happen if we're a regular user with only read permission
  }
  _ctx_mice_fd = mrg_mice_this->fd;
  _mrg_evsrc_coord = mrg_mice_this;
  return 0;
}

static void mice_destroy (void)
{
  if (mrg_mice_this->fd != -1)
    close (mrg_mice_this->fd);
}

static int mice_has_event (void)
{
  struct timeval tv;
  int retval;

  if (mrg_mice_this->fd == -1)
    return 0;

  fd_set rfds;
  FD_ZERO (&rfds);
  FD_SET(mrg_mice_this->fd, &rfds);
  tv.tv_sec = 0; tv.tv_usec = 0;
  retval = select (mrg_mice_this->fd+1, &rfds, NULL, NULL, &tv);
  if (retval == 1)
    return FD_ISSET (mrg_mice_this->fd, &rfds);
  return 0;
}

static char *mice_get_event (void)
{
  const char *ret = "pm";
  double relx, rely;
  signed char buf[3];
  int n_read = 0;
  n_read = read (mrg_mice_this->fd, buf, 3);
  if (n_read == 0)
     return ctx_strdup ("");
  relx = buf[1];
  rely = -buf[2];

  Ctx *ctx = (void*)ctx_ev_src_mice.priv;
  int width = ctx_width (ctx);
  int height = ctx_height (ctx);

  if (relx < 0)
  {
    if (relx > -6)
    relx = - relx*relx;
    else
    relx = -36;
  }
  else
  {
    if (relx < 6)
    relx = relx*relx;
    else
    relx = 36;
  }

  if (rely < 0)
  {
    if (rely > -6)
    rely = - rely*rely;
    else
    rely = -36;
  }
  else
  {
    if (rely < 6)
    rely = rely*rely;
    else
    rely = 36;
  }

  mrg_mice_this->x += relx;
  mrg_mice_this->y += rely;

  if (mrg_mice_this->x < 0)
    mrg_mice_this->x = 0;
  if (mrg_mice_this->y < 0)
    mrg_mice_this->y = 0;
  if (mrg_mice_this->x >= width)
    mrg_mice_this->x = width -1;
  if (mrg_mice_this->y >= height)
    mrg_mice_this->y = height -1;
  int button = 0;
  
  if ((mrg_mice_this->prev_state & 1) != (buf[0] & 1))
    {
      if (buf[0] & 1)
        {
          ret = "pp";
        }
      else
        {
          ret = "pr";
        }
      button = 1;
    }
  else if (buf[0] & 1)
  {
    ret = "pd";
    button = 1;
  }

  if (!button)
  {
    if ((mrg_mice_this->prev_state & 2) != (buf[0] & 2))
    {
      if (buf[0] & 2)
        {
          ret = "pp";
        }
      else
        {
          ret = "pr";
        }
      button = 3;
    }
    else if (buf[0] & 2)
    {
      ret = "pd";
      button = 3;
    }
  }

  if (!button)
  {
    if ((mrg_mice_this->prev_state & 4) != (buf[0] & 4))
    {
      if (buf[0] & 4)
        {
          ret = "pp";
        }
      else
        {
          ret = "pr";
        }
      button = 2;
    }
    else if (buf[0] & 4)
    {
      ret = "pd";
      button = 2;
    }
  }

  mrg_mice_this->prev_state = buf[0];

  {
    char *r = ctx_malloc (64);
    sprintf (r, "%s %.0f %.0f %i", ret, mrg_mice_this->x, mrg_mice_this->y, button);
    return r;
  }

  return NULL;
}

static int mice_get_fd (EvSource *ev_source)
{
  return mrg_mice_this->fd;
}

static void mice_set_coord (EvSource *ev_source, double x, double y)
{
  mrg_mice_this->x = x;
  mrg_mice_this->y = y;
}

EvSource *ctx_evsource_mice_new (void)
{
  if (mmm_ctx_evsource_mice_init () == 0)
    {
      mrg_mice_this->x = 0;
      mrg_mice_this->y = 0;
      return &ctx_ev_src_mice;
    }
  return NULL;
}
#endif

static int ctx_evsource_kb_term_has_event (void);
static char *ctx_evsource_kb_term_get_event (void);
static void ctx_evsource_kb_term_destroy (int sign);
static int ctx_evsource_kb_term_get_fd (void);

/* kept out of struct to be reachable by atexit */
static EvSource ctx_ev_src_kb_term = {
  NULL,
  (void*)ctx_evsource_kb_term_has_event,
  (void*)ctx_evsource_kb_term_get_event,
  (void*)ctx_evsource_kb_term_destroy,
  (void*)ctx_evsource_kb_term_get_fd,
  NULL
};

#if CTX_PTY
static struct termios orig_attr;
#endif

static void real_ctx_evsource_kb_term_destroy (int sign)
{
#if CTX_PTY
  static int done = 0;

  if (sign == 0)
    return;

  if (done)
    return;
  done = 1;

  switch (sign)
  {
    case  -11:break; /* will be called from atexit with sign==-11 */
    case   SIGSEGV: break;//fprintf (stderr, " SIGSEGV\n");break;
    case   SIGABRT: fprintf (stderr, " SIGABRT\n");break;
    case   SIGBUS:  fprintf (stderr, " SIGBUS\n");break;
    case   SIGKILL: fprintf (stderr, " SIGKILL\n");break;
    case   SIGINT:  fprintf (stderr, " SIGINT\n");break;
    case   SIGTERM: fprintf (stderr, " SIGTERM\n");break;
    case   SIGQUIT: fprintf (stderr, " SIGQUIT\n");break;
    default: fprintf (stderr, "sign: %i\n", sign);
             fprintf (stderr, "%i %i %i %i %i %i %i\n", SIGSEGV, SIGABRT, SIGBUS, SIGKILL, SIGINT, SIGTERM, SIGQUIT);
  }
  tcsetattr (STDIN_FILENO, TCSAFLUSH, &orig_attr);
  //fprintf (stderr, "evsource kb destroy\n");
#endif
}

static void ctx_evsource_kb_term_destroy (int sign)
{
  real_ctx_evsource_kb_term_destroy (-11);
}

static int ctx_evsource_kb_term_init ()
{
#if CTX_PTY
//  ioctl(STDIN_FILENO, KDSKBMODE, K_RAW);
  //atexit ((void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGSEGV, (void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGABRT, (void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGBUS,  (void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGKILL, (void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGINT,  (void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGTERM, (void*) real_ctx_evsource_kb_term_destroy);
  signal (SIGQUIT, (void*) real_ctx_evsource_kb_term_destroy);

  struct termios raw;
  if (tcgetattr (STDIN_FILENO, &orig_attr) == -1)
    {
      fprintf (stderr, "error initializing keyboard\n");
      return -1;
    }
  raw = orig_attr;

  cfmakeraw (&raw);

  raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
  if (tcsetattr (STDIN_FILENO, TCSAFLUSH, &raw) < 0)
    return 0; // XXX? return other value?
#endif
  return 0;
}
static int ctx_evsource_kb_term_has_event (void)
{
  int retval = 0;
#if CTX_PTY
  struct timeval tv;
  fd_set rfds;
  FD_ZERO (&rfds);
  FD_SET(STDIN_FILENO, &rfds);
  tv.tv_sec = 0; tv.tv_usec = 0;
  retval = select (STDIN_FILENO+1, &rfds, NULL, NULL, &tv);
#endif
  return retval == 1;
}

/* note that a nick can have multiple occurences, the labels
 * should be kept the same for all occurences of a combination.
 *
 * this table is taken from nchanterm.
 */
typedef struct MmmKeyCode {
  char *nick;          /* programmers name for key */
  char  sequence[10];  /* terminal sequence */
} MmmKeyCode;
static const MmmKeyCode ufb_keycodes[]={
  {"up",                  "\033[A"},
  {"down",                "\033[B"},
  {"right",               "\033[C"},
  {"left",                "\033[D"},

  {"shift-up",            "\033[1;2A"},
  {"shift-down",          "\033[1;2B"},
  {"shift-right",         "\033[1;2C"},
  {"shift-left",          "\033[1;2D"},

  {"alt-up",              "\033[1;3A"},
  {"alt-down",            "\033[1;3B"},
  {"alt-right",           "\033[1;3C"},
  {"alt-left",            "\033[1;3D"},
  {"alt-shift-up",         "\033[1;4A"},
  {"alt-shift-down",       "\033[1;4B"},
  {"alt-shift-right",      "\033[1;4C"},
  {"alt-shift-left",       "\033[1;4D"},

  {"control-up",          "\033[1;5A"},
  {"control-down",        "\033[1;5B"},
  {"control-right",       "\033[1;5C"},
  {"control-left",        "\033[1;5D"},

  /* putty */
  {"control-up",          "\033OA"},
  {"control-down",        "\033OB"},
  {"control-right",       "\033OC"},
  {"control-left",        "\033OD"},

  {"control-shift-up",    "\033[1;6A"},
  {"control-shift-down",  "\033[1;6B"},
  {"control-shift-right", "\033[1;6C"},
  {"control-shift-left",  "\033[1;6D"},

  {"control-up",          "\033Oa"},
  {"control-down",        "\033Ob"},
  {"control-right",       "\033Oc"},
  {"control-left",        "\033Od"},

  {"shift-up",            "\033[a"},
  {"shift-down",          "\033[b"},
  {"shift-right",         "\033[c"},
  {"shift-left",          "\033[d"},

  {"insert",              "\033[2~"},
  {"delete",              "\033[3~"},
  {"page-up",             "\033[5~"},
  {"page-down",           "\033[6~"},
  {"home",                "\033OH"},
  {"end",                 "\033OF"},
  {"home",                "\033[H"},
  {"end",                 "\033[F"},
 {"control-delete",       "\033[3;5~"},
  {"shift-delete",        "\033[3;2~"},
  {"control-shift-delete","\033[3;6~"},

  {"F1",         "\033[25~"},
  {"F2",         "\033[26~"},
  {"F3",         "\033[27~"},
  {"F4",         "\033[26~"},


  {"F1",         "\033[11~"},
  {"F2",         "\033[12~"},
  {"F3",         "\033[13~"},
  {"F4",         "\033[14~"},
  {"F1",         "\033OP"},
  {"F2",         "\033OQ"},
  {"F3",         "\033OR"},
  {"F4",         "\033OS"},
  {"F5",         "\033[15~"},
  {"F6",         "\033[16~"},
  {"F7",         "\033[17~"},
  {"F8",         "\033[18~"},
  {"F9",         "\033[19~"},
  {"F9",         "\033[20~"},
  {"F10",        "\033[21~"},
  {"F11",        "\033[22~"},
  {"F12",        "\033[23~"},
  {"tab",         {9, '\0'}},
  {"shift-tab",   {27, 9, '\0'}}, // also generated by alt-tab in linux console
  {"alt-space",   {27, ' ', '\0'}},
  {"shift-tab",   "\033[Z"},
  {"backspace",   {127, '\0'}},
  {"space",       " "},
  {"\033",          "\033"},
  {"return",      {10,0}},
  {"return",      {13,0}},
  /* this section could be autogenerated by code */
  {"control-a",   {1,0}},
  {"control-b",   {2,0}},
  {"control-c",   {3,0}},
  {"control-d",   {4,0}},
  {"control-e",   {5,0}},
  {"control-f",   {6,0}},
  {"control-g",   {7,0}},
  {"control-h",   {8,0}}, /* backspace? */
  {"control-i",   {9,0}},
  {"control-j",   {10,0}},
  {"control-k",   {11,0}},
  {"control-l",   {12,0}},
  {"control-n",   {14,0}},
  {"control-o",   {15,0}},
  {"control-p",   {16,0}},
  {"control-q",   {17,0}},
  {"control-r",   {18,0}},
  {"control-s",   {19,0}},
  {"control-t",   {20,0}},
  {"control-u",   {21,0}},
  {"control-v",   {22,0}},
  {"control-w",   {23,0}},
  {"control-x",   {24,0}},
  {"control-y",   {25,0}},
  {"control-z",   {26,0}},
  {"alt-`",       "\033`"},
  {"alt-0",       "\0330"},
  {"alt-1",       "\0331"},
  {"alt-2",       "\0332"},
  {"alt-3",       "\0333"},
  {"alt-4",       "\0334"},
  {"alt-5",       "\0335"},
  {"alt-6",       "\0336"},
  {"alt-7",       "\0337"}, /* backspace? */
  {"alt-8",       "\0338"},
  {"alt-9",       "\0339"},
  {"alt-+",       "\033+"},
  {"alt--",       "\033-"},
  {"alt-/",       "\033/"},
  {"alt-a",       "\033a"},
  {"alt-b",       "\033b"},
  {"alt-c",       "\033c"},
  {"alt-d",       "\033d"},
  {"alt-e",       "\033e"},
  {"alt-f",       "\033f"},
  {"alt-g",       "\033g"},
  {"alt-h",       "\033h"}, /* backspace? */
  {"alt-i",       "\033i"},
  {"alt-j",       "\033j"},
  {"alt-k",       "\033k"},
  {"alt-l",       "\033l"},
  {"alt-n",       "\033m"},
  {"alt-n",       "\033n"},
  {"alt-o",       "\033o"},
  {"alt-p",       "\033p"},
  {"alt-q",       "\033q"},
  {"alt-r",       "\033r"},
  {"alt-s",       "\033s"},
  {"alt-t",       "\033t"},
  {"alt-u",       "\033u"},
  {"alt-v",       "\033v"},
  {"alt-w",       "\033w"},
  {"alt-x",       "\033x"},
  {"alt-y",       "\033y"},
  {"alt-z",       "\033z"},
  /* Linux Console  */
  {"home",       "\033[1~"},
  {"end",        "\033[4~"},
  {"F1",         "\033[[A"},
  {"F2",         "\033[[B"},
  {"F3",         "\033[[C"},
  {"F4",         "\033[[D"},
  {"F5",         "\033[[E"},
  {"F6",         "\033[[F"},
  {"F7",         "\033[[G"},
  {"F8",         "\033[[H"},
  {"F9",         "\033[[I"},
  {"F10",        "\033[[J"},
  {"F11",        "\033[[K"},
  {"F12",        "\033[[L"},
  {NULL, }
};
static int fb_keyboard_match_keycode (const char *buf, int length, const MmmKeyCode **ret)
{
  int i;
  int matches = 0;

  if (!strncmp (buf, "\033[M", length<3?length:3))
    {
      if (length >= 6)
        return 9001;
      return 2342;
    }
  for (i = 0; ufb_keycodes[i].nick; i++)
    if (!strncmp (buf, ufb_keycodes[i].sequence, length))
      {
        matches ++;
        if ((int)ctx_strlen (ufb_keycodes[i].sequence) == length && ret)
          {
            *ret = &ufb_keycodes[i];
            return 1;
          }
      }
  if (matches != 1 && ret)
    *ret = NULL;
  return matches==1?2:matches;
}

static char *ctx_evsource_kb_term_get_event (void)
{
  unsigned char buf[20];
  int length;


  for (length = 0; length < 10; length ++)
    if (read (STDIN_FILENO, &buf[length], 1) != -1)
      {
        const MmmKeyCode *match = NULL;

        //if (!is_active (ctx_ev_src_kb.priv))
        //  return NULL;

        /* special case ESC, so that we can use it alone in keybindings */
        if (length == 0 && buf[0] == 27)
          {
            struct timeval tv;
            fd_set rfds;
            FD_ZERO (&rfds);
            FD_SET (STDIN_FILENO, &rfds);
            tv.tv_sec = 0;
            tv.tv_usec = 1000 * 120;
            if (select (STDIN_FILENO+1, &rfds, NULL, NULL, &tv) == 0)
              return ctx_strdup ("escape");
          }

        switch (fb_keyboard_match_keycode ((void*)buf, length + 1, &match))
          {
            case 1: /* unique match */
              if (!match)
                return NULL;
              return ctx_strdup (match->nick);
              break;
            case 0: /* no matches, bail*/
             {
                char ret[256]="";
                if (length == 0 && ctx_utf8_len (buf[0])>1) /* read a
                                                             * single unicode
                                                             * utf8 character
                                                             */
                  {
                    int bytes = read (STDIN_FILENO, &buf[length+1], ctx_utf8_len(buf[0])-1);
                    if (bytes)
                    {
                      buf[ctx_utf8_len(buf[0])]=0;
                      strcpy (ret, (void*)buf);
                    }
                    return ctx_strdup(ret); //XXX: simplify
                  }
                if (length == 0) /* ascii */
                  {
                    buf[1]=0;
                    strcpy (ret, (void*)buf);
                    return ctx_strdup(ret);
                  }
                sprintf (ret, "unhandled %i:'%c' %i:'%c' %i:'%c' %i:'%c' %i:'%c' %i:'%c' %i:'%c'",
                    length >=0 ? buf[0] : 0,
                    length >=0 ? buf[0]>31?buf[0]:'?' : ' ',
                    length >=1 ? buf[1] : 0,
                    length >=1 ? buf[1]>31?buf[1]:'?' : ' ',
                    length >=2 ? buf[2] : 0,
                    length >=2 ? buf[2]>31?buf[2]:'?' : ' ',
                    length >=3 ? buf[3] : 0,
                    length >=3 ? buf[3]>31?buf[3]:'?' : ' ',
                    length >=4 ? buf[4] : 0,
                    length >=4 ? buf[4]>31?buf[4]:'?' : ' ',
                    length >=5 ? buf[5] : 0,
                    length >=5 ? buf[5]>31?buf[5]:'?' : ' ',
                    length >=6 ? buf[6] : 0,
                    length >=6 ? buf[6]>31?buf[6]:'?' : ' '
                    );
                return ctx_strdup(ret);
            }
              return NULL;
            default: /* continue */
              break;
          }
      }
    else
      return ctx_strdup("key read eek");
  return ctx_strdup("fail");
}

static int ctx_evsource_kb_term_get_fd (void)
{
  return STDIN_FILENO;
}


EvSource *ctx_evsource_kb_term_new (void)
{
  if (ctx_evsource_kb_term_init() == 0)
  {
    return &ctx_ev_src_kb_term;
  }
  return NULL;
}
#endif

#if CTX_RAW_KB_EVENTS

static int ctx_evsource_kb_raw_has_event (void);
static char *ctx_evsource_kb_raw_get_event (void);
static void ctx_evsource_kb_raw_destroy (int sign);
static int ctx_evsource_kb_raw_get_fd (void);


/* kept out of struct to be reachable by atexit */
static EvSource ctx_ev_src_kb_raw = {
  NULL,
  (void*)ctx_evsource_kb_raw_has_event,
  (void*)ctx_evsource_kb_raw_get_event,
  (void*)ctx_evsource_kb_raw_destroy,
  (void*)ctx_evsource_kb_raw_get_fd,
  NULL
};

#if 0
static void real_ctx_evsource_kb_raw_destroy (int sign)
{
  static int done = 0;

  if (sign == 0)
    return;

  if (done)
    return;
  done = 1;

  switch (sign)
  {
    case  -11:break; /* will be called from atexit with sign==-11 */
    case   SIGSEGV: break;//fprintf (stderr, " SIGSEGV\n");break;
    case   SIGABRT: fprintf (stderr, " SIGABRT\n");break;
    case   SIGBUS:  fprintf (stderr, " SIGBUS\n");break;
    case   SIGKILL: fprintf (stderr, " SIGKILL\n");break;
    case   SIGINT:  fprintf (stderr, " SIGINT\n");break;
    case   SIGTERM: fprintf (stderr, " SIGTERM\n");break;
    case   SIGQUIT: fprintf (stderr, " SIGQUIT\n");break;
    default: fprintf (stderr, "sign: %i\n", sign);
             fprintf (stderr, "%i %i %i %i %i %i %i\n", SIGSEGV, SIGABRT, SIGBUS, SIGKILL, SIGINT, SIGTERM, SIGQUIT);
  }
  tcsetattr (STDIN_FILENO, TCSAFLUSH, &orig_attr);
  //fprintf (stderr, "evsource kb destroy\n");
}
#endif

#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/ioctl.h>
#include <errno.h>


#include <linux/input.h>


static int kb_fd = -1;
static void ctx_evsource_kb_raw_destroy (int sign)
{
#if 0
  real_ctx_evsource_kb_raw_destroy (-11);
#endif
  if (kb_fd)
    close (kb_fd);
  kb_fd = 0;
}

static int ctx_kb_raw_open (int skip)
{
  char path[64]="";
  int fd = -1;
  for (int i = 0; i < 10; i++)
  {
    sprintf (path, "/dev/input/event%i", i);
    fd = open(path, O_RDONLY | O_CLOEXEC );
    unsigned long evbits = 0;
    if (fd != -1)
    {
      if (ioctl (fd, EVIOCGBIT(0, sizeof (unsigned long)), &evbits)<0)
      {
        printf ("error on event%i\n", i);
      }
      else
      {
        if ((evbits & (1<<EV_KEY)))
        {
          int got_a = 0;
          int got_z = 0;
          size_t nchar = KEY_MAX/8+1;
          unsigned char bits[nchar];
          if (ioctl (fd, EVIOCGBIT(EV_KEY, sizeof (bits)), &bits)>=0)
          {
            got_a = bits[KEY_A/8] & (1 << (KEY_A & 7));
            got_z = bits[KEY_Z/8] & (1 << (KEY_Z & 7));
          }
          if (got_a && got_z)
          {
            if (skip == 0)
              return fd;
            skip--;
          }
        }
      }
      close (fd);
    }

  }
  return -1;
}

static int ctx_evsource_kb_raw_init ()
{
   for (int skip = 0; skip < 4; skip++)
   {
   kb_fd = ctx_kb_raw_open (skip);

   if( -1 == kb_fd )
   {
     kb_fd = 0;
     continue;
   }

   char name[ 32 ];
   if( -1 == ioctl( kb_fd, EVIOCGNAME( sizeof( name )), name ))
   {
     kb_fd = 0;
     continue;
   }

   if( -1 == ioctl( kb_fd, EVIOCGRAB, (void*)1 ))
   {
     kb_fd = 0;
     continue;
   }

     return 0;
   }
   return -1;
}
static int ctx_evsource_kb_raw_has_event (void)
{
  struct timeval tv;
  int retval;

  fd_set rfds;
  FD_ZERO (&rfds);
  FD_SET(kb_fd, &rfds);
  tv.tv_sec = 0; tv.tv_usec = 0;
  retval = select (kb_fd+1, &rfds, NULL, NULL, &tv);
  return retval == 1;
}

typedef struct CtxRawKey{
  int code;
  const char *name;
  const char *shifted;
} CtxRawKey;


static const CtxRawKey raw_key_map[]=
{
   {KEY_F1, "F1","F1"},
   {KEY_F2, "F2","F2"},
   {KEY_F3, "F3","F3"},
   {KEY_F4, "F4","F4"},
   {KEY_F5, "F5","F5"},
   {KEY_F6, "F6","F6"},
   {KEY_F7, "F7","F7"},
   {KEY_F8, "F8","F8"},
   {KEY_F9, "F9","F9"},
   {KEY_F10, "F10","F10"},
   {KEY_ESC, "escape","escape"},
   {KEY_SPACE, "space","space"},
   {KEY_ENTER, "return","return"},
   {KEY_LEFT, "left","left"},
   {KEY_RIGHT, "right","right"},
   {KEY_UP, "up","up"},
   {KEY_DOWN, "down","down"},
   {KEY_HOME, "home","home"},
   {KEY_END, "end","end"},
   {KEY_PAGEUP, "page-up","page-up"},
   {KEY_PAGEDOWN, "page-down","page-down"},
   {KEY_INSERT, "insert","insert"},
   {KEY_DELETE, "delete","delete"},
   {KEY_LEFTCTRL, "control","control"},
   {KEY_RIGHTCTRL, "control","control"},
   {KEY_LEFTSHIFT, "shift","shift"},
   {KEY_RIGHTSHIFT, "shift","shift"},
   {KEY_LEFTALT, "alt","alt"},
   {KEY_RIGHTALT, "alt","alt"},
   {KEY_MINUS, "-","_"},
   {KEY_EQUAL, "=","+"},
   {KEY_BACKSPACE, "backspace","backspace"},
   {KEY_TAB, "tab","tab"},
   {KEY_GRAVE, "`","~"},
   {KEY_BACKSLASH, "\\","|"},
   {KEY_SLASH, "/","?"},
   {KEY_1, "1","!"},
   {KEY_2, "2","@"},
   {KEY_3, "3","#"},
   {KEY_4, "4","$"},
   {KEY_5, "5","%"},
   {KEY_6, "6","^"},
   {KEY_7, "7","&"},
   {KEY_8, "8","*"},
   {KEY_9, "9","("},
   {KEY_0, "0",")"},

   {KEY_Q, "q","Q"},
   {KEY_W, "w","W"},
   {KEY_E, "e","E"},
   {KEY_R, "r","R"},
   {KEY_T, "t","T"},
   {KEY_Y, "y","Y"},
   {KEY_U, "u","U"},
   {KEY_I, "i","I"},
   {KEY_O, "o","O"},
   {KEY_P, "p","P"},
   {KEY_A, "a","A"},
   {KEY_S, "s","S"},
   {KEY_D, "d","D"},
   {KEY_F, "f","F"},
   {KEY_G, "g","G"},
   {KEY_H, "h","H"},
   {KEY_J, "j","J"},
   {KEY_K, "k","K"},
   {KEY_L, "l","L"},
   {KEY_Z, "z","Z"},
   {KEY_X, "x","X"},
   {KEY_C, "c","C"},
   {KEY_V, "v","V"},
   {KEY_B, "b","B"},
   {KEY_N, "n","N"},
   {KEY_M, "m","M"},
   {KEY_SEMICOLON, ";",":"},
   {KEY_APOSTROPHE, "'", "\""},
   {KEY_EQUAL, "=", "+"},
   {KEY_MINUS, "-", "_"},
   {KEY_COMMA, ",", "<"},
   {KEY_DOT, ".", ">"},
   {KEY_SLASH, "/", "?"},
   {KEY_LEFTBRACE, "[", "{"},
   {KEY_RIGHTBRACE, "]", "}"}
};


static char *ctx_evsource_kb_raw_get_event (void)
{
  struct input_event ev;
  Ctx *ctx = (void*)ctx_ev_src_kb_raw.priv;

  memset (&ev, 0, sizeof (ev));
  if (-1==read(kb_fd, &ev, sizeof(ev)))
  {
    return NULL;
  }
  if (ev.type == EV_KEY)
  {
     for (unsigned int i = 0; i < sizeof(raw_key_map)/sizeof(raw_key_map[0]); i++)
     {
       if (raw_key_map[i].code == ev.code)
       {
          const char *name = raw_key_map[i].name;
          switch (ev.value)
          {
            case 0: /* up */
              ctx_key_up (ctx, 0, name, 0);
              break;
            case 1: /* down */
              ctx_key_down (ctx, 0, name, 0);
              /*FALLTHROUGH*/
            case 2: /* repeat */
              if (strcmp(name,"shift") &&
                  strcmp(name,"control") &&
                  strcmp(name,"alt"))
              ctx_key_press (ctx, 0, name, 0);
              break;
          }
          return NULL;
       }
     }
  }
  return NULL;
}

static int ctx_evsource_kb_raw_get_fd (void)
{
  if (kb_fd >= 0)
    return kb_fd;
  return 0;
}


EvSource *ctx_evsource_kb_raw_new (void)
{
  if (ctx_evsource_kb_raw_init() == 0)
  {
    return &ctx_ev_src_kb_raw;
  }
  return NULL;
}
#endif

#if CTX_RAW_KB_EVENTS

static int ts_is_mt = 0;

static int ctx_evsource_linux_ts_has_event (void);
static char *ctx_evsource_linux_ts_get_event (void);
static void ctx_evsource_linux_ts_destroy (int sign);
static int ctx_evsource_linux_ts_get_fd (void);


/* kept out of struct to be reachable by atexit */
static EvSource ctx_ev_src_linux_ts = {
  NULL,
  (void*)ctx_evsource_linux_ts_has_event,
  (void*)ctx_evsource_linux_ts_get_event,
  (void*)ctx_evsource_linux_ts_destroy,
  (void*)ctx_evsource_linux_ts_get_fd,
  NULL
};

#if 0
static void real_ctx_evsource_linux_ts_destroy (int sign)
{
  static int done = 0;

  if (sign == 0)
    return;

  if (done)
    return;
  done = 1;

  switch (sign)
  {
    case  -11:break; /* will be called from atexit with sign==-11 */
    case   SIGSEGV: break;//fprintf (stderr, " SIGSEGV\n");break;
    case   SIGABRT: fprintf (stderr, " SIGABRT\n");break;
    case   SIGBUS:  fprintf (stderr, " SIGBUS\n");break;
    case   SIGKILL: fprintf (stderr, " SIGKILL\n");break;
    case   SIGINT:  fprintf (stderr, " SIGINT\n");break;
    case   SIGTERM: fprintf (stderr, " SIGTERM\n");break;
    case   SIGQUIT: fprintf (stderr, " SIGQUIT\n");break;
    default: fprintf (stderr, "sign: %i\n", sign);
             fprintf (stderr, "%i %i %i %i %i %i %i\n", SIGSEGV, SIGABRT, SIGBUS, SIGKILL, SIGINT, SIGTERM, SIGQUIT);
  }
  tcsetattr (STDIN_FILENO, TCSAFLUSH, &orig_attr);
  //fprintf (stderr, "evsource kb destroy\n");
}
#endif

#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/ioctl.h>
#include <errno.h>


#include <linux/input.h>

static int ctx_ts_fd = -1;
static void ctx_evsource_linux_ts_destroy (int sign)
{
#if 0
  real_ctx_evsource_linux_ts_destroy (-11);
#endif
  if (ctx_ts_fd)
    close (ctx_ts_fd);
  ctx_ts_fd = 0;
}

static struct input_absinfo ctx_linux_ts_abs_x;
static struct input_absinfo ctx_linux_ts_abs_y;

static int ctx_linux_ts_open (void)
{
  char path[64]="";
  int fd = -1;
  for (int i = 0; i < 10; i++)
  {
    sprintf (path, "/dev/input/event%i", i);
    fd = open(path, O_RDONLY | O_CLOEXEC );
    unsigned long evbits = 0;
    size_t nabs  = ABS_MAX/8+1;
    unsigned char absbits[nabs];
    unsigned long propbits = 0;
    if (fd != -1)
    {
      if (ioctl (fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), &absbits) != -1)
      if (ioctl (fd, EVIOCGPROP(sizeof (unsigned long)), &propbits) != -1)
      if (ioctl (fd, EVIOCGBIT(0, sizeof (unsigned long)), &evbits) != -1)
      {
        if ((evbits & (1<<EV_ABS)))
        {
          int touch = 0;
          size_t nchar = KEY_MAX/8+1;
          unsigned char bits[nchar];
#define CHECK_BIT(bits,bitno)   bits[(bitno)/8] & (1 << ((bitno) & 7));
          if (ioctl (fd, EVIOCGBIT(EV_KEY, sizeof (bits)), &bits)>=0)
            touch = CHECK_BIT(bits, BTN_TOUCH);
          int pointer = propbits & (1<<INPUT_PROP_POINTER);
          int x_axis         = CHECK_BIT(absbits, ABS_X);
          int y_axis         = CHECK_BIT(absbits, ABS_Y);
          int slot           = CHECK_BIT(absbits,ABS_MT_SLOT);
          int x_axis_mt      = CHECK_BIT(absbits,ABS_MT_POSITION_X);
          int y_axis_mt      = CHECK_BIT(absbits,ABS_MT_POSITION_Y);
          int mt_tracking_id = CHECK_BIT(absbits,ABS_MT_TRACKING_ID);
#undef CHECK_BIT

          int touchpad_touchscreen = 0;

          if (getenv("CTX_TOUCHPAD_TOUCHSCREEN")) touchpad_touchscreen = 
                  atoi(getenv("CTX_TOUCHPAD_TOUCHSCREEN"));

          if (   ( !pointer || touchpad_touchscreen) && 
              (x_axis_mt && y_axis_mt && mt_tracking_id && slot))
          { // multi-touch, protocol-B
            ioctl(fd, EVIOCGABS(ABS_MT_POSITION_X), &ctx_linux_ts_abs_x);
            ioctl(fd, EVIOCGABS(ABS_MT_POSITION_Y), &ctx_linux_ts_abs_y);
            ts_is_mt = 1;
            return fd;
          }
          if (touch && !pointer && x_axis && y_axis)
          {
            ioctl(fd, EVIOCGABS(ABS_X), &ctx_linux_ts_abs_x);
            ioctl(fd, EVIOCGABS(ABS_Y), &ctx_linux_ts_abs_y);
            ts_is_mt = 0;
            return fd;
          }
        }
      }
      close (fd);
    }

  }
  return -1;
}

static int ctx_evsource_linux_ts_init ()
{
   ctx_ts_fd = ctx_linux_ts_open ();

   if( -1 == ctx_ts_fd )
   {
     ctx_ts_fd = 0;
     return -1;
   }

   char name[ 32 ];
   if( -1 == ioctl( ctx_ts_fd, EVIOCGNAME( sizeof( name )), name ))
   {
     ctx_ts_fd = 0;
     return -1;
   }

   if( -1 == ioctl( ctx_ts_fd, EVIOCGRAB, (void*)1 ))
   {
     ctx_ts_fd = 0;
     return -1;
   }

  return 0;
}
static int ctx_evsource_linux_ts_has_event (void)
{
  struct timeval tv;
  int retval;

  fd_set rfds;
  FD_ZERO (&rfds);
  FD_SET(ctx_ts_fd, &rfds);
  tv.tv_sec = 0; tv.tv_usec = 0;
  retval = select (ctx_ts_fd+1, &rfds, NULL, NULL, &tv);
  return retval == 1;
}

int ts_x = 0;
int ts_y = 0;

typedef struct MtMtSlot {
  int x;
  int y;
  int id;

  int reported_x;
  int reported_y;
  int reported_id;
} MtMtSlot;

static int mt_slot = 0;


MtMtSlot ctx_mt[CTX_MAX_DEVICES];

static char *ctx_evsource_linux_ts_get_event (void)
{
  struct input_event ev;
  static int down_count = 0;
  memset (&ev, 0, sizeof (ev));
  Ctx *ctx = (void*)ctx_ev_src_mice.priv;
  if (-1==read(ctx_ts_fd, &ev, sizeof(ev)))
  {
    return NULL;
  }

  if (ts_is_mt)
  {
    if (ev.type == EV_ABS)
    {
       switch (ev.code)
       {
          case ABS_MT_POSITION_X:
            ctx_mt[mt_slot].x = (ev.value - ctx_linux_ts_abs_x.minimum) * ctx_width (ctx) / (ctx_linux_ts_abs_x.maximum- ctx_linux_ts_abs_x.minimum + 1);
            break;
          case ABS_MT_POSITION_Y:
            ctx_mt[mt_slot].y = (ev.value - ctx_linux_ts_abs_y.minimum) * ctx_height (ctx) / (ctx_linux_ts_abs_y.maximum- ctx_linux_ts_abs_y.minimum + 1);
            break;
          case ABS_MT_SLOT:
            mt_slot = ev.value;
            if (mt_slot >= CTX_MAX_DEVICES)
              mt_slot = CTX_MAX_DEVICES-1;
            break;
          case ABS_MT_TRACKING_ID:
            ctx_mt[mt_slot].id = ev.value;
            break;
       }
    }
  }
  else
  {
    if (ev.type == EV_KEY)
    {
     if (ev.code == BTN_TOUCH || ev.code == BTN_LEFT)
     {
        int prev_down_count = down_count;

        switch (ev.value)
        {
            case 0: /* up */
              down_count--;
              break;
            case 1: /* down */
              down_count++;
              break;
        }
        if ( (prev_down_count!=0) != (down_count!=0))
        {
           if (down_count)
             ctx_mt[0].id = 23;
           else
             ctx_mt[0].id = -1;
        }
     }
    }
    else if (ev.type == EV_ABS)
    {
      switch (ev.code)
      {
        case ABS_X: ctx_mt[0].x = (ev.value - ctx_linux_ts_abs_x.minimum) * ctx_width (ctx) / (ctx_linux_ts_abs_x.maximum- ctx_linux_ts_abs_x.minimum + 1);
        break;
        case ABS_Y: ctx_mt[0].y = (ev.value - ctx_linux_ts_abs_y.minimum) * ctx_height (ctx) / (ctx_linux_ts_abs_y.maximum- ctx_linux_ts_abs_y.minimum + 1);
        break;
      }
    }
  }

  if (ev.type == EV_SYN && ev.code == SYN_REPORT)
  { 
    for (int i = 0; i < (ts_is_mt?CTX_MAX_DEVICES:1); i++)
    {
      if ((ctx_mt[i].id != ctx_mt[i].reported_id) ||
          (ctx_mt[i].id >= 0 && (
             ctx_mt[i].x != ctx_mt[i].reported_x ||
            ctx_mt[i].y != ctx_mt[i].reported_y)))
      {
         if (ctx_mt[i].id == -1)
            ctx_pointer_release (ctx, ctx_mt[i].x, ctx_mt[i].y, 4+i, 0);
         else if (ctx_mt[i].id != ctx_mt[i].reported_id)
            ctx_pointer_press (ctx, ctx_mt[i].x, ctx_mt[i].y, 4+i, 0);
         else
            ctx_pointer_motion (ctx, ctx_mt[i].x, ctx_mt[i].y, 4+i, 0);

         ctx_mt[i].reported_id = ctx_mt[i].id;
         ctx_mt[i].reported_x  = ctx_mt[i].x;
         ctx_mt[i].reported_y  = ctx_mt[i].y;
      }
    }
  }
  return NULL;
}

static int ctx_evsource_linux_ts_get_fd (void)
{
  if (ctx_ts_fd >= 0)
    return ctx_ts_fd;
  return 0;
}

EvSource *ctx_evsource_linux_ts_new (void)
{
  for (int i = 0; i < CTX_MAX_DEVICES; i++) ctx_mt[i].id=ctx_mt[i].reported_id=-1;

  if (ctx_evsource_linux_ts_init() == 0)
  {
    return &ctx_ev_src_linux_ts;
  }
  return NULL;
}
#endif


#endif

void ctx_queue_draw (Ctx *ctx)
{
  ctx->dirty ++;
}

#if CTX_CURRENT_PATH
int ctx_in_fill_path (Ctx *ctx, float x, float y, CtxDrawlist *path)
{
#if CTX_RASTERIZER
  float x1, y1, x2, y2;
  float width, height;
  float factor = 1.0f;
  ctx_path_extents_path (ctx, &x1, &y1, &x2, &y2, path);
  width = x2-x1;
  height = y2-y1;
  while ((width < 200 || height < 200) && factor < 16.0f)
  {
    width *=2;
    height *=2;
    factor *=2;
  }
  x1 *= factor;
  y1 *= factor;
  x2 *= factor;
  y2 *= factor;
  x *= factor;
  y *= factor;

  if (x1 <= x && x <= x2 && y1 <= y && y <= y2)
  {
     uint32_t pixels[9] = {0,};
     Ctx *tester = ctx_new_for_framebuffer (&pixels[0], 3, 3, 3*4, CTX_FORMAT_RGBA8);
     ctx_translate (tester, -(x-1), -(y-1));
     ctx_scale (tester, factor, factor);
     ctx_gray (tester, 1.0f);
     ctx_append_drawlist (tester, path->entries, path->count*9);
     ctx_fill (tester);
     ctx_destroy (tester);
     if (pixels[1+3] != 0)
       return 1;
     return 0;
  }
#endif
  return 0;
}
#endif

int ctx_in_fill (Ctx *ctx, float x, float y)
{
#if CTX_CURRENT_PATH
  return ctx_in_fill_path (ctx, x, y, &ctx->current_path);
#else
  return 0;
#endif
}

int ctx_in_stroke (Ctx *ctx, float x, float y)
{
#if CTX_RASTERIZER
  float x1, y1, x2, y2;
  float width, height;
  float factor = 1.0f;
  ctx_path_extents (ctx, &x1, &y1, &x2, &y2);
  width = x2-x1;
  height = y2-y1;

  while ((width < 200 || height < 200) && factor < 16.0f)
  {
    width *=2;
    height *=2;
    factor *=2;
  }
  x1 *= factor;
  y1 *= factor;
  x2 *= factor;
  y2 *= factor;
  x *= factor;
  y *= factor;
  if (x1 <= x && x <= x2 && y1 <= y && y <= y2)
  {
#if CTX_CURRENT_PATH
     uint32_t pixels[9] = {0,};
     Ctx *tester = ctx_new_for_framebuffer (&pixels[0], 3, 3, 3*4, CTX_FORMAT_RGBA8);
     ctx_translate (tester, -(x-1), -(y-1));
     ctx_scale (tester, factor, factor);
     ctx_gray (tester, 1.0f);
     ctx_append_drawlist (tester, ctx->current_path.entries, ctx->current_path.count*9);
     ctx_line_width  (tester, ctx_get_line_width  (ctx) * factor);
     ctx_line_cap    (tester, ctx_get_line_cap    (ctx));
     ctx_line_join   (tester, ctx_get_line_join   (ctx));
     ctx_miter_limit (tester, ctx_get_miter_limit (ctx) * factor);
     ctx_stroke (tester);
     ctx_destroy (tester);
     if (pixels[1+3] != 0)
       return 1;
     return 0;
#else
     return 1;
#endif
  }
#endif
  return 0;
}


static void ctx_svg_arc_circle_to (Ctx *ctx,
                                   float radius,
                                   int large,
                                   int sweep,
                                   float x1, float y1)
{
  float x0, y0;
  ctx_current_point (ctx, &x0, &y0);
  int left_side = (large && !sweep) || (sweep && !large);

  float delta_x = (x1-x0) * 0.5f;
  float delta_y = (y1-y0) * 0.5f;

  float midpoint_x = x0 + delta_x;
  float midpoint_y = y0 + delta_y;

  float radius_vec_x;
  float radius_vec_y;
  float r = radius;

  if (left_side)
  {
    radius_vec_x = -delta_y;
    radius_vec_y = delta_x;
  }
  else
  {
    radius_vec_x = delta_y;
    radius_vec_y = -delta_x;
  }

  float len_squared = ctx_pow2(radius_vec_x) + ctx_pow2(radius_vec_y);
  if (len_squared - 0.03f > r * r || r < 0)
  {
    r = ctx_sqrtf (len_squared);
  }

  float center_x = midpoint_x +
           radius_vec_x * ctx_sqrtf(ctx_maxf(0, r * r / len_squared-1));
  float center_y = midpoint_y +
           radius_vec_y * ctx_sqrtf(ctx_maxf(0, r * r / len_squared-1));

  float arc = ctx_asinf(ctx_clampf(ctx_sqrtf(len_squared)/r, -1.0, 1.0))*2;
  if (large) arc = CTX_PI*2-arc;

  float start_angle = ctx_atan2f(y0 - center_y, x0 - center_x);
  float end_angle = sweep?start_angle+arc:start_angle-arc;

  ctx_arc (ctx, center_x, center_y, r, start_angle, end_angle, !sweep);
}


void ctx_svg_arc_to (Ctx *ctx, float rx, float ry, 
                     float rotation,  int large, int sweep,
                     float x1, float y1)
{
  ctx_svg_arc_circle_to (ctx, rx, large, sweep, x1, y1);
  return;
   // XXX the following fails, one reason is that
   // ctx_current_point returns the point in the previous user_space
   // not the current.

  float x0, y0;
  ctx_current_point (ctx, &x0, &y0);
  float radius_min = ctx_hypotf (x1-x0,y1-y0)/2.0f;
  float radius_lim = ctx_hypotf (rx, ry);
  float up_scale = 1.0f;
  if (radius_lim < radius_min)
    up_scale = radius_min / radius_lim;
  float ratio = rx / ry;
  ctx_save (ctx);
  ctx_scale (ctx, up_scale * ratio, up_scale);

  //  the following is a hack, current_point should change instead,
  //  but that can have performance impact on adding coordinates
  ctx->state.x /= (up_scale * ratio);
  ctx->state.y /= (up_scale);


  //ctx_rotate (ctx, rotation);
  
  x1 = x1 / (up_scale * ratio);
  y1 = y1 / (up_scale);

  ctx_svg_arc_circle_to (ctx, rx, large, sweep, x1, y1);

  ctx_restore (ctx);
}

/* the parser comes in the end, nothing in ctx knows about the parser  */

#if CTX_PARSER

/* ctx parser, */

#define CTX_ID_MAXLEN 64 // in use should not be more than 40!
                         // to offer headroom for multiplexing


#define CTX_REPORT_COL_ROW 1


struct
  _CtxParser
{
  Ctx       *ctx;
  CtxParserConfig config;
  int        escape_first_char;
  int        t_args; // total number of arguments seen for current command
  int        state;
#if CTX_PARSER_FIXED_TEMP
  uint8_t    holding[CTX_PARSER_MAXLEN]; /*  */
#else
  uint8_t   *holding;
#endif
  int        hold_len;
  int        pos;

#if CTX_REPORT_COL_ROW
  int        line; /*  for error reporting */
  int        col;  /*  for error reporting */
#endif
  float      numbers[CTX_PARSER_MAX_ARGS+1];
  int        n_numbers;
  int        decimal;
  int        exponent;
  int        exp;
  CtxCode    command;
  int        expected_args; /* low digits are literal higher values
                               carry special meaning */
  int        n_args;
  int        texture_done;
  uint8_t    texture_id[CTX_ID_MAXLEN]; // used in defineTexture only
  uint32_t   set_key_hash;
  float      pcx;
  float      pcy;
  int        color_components;
  int        color_stroke; // 0 is fill source  1 is stroke source
  CtxColorModel   color_model; // 1 gray 3 rgb 4 cmyk
  float      left_margin; // set by last user provided move_to
                          //

  int        translate_origin;

  CtxColorSpace   color_space_slot;

  int   prev_byte;

#if CTX_REPORT_COL_ROW
  char *error;
  int   error_col;
  int   error_row;
#endif
};

void
ctx_parser_set_size (CtxParser *parser,
                 int        width,
                 int        height,
                 float      cell_width,
                 float      cell_height)
{
  if (cell_width > 0)
    parser->config.cell_width       = cell_width;
  if (cell_height > 0)
    parser->config.cell_height      = cell_height;
  if (width > 0)
    parser->config.width            = width;
  if (height > 0)
    parser->config.height           = height;
}

static CtxParser *
ctx_parser_init (CtxParser *parser,
                 Ctx       *ctx,
                 CtxParserConfig *config
                )
{
  memset (parser, 0, sizeof (CtxParser) );
  parser->config = *config;
#if CTX_REPORT_COL_ROW
  parser->line             = 1;
#endif
  parser->ctx              = ctx;
  parser->color_model      = CTX_RGBA;
  parser->color_stroke     = 0;
  parser->color_components = 4;
  parser->command          = CTX_MOVE_TO;
  
#if CTX_PARSER_FIXED_TEMP
  parser->hold_len = CTX_PARSER_MAXLEN;
#else
  int new_len = 512;
  parser->holding = (uint8_t*)ctx_realloc (parser->holding, parser->hold_len, new_len);
  parser->hold_len = new_len;
#endif

  if (parser->config.response)
      parser->config.flags |= CTX_FLAG_HANDLE_ESCAPES;

  return parser;
}

CtxParser *ctx_parser_new (
  Ctx       *ctx,
  CtxParserConfig *config)
{
  return ctx_parser_init ( (CtxParser *) ctx_calloc (sizeof (CtxParser), 1),
                           ctx, config);
}

void ctx_parser_destroy (CtxParser *parser)
{
#if !CTX_PARSER_FIXED_TEMP
  if (parser->holding)
    ctx_free (parser->holding);
#endif
  if (parser->error)
  {
    fprintf (stderr, "ctx parse error: %s\n", parser->error);
    ctx_free (parser->error);
  }
  ctx_free (parser);
}



static int ctx_parser_set_command (CtxParser *parser, CtxCode code)
{
  if (code <= CTX_LAST_COMMAND && code >= 32)
  {
  parser->expected_args = ctx_arguments_for_code (code);
  parser->n_args = 0;
  parser->texture_done = 0;
  if (parser->expected_args >= CTX_ARG_NUMBER_OF_COMPONENTS)
    {
      parser->expected_args = (parser->expected_args % 100) + parser->color_components;
    }
  }
  return code;
}

static void ctx_parser_set_color_model (CtxParser *parser, CtxColorModel color_model, int stroke);

static int ctx_parser_resolve_command (CtxParser *parser, const uint8_t *str)
{
  uint32_t ret = str[0]; /* if it is single char it already is the CtxCode */

  /* this is handled outside the hashing to make it possible to be case insensitive
   * with the rest.
   */
  if (str[0] == CTX_SET_KEY && str[1] && str[2] == 0)
  {
    switch (str[1])
    {
      case 'm': return ctx_parser_set_command (parser, CTX_COMPOSITING_MODE);
      case 'B': return ctx_parser_set_command (parser, CTX_BLEND_MODE);
      case 'e': return ctx_parser_set_command (parser, CTX_EXTEND);
      case 'l': return ctx_parser_set_command (parser, CTX_MITER_LIMIT);
      case 't': return ctx_parser_set_command (parser, CTX_TEXT_ALIGN);
      case 'b': return ctx_parser_set_command (parser, CTX_TEXT_BASELINE);
      case 'd': return ctx_parser_set_command (parser, CTX_TEXT_DIRECTION);
      case 'j': return ctx_parser_set_command (parser, CTX_LINE_JOIN);
      case 'c': return ctx_parser_set_command (parser, CTX_LINE_CAP);
      case 'w': return ctx_parser_set_command (parser, CTX_LINE_WIDTH);
      case 'D': return ctx_parser_set_command (parser, CTX_LINE_DASH_OFFSET);
      case 'p': return ctx_parser_set_command (parser, CTX_STROKE_POS);
      case 'F': return ctx_parser_set_command (parser, CTX_FEATHER);
      case 'H': return ctx_parser_set_command (parser, CTX_LINE_HEIGHT);
      case 'L': return ctx_parser_set_command (parser, CTX_WRAP_LEFT);
      case 'R': return ctx_parser_set_command (parser, CTX_WRAP_RIGHT);
      case 'S': return ctx_parser_set_command (parser, CTX_IMAGE_SMOOTHING);
      case 'C': return ctx_parser_set_command (parser, CTX_SHADOW_COLOR);
      case 's': return ctx_parser_set_command (parser, CTX_SHADOW_BLUR);
      case 'x': return ctx_parser_set_command (parser, CTX_SHADOW_OFFSET_X);
      case 'y': return ctx_parser_set_command (parser, CTX_SHADOW_OFFSET_Y);
      case 'a': return ctx_parser_set_command (parser, CTX_GLOBAL_ALPHA);
      case 'f': return ctx_parser_set_command (parser, CTX_FONT_SIZE);
      case 'r': return ctx_parser_set_command (parser, CTX_FILL_RULE);
    }
  }

  if (str[0] && str[1])
    {
      uint32_t str_hash;
      /* trim ctx_ and CTX_ prefix */
      if ( (str[0] == 'c' && str[1] == 't' && str[2] == 'x' && str[3] == '_') ||
           (str[0] == 'C' && str[1] == 'T' && str[2] == 'X' && str[3] == '_') )
        {
          str += 4;
        }
      if ( (str[0] == 's' && str[1] == 'e' && str[2] == 't' && str[3] == '_') )
        { str += 4; }
      str_hash = ctx_strhash ( (char *) str);
      switch (str_hash)
        {
          /* first a list of mappings to one_char hashes, handled in a
           * separate fast path switch without hashing
           */
          case SQZ_arcTo:          ret = CTX_ARC_TO; break;
          case SQZ_arc:            ret = CTX_ARC; break;
          case SQZ_curveTo:        ret = CTX_CURVE_TO; break;
          case SQZ_restore:        ret = CTX_RESTORE; break;
          case SQZ_stroke:         ret = CTX_STROKE; break;
          case SQZ_fill:           ret = CTX_FILL; break;
          case SQZ_paint:          ret = CTX_PAINT; break;
          case SQZ_preserve:       ret = CTX_PRESERVE; break;
          case SQZ_horLineTo:      ret = CTX_HOR_LINE_TO; break;
          case SQZ_rotate:         ret = CTX_ROTATE; break;
          case SQZ_color:          ret = CTX_COLOR; break;
          case SQZ_lineTo:         ret = CTX_LINE_TO; break;
          case SQZ_moveTo:         ret = CTX_MOVE_TO; break;
          case SQZ_scale:          ret = CTX_SCALE; break;
          case SQZ_newPage:        ret = CTX_NEW_PAGE; break;
          case SQZ_quadTo:         ret = CTX_QUAD_TO; break;
          case SQZ_viewBox:        ret = CTX_VIEW_BOX; break;
          case SQZ_smoothTo:       ret = CTX_SMOOTH_TO; break;
          case SQZ_smoothQuadTo:   ret = CTX_SMOOTHQ_TO; break;
          case SQZ_clear:          ret = CTX_COMPOSITE_CLEAR; break;
          case SQZ_copy:           ret = CTX_COMPOSITE_COPY; break;
          case SQZ_destinationOver:  ret = CTX_COMPOSITE_DESTINATION_OVER; break;
          case SQZ_destinationIn:    ret = CTX_COMPOSITE_DESTINATION_IN; break;
          case SQZ_destinationOut:   ret = CTX_COMPOSITE_DESTINATION_OUT; break;
          case SQZ_sourceOver:       ret = CTX_COMPOSITE_SOURCE_OVER; break;
          case SQZ_sourceAtop:       ret = CTX_COMPOSITE_SOURCE_ATOP; break;
          case SQZ_destinationAtop:  ret = CTX_COMPOSITE_DESTINATION_ATOP; break;
          case SQZ_sourceOut:        ret = CTX_COMPOSITE_SOURCE_OUT; break;
          case SQZ_sourceIn:         ret = CTX_COMPOSITE_SOURCE_IN; break;
          case SQZ_xor:              ret = CTX_COMPOSITE_XOR; break;
          case SQZ_darken:           ret = CTX_BLEND_DARKEN; break;
          case SQZ_lighten:          ret = CTX_BLEND_LIGHTEN; break;
          //case SQZ_color:          ret = CTX_BLEND_COLOR; break;
          //
          //  XXX check that he special casing for color works
          //      it is the first collision and it is due to our own
          //      color, not w3c for now unique use of it
          //
          case SQZ_hue:            ret = CTX_BLEND_HUE; break;
          case SQZ_multiply:       ret = CTX_BLEND_MULTIPLY; break;
          case SQZ_normal:         ret = CTX_BLEND_NORMAL;break;
          case SQZ_screen:         ret = CTX_BLEND_SCREEN;break;
          case SQZ_difference:     ret = CTX_BLEND_DIFFERENCE; break;
          case SQZ_startFrame:     ret = CTX_START_FRAME; break;
          case SQZ_verLineTo:      ret = CTX_VER_LINE_TO; break;
          case SQZ_endFrame:       ret = CTX_END_FRAME; break;
          case SQZ_closePath:      ret = CTX_CLOSE_PATH; break;
          case SQZ_resetPath:
          case SQZ_beginPath:
          case SQZ_newPath:        ret = CTX_RESET_PATH; break;
          case SQZ_relArcTo:       ret = CTX_REL_ARC_TO; break;
          case SQZ_clip:           ret = CTX_CLIP; break;
          case SQZ_relCurveTo:     ret = CTX_REL_CURVE_TO; break;
          case SQZ_startGroup:     ret = CTX_START_GROUP; break;
          case SQZ_endGroup:       ret = CTX_END_GROUP; break;
          case SQZ_save:           ret = CTX_SAVE; break;
          case SQZ_translate:      ret = CTX_TRANSLATE; break;
          case SQZ_linearGradient: ret = CTX_LINEAR_GRADIENT; break;
          case SQZ_conicGradient:  ret = CTX_CONIC_GRADIENT; break;
          case SQZ_relHorLineTo:   ret = CTX_REL_HOR_LINE_TO; break;
          case SQZ_relLineTo:      ret = CTX_REL_LINE_TO; break;
          case SQZ_relMoveTo:      ret = CTX_REL_MOVE_TO; break;
          case SQZ_font:           ret = CTX_FONT; break;
          case SQZ_radialGradient:ret = CTX_RADIAL_GRADIENT; break;
          case SQZ_gradientAddStop:
          case SQZ_addStop:        ret = CTX_GRADIENT_STOP; break;
          case SQZ_relQuadTo:      ret = CTX_REL_QUAD_TO; break;
          case SQZ_rectangle:
          case SQZ_rect:           ret = CTX_RECTANGLE; break;
          case SQZ_roundRectangle: ret = CTX_ROUND_RECTANGLE; break;
          case SQZ_relSmoothTo:    ret = CTX_REL_SMOOTH_TO; break;
          case SQZ_relSmoothqTo:   ret = CTX_REL_SMOOTHQ_TO; break;
          case SQZ_strokeRect:     ret = CTX_STROKE_RECT; break;
          case SQZ_fillRect:       ret = CTX_FILL_RECT; break;
          case SQZ_relVerLineTo:   ret = CTX_REL_VER_LINE_TO; break;
          case SQZ_text:           ret = CTX_TEXT; break;
          case SQZ_identity:       ret = CTX_IDENTITY; break;
          case SQZ_transform:      ret = CTX_APPLY_TRANSFORM; break;
          case SQZ_sourceTransform: ret = CTX_SOURCE_TRANSFORM; break;
          case SQZ_texture:        ret = CTX_TEXTURE; break;
          case SQZ_defineTexture:  ret = CTX_DEFINE_TEXTURE; break;
#if 0
          case SQZ_rgbSpace:
            return ctx_parser_set_command (parser, CTX_SET_RGB_SPACE);
          case SQZ_cmykSpace:
            return ctx_parser_set_command (parser, CTX_SET_CMYK_SPACE);
          case SQZ_drgbSpace:
            return ctx_parser_set_command (parser, CTX_SET_DRGB_SPACE);
#endif
          case SQZ_defineFont:
            return ctx_parser_set_command (parser, CTX_DEFINE_FONT);
          case SQZ_defineGlyph:
            return ctx_parser_set_command (parser, CTX_DEFINE_GLYPH);
          case SQZ_kerningPair:
            return ctx_parser_set_command (parser, CTX_KERNING_PAIR);

          case SQZ_colorSpace:
            return ctx_parser_set_command (parser, CTX_COLOR_SPACE);
          case SQZ_fillRule:
            return ctx_parser_set_command (parser, CTX_FILL_RULE);
          case SQZ_fontSize:
          case SQZ_setFontSize:
            return ctx_parser_set_command (parser, CTX_FONT_SIZE);
          case SQZ_compositingMode:
            return ctx_parser_set_command (parser, CTX_COMPOSITING_MODE);

          case SQZ_extend:
            return ctx_parser_set_command (parser, CTX_EXTEND);

          case SQZ_blend:
          case SQZ_blending:
          case SQZ_blendMode:
            return ctx_parser_set_command (parser, CTX_BLEND_MODE);

          case SQZ_miterLimit:
            return ctx_parser_set_command (parser, CTX_MITER_LIMIT);
          case SQZ_textAlign:
            return ctx_parser_set_command (parser, CTX_TEXT_ALIGN);
          case SQZ_textBaseline:
            return ctx_parser_set_command (parser, CTX_TEXT_BASELINE);
          case SQZ_textDirection:
            return ctx_parser_set_command (parser, CTX_TEXT_DIRECTION);
          case SQZ_join:
          case SQZ_lineJoin:
          case SQZ_setLineJoin:
            return ctx_parser_set_command (parser, CTX_LINE_JOIN);
          case SQZ_glyph:
            return ctx_parser_set_command (parser, CTX_GLYPH);
          case SQZ_cap:
          case SQZ_lineCap:
          case SQZ_setLineCap:
            return ctx_parser_set_command (parser, CTX_LINE_CAP);
          case SQZ_lineDash:
            return ctx_parser_set_command (parser, CTX_LINE_DASH);
          case SQZ_lineWidth:
          case SQZ_setLineWidth:
            return ctx_parser_set_command (parser, CTX_LINE_WIDTH);
          case SQZ_lineDashOffset:
            return ctx_parser_set_command (parser, CTX_LINE_DASH_OFFSET);
          case SQZ_strokePos:
            return ctx_parser_set_command (parser, CTX_STROKE_POS);
          case SQZ_feather:
            return ctx_parser_set_command (parser, CTX_FEATHER);
          case SQZ_lineHeight:
            return ctx_parser_set_command (parser, CTX_LINE_HEIGHT);
          case SQZ_wrapLeft:
            return ctx_parser_set_command (parser, CTX_WRAP_LEFT);
          case SQZ_wrapRight:
            return ctx_parser_set_command (parser, CTX_WRAP_RIGHT);
          case SQZ_imageSmoothing:
            return ctx_parser_set_command (parser, CTX_IMAGE_SMOOTHING);
          case SQZ_shadowColor:
            return ctx_parser_set_command (parser, CTX_SHADOW_COLOR);
          case SQZ_shadowBlur:
            return ctx_parser_set_command (parser, CTX_SHADOW_BLUR);
          case SQZ_shadowOffsetX:
            return ctx_parser_set_command (parser, CTX_SHADOW_OFFSET_X);
          case SQZ_shadowOffsetY:
            return ctx_parser_set_command (parser, CTX_SHADOW_OFFSET_Y);
          case SQZ_globalAlpha:
            return ctx_parser_set_command (parser, CTX_GLOBAL_ALPHA);

          case SQZ_strokeSource:
            return ctx_parser_set_command (parser, CTX_STROKE_SOURCE);

          /* strings are handled directly here,
           * instead of in the one-char handler, using return instead of break
           */
          case SQZ_gray:
            ctx_parser_set_color_model (parser, CTX_GRAY, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_graya:
            ctx_parser_set_color_model (parser, CTX_GRAYA, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_rgb:
            ctx_parser_set_color_model (parser, CTX_RGB, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_drgb:
            ctx_parser_set_color_model (parser, CTX_DRGB, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_rgba:
            ctx_parser_set_color_model (parser, CTX_RGBA, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_drgba:
            ctx_parser_set_color_model (parser, CTX_DRGBA, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_cmyk:
            ctx_parser_set_color_model (parser, CTX_CMYK, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_cmyka:
            ctx_parser_set_color_model (parser, CTX_CMYKA, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_lab:
            ctx_parser_set_color_model (parser, CTX_LAB, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_laba:
            ctx_parser_set_color_model (parser, CTX_LABA, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_lch:
            ctx_parser_set_color_model (parser, CTX_LCH, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_lcha:
            ctx_parser_set_color_model (parser, CTX_LCHA, 0);
            return ctx_parser_set_command (parser, CTX_COLOR);

          /* and a full repeat of the above, with S for Stroke suffix */
          case SQZ_grayS:
            ctx_parser_set_color_model (parser, CTX_GRAY, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_grayaS:
            ctx_parser_set_color_model (parser, CTX_GRAYA, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_rgbS:
            ctx_parser_set_color_model (parser, CTX_RGB, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_drgbS:
            ctx_parser_set_color_model (parser, CTX_DRGB, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_rgbaS:
            ctx_parser_set_color_model (parser, CTX_RGBA, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_drgbaS:
            ctx_parser_set_color_model (parser, CTX_DRGBA, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_cmykS:
            ctx_parser_set_color_model (parser, CTX_CMYK, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_cmykaS:
            ctx_parser_set_color_model (parser, CTX_CMYKA, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_labS:
            ctx_parser_set_color_model (parser, CTX_LAB, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_labaS:
            ctx_parser_set_color_model (parser, CTX_LABA, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_lchS:
            ctx_parser_set_color_model (parser, CTX_LCH, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);
          case SQZ_lchaS:
            ctx_parser_set_color_model (parser, CTX_LCHA, 1);
            return ctx_parser_set_command (parser, CTX_COLOR);

          /* words that correspond to low integer constants
          */
          case SQZ_nonzero:     return CTX_FILL_RULE_WINDING;
          case SQZ_winding:     return CTX_FILL_RULE_WINDING;
          case SQZ_evenOdd:     return CTX_FILL_RULE_EVEN_ODD;
          case SQZ_bevel:       return CTX_JOIN_BEVEL;
          case SQZ_round:       return CTX_JOIN_ROUND;
          case SQZ_miter:       return CTX_JOIN_MITER;
          case SQZ_none:        return CTX_CAP_NONE;
          case SQZ_square:      return CTX_CAP_SQUARE;
          case SQZ_start:       return CTX_TEXT_ALIGN_START;
          case SQZ_end:         return CTX_TEXT_ALIGN_END;
          case SQZ_left:        return CTX_TEXT_ALIGN_LEFT;
          case SQZ_right:       return CTX_TEXT_ALIGN_RIGHT;
          case SQZ_center:      return CTX_TEXT_ALIGN_CENTER;
          case SQZ_top:         return CTX_TEXT_BASELINE_TOP;
          case SQZ_bottom :     return CTX_TEXT_BASELINE_BOTTOM;
          case SQZ_middle:      return CTX_TEXT_BASELINE_MIDDLE;
          case SQZ_alphabetic:  return CTX_TEXT_BASELINE_ALPHABETIC;
          case SQZ_hanging:     return CTX_TEXT_BASELINE_HANGING;
          case SQZ_ideographic: return CTX_TEXT_BASELINE_IDEOGRAPHIC;

          case SQZ_userRGB:     return CTX_COLOR_SPACE_USER_RGB;
          case SQZ_deviceRGB:   return CTX_COLOR_SPACE_DEVICE_RGB;
          case SQZ_userCMYK:    return CTX_COLOR_SPACE_USER_CMYK;
          case SQZ_deviceCMYK:  return CTX_COLOR_SPACE_DEVICE_CMYK;
#undef STR
#undef LOWER
          default:
            ret = str_hash;
        }
    }
  if (ret == CTX_CLOSE_PATH2)
   {
     ret = CTX_CLOSE_PATH;
   }

  return ctx_parser_set_command (parser, (CtxCode) ret);
}

enum
{
  CTX_PARSER_NEUTRAL = 0,
  CTX_PARSER_NUMBER,
  CTX_PARSER_NEGATIVE_NUMBER,
  CTX_PARSER_WORD,
  CTX_PARSER_COMMENT,
  CTX_PARSER_STRING_APOS,
  CTX_PARSER_STRING_QUOT,
  CTX_PARSER_STRING_APOS_ESCAPED,
  CTX_PARSER_STRING_QUOT_ESCAPED,
  CTX_PARSER_STRING_A85,
  CTX_PARSER_STRING_YENC,
  CTX_PARSER_ESCAPE

} CTX_STATE;


int ctx_parser_neutral (CtxParser *parser)
{
  return parser->state == CTX_PARSER_NEUTRAL;
}

static void ctx_parser_set_color_model (CtxParser *parser, CtxColorModel color_model, int stroke)
{
  parser->color_model      = color_model;
  parser->color_stroke     = stroke;
  parser->color_components = ctx_color_model_get_components (color_model);
}

static void ctx_parser_get_color_rgba (CtxParser *parser, int offset, float *red, float *green, float *blue, float *alpha)
{
  /* XXX - this function is to be deprecated */
  *alpha = 1.0f;
  switch (parser->color_model)
    {
      case CTX_GRAYA:
        *alpha = parser->numbers[offset + 1];
        /* FALLTHROUGH */
      case CTX_GRAY:
        *red = *green = *blue = parser->numbers[offset + 0];
        break;
      default:
      case CTX_LABA: // NYI - needs RGB profile
      case CTX_LCHA: // NYI - needs RGB profile
      case CTX_RGBA:
        *alpha = parser->numbers[offset + 3];
        /* FALLTHROUGH */
      case CTX_LAB: // NYI
      case CTX_LCH: // NYI
      case CTX_RGB:
        *red = parser->numbers[offset + 0];
        *green = parser->numbers[offset + 1];
        *blue = parser->numbers[offset + 2];
        break;
      case CTX_CMYKA:
        *alpha = parser->numbers[offset + 4];
        /* FALLTHROUGH */
      case CTX_CMYK:
        /* should use profile instead  */
        *red = (1.0f-parser->numbers[offset + 0]) *
               (1.0f - parser->numbers[offset + 3]);
        *green = (1.0f-parser->numbers[offset + 1]) *
                 (1.0f - parser->numbers[offset + 3]);
        *blue = (1.0f-parser->numbers[offset + 2]) *
                (1.0f - parser->numbers[offset + 3]);
        break;
    }
}

static inline int ctx_clamp (int val, int min, int max)
{
  if (val < min) return min;
  if (val > max) return max;
  return val;
}

#if CTX_EVENTS

static void
ctx_parser_response (CtxParser *parser, char *buf, int len)
{
  if (parser->config.response)
  {
    void *user_data = parser->config.response_user_data?
                      parser->config.response_user_data:
                      parser->config.user_data;
    parser->config.response (parser->ctx, user_data, buf, len);
  }
}

static void
ctx_parser_motion (CtxEvent *event, void *data1, void *data2)
{
  char buf[128];
  snprintf (buf, sizeof(buf)-1, "pm %.0f %.0f %i\n", event->x, event->y, event->device_no);
  ctx_parser_response ((CtxParser*)data1, buf, strlen (buf));
}

static void
ctx_parser_press (CtxEvent *event, void *data1, void *data2)
{
  char buf[128];
  snprintf (buf, sizeof(buf)-1, "pp %.0f %.0f %i\n", event->x, event->y, event->device_no);
  ctx_parser_response ((CtxParser*)data1, buf, strlen (buf));
}

static void
ctx_parser_release (CtxEvent *event, void *data1, void *data2)
{
  char buf[128];
  snprintf (buf, sizeof(buf)-1, "pr %.0f %.0f %i\n", event->x, event->y, event->device_no);
  ctx_parser_response ((CtxParser*)data1, buf, strlen (buf));
}

static void
ctx_parser_key_down (CtxEvent *event, void *data1, void *data2)
{
  char buf[128];
  snprintf (buf, sizeof(buf)-1, "keydown %s\n", event->string);
  ctx_parser_response ((CtxParser*)data1, buf, strlen (buf));
}

static void
ctx_parser_key_up (CtxEvent *event, void *data1, void *data2)
{
  char buf[128];
  snprintf (buf, sizeof(buf)-1, "keyup %s\n", event->string);
  ctx_parser_response ((CtxParser*)data1, buf, strlen (buf));
}

static void
ctx_parser_key_press (CtxEvent *event, void *data1, void *data2)
{
  char buf[128];
  snprintf (buf, sizeof(buf)-1, "%s\n", event->string);
  ctx_parser_response ((CtxParser*)data1, buf, strlen (buf));
}
#endif

static void ctx_parser_dispatch_command (CtxParser *parser)
{
  CtxCode cmd = parser->command;
  Ctx *ctx = parser->ctx;
  if (parser->error)
    return;

  if (parser->expected_args != CTX_ARG_STRING_OR_NUMBER &&
      parser->expected_args != CTX_ARG_COLLECT_NUMBERS &&
      parser->expected_args != parser->n_numbers)
    {
#if CTX_REPORT_COL_ROW
       char *error = (char*)ctx_malloc (256);
       sprintf (error, "ctx:%i:%i %c got %i instead of %i args\n",
               parser->line, parser->col,
               cmd, parser->n_numbers, parser->expected_args);
       parser->error = error;
#endif
      return;
    }

#define arg(a)  (parser->numbers[a])
  parser->command = CTX_NOP;
  //parser->n_args = 0;
  switch (cmd)
    {
      default:
        break; // to silence warnings about missing ones
      case CTX_PRESERVE:
        ctx_preserve (ctx);
        break;
      case CTX_FILL:
        ctx_fill (ctx);
        break;
      case CTX_PAINT:
        ctx_paint (ctx);
        break;
      case CTX_SAVE:
        ctx_save (ctx);
        break;
      case CTX_START_GROUP:
        ctx_start_group (ctx);
        break;
      case CTX_END_GROUP:
        ctx_end_group (ctx);
        break;
      case CTX_STROKE:
        ctx_stroke (ctx);
        break;
      case CTX_STROKE_SOURCE:
        ctx_stroke_source (ctx);
        break;
      case CTX_RESTORE:
        ctx_restore (ctx);
        break;
#if CTX_ENABLE_CM
      case CTX_COLOR_SPACE:
        if (parser->n_numbers == 1)
        {
          parser->color_space_slot = (CtxColorSpace) ctx_clamp(arg(0), 0, CTX_COLOR_SPACE_LAST);
          parser->command = CTX_COLOR_SPACE; // did this work without?
        }
        else
        {
          ctx_colorspace (ctx, (CtxColorSpace)parser->color_space_slot,
                               parser->holding, parser->pos);
        }
        break;
#endif
      case CTX_KERNING_PAIR:
        switch (parser->n_args)
        {
          case 0:
            parser->numbers[0] = ctx_utf8_to_unichar ((char*)parser->holding);
            break;
          case 1:
            parser->numbers[1] = ctx_utf8_to_unichar ((char*)parser->holding);
            break;
          case 2:
            parser->numbers[2] = _ctx_parse_float ((char*)parser->holding, NULL);
            {
              CtxEntry e = {CTX_KERNING_PAIR, {{0},}};
              e.data.u16[0] = (uint16_t)parser->numbers[0];
              e.data.u16[1] = (uint16_t)parser->numbers[1];
              e.data.s32[1] = (int32_t)(parser->numbers[2] * 256);
              ctx_process (ctx, &e);
            }
            break;
        }
        parser->command = CTX_KERNING_PAIR;
        parser->n_args ++; // make this more generic?
        break;             
      case CTX_TEXTURE:
        if (parser->texture_done)
        {
        }
        else
        if (parser->n_numbers == 2)
        {
          const char *eid = (char*)parser->holding;
          float x0 = arg(0);
          float x1 = arg(1);
          ctx_texture (ctx, eid, x0, x1);
          parser->texture_done = 1;
        }
        parser->command = CTX_TEXTURE;
        //parser->n_args++;
        break;
      case CTX_DEFINE_TEXTURE:
        if (parser->texture_done)
        {
          if (parser->texture_done++ == 1)
          {
             const char *eid = (char*)parser->texture_id;
             int width  = (int)arg(0);
             int height = (int)arg(1);
             CtxPixelFormat format = (CtxPixelFormat)arg(2);
             if (width > 0 && height > 0 && width < 65536 && height < 65536 && ctx_pixel_format_info (format))
             {
             int stride = ctx_pixel_format_get_stride (format, width);
             int data_len = stride * height;
             if (format == CTX_FORMAT_YUV420)
                 data_len = height * width + 2*(height/2) * (width/2);
          {


             if (parser->pos != data_len)
             {
#if 0
             fprintf (stderr, "unexpected datasize for define texture %s %ix%i\n size:%i != expected:%i - start of data: %i %i %i %i\n", eid, width, height,
                               parser->pos,
                               stride * height,
                               parser->holding[0],
                               parser->holding[1],
                               parser->holding[2],
                               parser->holding[3]
                               );
#endif
             }
             else
             ctx_define_texture (ctx, eid, width, height, stride, format, parser->holding, NULL);
             }
             }
          }
        }
        else
        {
        switch (parser->n_numbers)
        {
          case 0:
             strncpy ((char*)parser->texture_id, (char*)parser->holding, sizeof(parser->texture_id));
             parser->texture_id[sizeof(parser->texture_id)-1]=0;
             break;
          case 1:
          case 2:
             break;
          case 3:
             parser->texture_done = 1;
             break;
          default:
             fprintf (stderr, "!!%i\n", parser->n_numbers);
             break;
        }
        }
        parser->command = CTX_DEFINE_TEXTURE;
        break;

      case CTX_DEFINE_FONT:
        // XXX: todo
        break;

      case CTX_DEFINE_GLYPH:
        /* XXX : reuse n_args logic - to enforce order */
        if (parser->n_numbers == 1)
        {
          CtxEntry e = {CTX_DEFINE_GLYPH, {{0},}};
          e.data.u32[0] = parser->color_space_slot;
          e.data.u32[1] = (int)arg(0) * 256;
          ctx_process (ctx, &e);
        }
        else
        {
          int unichar = ctx_utf8_to_unichar ((char*)parser->holding);
          parser->color_space_slot = (CtxColorSpace)unichar;
        }
        parser->command = CTX_DEFINE_GLYPH;
        break;             

      case CTX_COLOR:
        {
          switch (parser->color_model)
            {
              case CTX_GRAY:
              case CTX_GRAYA:
              case CTX_RGB:
              case CTX_RGBA:
              case CTX_DRGB:
              case CTX_DRGBA:
                ctx_color_raw (ctx, parser->color_model, parser->numbers, parser->color_stroke);
                break;
#if CTX_ENABLE_CMYK
              case CTX_CMYK:
              case CTX_CMYKA:
                ctx_color_raw (ctx, parser->color_model, parser->numbers, parser->color_stroke);
                break;
#else
              /* when there is no cmyk support at all in rasterizer
               * do a naive mapping to RGB on input.
               */
              case CTX_CMYK:
              case CTX_CMYKA:
              case CTX_DCMYKA:
                {
                  float rgba[4] = {1,1,1,1.0f};

                  ctx_cmyk_to_rgb (arg(0), arg(1), arg(2), arg(3), &rgba[0], &rgba[1], &rgba[2]);
                  if (parser->color_model == CTX_CMYKA)
                    { rgba[3] = arg(4); }
                  ctx_color_raw (ctx, CTX_RGBA, rgba, parser->color_stroke);
                }
                break;
#endif
              case CTX_LAB:
              case CTX_LCH:
              default:
                break;
            }
        }
        break;
      case CTX_LINE_DASH:
        if (parser->n_numbers)
        {
          ctx_line_dash (ctx, parser->numbers, parser->n_numbers);
        }
        else
        {
          ctx_line_dash (ctx, NULL, 0);
        }
        //append_dash_val (ctx, arg(0));
        break;
      case CTX_ARC_TO:
        ctx_svg_arc_to (ctx, arg(0), arg(1), arg(2), (int)arg(3), (int)arg(4), arg(5), arg(6));
        break;
      case CTX_REL_ARC_TO:
        //ctx_rel_arc_to (ctx, arg(0), arg(1), arg(2), arg(3), arg(4) );
        //
        {
          float x = ctx_x (ctx);
          float y = ctx_y (ctx);
          ctx_svg_arc_to (ctx, arg(0), arg(1), arg(2), (int)arg(3), (int)arg(4), arg(5)+x, arg(6)+y);
        }
        break;
      case CTX_REL_SMOOTH_TO:
        {
          float cx = parser->pcx;
          float cy = parser->pcy;
          float ox = ctx_x (ctx);
          float oy = ctx_y (ctx);
          float ax = 2 * ox - cx;
          float ay = 2 * oy - cy;
          parser->pcx = arg(0) + ox;
          parser->pcy = arg(1) + oy;
          ctx_curve_to (ctx, ax, ay, arg(0) +  ox, arg(1) + oy,
                        arg(2) + ox, arg(3) + oy);
        }
        break;
      case CTX_SMOOTH_TO:
        {
          float cx = parser->pcx;
          float cy = parser->pcy;
          float ox = ctx_x (ctx);
          float oy = ctx_y (ctx);
          float ax = 2 * ox - cx;
          float ay = 2 * oy - cy;
          ctx_curve_to (ctx, ax, ay, arg(0), arg(1),
                        arg(2), arg(3) );
          parser->pcx = arg(0);
          parser->pcy = arg(1);
        }
        break;
      case CTX_SMOOTHQ_TO:
        parser->pcx = 2 * ctx_x (ctx) - parser->pcx;
        parser->pcy = 2 * ctx_y (ctx) - parser->pcy;
        ctx_quad_to (ctx, parser->pcx, parser->pcy, arg(0), arg(1) );
        break;
      case CTX_REL_SMOOTHQ_TO:
        {
          float x = ctx_x (ctx);
          float y = ctx_y (ctx);
          parser->pcx = 2 * x - parser->pcx;
          parser->pcy = 2 * y - parser->pcy;
          ctx_quad_to (ctx, parser->pcx, parser->pcy, arg(0) + x, arg(1) + y);
        }
        break;
      case CTX_VER_LINE_TO:
        ctx_line_to (ctx, ctx_x (ctx), arg(0) );
        parser->command = CTX_VER_LINE_TO;
        parser->pcx = ctx_x (ctx);
        parser->pcy = ctx_y (ctx);
        break;
      case CTX_HOR_LINE_TO:
        ctx_line_to (ctx, arg(0), ctx_y (ctx) );
        parser->command = CTX_HOR_LINE_TO;
        parser->pcx = ctx_x (ctx);
        parser->pcy = ctx_y (ctx);
        break;
      case CTX_REL_HOR_LINE_TO:
        ctx_rel_line_to (ctx, arg(0), 0.0f);
        parser->command = CTX_REL_HOR_LINE_TO;
        parser->pcx = ctx_x (ctx);
        parser->pcy = ctx_y (ctx);
        break;
      case CTX_REL_VER_LINE_TO:
        ctx_rel_line_to (ctx, 0.0f, arg(0) );
        parser->command = CTX_REL_VER_LINE_TO;
        parser->pcx = ctx_x (ctx);
        parser->pcy = ctx_y (ctx);
        break;
      case CTX_ARC:
        ctx_arc (ctx, arg(0), arg(1), arg(2), arg(3), arg(4), (int)arg(5));
        break;
      case CTX_APPLY_TRANSFORM:
        ctx_apply_transform (ctx, arg(0), arg(1), arg(2), arg(3), arg(4), arg(5) , arg(6), arg(7), arg(8));
        break;
      case CTX_SOURCE_TRANSFORM:
        ctx_source_transform (ctx, arg(0), arg(1), arg(2), arg(3), arg(4), arg(5), arg(6), arg(7), arg(8));
        break;
      case CTX_CURVE_TO:
        ctx_curve_to (ctx, arg(0), arg(1), arg(2), arg(3), arg(4), arg(5) );
        parser->pcx = arg(2);
        parser->pcy = arg(3);
        parser->command = CTX_CURVE_TO;
        break;
      case CTX_REL_CURVE_TO:
        parser->pcx = arg(2) + ctx_x (ctx);
        parser->pcy = arg(3) + ctx_y (ctx);
        ctx_rel_curve_to (ctx, arg(0), arg(1), arg(2), arg(3), arg(4), arg(5) );
        parser->command = CTX_REL_CURVE_TO;
        break;
      case CTX_LINE_TO:
        ctx_line_to (ctx, arg(0), arg(1) );
        parser->command = CTX_LINE_TO;
        parser->pcx = arg(0);
        parser->pcy = arg(1);
        break;
      case CTX_MOVE_TO:
        ctx_move_to (ctx, arg(0), arg(1) );
        parser->command = CTX_LINE_TO;
        parser->pcx = arg(0);
        parser->pcy = arg(1);
        parser->left_margin = parser->pcx;
        break;
      case CTX_FONT_SIZE:
        ctx_font_size (ctx, arg(0) );
        break;
      case CTX_MITER_LIMIT:
        ctx_miter_limit (ctx, arg(0) );
        break;
      case CTX_SCALE:
        ctx_scale (ctx, arg(0), arg(1) );
        break;
      case CTX_NEW_PAGE:
        ctx_new_page (ctx);
        break;
      case CTX_QUAD_TO:
        parser->pcx = arg(0);
        parser->pcy = arg(1);
        ctx_quad_to (ctx, arg(0), arg(1), arg(2), arg(3) );
        parser->command = CTX_QUAD_TO;
        break;
      case CTX_REL_QUAD_TO:
        parser->pcx = arg(0) + ctx_x (ctx);
        parser->pcy = arg(1) + ctx_y (ctx);
        ctx_rel_quad_to (ctx, arg(0), arg(1), arg(2), arg(3) );
        parser->command = CTX_REL_QUAD_TO;
        break;
      case CTX_CLIP:
        ctx_clip (ctx);
        break;
      case CTX_TRANSLATE:
        ctx_translate (ctx, arg(0), arg(1) );
        break;
      case CTX_ROTATE:
        ctx_rotate (ctx, arg(0) );
        break;
      case CTX_FONT:
        ctx_font (ctx, (char *) parser->holding);
        break;

      case CTX_TEXT:
        if (parser->n_numbers == 1)
          { ctx_rel_move_to (ctx, -parser->numbers[0], 0.0); }  //  XXX : scale by font(size)
        else
          {
            for (char *c = (char *) parser->holding; c; )
              {
                char *next_nl = ctx_strchr (c, '\n');
                if (next_nl)
                  { *next_nl = 0; }
                /* do our own layouting on a per-word basis?, to get justified
                 * margins? then we'd want explict margins rather than the
                 * implicit ones from move_to's .. making move_to work within
                 * margins.
                 */
                ctx_text (ctx, c);

                if (next_nl)
                  {
                    *next_nl = '\n'; // swap it newline back in
                    ctx_move_to (ctx, parser->left_margin, ctx_y (ctx) +
                                 ctx_get_font_size (ctx) );
                    c = next_nl + 1;
                    if (c[0] == 0)
                      { c = NULL; }
                  }
                else
                  {
                    c = NULL;
                  }
              }
          }
          parser->command = CTX_TEXT;
        break;
      case CTX_REL_LINE_TO:
        ctx_rel_line_to (ctx, arg(0), arg(1) );
        parser->pcx = ctx_x (ctx);
        parser->pcy = ctx_y (ctx);
        break;
      case CTX_REL_MOVE_TO:
        ctx_rel_move_to (ctx, arg(0), arg(1) );
        parser->command = CTX_REL_LINE_TO;
        parser->pcx = ctx_x (ctx);
        parser->pcy = ctx_y (ctx);
        parser->left_margin = ctx_x (ctx);
        break;
      case CTX_LINE_WIDTH:
        ctx_line_width (ctx, arg(0));
        break;
      case CTX_LINE_DASH_OFFSET:
        ctx_line_dash_offset (ctx, arg(0));
        break;
      case CTX_STROKE_POS:
        ctx_stroke_pos (ctx, arg(0));
        break;
      case CTX_FEATHER:
        ctx_feather (ctx, arg(0));
        break;
      case CTX_LINE_HEIGHT:
        ctx_line_height (ctx, arg(0));
        break;
      case CTX_WRAP_LEFT:
        ctx_wrap_left (ctx, arg(0));
        break;
      case CTX_WRAP_RIGHT:
        ctx_wrap_right (ctx, arg(0));
        break;
      case CTX_IMAGE_SMOOTHING:
        ctx_image_smoothing (ctx, (int)arg(0));
        break;
      case CTX_SHADOW_COLOR:
        ctx_shadow_rgba (ctx, arg(0), arg(1), arg(2), arg(3));
        break;
      case CTX_SHADOW_BLUR:
        ctx_shadow_blur (ctx, arg(0) );
        break;
      case CTX_SHADOW_OFFSET_X:
        ctx_shadow_offset_x (ctx, arg(0) );
        break;
      case CTX_SHADOW_OFFSET_Y:
        ctx_shadow_offset_y (ctx, arg(0) );
        break;
      case CTX_LINE_JOIN:
        ctx_line_join (ctx, (CtxLineJoin) ctx_clamp (arg(0), 0, 2));
        break;
      case CTX_LINE_CAP:
        ctx_line_cap (ctx, (CtxLineCap) ctx_clamp (arg(0), 0, 2));
        break;
      case CTX_COMPOSITING_MODE:
        {
          int val = (int)arg(0);
          val = ctx_clamp (val, 0, CTX_COMPOSITE_LAST);
          ctx_compositing_mode (ctx, (CtxCompositingMode) val );
        }
        break;
      case CTX_BLEND_MODE:
        {
          int blend_mode = (int)arg(0);
          if (blend_mode == CTX_COLOR) blend_mode = CTX_BLEND_COLOR;
          blend_mode = ctx_clamp (blend_mode, 0, CTX_BLEND_LAST);
          ctx_blend_mode (ctx, (CtxBlend)blend_mode);
        }
        break;
      case CTX_EXTEND:
        ctx_extend (ctx, (CtxExtend)ctx_clamp(arg(0), 0, CTX_EXTEND_LAST));
        break;
      case CTX_FILL_RULE:
        ctx_fill_rule (ctx, (CtxFillRule) ctx_clamp(arg(0), 0, 1));
        break;
      case CTX_TEXT_ALIGN:
        ctx_text_align (ctx, (CtxTextAlign) ctx_clamp(arg(0), 0, CTX_TEXT_ALIGN_RIGHT));
        break;
      case CTX_TEXT_BASELINE:
        ctx_text_baseline (ctx, (CtxTextBaseline) ctx_clamp(arg(0), 0, CTX_TEXT_BASELINE_BOTTOM));
        break;
      case CTX_TEXT_DIRECTION:
        ctx_text_direction (ctx, (CtxTextDirection) ctx_clamp(arg(0), 0, CTX_TEXT_DIRECTION_RTL));
        break;
      case CTX_IDENTITY:
        ctx_identity (ctx);
        break;
      case CTX_RECTANGLE:
        ctx_rectangle (ctx, arg(0), arg(1), arg(2), arg(3));
        break;
      case CTX_FILL_RECT:
        ctx_rectangle (ctx, arg(0), arg(1), arg(2), arg(3));
        ctx_fill (ctx);
        break;
      case CTX_STROKE_RECT:
        ctx_rectangle (ctx, arg(0), arg(1), arg(2), arg(3));
        ctx_stroke (ctx);
        break;
      case CTX_ROUND_RECTANGLE:
        ctx_round_rectangle (ctx, arg(0), arg(1), arg(2), arg(3), arg(4));
        break;
      case CTX_VIEW_BOX:
        {
          float x = arg(0);
          float y = arg(1);
          float w = arg(2);
          float h = arg(3);

          if (w > 1 && h > 1)
          {
            ctx_view_box (ctx, x, y, w, h);
            ctx_parser_set_size (parser, w, h, 0, 0);
          }
        }
        break;
      case CTX_LINEAR_GRADIENT:
        ctx_linear_gradient (ctx, arg(0), arg(1), arg(2), arg(3));
        break;
      case CTX_CONIC_GRADIENT:
        if (parser->n_args > 3)
          ctx_conic_gradient (ctx, arg(0), arg(1), arg(2), arg(3));
        else
          ctx_conic_gradient (ctx, arg(0), arg(1), arg(2), 1.0f);
        break;
      case CTX_RADIAL_GRADIENT:
        ctx_radial_gradient (ctx, arg(0), arg(1), arg(2), arg(3), arg(4), arg(5) );
        break;
      case CTX_GRADIENT_STOP:
        {
          float red, green, blue, alpha;
          ctx_parser_get_color_rgba (parser, 1, &red, &green, &blue, &alpha);
          ctx_gradient_add_stop_rgba (ctx, arg(0), red, green, blue, alpha);
        }
        break;
      case CTX_GLOBAL_ALPHA:
        ctx_global_alpha (ctx, arg(0) );
        break;
      case CTX_RESET_PATH:
        ctx_reset_path (ctx);
        break;
      case CTX_GLYPH:
        ctx_glyph_id (ctx, (uint32_t)arg(0), 0);
        break;
      case CTX_CLOSE_PATH:
        ctx_close_path (ctx);
        break;
      case CTX_END_FRAME:
      #if CTX_EVENTS
        if (parser->config.flags & CTX_FLAG_FORWARD_EVENTS)
        {
          ctx_rectangle (ctx, 0, 0, ctx_width(ctx), ctx_height(ctx));
          ctx_listen (ctx, CTX_PRESS, ctx_parser_press, parser, NULL);
          ctx_listen (ctx, CTX_MOTION, ctx_parser_motion, parser, NULL);
          ctx_listen (ctx, CTX_RELEASE, ctx_parser_release, parser, NULL);
          ctx_listen (ctx, CTX_KEY_DOWN, ctx_parser_key_down, parser, NULL);
          ctx_listen (ctx, CTX_KEY_PRESS, ctx_parser_key_press, parser, NULL);
          ctx_listen (ctx, CTX_KEY_UP, ctx_parser_key_up, parser, NULL);
          ctx_reset_path (ctx);
        }
      #endif
        if (parser->config.end_frame)
          { 
            parser->config.end_frame (parser->ctx, parser->config.user_data);
          }
      #if CTX_EVENTS
        if (parser->config.flags & CTX_FLAG_FORWARD_EVENTS)
          ctx_handle_events (ctx);
      #endif
        break;
      case CTX_START_FRAME:
        if (parser->config.start_frame)
          { parser->config.start_frame (parser->ctx, parser->config.user_data);
          }
        if (parser->translate_origin)
        {
          ctx_translate (ctx,
                         (parser->config.cursor_x-1) * parser->config.cell_width * 1.0f,
                         (parser->config.cursor_y-1) * parser->config.cell_height * 1.0f);
        }
        break;
    }
#undef arg
}

static inline void ctx_parser_holding_append (CtxParser *parser, int byte)
{
#if !CTX_PARSER_FIXED_TEMP
  if (CTX_UNLIKELY(parser->hold_len < parser->pos + 1 + 1))
  {
    int new_len = parser->hold_len * 2;
    if (new_len < 512) new_len = 512;
    parser->holding = (uint8_t*)ctx_realloc (parser->holding, parser->hold_len, new_len);
    parser->hold_len = new_len;
  }
#endif

  parser->holding[parser->pos++]=byte;
#if CTX_PARSER_FIXED_TEMP
  if (CTX_UNLIKELY(parser->pos > (int) sizeof (parser->holding)-2))
    { parser->pos = sizeof (parser->holding)-2; }
#endif
  parser->holding[parser->pos]=0;
}

static void ctx_parser_transform_percent (CtxParser *parser, CtxCode code, int arg_no, float *value)
{
  int big   = parser->config.width;
  int small = parser->config.height;
  if (big < small)
    {
      small = parser->config.width;
      big   = parser->config.height;
    }
  switch (code)
    {
      case CTX_RADIAL_GRADIENT:
      case CTX_ARC:
        switch (arg_no)
          {
            case 0:
            case 3:
              *value *= (parser->config.width/100.0f);
              break;
            case 1:
            case 4:
              *value *= (parser->config.height/100.0f);
              break;
            case 2:
            case 5:
              *value *= small/100.0f;
              break;
          }
        break;
      case CTX_STROKE_POS:
      case CTX_FEATHER:
      case CTX_FONT_SIZE:
      case CTX_MITER_LIMIT:
      case CTX_LINE_WIDTH:
      case CTX_LINE_DASH_OFFSET:
        {
          *value *= (small/100.0f);
        }
        break;
      case CTX_ARC_TO:
      case CTX_REL_ARC_TO:
        if (arg_no > 3)
          {
            *value *= (small/100.0f);
          }
        else
          {
            if (arg_no % 2 == 0)
              { *value  *= ( (parser->config.width) /100.0f); }
            else
              { *value *= ( (parser->config.height) /100.0f); }
          }
        break;
      case CTX_ROUND_RECTANGLE:
        if (arg_no == 4)
        {
          { *value *= ((parser->config.height)/100.0f); }
          return;
        }
        /* FALLTHROUGH */
      default: // even means x coord
        if (arg_no % 2 == 0)
          { *value  *= ((parser->config.width)/100.0f); }
        else
          { *value *= ((parser->config.height)/100.0f); }
        break;
    }
}

static void ctx_parser_transform_percent_height (CtxParser *parser, CtxCode code, int arg_no, float *value)
{
  *value *= (parser->config.height/100.0f);
}

static void ctx_parser_transform_percent_width (CtxParser *parser, CtxCode code, int arg_no, float *value)
{
  *value *= (parser->config.height/100.0f);
}

static void ctx_parser_transform_cell (CtxParser *parser, CtxCode code, int arg_no, float *value)
{
  float small = parser->config.cell_width;
  if (small > parser->config.cell_height)
    { small = parser->config.cell_height; }
  switch (code)
    {
      case CTX_RADIAL_GRADIENT:
      case CTX_ARC:
        switch (arg_no)
          {
            case 0:
            case 3:
              *value *= parser->config.cell_width;
              break;
            case 1:
            case 4:
              *value *= parser->config.cell_height;
              break;
            case 2:
            case 5:
              *value *= small; // use height?
              break;
          }
        break;
      case CTX_MITER_LIMIT:
      case CTX_FONT_SIZE:
      case CTX_STROKE_POS:
      case CTX_FEATHER:
      case CTX_LINE_WIDTH:
      case CTX_LINE_DASH_OFFSET:
        {
          *value *= parser->config.cell_height;
        }
        break;
      case CTX_ARC_TO:
      case CTX_REL_ARC_TO:
        if (arg_no > 3)
          {
            *value *= small;
          }
        else
          {
            *value *= (arg_no%2==0) ?parser->config.cell_width:parser->config.cell_height;
          }
        break;
      case CTX_RECTANGLE:
        if (arg_no % 2 == 0)
          { *value *= parser->config.cell_width; }
        else
          {
            if (! (arg_no > 1) )
              { (*value) -= 1.0f; }
            *value *= parser->config.cell_height;
          }
        break;
      default: // even means x coord odd means y coord
        *value *= (arg_no%2==0) ?parser->config.cell_width:parser->config.cell_height;
        break;
    }
}

static void ctx_parser_word_done (CtxParser *parser)
{
  parser->holding[parser->pos]=0;

  if (parser->pos > 1 && (parser->holding[0]=='Z' || 
                          parser->holding[0]=='z'))
  {
    ctx_close_path (parser->ctx);
    memmove (parser->holding, parser->holding+1, parser->pos-1);
    parser->pos--;
    ctx_parser_word_done (parser);
    return;
  }

  int command = ctx_parser_resolve_command (parser, parser->holding);
  if ((command >= 0 && command < 32)
      || (command > 150) || (command < 0)
      )  // special case low enum values
    {                   // and enum values too high to be
                        // commands - permitting passing words
                        // for strings in some cases
      parser->numbers[parser->n_numbers] = command;

      // trigger transition from number
      parser->state = CTX_PARSER_NUMBER;
      char c = ',';
      ctx_parser_feed_bytes (parser, &c, 1);
    }
  else if (command > 0)
    {
      parser->command = (CtxCode) command;
      parser->n_numbers = 0;
      parser->n_args = 0;
      if (parser->expected_args == 0)
        {
          ctx_parser_dispatch_command (parser);
        }
      //parser->numbers[0] = 0;
    }
  else
    { 
        fprintf (stderr, "unhandled command '%s'\n", parser->holding);
    }
}

static void ctx_parser_string_done (CtxParser *parser)
{
  if (parser->expected_args == CTX_ARG_STRING_OR_NUMBER)
  {
    int tmp1 = parser->command;
    int tmp2 = parser->expected_args;
    int tmp3 = parser->n_numbers;
    int tmp4 = parser->n_args;
    ctx_parser_dispatch_command (parser);
    parser->command = (CtxCode)tmp1;
    parser->expected_args = tmp2;
    parser->n_numbers = tmp3;
    parser->n_args = tmp4;
  }
  else
  {
    ctx_parser_dispatch_command (parser);
  }
}
static inline void ctx_parser_finish_number (CtxParser *parser)
{
  if (parser->state == CTX_PARSER_NEGATIVE_NUMBER)
     { parser->numbers[parser->n_numbers] *= -1; }
  if (parser->exp > 100) parser->exp = 100;
  if (parser->exponent < 0)
  {
    for (int i = 0; i < parser->exp; i++)
     parser->numbers[parser->n_numbers] *= 0.1f;
  }
  else if (parser->exponent > 0)
  {
    for (int i = 0; i < parser->exp; i++)
     parser->numbers[parser->n_numbers] *= 10.0f;
  }
  parser->exponent = 0;
}

void ctx_parser_feed_byte (CtxParser *parser, char byte)
{
#if CTX_REPORT_COL_ROW
    if (CTX_UNLIKELY(byte == '\n'))
    {
        parser->col=0;
        parser->line++;
    }
    else
    {
        parser->col++;
    }
#endif

  switch (parser->state)
    {

    case CTX_PARSER_STRING_YENC:
    {
        if (CTX_UNLIKELY((parser->prev_byte == '=') && (byte == 'y')))
        {
          parser->state = CTX_PARSER_NEUTRAL;
                 //   fprintf (stderr, "got %i\n", parser->pos);
          parser->pos = ctx_ydec ((char*)parser->holding, (char*)parser->holding, parser->pos) - 1;
#if 0
          if (parser->pos > 5)
                    fprintf (stderr, "dec got %i %c %c %c %c\n", parser->pos,
                                    parser->holding[0],
                                    parser->holding[1],
                                    parser->holding[2],
                                    parser->holding[3]
                                    );
#endif
          ctx_parser_string_done (parser);
        }
        else
        {
          ctx_parser_holding_append (parser, byte);
        }
        parser->prev_byte = byte;
        return;
    }

    case CTX_PARSER_STRING_A85:
    {
        /* since these are our largest bulk transfers, minimize
         * overhead for this case. */
        if (CTX_LIKELY(byte!='~')) 
        {
          ctx_parser_holding_append (parser, byte);
        }
        else
        {
          parser->state = CTX_PARSER_NEUTRAL;
                 //   fprintf (stderr, "got %i\n", parser->pos);
          parser->pos = ctx_a85dec ((char*)parser->holding, (char*)parser->holding, parser->pos);
                 //   fprintf (stderr, "dec got %i\n", parser->pos);
          ctx_parser_string_done (parser);
        }
        return;
    }
    #if CTX_EVENTS
      case CTX_PARSER_ESCAPE:
        if (parser->escape_first_char == 0)
        {
          parser->escape_first_char = byte;
        }

        if (byte >= 0x20) // signed so only ascii
        {
          ctx_parser_holding_append (parser, byte);

          if (parser->pos > 1 && ((byte >='a' && byte <= 'z') | ((byte >='A' && byte <= 'Z'))))
          {
             if (!strcmp ((char*)parser->holding, "[5n"))
             {
               char buf[64]="\033[0n";
               ctx_wait_frame (parser->ctx, NULL);
               ctx_parser_response (parser, buf, strlen(buf));
             }
             else if (!strcmp ((char*)parser->holding, "[?200$p"))
             {
               char buf[64]="\033?200;2$y";
               ctx_parser_response (parser, buf, strlen(buf));
             }
             else if (!strcmp ((char*)parser->holding, "[14t"))
             {
               char buf[64];
               sprintf (buf, "\033[4;%i;%it", (int)ctx_height(parser->ctx), (int)ctx_width(parser->ctx));
               ctx_parser_response (parser, buf, strlen(buf));
             }
             else if (!strcmp ((char*)parser->holding, "[18t"))
             {
               char buf[64];
               float font_size = ctx_height (parser->ctx) / 10.0f;
               sprintf (buf, "\033[8;%i;%it", (int)(ctx_height(parser->ctx)/font_size), (int)(ctx_width(parser->ctx) / font_size * 0.6f));
               ctx_parser_response (parser, buf, strlen(buf));
             }
             parser->state = CTX_PARSER_NEUTRAL;
          }
        }
        else
        {
          parser->state = CTX_PARSER_NEUTRAL;
        }
        break;
#endif
      case CTX_PARSER_NEUTRAL:
        switch (byte)
          {
            case 27:
              if (parser->config.flags & CTX_FLAG_HANDLE_ESCAPES)
              {
                parser->state = CTX_PARSER_ESCAPE;
                parser->escape_first_char = 0;
                parser->pos = 0;
                parser->holding[0] = 0;
              }
              break;

            case  0: case  1: case  2: case  3:  case 4:  case 5:
            case  6: case  7: case  8: case 11: case 12: case 14:
            case 15: case 16: case 17: case 18: case 19: case 20:
            case 21: case 22: case 23: case 24: case 25: case 26:
            case 28: case 29: case 30: case 31:
              break;
            case ' ': case '\t': case '\r': case '\n':
            case ';': case ',':
            case '(': case ')':
            case '{': case '}':
            //case '=':
              break;
            case '#':
              parser->state = CTX_PARSER_COMMENT;
              break;
            case '\'':
              parser->state = CTX_PARSER_STRING_APOS;
              parser->pos = 0;
              parser->holding[0] = 0;
              break;
            case '=':
              parser->state = CTX_PARSER_STRING_YENC;
              parser->pos = 0;
              parser->holding[0] = 0;
              break;
            case '~':
              parser->state = CTX_PARSER_STRING_A85;
              parser->pos = 0;
              parser->holding[0] = 0;
              break;
            case '"':
              parser->state = CTX_PARSER_STRING_QUOT;
              parser->pos = 0;
              parser->holding[0] = 0;
              break;
            case '-':
              parser->state = CTX_PARSER_NEGATIVE_NUMBER;
              parser->numbers[parser->n_numbers] = 0;
              parser->exponent =
              parser->decimal = 0;
              break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
              parser->state = CTX_PARSER_NUMBER;
              parser->numbers[parser->n_numbers] = 0;
              parser->numbers[parser->n_numbers] += (byte - '0');
              parser->exponent =
              parser->decimal = 0;
              break;
            case '.':
              parser->state = CTX_PARSER_NUMBER;
              parser->numbers[parser->n_numbers] = 0;
              parser->exponent = 0;
              parser->decimal = 1;
              break;
            default:
              parser->state = CTX_PARSER_WORD;
              parser->pos = 0;
              ctx_parser_holding_append (parser, byte);
              break;
          }
        break;
      case CTX_PARSER_NUMBER:
      case CTX_PARSER_NEGATIVE_NUMBER:
        {
          int do_process = 0;
          switch (byte)
            {
              case 0: case 1: case 2: case 3: case 4: case 5:
              case 6: case 7: case 8:
              case 11: case 12: case 14: case 15: case 16:
              case 17: case 18: case 19: case 20: case 21:
              case 22: case 23: case 24: case 25: case 26:
              case 27: case 28: case 29: case 30: case 31:
                parser->state = CTX_PARSER_NEUTRAL;
                break;
              case ' ':
              case '\t':
              case '\r':
              case '\n':
              case ';':
              case ',':
              case '(':
              case ')':
              case '{':
              case '}':
              case '=':
                ctx_parser_finish_number (parser);
                parser->state = CTX_PARSER_NEUTRAL;
                break;
              case '#':
                parser->state = CTX_PARSER_COMMENT;
                break;
              case '-':
                if (parser->exponent==1)
                {
                  parser->exponent = -1;
                }
                else
                {
                  ctx_parser_finish_number (parser);
                  parser->state = CTX_PARSER_NEGATIVE_NUMBER;
                  if (parser->n_numbers < CTX_PARSER_MAX_ARGS)
                    parser->n_numbers ++;
                  parser->numbers[parser->n_numbers] = 0;
                  parser->exponent =
                  parser->decimal = 0;
                  do_process = 1;
                }
                break;
              case '.':
                if (parser->decimal){
                  ctx_parser_finish_number (parser);
                  parser->state = CTX_PARSER_NUMBER;
                  if (parser->n_numbers < CTX_PARSER_MAX_ARGS)
                    parser->n_numbers ++;
                  parser->numbers[parser->n_numbers] = 0;
                  do_process = 1;
                }
                parser->exponent = 0;
                parser->decimal = 1;
                break;
              case '0': case '1': case '2': case '3': case '4':
              case '5': case '6': case '7': case '8': case '9':
                if (parser->exponent)
                {
                   parser->exp *= 10;
                   parser->exp += (byte - '0');
                }
                else if (parser->decimal)
                  {
                    parser->decimal *= 10;
                    parser->numbers[parser->n_numbers] += (byte - '0') / (1.0f * parser->decimal);
                  }
                else
                  {
                    parser->numbers[parser->n_numbers] *= 10;
                    parser->numbers[parser->n_numbers] += (byte - '0');
                  }
                break;
              case '@': // cells
                ctx_parser_finish_number (parser);
                {
                float fval = parser->numbers[parser->n_numbers];
                ctx_parser_transform_cell (parser, parser->command, parser->n_numbers, &fval);
                parser->numbers[parser->n_numbers]= fval;
                }
                parser->state = CTX_PARSER_NEUTRAL;
                break;
              case '%': // percent of width/height
                if (parser->state == CTX_PARSER_NEGATIVE_NUMBER)
                  { parser->numbers[parser->n_numbers] *= -1; }
                {
                float fval = parser->numbers[parser->n_numbers];
                ctx_parser_transform_percent (parser, parser->command, parser->n_numbers, &fval);
                parser->numbers[parser->n_numbers]= fval;
                }
                parser->state = CTX_PARSER_NEUTRAL;
                break;
              case '^': // percent of height
                ctx_parser_finish_number (parser);
                {
                float fval = parser->numbers[parser->n_numbers];
                ctx_parser_transform_percent_height (parser, parser->command, parser->n_numbers, &fval);
                parser->numbers[parser->n_numbers]= fval;
                }
                parser->state = CTX_PARSER_NEUTRAL;
                break;
              case '~': // percent of width
                ctx_parser_finish_number (parser);
                {
                float fval = parser->numbers[parser->n_numbers];
                ctx_parser_transform_percent_width (parser, parser->command, parser->n_numbers, &fval);
                parser->numbers[parser->n_numbers]= fval;
                }
                parser->state = CTX_PARSER_NEUTRAL;
                break;
              case 'e':
              case 'E':
                parser->exponent = 1;
                parser->exp = 0;
                break;
              default:
                ctx_parser_finish_number (parser);

                parser->state = CTX_PARSER_WORD;
                parser->pos = 0;
                ctx_parser_holding_append (parser, byte);
                break;
            }
          if (do_process ||
               ((parser->state != CTX_PARSER_NUMBER) &&
               (parser->state != CTX_PARSER_NEGATIVE_NUMBER)))
            {
              if (!do_process)
              {
                if (parser->n_numbers < CTX_PARSER_MAX_ARGS)
                  parser->n_numbers ++;
              }

              if (parser->n_numbers == parser->expected_args ||
                  parser->expected_args == CTX_ARG_COLLECT_NUMBERS ||
                  parser->expected_args == CTX_ARG_STRING_OR_NUMBER)
                {
                  int tmp1 = parser->n_numbers;
                  int tmp2 = parser->n_args;
                  CtxCode tmp3 = parser->command;
                  int tmp4 = parser->expected_args;
                  ctx_parser_dispatch_command (parser);
                  parser->command = tmp3;
                  switch (parser->command)
                  {
                    case CTX_DEFINE_TEXTURE:
                    case CTX_TEXTURE:
                      parser->n_numbers = tmp1;
                      parser->n_args = tmp2;
                      break;
                          default:
                      parser->n_numbers = 0;
                      parser->n_args = 0;
                      parser->numbers[0] = parser->numbers[tmp1];
                      break;
                  }
                  parser->expected_args = tmp4;
                }
              //if (parser->n_numbers > CTX_PARSER_MAX_ARGS)
              //  { parser->n_numbers = CTX_PARSER_MAX_ARGS;
              //  }
            }
        }
        break;
      case CTX_PARSER_WORD:
        switch (byte)
          {
            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
            case 8: case 11: case 12: case 14: case 15: case 16: case 17:
            case 18: case 19: case 20: case 21: case 22: case 23: case 24:
            case 25: case 26: case 27: case 28: case 29: case 30: case 31:
            case ' ': case '\t': case '\r': case '\n':
            case ';': case ',':
            case '(': case ')': case '=': case '{': case '}':
              parser->state = CTX_PARSER_NEUTRAL;
              break;
            case '#':
              parser->state = CTX_PARSER_COMMENT;
              break;
            case '-':
              parser->state = CTX_PARSER_NEGATIVE_NUMBER;
              parser->numbers[parser->n_numbers] = 0;
              parser->exponent =
              parser->decimal = 0;
              break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
              parser->state = CTX_PARSER_NUMBER;
              parser->numbers[parser->n_numbers] = 0;
              parser->numbers[parser->n_numbers] += (byte - '0');
              parser->exponent =
              parser->decimal = 0;
              break;
            case '.':
              parser->state = CTX_PARSER_NUMBER;
              parser->numbers[parser->n_numbers] = 0;
              parser->exponent = 0;
              parser->decimal = 1;
              break;
            default:
              ctx_parser_holding_append (parser, byte);
              break;
          }
        if (parser->state != CTX_PARSER_WORD)
          {
            ctx_parser_word_done (parser);
          }
        break;
#if 0
      case CTX_PARSER_STRING_A85:
        if (CTX_LIKELY(byte!='~'))
        {
          ctx_parser_holding_append (parser, byte);
        }
        else
        {
          parser->state = CTX_PARSER_NEUTRAL;
                 //   fprintf (stderr, "got %i\n", parser->pos);
          parser->pos = ctx_a85dec ((char*)parser->holding, (char*)parser->holding, parser->pos);
                 //   fprintf (stderr, "dec got %i\n", parser->pos);
          ctx_parser_string_done (parser);
        }
        break;
#endif
      case CTX_PARSER_STRING_APOS:
        switch (byte)
          {
            case '\\': parser->state = CTX_PARSER_STRING_APOS_ESCAPED; break;
            case '\'': parser->state = CTX_PARSER_NEUTRAL;
              ctx_parser_string_done (parser);
              break;
            default:
              ctx_parser_holding_append (parser, byte); break;
          }
        break;
      case CTX_PARSER_STRING_APOS_ESCAPED:
        switch (byte)
          {
            case '0': byte = '\0'; break;
            case 'b': byte = '\b'; break;
            case 'f': byte = '\f'; break;
            case 'n': byte = '\n'; break;
            case 'r': byte = '\r'; break;
            case 't': byte = '\t'; break;
            case 'v': byte = '\v'; break;
            default: break;
          }
        ctx_parser_holding_append (parser, byte);
        parser->state = CTX_PARSER_STRING_APOS;
        break;
      case CTX_PARSER_STRING_QUOT_ESCAPED:
        switch (byte)
          {
            case '0': byte = '\0'; break;
            case 'b': byte = '\b'; break;
            case 'f': byte = '\f'; break;
            case 'n': byte = '\n'; break;
            case 'r': byte = '\r'; break;
            case 't': byte = '\t'; break;
            case 'v': byte = '\v'; break;
            default: break;
          }
        ctx_parser_holding_append (parser, byte);
        parser->state = CTX_PARSER_STRING_QUOT;
        break;
      case CTX_PARSER_STRING_QUOT:
        switch (byte)
          {
            case '\\':
              parser->state = CTX_PARSER_STRING_QUOT_ESCAPED;
              break;
            case '"':
              parser->state = CTX_PARSER_NEUTRAL;
              ctx_parser_string_done (parser);
              break;
            default:
              ctx_parser_holding_append (parser, byte);
              break;
          }
        break;
      case CTX_PARSER_COMMENT:
        switch (byte)
          {
            case '\r':
            case '\n':
              parser->state = CTX_PARSER_NEUTRAL;
            default:
              break;
          }
        break;
    }
}

void ctx_parser_feed_bytes (CtxParser *parser, const char *data, int count)
{
  for (int i = 0; i < count; i++)
    ctx_parser_feed_byte (parser, data[i]);
}

CTX_EXPORT void
ctx_parse (Ctx *ctx, const char *string)
{
  if (!string)
    return;
  CtxParserConfig config =
  {
    .width = ctx_width(ctx),
    .height = ctx_height(ctx),
    .cell_width = ctx_get_font_size(ctx),
    .cell_height = ctx_get_font_size(ctx) * 1.2,
  };
  CtxParser *parser = ctx_parser_new (ctx, &config);
  ctx_parser_feed_bytes (parser, string, ctx_strlen (string));
  ctx_parser_feed_bytes (parser, " ", 1);
  ctx_parser_destroy (parser);
}

CTX_EXPORT void
ctx_parse_animation (Ctx *ctx, const char *string,
                     float *scene_elapsed_time, 
                     int *scene_no_p)
{
  float time = *scene_elapsed_time;
  int scene_no = *scene_no_p;
  CtxString *str = ctx_string_new ("");
  int in_var = 0;
  float scene_duration = 5.0f;

  int i;

//again:
  i = 0;

  // XXX : this doesn't work when there are [  or ('s in text

  int scene_pos = 0;
  int last_scene = 0;
  int scene_start = 0;
  int got_duration = 0;

  {
    int start = 0;
    for (; string[i]; i++)
    {
       if ((string[i]=='n') && (!strncmp (&string[i+1], "ewPage", 6)))
       {
         if (scene_pos == scene_no)
         {
            if (scene_duration < time)
            {
              scene_no ++;
              (*scene_no_p)++;
              *scene_elapsed_time = time = time- scene_duration;
            }
            else
            {
              scene_start = start;
            }
         }

         scene_pos++;
         last_scene = scene_pos;
         start = i + 7;
         scene_duration = 5.0f;
         got_duration = 0;
       }

       if (!got_duration && (string[i]=='d') && !strncmp (&string[i+1], "uration ", 8))
       {
         scene_duration = _ctx_parse_float (&string[i+9], NULL);
         got_duration = 1;
       }
    }
  }
  i = scene_start;
  if (last_scene)
    last_scene --;
#if 0
  {
  int in_scene_marker = 0;
  float duration = -1;

  // go through the string,
  //
  // post:
  //   last_scene = highest scene seen
  //   i = byte offset of start of scene
  //   scene_duration = duration of current scene
  for (; string[i]; i++)
  {
    char p = string[i];
    if (in_scene_marker)
    {
       if (p == ']')
       {
          in_scene_marker = 0;
       //   printf ("scene: %i time: %f scene %i: %f\n", scene_no, time, scene_pos, duration);
          last_scene = scene_pos;
          if (scene_pos == scene_no)
          {
            scene_duration = duration;
            if (scene_duration < time)
            {
              scene_no ++;
              (*scene_no_p)++;
              *scene_elapsed_time = time = time- scene_duration;
            }
            else
            {
              break;
            }
          }
          scene_pos++;
       }
       else if (p>='0' && p<='9' && duration < 0)
       {
          duration = _ctx_parse_float (&string[i], NULL);
       }
    }
    else
    {
       if (p == '[')
       {
          in_scene_marker = 1;
          duration = -1;
       }
    }
  }
  }
#endif

  if (scene_no > last_scene)
  {
     scene_no = 0;
     (*scene_no_p) = 0;
     return;
     //goto again;
  }
  
  if (scene_no == 0 && last_scene==0 && string[i]==0)
    i=0;

#define MAX_KEY_FRAMES 64
  float keys[MAX_KEY_FRAMES];
  float values[MAX_KEY_FRAMES];
  int n_keys = 0;
  int smooth = 1; // default to catmull rom

  for (; string[i]; i++)
  {
    char p = string[i];
    if (in_var == 0)
    {
      if ((string[i]=='n') && (!strncmp (&string[i+1], "ewPage", 6)))
        break;
      else if (p == '(')
      {
        in_var = 1;
        n_keys = 0;
      }
      else
      {
        ctx_string_append_byte (str, p);
      }
    }
    else
    {
      if (p == ')')
      {
        float resolved_val = -100000.0;
        float prev_val = 0;
        for (int i = 0; i < n_keys; i++)
        {
          float key = keys[i];
          float val = values[i];
          //printf ("%f=%f\n", key, val);
          if (key>=time && resolved_val <=-10000.0f)
          {
            if (smooth == 0) // linear interpolation
            {
              if (i == 0)
                resolved_val = val;
              else
                resolved_val = ctx_lerpf (values[i-1], val, 
                                (time-keys[i-1])/(key-keys[i-1]));
            }
            else
            {
              if (i == 0)
              {
                resolved_val = val;
              }
              else if (n_keys<=2)
              {
                resolved_val = ctx_lerpf (values[i-1], val, 
                                 (time-keys[i-1])/(key-keys[i-1]));
              } else if (i == 1)
              {
                resolved_val = ctx_catmull_rom_left (values[i-1], values[i],
                                 values[i+1],
                                 (time-keys[i-1])/(key-keys[i-1]));
              }
              else if (i > 1 && i+1 < n_keys)
              {
                resolved_val = ctx_catmull_rom (values[i-2], values[i-1],
                                 val, values[i+1],
                                 (time-keys[i-1])/(key-keys[i-1]));
              }
              else if (i >= 2 && i < n_keys)
              {
                resolved_val = ctx_catmull_rom_right (values[i-2], values[i-1],
                                 values[i],
                                 (time-keys[i-1])/(key-keys[i-1]));
              }
            }
          }
          prev_val = val;
        }
        if (resolved_val <= -100000.0f) resolved_val = prev_val;
        ctx_string_append_printf (str, "%f", (double)resolved_val);
        in_var = 0;
      }
      else if (p>='0' && p<='9')
      {
        char *sp = (char*)&string[i];
        char *ep = sp;
        float key      = _ctx_parse_float (sp, &ep);
        char *eq       = strchr (sp, '=');
        float val      = 0.0;

        if (eq)
           val = _ctx_parse_float (eq+1, &ep);

        keys[n_keys] = key;
        if (n_keys < MAX_KEY_FRAMES-1)
        values[n_keys++] = val;

        i+=(ep-sp)-1;
      }
      else if (p=='s')
      {
        smooth = 1;
      } else if (p=='l')
      {
        smooth = 0;
      }
      else
      {
        /* ignore */
      }

    }
  }

  /* we've now built up the frame, and parse
   * it with the regular parser
   */
  ctx_parse (ctx, str->str);
  ctx_string_free (str, 1);
}

#endif

#if !__COSMOPOLITAN__
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#endif

//#include "ctx.h"
/* instead of including ctx.h we declare the few utf8
 * functions we use
 */
void ctx_string_init (CtxString *string, int initial_size)
{
  string->allocated_length = initial_size;
  string->length = 0;
  string->utf8_length = 0;
  string->str = (char*)ctx_malloc (string->allocated_length + 1);
  string->str[0]='\0';
}

static void ctx_string_destroy (CtxString *string)
{
  if (string->str)
    {
      ctx_free (string->str);
      string->str = NULL;
    }
}

void ctx_string_clear (CtxString *string)
{
  string->length = 0;
  string->utf8_length = 0;
  string->str[string->length]=0;
}


void ctx_string_pre_alloc (CtxString *string, int size)
{
  char *old = string->str;
  int old_len = string->allocated_length;
  string->allocated_length = CTX_MAX (size + 2, string->length + 2);
  string->str = (char*)ctx_realloc (old, old_len, string->allocated_length);
}


static inline void _ctx_string_append_byte (CtxString *string, char  val)
{
  if (CTX_LIKELY((val & 0xC0) != 0x80))
    { string->utf8_length++; }
  if (CTX_UNLIKELY(string->length + 2 >= string->allocated_length))
    {
      char *old = string->str;
      int old_len = string->allocated_length;
      string->allocated_length = CTX_MAX ((int)(string->allocated_length * 1.5f), string->length + 2);
      string->str = (char*)ctx_realloc (old, old_len, string->allocated_length);
    }
  string->str[string->length++] = val;
  string->str[string->length] = '\0';
}

void ctx_string_append_byte (CtxString *string, char  val)
{
  _ctx_string_append_byte (string, val);
}

void ctx_string_append_unichar (CtxString *string, unsigned int unichar)
{
  char *str;
  char utf8[5];
  utf8[_ctx_unichar_to_utf8 (unichar, (unsigned char *) utf8)]=0;
  str = utf8;
  while (str && *str)
    {
      _ctx_string_append_byte (string, *str);
      str++;
    }
}

static inline void _ctx_string_append_str (CtxString *string, const char *str)
{
  if (!str) { return; }
  while (*str)
    {
      _ctx_string_append_byte (string, *str);
      str++;
    }
}

void ctx_string_append_utf8char (CtxString *string, const char *str)
{
  if (!str) { return; }
  int len = _ctx_utf8_len (*str);
  for (int i = 0; i < len && *str; i++)
    {
      _ctx_string_append_byte (string, *str);
      str++;
    }
}

void ctx_string_append_str (CtxString *string, const char *str)
{
  _ctx_string_append_str (string, str);
}

CtxString *ctx_string_new_with_size (const char *initial, int initial_size)
{
  CtxString *string = (CtxString*)ctx_calloc (1, sizeof (CtxString));
  ctx_string_init (string, initial_size);
  if (initial)
    { _ctx_string_append_str (string, initial); }
  return string;
}

CtxString *ctx_string_new (const char *initial)
{
  return ctx_string_new_with_size (initial, 8);
}

void ctx_string_append_data (CtxString *string, const char *str, int len)
{
  int i;
  for (i = 0; i<len; i++)
    { _ctx_string_append_byte (string, str[i]); }
}

void ctx_string_append_string (CtxString *string, CtxString *string2)
{
  const char *str = ctx_string_get (string2);
  while (str && *str)
    {
      _ctx_string_append_byte (string, *str);
      str++;
    }
}

const char *ctx_string_get (CtxString *string)
{
  return string->str;
}

int ctx_string_get_utf8length (CtxString *string)
{
  return string->utf8_length;
}

int ctx_string_get_length (CtxString *string)
{
  return string->length;
}

void
ctx_string_free (CtxString *string, int freealloc)
{
  if (freealloc)
    {
      ctx_string_destroy (string);
    }
#if 0
  if (string->is_line)
  {
    VtLine *line = (VtLine*)string;
    if (line->style)
      { ctx_free (line->style); }
    if (line->ctx)
      { ctx_destroy (line->ctx); }
    if (line->ctx_copy)
      { ctx_destroy (line->ctx_copy); }
  }
#endif
  ctx_free (string);
}

char       *ctx_string_dissolve       (CtxString *string)
{
  char *ret = string->str;
  ctx_string_free (string, 0);
  return ret;
}

void
ctx_string_set (CtxString *string, const char *new_string)
{
  ctx_string_clear (string);
  _ctx_string_append_str (string, new_string);
}


static inline void ctx_string_replace_utf8_ (CtxString *string, int pos, const char *new_glyph)
{
#if 1
  int old_len = string->utf8_length;
#else
  int old_len = _ctx_utf8_strlen (string->str);// string->utf8_length;
#endif
  if (pos < 0) return;

  if (CTX_LIKELY(pos == old_len))
    {
      _ctx_string_append_str (string, new_glyph);
      return;
    }

  char tmpg[3]=" ";
  int new_len = _ctx_utf8_len (*new_glyph);
  if (new_len <= 1 && new_glyph[0] < 32)
    {
      new_len = 1;
      tmpg[0]=new_glyph[0]+64;
      new_glyph = tmpg;
    }
  {
    for (int i = old_len; i <= pos + 2; i++)
      {
        _ctx_string_append_byte (string, ' ');
        old_len++;
      }
  }
  if (string->length + new_len  >= string->allocated_length - 2)
    {
      char *tmp;
      char *defer;
      string->allocated_length = string->length + new_len + 10;
      tmp = (char*) ctx_calloc (1, string->allocated_length + 1 + 8);
      strcpy (tmp, string->str);
      defer = string->str;
      string->str = tmp;
      ctx_free (defer);
    }
  char *p = (char *) _ctx_utf8_skip (string->str, pos);
  int prev_len = _ctx_utf8_len (*p);
  char *rest;
  if (*p == 0 || * (p+prev_len) == 0)
    {
      rest = ctx_strdup ("");
    }
  else
    {
      if (p + prev_len >= string->length  + string->str)
        { rest = ctx_strdup (""); }
      else
        { rest = ctx_strdup (p + prev_len); }
    }
  memcpy (p, new_glyph, new_len);
  memcpy (p + new_len, rest, ctx_strlen (rest) + 1);

#if 1
  string->length += new_len;
  string->length -= prev_len;
#else
  if (string->length + new_len - prev_len != strlen (string->str))
  {
      printf ("owww: pos:%i olen:%i new_len:%i prev_len:%i actual:%i computed:%i\n",
                          pos, string->length, new_len, prev_len, strlen(string->str),
      string->length + new_len - prev_len != strlen (string->str)
                          );
  }
  //  XXX : fixing these to be update correctly - would speed up terminals
  string->length = strlen (string->str);
  //string->utf8_length = _ctx_utf8_strlen (string->str);
#endif
  ctx_free (rest);
}

void ctx_string_replace_utf8 (CtxString *string, int pos, const char *new_glyph)
{
  ctx_string_replace_utf8_ (string, pos, new_glyph);
}

void ctx_string_replace_unichar (CtxString *string, int pos, uint32_t unichar)
{
  uint8_t utf8[8];
  _ctx_unichar_to_utf8 (unichar, utf8);
  ctx_string_replace_utf8 (string, pos, (char *) utf8);
}

uint32_t ctx_string_get_unichar (CtxString *string, int pos)
{
  char *p = (char *) _ctx_utf8_skip (string->str, pos);
  if (!p)
    { return 0; }
  return _ctx_utf8_to_unichar (p);
}

void ctx_string_insert_utf8 (CtxString *string, int pos, const char *new_glyph)
{
  int new_len = _ctx_utf8_len (*new_glyph);
  int old_len = string->utf8_length;
  char tmpg[3]=" ";
  if (pos < 0)
    return;
  if (old_len == pos && 0)
    {
      ctx_string_append_str (string, new_glyph);
      return;
    }
  if (new_len <= 1 && new_glyph[0] < 32)
    {
      tmpg[0]=new_glyph[0]+64;
      new_glyph = tmpg;
    }
  {
    for (int i = old_len; i <= pos; i++)
      {
        _ctx_string_append_byte (string, ' ');
        old_len++;
      }
  }
  if (string->length + new_len + 1  > string->allocated_length)
    {
      char *tmp;
      char *defer;
      string->allocated_length = string->length + new_len + 1;
      tmp = (char*) ctx_calloc (1, string->allocated_length + 1);
      strcpy (tmp, string->str);
      defer = string->str;
      string->str = tmp;
      ctx_free (defer);
    }
  char *p = (char *) _ctx_utf8_skip (string->str, pos);
  int prev_len = _ctx_utf8_len (*p);
  char *rest;
  if ( (*p == 0 || * (p+prev_len) == 0) && pos != 0)
    {
      rest = ctx_strdup ("");
    }
  else
    {
      rest = ctx_strdup (p);
    }
  memcpy (p, new_glyph, new_len);
  memcpy (p + new_len, rest, ctx_strlen (rest) + 1);
  ctx_free (rest);
  string->length = ctx_strlen (string->str);
  string->utf8_length = _ctx_utf8_strlen (string->str);
}

void ctx_string_insert_unichar (CtxString *string, int pos, uint32_t unichar)
{
  uint8_t utf8[5]="";
  utf8[_ctx_unichar_to_utf8(unichar, utf8)]=0;
  ctx_string_insert_utf8 (string, pos, (char*)utf8);
}

void ctx_string_remove (CtxString *string, int pos)
{
  int old_len = string->utf8_length;
  if (pos < 0)
    return;
  {
    for (int i = old_len; i <= pos; i++)
      {
        _ctx_string_append_byte (string, ' ');
        old_len++;
      }
  }
  char *p = (char *) _ctx_utf8_skip (string->str, pos);
  int prev_len = _ctx_utf8_len (*p);
  char *rest;
  if (!p || *p == 0)
    {
      return;
      rest = ctx_strdup ("");
      prev_len = 0;
    }
  else if (* (p+prev_len) == 0)
  {
      rest = ctx_strdup ("");
  }
  else
    {
      rest = ctx_strdup (p + prev_len);
    }
  strcpy (p, rest);
  string->str[string->length - prev_len] = 0;
  ctx_free (rest);
  string->length = ctx_strlen (string->str);
  string->utf8_length = _ctx_utf8_strlen (string->str);
}

char *ctx_strdup_printf (const char *format, ...)
{
  va_list ap;
  size_t needed;
  char *buffer;
  va_start (ap, format);
  needed = vsnprintf (NULL, 0, format, ap) + 1;
  buffer = (char*)ctx_malloc (needed);
  va_end (ap);
  va_start (ap, format);
  vsnprintf (buffer, needed, format, ap);
  va_end (ap);
  return buffer;
}

void ctx_string_append_printf (CtxString *string, const char *format, ...)
{
  va_list ap;
  size_t needed;
  char *buffer;
  va_start (ap, format);
  needed = vsnprintf (NULL, 0, format, ap) + 1;
  buffer = (char*)ctx_malloc (needed);
  va_end (ap);
  va_start (ap, format);
  vsnprintf (buffer, needed, format, ap);
  va_end (ap);
  ctx_string_append_str (string, buffer);
  ctx_free (buffer);
}

CtxString *ctx_string_new_printf (const char *format, ...)
{
  CtxString *string = ctx_string_new ("");
  va_list ap;
  size_t needed;
  char *buffer;
  va_start (ap, format);
  needed = vsnprintf (NULL, 0, format, ap) + 1;
  buffer = (char*)ctx_malloc (needed);
  va_end (ap);
  va_start (ap, format);
  vsnprintf (buffer, needed, format, ap);
  va_end (ap);
  ctx_string_append_str (string, buffer);
  ctx_free (buffer);
  return string;
}


void
ctx_string_append_int (CtxString *string, int val)
{
  char buf[64];
  char *bp = &buf[0];
  int remainder;
  if (val < 0)
  {
    buf[0]='-';
    bp++;
    remainder = -val;
  }
  else
  remainder = val;

  int len = 0;
  do {
    int digit = remainder % 10;
    bp[len++] = digit + '0';
    remainder /= 10;
  } while (remainder);

  bp[len]=0;
  for (int i = 0; i < len/2; i++)
  {
    int tmp = bp[i];
    bp[i] = bp[len-1-i];
    bp[len-1-i] = tmp;
  }
  len += (val < 0);
  ctx_string_append_str (string, buf);
}

void
ctx_string_append_float (CtxString *string, float val)
{
  if (val < 0.0f)
  {
    ctx_string_append_byte (string, '-');
    val = -val;
  }
  int remainder = ((int)(val*10000))%10000;
  if (remainder % 10 > 5)
    remainder = remainder/10+1;
  else
    remainder /= 10;
  ctx_string_append_int (string, (int)val);
  if (remainder)
  {
    if (remainder<0)
      remainder=-remainder;
    ctx_string_append_byte (string, '.');
    if (remainder < 10)
      ctx_string_append_byte (string, '0');
    if (remainder < 100)
      ctx_string_append_byte (string, '0');
    ctx_string_append_int (string, remainder);
  }
}

void ctx_drawlist_clear (Ctx *ctx)
{
  ctx->drawlist.count = 0;
}

static void ctx_drawlist_backend_destroy (void *backend)
{
  ctx_free (backend);
}

void ctx_update_current_path (Ctx *ctx, const CtxEntry *entry)
{
#if CTX_CURRENT_PATH
  switch (entry->code)
    {
      case CTX_TEXT:
      case CTX_RESET_PATH:
        ctx->current_path.count = 0;
        break;
      case CTX_CLIP:
      case CTX_FILL:
      case CTX_STROKE:
              // XXX unless preserve
        ctx->current_path.count = 0;
        break;
      case CTX_CLOSE_PATH:
      case CTX_LINE_TO:
      case CTX_MOVE_TO:
      case CTX_CURVE_TO:
      case CTX_QUAD_TO:
      case CTX_SMOOTH_TO:
      case CTX_SMOOTHQ_TO:
      case CTX_REL_LINE_TO:
      case CTX_REL_MOVE_TO:
      case CTX_REL_QUAD_TO:
      case CTX_REL_SMOOTH_TO:
      case CTX_REL_SMOOTHQ_TO:
      case CTX_REL_CURVE_TO:
      case CTX_ARC:
      case CTX_ARC_TO:
      case CTX_REL_ARC_TO:
      case CTX_RECTANGLE:
      case CTX_ROUND_RECTANGLE:
        ctx_drawlist_add_entry (&ctx->current_path, entry);
        break;
      default:
        break;
    }
#endif
}

void
ctx_drawlist_process (Ctx *ctx, const CtxCommand *command)
{
  CtxEntry *entry = (CtxEntry*)command;
#if CTX_CURRENT_PATH
  ctx_update_current_path (ctx, entry);
#endif
  /* these functions can alter the code and coordinates of
     command that in the end gets added to the drawlist
   */
  ctx_interpret_style (&ctx->state, entry, ctx);
  ctx_interpret_transforms (&ctx->state, entry, ctx);
  ctx_interpret_pos (&ctx->state, entry, ctx);
  ctx_drawlist_add_entry (&ctx->drawlist, entry);
}

CtxBackend *ctx_drawlist_backend_new (void)
{
  CtxBackend *backend = (CtxBackend*)ctx_calloc (1, sizeof (CtxCtx));
                       // the sizeof(CtxCtx) should actually be sizeof(CtxBackend)
                       // but static analysis complains about event code
                       // initializing the extra members - which might most
                       // often be a false report - we add slack since it is
                       // "only" ~ 40 bytes per instance.
  backend->process = ctx_drawlist_process;
  backend->destroy = ctx_drawlist_backend_destroy;
  backend->type = CTX_BACKEND_DRAWLIST;
  return backend;
}

#if CTX_RASTERIZER

static int
ctx_rect_intersect (const CtxIntRectangle *a, const CtxIntRectangle *b)
{
  if (a->x >= b->x + b->width ||
      b->x >= a->x + a->width ||
      a->y >= b->y + b->height ||
      b->y >= a->y + a->height) return 0;

  return 1;
}


static void
_ctx_add_hash (CtxHasher *hasher, CtxIntRectangle *shape_rect, uint32_t hash)
{
  CtxIntRectangle rect = {0,0, hasher->rasterizer.blit_width/hasher->cols,
                               hasher->rasterizer.blit_height/hasher->rows};
  uint32_t active = 0;
  int hno = 0;
  for (int row = 0; row < hasher->rows; row++)
    for (int col = 0; col < hasher->cols; col++, hno++)
     {
      rect.x = col * rect.width;
      rect.y = row * rect.height;
      if (ctx_rect_intersect (shape_rect, &rect))
      {
        hasher->hashes[(row * hasher->cols + col)] ^= hash;
        hasher->hashes[(row * hasher->cols + col)] += 11;
        active |= (1<<hno);
      }
    }

  if (hasher->prev_command >=0)
  {
    hasher->drawlist->entries[hasher->prev_command].data.u32[1] = active;
  }

  hasher->prev_command = hasher->pos;
}

static int
ctx_str_count_lines (Ctx *ctx, const char *str)
{
  int count = 0;
  int len = 0;
  for (const char *p = str; *p; p++)
  {
    if (*p == '\n' || len > 40){ // hacky - but catches some wordwrap
      count ++;
      len = 0;
    }
    else len ++;
  }
  return count;
}

static inline uint32_t murmur_32_scramble(uint32_t k) {
    k *= 0xcc9e2d51;
    k = (k << 15) | (k >> 17);
    k *= 0x1b873593;
    return k;
}

static inline void murmur3_32_process(CtxMurmur *murmur, const uint8_t* key, size_t len)
{
    // code direct from the wikipedia article, it appears there without
    // a license
    uint32_t h = murmur->state[0];
    uint32_t k;
    /* Read in groups of 4. */
    for (size_t i = len >> 2; i; i--) {
        // Here is a source of differing results across endiannesses.
        // A swap here has no effects on hash properties though.
        memcpy(&k, key, sizeof(uint32_t));
        key += sizeof(uint32_t);
        h ^= murmur_32_scramble(k);
        h = (h << 13) | (h >> 19);
        h = h * 5 + 0xe6546b64;
    }
    /* Read the rest. */
    k = 0;
    for (size_t i = len & 3; i; i--) {
        k <<= 8;
        k |= key[i - 1];
    }
    // A swap is *not* necessary here because the preceding loop already
    // places the low bytes in the low places according to whatever endianness
    // we use. Swaps only apply when the memory is copied in a chunk.
    h ^= murmur_32_scramble(k);
    murmur->state[0] = h;
    murmur->state[1] += len;
}

static inline void murmur3_32_init (CtxMurmur *murmur)
{
  murmur->state[0]=0;
  murmur->state[1]=0;
}
static inline void murmur3_32_free (CtxMurmur *murmur)
{
  ctx_free (murmur);
}
static inline uint32_t murmur3_32_finalize (CtxMurmur *murmur)
{
  uint32_t h = murmur->state[0];
  /* Finalize. */
  h ^= murmur->state[1];
  h ^= h >> 16;
  h *= 0x85ebca6b;
  h ^= h >> 13;
  h *= 0xc2b2ae35;
  h ^= h >> 16;
  return h;
}

static inline int murmur3_32_done (CtxMurmur *murmur, unsigned char *out)
{
  murmur3_32_finalize (murmur);
  for (int i = 0; i < 4; i++)
    out[i]=0;
  memcpy (out, &murmur->state[0], 4);
  return murmur->state[0];
}

/*
 * the hasher should store a list of
 * times when the activeness of each tile changes
 *
 * on replay path and text/glyph commands as well
 * as stroke/fill can be ignored  clips outside
 * should mean no more drawing until restore
 */

static inline void
ctx_device_corners_to_user_rect (CtxState *state,
                                 float x0, float y0, float x1, float y1,
                                 CtxIntRectangle *shape_rect)
{
  int itw, ith;
  int itx = 0, ity = 0, itx2 = 0, ity2 = 0;
  _ctx_user_to_device_prepped (state, x0, y0, &itx, &ity);
  _ctx_user_to_device_prepped (state, x1, y1, &itx2, &ity2);
  itx /= CTX_SUBDIV;
  itx2 /= CTX_SUBDIV;
  ity /= CTX_FULL_AA;
  ity2 /= CTX_FULL_AA;
  if (itx2 < itx)
  {
    int tmp = itx2;itx2=itx;itx=tmp;
  }
  if (ity2 < ity)
  {
    int tmp = ity2;ity2=ity;ity=tmp;
  }
  itw = itx2-itx;
  ith = ity2-ity;
  shape_rect->x=itx;
  shape_rect->y=ity;
  shape_rect->width = itw;
  shape_rect->height = ith;
}

void
ctx_hasher_process (Ctx *ctx, const CtxCommand *command)
{
  const CtxEntry      *entry      = &command->entry;
  CtxRasterizer *rasterizer = (CtxRasterizer *) ctx->backend;
  CtxHasher     *hasher     = (CtxHasher*) ctx->backend;
  CtxState      *state      = rasterizer->state;
  CtxCommand *c = (CtxCommand *) entry;
  int aa = 15;//rasterizer->aa;

  ctx_interpret_pos_bare (rasterizer->state, entry, NULL);
  ctx_interpret_style (rasterizer->state, entry, NULL);

  switch (c->code)
    {
      case CTX_TEXT:
        {
          const char *str = ctx_arg_string();
          CtxMurmur murmur;
          memcpy (&murmur, &hasher->murmur_fill[hasher->source_level], sizeof (CtxMurmur));
          float width = ctx_text_width (rasterizer->backend.ctx, str);
          float height = ctx_get_font_size (rasterizer->backend.ctx);
           CtxIntRectangle shape_rect = {0,0,0,0};

           float tx = rasterizer->x;
           float ty = rasterizer->y - height * 1.2f;
           float tx2 = tx+width;
           float ty2 = ty+height * (ctx_str_count_lines (ctx, str) + 1.5f);

          switch ((int)ctx_state_get (rasterizer->state, SQZ_textAlign))
          {
          case CTX_TEXT_ALIGN_LEFT:
          case CTX_TEXT_ALIGN_START:
                  break;
          case CTX_TEXT_ALIGN_END:
          case CTX_TEXT_ALIGN_RIGHT:
           tx -= width;
           tx2 -= width;
           break;
          case CTX_TEXT_ALIGN_CENTER:
           tx -= width/2;
           tx2 -= width/2;
           break;
                   // XXX : doesn't take all text-alignments into account
          }
           ctx_device_corners_to_user_rect (rasterizer->state, tx,ty,tx2,ty2, &shape_rect);

          murmur3_32_process(&murmur, (const unsigned char*)ctx_arg_string(), ctx_strlen  (ctx_arg_string()));
#if 1
        murmur3_32_process(&murmur, (unsigned char*)(&rasterizer->state->gstate.transform), sizeof (rasterizer->state->gstate.transform));
    //      murmur3_32_process(&murmur, (unsigned char*)&color, 4);
#endif
          murmur3_32_process(&murmur, (unsigned char*)&shape_rect, sizeof (CtxIntRectangle));

        {
          float f = rasterizer->state->gstate.global_alpha_f;
          murmur3_32_process(&murmur, (uint8_t*)&f, sizeof(float));
        }


          _ctx_add_hash (hasher, &shape_rect, murmur3_32_finalize (&murmur));

          ctx_rasterizer_rel_move_to (rasterizer, width, 0);
        }
        ctx_rasterizer_reset (rasterizer);
        break;
      case CTX_GLYPH:
         {
          CtxMurmur murmur;
          memcpy (&murmur, &hasher->murmur_fill[hasher->source_level], sizeof (CtxMurmur));

          float width = ctx_glyph_width (rasterizer->backend.ctx, c->u32.a0);
          float height = ctx_get_font_size (rasterizer->backend.ctx);

          float tx = rasterizer->x;
          float ty = rasterizer->y;
          float tx2 = rasterizer->x + width;
          float ty2 = rasterizer->y + height * 2;
          CtxIntRectangle shape_rect;
          ctx_device_corners_to_user_rect (rasterizer->state, tx,ty,tx2,ty2, &shape_rect);

          shape_rect.y-=shape_rect.height/2;


        {
        uint32_t color;
        ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color, (uint8_t*)(&color));
          murmur3_32_process(&murmur, (unsigned char*)&color, 4);
        }
          murmur3_32_process(&murmur, (unsigned char*)&c->u32.a0, 4);
          murmur3_32_process(&murmur, (unsigned char*)(&rasterizer->state->gstate.transform), sizeof (rasterizer->state->gstate.transform));
          murmur3_32_process(&murmur, (unsigned char*)&shape_rect, sizeof (CtxIntRectangle));


        {
          float f = rasterizer->state->gstate.global_alpha_f;
          murmur3_32_process(&murmur, (uint8_t*)&f, sizeof(float));
        }

          _ctx_add_hash (hasher, &shape_rect, murmur3_32_finalize (&murmur));

          //ctx_rasterizer_rel_move_to (rasterizer, width, 0);
          //ctx_rasterizer_reset (rasterizer);
         }
        break;

      case CTX_CLIP:
      case CTX_PAINT:
        {
        CtxMurmur murmur;
        memcpy (&murmur, &hasher->murmur_fill[hasher->source_level], sizeof (CtxMurmur));
        if (rasterizer->edge_list.count)
          murmur3_32_process(&murmur,  (uint8_t*)rasterizer->edge_list.entries, sizeof(CtxSegment) * rasterizer->edge_list.count);

        {
          int is = rasterizer->state->gstate.fill_rule;
          murmur3_32_process(&murmur, (uint8_t*)&is, sizeof(int));
        }

        {
          float f = rasterizer->state->gstate.global_alpha_f;
          murmur3_32_process(&murmur, (uint8_t*)&f, sizeof(float));
        }
        {
        uint32_t color;
        ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color, (uint8_t*)(&color));
          murmur3_32_process(&murmur, (unsigned char*)&color, 4);
        }


        CtxIntRectangle shape_rect = {-100,-100,
                rasterizer->blit_width*10,
                rasterizer->blit_height*10};
        _ctx_add_hash (hasher, &shape_rect, murmur3_32_finalize (&murmur));
        }

        break;
      case CTX_FILL:
        {
          CtxMurmur murmur;
          memcpy (&murmur, &hasher->murmur_fill[hasher->source_level], sizeof (CtxMurmur));

          /* we eant this hasher to be as good as possible internally,
           * since it is also used in the small shapes rasterization
           * cache
           */
        CtxIntRectangle shape_rect = {
          (int)(rasterizer->col_min / CTX_SUBDIV - 3),
          (int)(rasterizer->scan_min / aa - 3),
          (int)(5+(rasterizer->col_max - rasterizer->col_min + CTX_SUBDIV-1) / CTX_SUBDIV),
          (int)(5+(rasterizer->scan_max - rasterizer->scan_min + aa-1) / aa)
        };

        if (rasterizer->edge_list.count)
          murmur3_32_process(&murmur,  (uint8_t*)rasterizer->edge_list.entries, sizeof(CtxSegment) * rasterizer->edge_list.count);

        {
          int is = rasterizer->state->gstate.fill_rule;
          murmur3_32_process(&murmur, (uint8_t*)&is, sizeof(int));
        }
        {
          int is = rasterizer->state->gstate.image_smoothing;
          murmur3_32_process(&murmur, (uint8_t*)&is, sizeof(int));
        }
        {
          int e = rasterizer->state->gstate.extend;
          murmur3_32_process(&murmur, (uint8_t*)&e, sizeof(int));
        }
        {
          float f = rasterizer->state->gstate.global_alpha_f;
          murmur3_32_process(&murmur, (uint8_t*)&f, sizeof(float));
        }
        {
        uint32_t color;
        ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color, (uint8_t*)(&color));
          murmur3_32_process(&murmur, (unsigned char*)&color, 4);
        }

          _ctx_add_hash (hasher, &shape_rect, murmur3_32_finalize (&murmur));

        if (c->code == CTX_CLIP)
          ctx_rasterizer_clip (rasterizer);

        if (!rasterizer->preserve)
          ctx_rasterizer_reset (rasterizer);
        rasterizer->preserve = 0;

        }
        break;
      case CTX_STROKE:
        {
          CtxMurmur murmur;
          memcpy (&murmur, &hasher->murmur_stroke[hasher->source_level], sizeof (CtxMurmur));
        if (rasterizer->edge_list.count)
        murmur3_32_process(&murmur,  (uint8_t*)rasterizer->edge_list.entries, sizeof(CtxSegment) * rasterizer->edge_list.count);
        CtxIntRectangle shape_rect = {
          (int)(rasterizer->col_min / CTX_SUBDIV - rasterizer->state->gstate.line_width),
          (int)(rasterizer->scan_min / aa - rasterizer->state->gstate.line_width),
          (int)((rasterizer->col_max - rasterizer->col_min + 1) / CTX_SUBDIV + rasterizer->state->gstate.line_width),
          (int)((rasterizer->scan_max - rasterizer->scan_min + 1) / aa + rasterizer->state->gstate.line_width)
        };
        //printf ("%ix%i %i %i\n", shape_rect.width, shape_rect.height, shape_rect.x, shape_rect.y);
        // XXX the height and y coordinates seem off!

        shape_rect.width += (int)(rasterizer->state->gstate.line_width * 2);
        shape_rect.height += (int)(rasterizer->state->gstate.line_width * 2);
        shape_rect.x -= (int)(rasterizer->state->gstate.line_width);
        shape_rect.y -= (int)(rasterizer->state->gstate.line_width);

        {
          float f;
          int i;
          f = rasterizer->state->gstate.global_alpha_f;
          murmur3_32_process(&murmur, (uint8_t*)&f, sizeof(float));
          f = rasterizer->state->gstate.line_width;
          murmur3_32_process(&murmur, (uint8_t*)&f, sizeof(float));
          i = rasterizer->state->gstate.line_cap;
          murmur3_32_process(&murmur, (uint8_t*)&i, sizeof(int));
          i = rasterizer->state->gstate.line_join;
          murmur3_32_process(&murmur, (uint8_t*)&i, sizeof(int));
          i = rasterizer->state->gstate.source_stroke.type;
          murmur3_32_process(&murmur, (uint8_t*)&i, sizeof(int));
        }

        uint32_t color;
        ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_stroke.color, (uint8_t*)(&color));
          murmur3_32_process(&murmur, (unsigned char*)&color, 4);
        ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color, (uint8_t*)(&color));
          murmur3_32_process(&murmur, (unsigned char*)&color, 4);

          _ctx_add_hash (hasher, &shape_rect, murmur3_32_finalize (&murmur));
        }
        if (!rasterizer->preserve)
          ctx_rasterizer_reset (rasterizer);
        rasterizer->preserve = 0;
        break;
        /* the above cases are the painting cases and 
         * the only ones differing from the rasterizer's process switch
         */

      case CTX_LINE_TO:
        ctx_rasterizer_line_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_REL_LINE_TO:
        ctx_rasterizer_rel_line_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_MOVE_TO:
        ctx_rasterizer_move_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_REL_MOVE_TO:
        ctx_rasterizer_rel_move_to (rasterizer, c->c.x0, c->c.y0);
        break;
      case CTX_CURVE_TO:
        ctx_rasterizer_line_to (rasterizer, c->c.x0, c->c.y0);
        ctx_rasterizer_line_to (rasterizer, c->c.x1, c->c.y1);
        ctx_rasterizer_line_to (rasterizer, c->c.x2, c->c.y2);
        //ctx_rasterizer_curve_to (rasterizer, c->c.x0, c->c.y0,
        //                         c->c.x1, c->c.y1,
        //                         c->c.x2, c->c.y2);
        break;
      case CTX_REL_CURVE_TO:
        ctx_rasterizer_rel_line_to (rasterizer, c->c.x2, c->c.y2);
        //ctx_rasterizer_rel_curve_to (rasterizer, c->c.x0, c->c.y0,
        //                             c->c.x1, c->c.y1,
        //                             c->c.x2, c->c.y2);
        break;
      case CTX_QUAD_TO:
        ctx_rasterizer_line_to (rasterizer, c->c.x1, c->c.y1);
        //ctx_rasterizer_quad_to (rasterizer, c->c.x0, c->c.y0, c->c.x1, c->c.y1);
        break;
      case CTX_REL_QUAD_TO:
        ctx_rasterizer_rel_line_to (rasterizer, c->c.x1, c->c.y1);
        //ctx_rasterizer_rel_quad_to (rasterizer, c->c.x0, c->c.y0, c->c.x1, c->c.y1);
        break;
      case CTX_ARC:
        ctx_rasterizer_arc (rasterizer, c->arc.x, c->arc.y, c->arc.radius, c->arc.angle1, c->arc.angle2, (int)c->arc.direction);
        break;
      case CTX_RECTANGLE:
        ctx_rasterizer_rectangle (rasterizer, c->rectangle.x, c->rectangle.y,
                                  c->rectangle.width, c->rectangle.height);
        break;
      case CTX_ROUND_RECTANGLE:
        ctx_rasterizer_round_rectangle (rasterizer, c->rectangle.x, c->rectangle.y,
                                        c->rectangle.width, c->rectangle.height,
                                        c->rectangle.radius);
        break;
      case CTX_SET_PIXEL:
        ctx_rasterizer_set_pixel (rasterizer, c->set_pixel.x, c->set_pixel.y,
                                  c->set_pixel.rgba[0],
                                  c->set_pixel.rgba[1],
                                  c->set_pixel.rgba[2],
                                  c->set_pixel.rgba[3]);
        break;
      case CTX_PRESERVE:
        rasterizer->preserve = 1;
        break;
      case CTX_SAVE:
      case CTX_RESTORE:

        if (c->code == CTX_SAVE)
        {
           if (hasher->source_level + 1 < CTX_MAX_STATES)
           {
             hasher->source_level++;
             hasher->murmur_fill[hasher->source_level] =
               hasher->murmur_fill[hasher->source_level-1];
             hasher->murmur_stroke[hasher->source_level] =
               hasher->murmur_stroke[hasher->source_level-1];
           }
        }
        else
        {
           if (hasher->source_level - 1 >= 0)
           {
             hasher->source_level--;
             hasher->murmur_fill[hasher->source_level] =
               hasher->murmur_fill[hasher->source_level+1];
             hasher->murmur_stroke[hasher->source_level] =
               hasher->murmur_stroke[hasher->source_level+1];
           }
        }

        /* FALLTHROUGH */
      case CTX_ROTATE:
      case CTX_SCALE:
      case CTX_TRANSLATE:
      case CTX_APPLY_TRANSFORM:

        ctx_interpret_transforms (rasterizer->state, entry, NULL);
        break;
      case CTX_FONT:
        ctx_rasterizer_set_font (rasterizer, ctx_arg_string() );
        break;
      case CTX_RESET_PATH:
        ctx_rasterizer_reset (rasterizer);
        break;
      case CTX_CLOSE_PATH:
        ctx_rasterizer_close_path (rasterizer);
        break;
      case CTX_DEFINE_TEXTURE:
        {
        murmur3_32_init (&hasher->murmur_fill[hasher->source_level]);
        murmur3_32_process(&hasher->murmur_fill[hasher->source_level], &rasterizer->state->gstate.global_alpha_u8, 1);
        murmur3_32_process (&hasher->murmur_fill[hasher->source_level], (uint8_t*)c->define_texture.eid, ctx_strlen (c->define_texture.eid));
        murmur3_32_process(&hasher->murmur_fill[hasher->source_level], (unsigned char*)(&rasterizer->state->gstate.transform), sizeof (rasterizer->state->gstate.transform));

        rasterizer->comp_op = NULL; // why?
        }
        break;
      case CTX_TEXTURE:
        murmur3_32_init (&hasher->murmur_fill[hasher->source_level]);
        murmur3_32_process(&hasher->murmur_fill[hasher->source_level], &rasterizer->state->gstate.global_alpha_u8, 1);
        murmur3_32_process (&hasher->murmur_fill[hasher->source_level], (uint8_t*)c->texture.eid, ctx_strlen (c->texture.eid));
        murmur3_32_process (&hasher->murmur_fill[hasher->source_level], (uint8_t*)(&rasterizer->state->gstate.transform), sizeof (rasterizer->state->gstate.transform));
        rasterizer->comp_op = NULL; // why?
        break;
      case CTX_COLOR:
        {
          uint32_t color;
          if (((int)(ctx_arg_float(0))&512))
          {
            ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_stroke.color, (uint8_t*)(&color));
            murmur3_32_init (&hasher->murmur_stroke[hasher->source_level]);
            murmur3_32_process(&hasher->murmur_stroke[hasher->source_level], &rasterizer->state->gstate.global_alpha_u8, 1);
            murmur3_32_process(&hasher->murmur_stroke[hasher->source_level], (unsigned char*)&color, 4);
          }
          else
          {
            ctx_color_get_rgba8 (rasterizer->state, &rasterizer->state->gstate.source_fill.color, (uint8_t*)(&color));
            murmur3_32_init (&hasher->murmur_fill[hasher->source_level]);
            murmur3_32_process(&hasher->murmur_fill[hasher->source_level], &rasterizer->state->gstate.global_alpha_u8, 1);
            murmur3_32_process(&hasher->murmur_fill[hasher->source_level], (unsigned char*)&color, 4);
          }
        }
        break;
      case CTX_CONIC_GRADIENT: // XXX: good enough?
      case CTX_LINEAR_GRADIENT:
          murmur3_32_init (&hasher->murmur_fill[hasher->source_level]);
          murmur3_32_process(&hasher->murmur_fill[hasher->source_level], &rasterizer->state->gstate.global_alpha_u8, 1);
          murmur3_32_process(&hasher->murmur_fill[hasher->source_level], 
                           (uint8_t*)c, sizeof (c->linear_gradient));
          murmur3_32_process (&hasher->murmur_fill[hasher->source_level], (unsigned char*)(&rasterizer->state->gstate.transform), sizeof (rasterizer->state->gstate.transform));
        break;
      case CTX_RADIAL_GRADIENT:
          murmur3_32_init (&hasher->murmur_fill[hasher->source_level]);
          murmur3_32_process(&hasher->murmur_fill[hasher->source_level], &rasterizer->state->gstate.global_alpha_u8, 1);
          murmur3_32_process(&hasher->murmur_fill[hasher->source_level], 
                           (uint8_t*)c, sizeof (c->radial_gradient));
          murmur3_32_process (&hasher->murmur_fill[hasher->source_level], (unsigned char*)(&rasterizer->state->gstate.transform), sizeof (rasterizer->state->gstate.transform));
        //ctx_state_gradient_clear_stops (rasterizer->state);
        break;
#if CTX_GRADIENTS
      case CTX_GRADIENT_STOP:
        {
          float rgba[4]= {ctx_u8_to_float (ctx_arg_u8 (4) ),
                          ctx_u8_to_float (ctx_arg_u8 (4+1) ),
                          ctx_u8_to_float (ctx_arg_u8 (4+2) ),
                          ctx_u8_to_float (ctx_arg_u8 (4+3) )
                         };
          murmur3_32_process(&hasher->murmur_fill[hasher->source_level], 
                           (uint8_t*) &rgba[0], sizeof(rgba));
        }
        break;
#endif
    }

#if 0
  if (command->code == CTX_START_FRAME)
  {
  }
#endif

    hasher->pos += ctx_conts_for_entry ((CtxEntry*)(command))+1;
  if (command->code == CTX_LINE_WIDTH)
    {
      float x = state->gstate.line_width;
      /* normalize line width according to scaling factor
       */
      x = x * ctx_maxf (ctx_maxf (ctx_fabsf (state->gstate.transform.m[0][0]),
                                  ctx_fabsf (state->gstate.transform.m[0][1]) ),
                        ctx_maxf (ctx_fabsf (state->gstate.transform.m[1][0]),
                                  ctx_fabsf (state->gstate.transform.m[1][1]) ) );
      state->gstate.line_width = x;
    }
}

CtxRasterizer *
ctx_hasher_init (CtxRasterizer *rasterizer, Ctx *ctx, CtxState *state, int width, int height, int cols, int rows, CtxDrawlist *drawlist)
{
  CtxHasher *hasher = (CtxHasher*)rasterizer;
  memset (rasterizer, 0, sizeof (CtxHasher) );
  CtxBackend *backend = (CtxBackend*)hasher;
  backend->type        = CTX_BACKEND_HASHER;
  backend->ctx         = ctx;
  backend->process = ctx_hasher_process;
  backend->destroy = (CtxDestroyNotify)ctx_rasterizer_destroy;
  // XXX need own destructor to not leak ->hashes
  rasterizer->edge_list.flags |= CTX_DRAWLIST_EDGE_LIST;
  rasterizer->state       = state;
  ctx_state_init (rasterizer->state);
  rasterizer->blit_x      = 0;
  rasterizer->blit_y      = 0;
  rasterizer->blit_width  = width;
  rasterizer->blit_height = height;
  rasterizer->state->gstate.clip_min_x  = 0;
  rasterizer->state->gstate.clip_min_y  = 0;
  rasterizer->state->gstate.clip_max_x  = width - 1;
  rasterizer->state->gstate.clip_max_y  = height - 1;
  rasterizer->scan_min    = 5000;
  rasterizer->scan_max    = -5000;
  //rasterizer->aa          = 15;

  hasher->rows = rows;
  hasher->cols = cols;
  hasher->pos  = 0;

  hasher->drawlist = drawlist;
  hasher->prev_command = -1;

  memset(hasher->hashes,0, sizeof (hasher->hashes));
  murmur3_32_init (&hasher->murmur_fill[hasher->source_level]);
  murmur3_32_init (&hasher->murmur_stroke[hasher->source_level]);

  return rasterizer;
}

Ctx *ctx_hasher_new (int width, int height, int cols, int rows, CtxDrawlist *drawlist)
{
  Ctx *ctx           = ctx_new_drawlist (width, height);
  CtxState    *state = &ctx->state;
  CtxRasterizer *rasterizer = (CtxRasterizer *) ctx_calloc (1, sizeof (CtxHasher));
  ctx_hasher_init (rasterizer, ctx, state, width, height, cols, rows, drawlist);
  ctx_set_backend (ctx, (void*)rasterizer);
  return ctx;
}

uint32_t ctx_hasher_get_hash (Ctx *ctx, int col, int row)
{
  CtxHasher *hasher = (CtxHasher*)ctx->backend;
  if (row < 0) row =0;
  if (col < 0) col =0;
  if (row >= hasher->rows) row = hasher->rows-1;
  if (col >= hasher->cols) col = hasher->cols-1;

  if (hasher->prev_command >= 0)
  hasher->drawlist->entries[hasher->prev_command].data.u32[1] = 0xffffffff;

  return hasher->hashes[(row*hasher->cols+col)];
}

#endif
/*
 * TODO:
 *   gradients
 *   text-layout
 *   textures
 *   links
 *
 */


#if CTX_PDF

#define CTX_PDF_MAX_OBJS 256
#define CTX_PDF_MAX_RESOURCES 256 // in one page

#define CTX_PDF_MAX_PAGES CTX_PDF_MAX_OBJS

typedef struct _CtxPDF CtxPDF;
enum { CTX_PDF_TIMES = 1,
       CTX_PDF_HELVETICA, //2
       CTX_PDF_COURIER, //3
       CTX_PDF_SYMBOL, //4
       CTX_PDF_TIMES_BOLD,
       CTX_PDF_HELVETICA_BOLD,
       CTX_PDF_COURIER_BOLD,
       CTX_PDF_ZAPF_DING_BATS, // 8
       CTX_PDF_TIMES_ITALIC, // 9
       CTX_PDF_HELVETICA_ITALIC, // 10
       CTX_PDF_COURIER_ITALIC, // 11
       CTX_PDF_TIMES_BOLD_ITALIC, // 12
       CTX_PDF_HELVETICA_BOLD_ITALIC, //13
       CTX_PDF_COURIER_BOLD_ITALIC, //14
       // courier and helvetica variants are called
       // oblique not italic in the PDF spec

};

typedef struct
_CtxPdfResource
{
  int id;
  int type; // 0 opacity, 1 linear grad, 2 radial grad
  union { 
     struct { float value;}                   opacity;
     struct { float x0, y0, x1, y1;}          linear_gradient;
     struct { float x0, y0, r0, x1, y1, r1;}  radial_gradient;
     struct { const char *eid;int width, height,stride,format;uint8_t *data;}  texture;
     struct { int   no;}    font;
     // texture
     // linear-gradient
     // radial-gradient
  };
} CtxPdfResource;


struct
  _CtxPDF
{
  CtxBackend     backend;
  int            preserve;
  const char    *path;
  CtxString     *document;
  CtxState       state;
  int            pat;
  int            xref[CTX_PDF_MAX_OBJS];
  int            objs;
  int            page_length_offset;
  int            page_height_offset;
  int            kids_offset;
  int            page_count_offset;

  int            width;
  int            height;

  char          *encoding;

  CtxPdfResource resource[CTX_PDF_MAX_RESOURCES];
  int            resource_count;

  int            page_resource[CTX_PDF_MAX_RESOURCES];
  int            page_resource_count;
  int            new_resource[CTX_PDF_MAX_RESOURCES];
  int            new_resource_count;

  int            next_obj; // pre-emptive builds
                           // during page build

  float          page_size[4];

  int            page_objs[CTX_PDF_MAX_PAGES];
  int            content_objs[CTX_PDF_MAX_PAGES];
  int            page_count;

  int            pages; // known to be 1
  int            font;
  int            font_map;


  int alphas[10];
};


#define ctx_pdf_print(str) \
        do { ctx_string_append_str (pdf->document, str);\
}while (0)
#define ctx_pdf_printf(fmt, a...) \
        do { ctx_string_append_printf (pdf->document, fmt, ##a);\
}while (0)
#define ctx_pdf_print1i(i0) \
        do { ctx_string_append_int (pdf->document, i0);\
        ctx_string_append_byte (pdf->document, ' ');\
}while (0)
#define ctx_pdf_print1f(f0) \
        do { ctx_string_append_float (pdf->document, f0);\
             ctx_string_append_byte (pdf->document, ' '); }while (0)
#define ctx_pdf_print2f(f0,f1) \
        do { ctx_pdf_print1f(f0);ctx_pdf_print1f(f1); }while (0)
#define ctx_pdf_print3f(f0,f1,f2) \
        do { ctx_pdf_print2f(f0,f1);ctx_pdf_print1f(f2); }while (0)
#define ctx_pdf_print4f(f0,f1,f2,f3) \
        do { ctx_pdf_print3f(f0,f1,f2);ctx_pdf_print1f(f3); }while (0)
#define ctx_pdf_print5f(f0,f1,f2,f3,f4) \
        do { ctx_pdf_print4f(f0,f1,f2,f3);ctx_pdf_print1f(f4); }while (0)
#define ctx_pdf_print6f(f0,f1,f2,f3,f4,f5) \
        do { ctx_pdf_print5f(f0,f1,f2,f3,f4);ctx_pdf_print1f(f5); }while (0)

/**
 * Generate a cubic Bezier representing an arc on the unit circle of total
 * angle ‘size‘ radians, beginning ‘start‘ radians above the x-axis.
 */
static void acuteArcToBezier(float start, float size,
                float *ax,
                float *ay,
                float *bx,
                float *by,
                float *cx,
                float *cy,
                float *dx,
                float *dy
                ) {
  // Evaluate constants.
  float alpha = size / 2.0,
      cos_alpha = ctx_cosf(alpha),
      sin_alpha = ctx_sinf(alpha),
      cot_alpha = 1.0 / ctx_tanf(alpha),
      phi = start + alpha, // This is how far the arc needs to be rotated.
      cos_phi = ctx_cosf(phi),
      sin_phi = ctx_sinf(phi),
      lambda = (4.0 - cos_alpha) / 3.0,
      mu = sin_alpha + (cos_alpha - lambda) * cot_alpha;
 // Return rotated waypoints.
 *ax = ctx_cosf(start),
 *ay = ctx_sinf(start),
 *bx = lambda * cos_phi + mu * sin_phi,
 *by = lambda * sin_phi - mu * cos_phi,
 *cx = lambda * cos_phi - mu * sin_phi,
 *cy = lambda * sin_phi + mu * cos_phi,
 *dx = ctx_cosf(start + size),
 *dy = ctx_sinf(start + size);
}


static char *ctx_utf8_to_mac_roman (const uint8_t *string);
static char *ctx_utf8_to_windows_1252 (const uint8_t *string);

void pdf_end_object (CtxPDF *pdf)
{
  ctx_pdf_print("\nendobj\n");
}

int pdf_add_object (CtxPDF *pdf)
{
  if (pdf->objs) pdf_end_object (pdf);
  // we use 1 indexing in this array
  pdf->xref[++pdf->objs] = pdf->document->length;
  ctx_pdf_printf("%i 0 obj\n", pdf->objs);
  return pdf->objs;
}

static void
pdf_start_page (CtxPDF *pdf)
{
  pdf->page_count++;
  pdf->content_objs[pdf->page_count]=pdf_add_object (pdf); // 2 - our actual page contents
  ctx_pdf_printf ("<</Length ");
  pdf->page_length_offset = pdf->document->length;
  ctx_pdf_printf ("XXXXXXXXXX>>\n");
  ctx_pdf_printf ("stream\nBT\n1 0 0 -1 0 ");
  pdf->page_height_offset = pdf->document->length;
  ctx_pdf_printf ("XXXXXXXXXX cm\n/F1 24 Tf\n", pdf->height);

  pdf->page_resource_count = 0;
  pdf->new_resource_count = 0;
  pdf->next_obj = pdf->content_objs[pdf->page_count]+1;
}

static void
pdf_end_page (CtxPDF *pdf)
{
  int length = (pdf->document->length - pdf->page_length_offset) - 17;
  char buf[11];
  snprintf (buf, 11, "%10u", length);
  memcpy   (&pdf->document->str[pdf->page_length_offset], buf, 10);
  snprintf (buf, 11, "% 9f", pdf->page_size[3]);
  memcpy   (&pdf->document->str[pdf->page_height_offset], buf, 10);
  ctx_pdf_printf("\nET\nendstream\n");

  for (int i = 0; i < pdf->new_resource_count; i ++)
  {
    float opacity = 1.0f;
    for (int j = 0; j < pdf->resource_count; j ++)
    {
      if (pdf->resource[j].id == pdf->new_resource[i])
        opacity = pdf->resource[j].opacity.value;
    }
    pdf->alphas[i]=pdf_add_object (pdf); // 4
    ctx_pdf_printf ("<</Type/ExtGState/ca %.2f/CA %.2f>>", opacity, opacity);
  }

   pdf->page_objs[pdf->page_count]=pdf_add_object (pdf);
   ctx_pdf_printf ("<<"
"/Contents %i 0 R/Type/Page/Resources<</ProcSet[/PDF/Text]/Font %i 0 R", pdf->content_objs[pdf->page_count], pdf->font_map);
   ctx_pdf_printf ("/ExtGState");

   ctx_pdf_printf ("<<");
   for (int i = 0; i < pdf->page_resource_count; i++)
   {
     ctx_pdf_printf ("/G%i %i 0 R", pdf->page_resource[i],
                                    pdf->page_resource[i]);
   }
   ctx_pdf_print (">>");
   ctx_pdf_print (">>/Parent ");
   ctx_pdf_print1i (pdf->pages);ctx_pdf_print ("0 R");
   ctx_pdf_print ("/MediaBox[");
   ctx_pdf_print4f (pdf->page_size[0], pdf->page_size[1],
                    pdf->page_size[2]+pdf->page_size[0], pdf->page_size[3]+pdf->page_size[1]);
   ctx_pdf_print ("]>>");

}


void ctx_pdf_set_opacity (CtxPDF *pdf, float alpha)
{
  int obj_no = 0;

  for (int i = 0; i < pdf->resource_count; i++)
  {
    if (pdf->resource[i].type == 0 &&
        pdf->resource[i].opacity.value == alpha)
    {
      obj_no = pdf->resource[i].id;
    }
  }

  if (obj_no == 0)
  {
     pdf->resource[pdf->resource_count].type = 0;
     pdf->resource[pdf->resource_count].opacity.value = alpha;
     obj_no = pdf->resource[pdf->resource_count].id = 
             pdf->next_obj++;
     pdf->resource_count++;

     pdf->new_resource[pdf->new_resource_count++] =
       obj_no;
  }

  ctx_pdf_printf("/G%i gs ", obj_no);

  for (int i = 0; i < pdf->page_resource_count; i ++)
  {
    if (pdf->page_resource[i] == obj_no)
      return;
  }
  pdf->page_resource[pdf->page_resource_count++] = obj_no;
}

static void
ctx_pdf_line_to (Ctx *ctx, float x, float y)
{
  CtxPDF *pdf = (CtxPDF*)ctx->backend;
  ctx_pdf_print2f(x, y); ctx_pdf_print("l ");
}
static void
ctx_pdf_move_to (Ctx *ctx, float x, float y)
{
  CtxPDF *pdf = (CtxPDF*)ctx->backend;
  ctx_pdf_print2f(x, y); ctx_pdf_print("m ");
}
static void
ctx_pdf_curve_to (Ctx *ctx, float cx0, float cy0, float cx1, float cy1, float x, float y)
{
  CtxPDF *pdf = (CtxPDF*)ctx->backend;
  ctx_pdf_print6f(cx0,cy0,cx1,cy1,x,y); ctx_pdf_print("c ");
}

static void
ctx_pdf_apply_transform (Ctx *ctx, float a, float b, float c, float d, float e, float f)
{
  CtxPDF *pdf = (CtxPDF*)ctx->backend;
  ctx_pdf_print6f(a,b,c,d,e,f);
  ctx_pdf_print("cm\n");
}

static void
ctx_pdf_process (Ctx *ctx, const CtxCommand *c)
{
  CtxPDF *pdf = (CtxPDF*)ctx->backend;
  const CtxEntry *entry = (CtxEntry *) &c->entry;
  CtxState *state = &pdf->state;

  CtxDrawlist *preserved = NULL;

  ctx_interpret_style (&pdf->state, entry, NULL);

  switch (entry->code)
    {
      case CTX_NEW_PAGE:
        pdf_end_page (pdf);
        pdf_start_page (pdf);
        break;

      case CTX_LINE_TO:         ctx_pdf_line_to (ctx, c->line_to.x, c->line_to.y); break;
      case CTX_HOR_LINE_TO:     ctx_pdf_line_to (ctx, ctx_arg_float(0), state->y); break;
      case CTX_VER_LINE_TO:     ctx_pdf_line_to (ctx, state->x, ctx_arg_float(0)); break;
      case CTX_REL_LINE_TO:     ctx_pdf_line_to (ctx, c->line_to.x + state->x, c->line_to.y + state->y); break;
      case CTX_REL_HOR_LINE_TO: ctx_pdf_line_to (ctx, ctx_arg_float(0) + state->x, state->y); break;
      case CTX_REL_VER_LINE_TO: ctx_pdf_line_to (ctx, state->x, ctx_arg_float(0) + state->y); break;

      case CTX_MOVE_TO:         ctx_pdf_move_to (ctx, c->move_to.x, c->move_to.y); break;
      case CTX_REL_MOVE_TO:     ctx_pdf_move_to (ctx, c->move_to.x + state->x, c->move_to.y + state->y); break;

      case CTX_CURVE_TO:
        ctx_pdf_curve_to (ctx, c->curve_to.cx1, c->curve_to.cy1,
                               c->curve_to.cx2, c->curve_to.cy2,
                               c->curve_to.x, c->curve_to.y);
        break;


      case CTX_REL_CURVE_TO:
        ctx_pdf_curve_to (ctx, c->curve_to.cx1 + state->x, c->curve_to.cy1 + state->y,
                               c->curve_to.cx2 + state->x, c->curve_to.cy2 + state->y,
                               c->curve_to.x   + state->x, c->curve_to.y   + state->y);
        break;


      case CTX_PRESERVE:
        pdf->preserve = 1;
        break;

      case CTX_QUAD_TO:
        {
          float cx = ctx_arg_float (0);
          float cy = ctx_arg_float (1);
          float  x = ctx_arg_float (2);
          float  y = ctx_arg_float (3);
          float cx1 = (cx * 2 + state->x) / 3.0f;
          float cy1 = (cy * 2 + state->y) / 3.0f;
          float cx2 = (cx * 2 + x) / 3.0f;
          float cy2 = (cy * 2 + y) / 3.0f;
          ctx_pdf_curve_to (ctx, cx1, cy1, cx2, cy2, x, y);
        }
        break;

      case CTX_REL_QUAD_TO:
        {
          float cx = ctx_arg_float (0);
          float cy = ctx_arg_float (1);
          float  x = ctx_arg_float (2);
          float  y = ctx_arg_float (3);
          float cx1 = (cx * 2 ) / 3.0f;
          float cy1 = (cy * 2 ) / 3.0f;
          float cx2 = (cx * 2 + x) / 3.0f;
          float cy2 = (cy * 2 + y) / 3.0f;
          ctx_pdf_curve_to (ctx, cx1 + state->x, cy1 + state->y,
                                 cx2 + state->x, cy2 + state->y,
                                 x   + state->x, y   + state->y);
        }
        break;

      case CTX_LINE_WIDTH:
        ctx_pdf_printf("%f w\n", ctx_arg_float (0));
        break;

      case CTX_ARC:
        {
           float x = c->arc.x,
                 y = c->arc.y,
                 w = c->arc.radius,
                 h = c->arc.radius,
                 stop  = c->arc.angle1,
                 start = c->arc.angle2;
                 //direction = c->arc.direction;

           start = start * 0.99;

           while (start < 0) start += CTX_PI * 2;
           while (stop < 0) stop += CTX_PI * 2;

           start = ctx_fmodf (start, CTX_PI * 2);
           stop  = ctx_fmodf (stop, CTX_PI * 2);
           // Adjust angles to counter linear scaling.
           if (start <= CTX_PI/2) {
             start = ctx_atanf(w / h * ctx_tanf(start));
           } else if (start > CTX_PI/2 && start <= 3 * CTX_PI/2) {
             start = ctx_atanf(w / h * ctx_tanf(start)) + CTX_PI;
           } else {
             start = ctx_atanf(w / h * ctx_tanf(start)) + CTX_PI*2;
           }
           if (stop <= CTX_PI/2) {
             stop = ctx_atanf(w / h * ctx_tanf(stop));
           } else if (stop > CTX_PI/2 && stop <= 3 * CTX_PI/2) {
             stop = ctx_atanf (w / h * ctx_tanf(stop)) + CTX_PI;
           } else {
             stop = ctx_atanf (w / h * ctx_tanf(stop)) + CTX_PI*2;
           }
           // Exceed the interval if necessary in order to preserve the size and
           // orientation of the arc.
           if (start > stop) {
             stop += CTX_PI * 2;
           }
             // Create curves
             float epsilon = 0.00001f; // Smallest visible angle on displays up to 4K.
             float arcToDraw = 0;
             float curves[4][8]={{0.0f,}};
             int n_curves = 0;
             while(stop - start > epsilon) {
               arcToDraw = ctx_minf(stop - start, CTX_PI/2);
               {
                 //float cx0, cy0, cx1, cy1, cx2, cy2, x, y;
                 acuteArcToBezier(start, arcToDraw, 
                                 &curves[n_curves][0], &curves[n_curves][1],
                                 &curves[n_curves][2], &curves[n_curves][3],
                                 &curves[n_curves][4], &curves[n_curves][5],
                                 &curves[n_curves][6], &curves[n_curves][7]);
                 n_curves++;
               }
             start += arcToDraw;
           }

             float rx = w / 2.0f;
             float ry = h / 2.0f;
             ctx_pdf_print2f(x + rx * curves[0][0], y + ry * curves[0][1]);
             ctx_pdf_print("m\n");
             for (int i = 0; i < n_curves; i++)
             {
               ctx_pdf_curve_to (ctx, x + rx * curves[i][2], y + ry * curves[i][3],
                                  x + rx * curves[i][4], y + ry * curves[i][5],
                                  x + rx * curves[i][6], y + ry * curves[i][7]);
             }
        }
#if 0
        fprintf (stderr, "F %2.1f %2.1f %2.1f %2.1f %2.1f %2.1f\n",
                        ctx_arg_float(0),
                        ctx_arg_float(1),
                        ctx_arg_float(2),
                        ctx_arg_float(3),
                        ctx_arg_float(4),
                        ctx_arg_float(5),
                        ctx_arg_float(6));
        if (ctx_arg_float (5) == 1)
          pdf_arc (cr, ctx_arg_float (0), ctx_arg_float (1),
                     ctx_arg_float (2), ctx_arg_float (3),
                     ctx_arg_float (4) );
        else
          pdf_arc_negative (cr, ctx_arg_float (0), ctx_arg_float (1),
                              ctx_arg_float (2), ctx_arg_float (3),
                              ctx_arg_float (4) );
#endif
        break;

      case CTX_COLOR:
        {
        int space =  ((int) ctx_arg_float (0)) & 511;
        switch (space) // XXX remove 511 after stroke source is complete
        {
           case CTX_RGBA:
           case CTX_DRGBA:
             ctx_pdf_set_opacity (pdf, c->rgba.a);
             /*FALLTHROUGH*/
           case CTX_RGB:
              if (space == CTX_RGB || space == CTX_DRGB)
                ctx_pdf_set_opacity (pdf, 1.0);
             ctx_pdf_print3f(c->rgba.r, c->rgba.g, c->rgba.b);
             ctx_pdf_print("rg ");
             ctx_pdf_print3f(c->rgba.r, c->rgba.g, c->rgba.b);
             ctx_pdf_print("RG\n");
             break;
           case CTX_CMYKA:
           case CTX_DCMYKA:
             ctx_pdf_set_opacity (pdf, c->cmyka.a);
               /*FALLTHROUGH*/
           case CTX_CMYK:
           case CTX_DCMYK:
              if (space == CTX_CMYK || space == CTX_DCMYK)
                ctx_pdf_set_opacity (pdf, 1.0);
              ctx_pdf_print4f(c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k);
              ctx_pdf_print("k ");
              ctx_pdf_print4f(c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k);
              ctx_pdf_print("K ");
              break;
           case CTX_GRAYA:
             ctx_pdf_set_opacity (pdf, c->graya.a);
               /*FALLTHROUGH*/
           case CTX_GRAY:
              if (space == CTX_GRAY)
                ctx_pdf_set_opacity (pdf, 1.0);
              ctx_pdf_print1f(c->graya.g);
              ctx_pdf_print("g ");
              ctx_pdf_print1f(c->graya.g);
              ctx_pdf_print("G\n");
              break;
            }
        }
        break;

      case CTX_SET_RGBA_U8:
        ctx_pdf_printf("/G%i gs\n", ctx_arg_u8(3)*10/255);
        ctx_pdf_printf("%f %f %f RG\n",
                               ctx_u8_to_float (ctx_arg_u8 (0) ),
                               ctx_u8_to_float (ctx_arg_u8 (1) ),
                               ctx_u8_to_float (ctx_arg_u8 (2) ));
        ctx_pdf_printf("%f %f %f rg\n",
                               ctx_u8_to_float (ctx_arg_u8 (0) ),
                               ctx_u8_to_float (ctx_arg_u8 (1) ),
                               ctx_u8_to_float (ctx_arg_u8 (2) ));
        break;

      case CTX_RECTANGLE:
      case CTX_ROUND_RECTANGLE:
        ctx_pdf_print4f(c->rectangle.x, c->rectangle.y,
                        c->rectangle.width, c->rectangle.height);
        ctx_pdf_print("re\n");
        break;

      case CTX_SET_PIXEL:
#if 0
        pdf_set_source_rgba (cr, ctx_u8_to_float (ctx_arg_u8 (0) ),
                               ctx_u8_to_float (ctx_arg_u8 (1) ),
                               ctx_u8_to_float (ctx_arg_u8 (2) ),
                               ctx_u8_to_float (ctx_arg_u8 (3) ) );
        pdf_rectangle (cr, ctx_arg_u16 (2), ctx_arg_u16 (3), 1, 1);
        pdf_fill (cr);
#endif
        break;

      case CTX_FILL:
        if (pdf->preserve)
        {
          preserved = ctx_current_path (ctx);
          pdf->preserve = 0;
        }
        ctx_pdf_print ("f\n");
        break;

      case CTX_TRANSLATE:
         ctx_pdf_apply_transform (ctx, 1.f, 0.f, 0.f, 1.f, c->f.a0, c->f.a1); 
         break;
      case CTX_SCALE:     
         ctx_pdf_apply_transform (ctx, c->f.a0, 0.f, 0.f, c->f.a1, 0.f, 0.f); 
         break;
      case CTX_ROTATE:
         ctx_pdf_apply_transform (ctx,
             ctx_cosf (-c->f.a0), ctx_sinf (-c->f.a0),
             -ctx_sinf (-c->f.a0), ctx_cosf (-c->f.a0),
             0.f, 0.f);
         break;

      case CTX_APPLY_TRANSFORM:
        ctx_pdf_apply_transform (ctx, c->f.a0, c->f.a1,
                                      c->f.a3, c->f.a4,
                                      c->f.a4, c->f.a7);
        break;

      case CTX_STROKE:
        if (pdf->preserve)
        {
          preserved = ctx_current_path (ctx);
          ctx_pdf_print("S\n");
          pdf->preserve = 0;
        }
        else
        {
          ctx_pdf_print("S\n");
        }
        break;

      case CTX_CLIP:
        if (pdf->preserve)
        {
          preserved = ctx_current_path (ctx);
          ctx_pdf_print("W\n");
          pdf->preserve = 0;
        }
        else
        {
          ctx_pdf_print("W\n");
        }
        break;
      case CTX_RESET_PATH:  ctx_pdf_print("n\n"); break;
      case CTX_CLOSE_PATH:  ctx_pdf_print("h\n"); break;
      case CTX_SAVE:        ctx_pdf_print("q\n"); break;
      case CTX_RESTORE:     ctx_pdf_print("Q\n"); break;
      case CTX_FONT_SIZE:   ctx_pdf_printf("/F%i %f Tf\n", pdf->font, state->gstate.font_size); break;
      case CTX_MITER_LIMIT: ctx_pdf_printf("%f M\n", ctx_arg_float (0)); break;
      case CTX_LINE_CAP:    ctx_pdf_printf("%i J\n", ctx_arg_u8 (0)); break;
      case CTX_LINE_JOIN:   ctx_pdf_printf("%i j\n", ctx_arg_u8 (0)); break;

      case CTX_FONT:
        {
          const char *str = ctx_arg_string ();
          if (!strcmp (str, "Helvetica"))             pdf->font = CTX_PDF_HELVETICA;
          if (!strcmp (str, "Helvetica Bold"))        pdf->font = CTX_PDF_HELVETICA_BOLD;
          if (!strcmp (str, "Helvetica Italic"))      pdf->font = CTX_PDF_HELVETICA_ITALIC;
          if (!strcmp (str, "Helvetica BoldItalic"))  pdf->font = CTX_PDF_HELVETICA_BOLD_ITALIC;
          if (!strcmp (str, "Helvetica Bold Italic")) pdf->font = CTX_PDF_HELVETICA_BOLD_ITALIC;
          if (!strcmp (str, "Symbol"))                pdf->font = CTX_PDF_SYMBOL;
          if (!strcmp (str, "Zapf Dingbats"))         pdf->font = CTX_PDF_ZAPF_DING_BATS;
          if (!strcmp (str, "ZapfDingbats"))          pdf->font = CTX_PDF_ZAPF_DING_BATS;
          if (!strcmp (str, "Times"))                 pdf->font = CTX_PDF_TIMES;
          if (!strcmp (str, "Times Italic"))          pdf->font = CTX_PDF_TIMES_ITALIC;
          if (!strcmp (str, "Times Bold"))            pdf->font = CTX_PDF_TIMES_BOLD;
          if (!strcmp (str, "Times Bold Italic"))     pdf->font = CTX_PDF_TIMES_BOLD_ITALIC;
          if (!strcmp (str, "Times BoldItalic"))      pdf->font = CTX_PDF_TIMES_BOLD_ITALIC;
          if (!strcmp (str, "Courier"))               pdf->font = CTX_PDF_COURIER;
          if (!strcmp (str, "Courier Bold"))          pdf->font = CTX_PDF_COURIER_BOLD;
          if (!strcmp (str, "Courier Italic"))        pdf->font = CTX_PDF_COURIER_ITALIC;
          if (!strcmp (str, "Courier Bold Italic"))   pdf->font = CTX_PDF_COURIER_BOLD_ITALIC;
          if (!strcmp (str, "Courier BoldItalic"))    pdf->font = CTX_PDF_COURIER_BOLD_ITALIC;
        }
        ctx_pdf_printf("/F%i %f Tf\n", pdf->font, state->gstate.font_size);
        break;


#if 0
      case CTX_BLEND_MODE:
        {
        }
        break;
      case CTX_COMPOSITING_MODE:
        {
          int pdf_val = CAIRO_OPERATOR_OVER;
          switch (ctx_arg_u8 (0) )
            {
              case CTX_COMPOSITE_SOURCE_OVER:
                pdf_val = CAIRO_OPERATOR_OVER;
                break;
              case CTX_COMPOSITE_COPY:
                pdf_val = CAIRO_OPERATOR_SOURCE;
                break;
            }
          pdf_set_operator (cr, pdf_val);
        }
        break;
#endif
      case CTX_LINEAR_GRADIENT: { ctx_pdf_print("1 0 0 rg\n"); } break;
      case CTX_RADIAL_GRADIENT: { ctx_pdf_print("0 2 0 rg\n"); } break;
      case CTX_TEXTURE:
      case CTX_DEFINE_TEXTURE: { ctx_pdf_print("0 0 1 rg\n"); } break;
      case CTX_GRADIENT_STOP:
        // we set the color so we might get a flavour of the gradient
         ctx_pdf_printf("%f %f %f rg\n", ctx_arg_u8(4)/255.0f,
                                         ctx_arg_u8(4+1)/255.0f,
                                         ctx_arg_u8(4+2)/255.0f);
        break;
      case CTX_TEXT:
        ctx_pdf_print("1 0 0 -1 ");
        ctx_pdf_print2f(state->x, state->y);
        ctx_pdf_print("Tm ");
        if (0)
        {
          char *encoded = ctx_utf8_to_mac_roman ((uint8_t*)ctx_arg_string ());
          ctx_pdf_printf ("(%s) Tj\n", encoded);
          ctx_free (encoded);
        }
        else
        {
          char *encoded = ctx_utf8_to_windows_1252 ((uint8_t*)ctx_arg_string ());
          ctx_pdf_printf ("(%s) Tj\n", encoded);
          ctx_free (encoded);
        }
        break;
      case CTX_CONT:
      case CTX_DATA:
      case CTX_DATA_REV:
      case CTX_END_FRAME:
        break;
      case CTX_VIEW_BOX:
        pdf->page_size[0] = ctx_arg_float(0);
        pdf->page_size[1] = ctx_arg_float(1);
        pdf->page_size[2] = ctx_arg_float(2);
        pdf->page_size[3] = ctx_arg_float(3);
        ctx_set_size (ctx, 
          ctx_arg_float(2),
          ctx_arg_float(3));
        break;
    }
  ctx_interpret_pos_bare (&pdf->state, entry, pdf);
#if CTX_CURRENT_PATH
  ctx_update_current_path (ctx, entry);
#endif

  if (preserved)
  {
    CtxIterator iterator;
    CtxCommand *command;
    
    ctx_iterator_init (&iterator, preserved, 0, CTX_ITERATOR_EXPAND_BITPACK);
    while ( (command = ctx_iterator_next (&iterator) ) )
      { ctx_pdf_process (ctx, command); }
    ctx_free (preserved);
  }
}

void ctx_pdf_destroy (CtxPDF *pdf)
{
  FILE *f = fopen (pdf->path, "w");
  char buf[13];

  pdf_end_page (pdf);

  int outlines=pdf_add_object (pdf);
  ctx_pdf_print("<</Type/Outlines/Count 0>>");
  int catalog=pdf_add_object (pdf);
  ctx_pdf_printf("<</Type/Catalog/Outlines %i 0 R/Pages %i 0 R>>", outlines, pdf->pages);


  // patch-back the value in pages earlier
  snprintf (buf, 12, "% 10d", pdf->page_count);
  memcpy   (&pdf->document->str[pdf->page_count_offset], buf, 10);

  // patch-back the value in pages earlier
  int kids = pdf_add_object (pdf); 
  snprintf (buf, 12, "% 10d", kids);
  memcpy   (&pdf->document->str[pdf->kids_offset], buf, 10);

  ctx_pdf_print ("[");
  for (int page_no =1; page_no <= pdf->page_count; page_no++)
    ctx_pdf_printf ("%i 0 R ", pdf->page_objs[page_no]);
  ctx_pdf_print ("]");
  pdf_end_object(pdf);

  int start_xref = pdf->document->length;
  ctx_pdf_printf ("xref\n0 %i\n", pdf->objs + 1);
  ctx_pdf_print ("0000000000 65535 f\n");
        for(int i = 1; i <= pdf->objs; i++)
        {
          ctx_pdf_printf ("%010d 65535 n\n", pdf->xref[i]);
        }
  ctx_pdf_printf ("trailer\n\n"
"<</Root %i 0 R\n/Size %i>>\n"
"startxref\n"
"%d\n"
"%%%%EOF\n", catalog, pdf->objs+1,
       start_xref);

  fwrite (pdf->document->str, pdf->document->length, 1, f);
  ctx_string_free (pdf->document, 1);
  ctx_free (pdf);
}

Ctx *
ctx_new_pdf (const char *path, float width, float height)
{
  Ctx *ctx = ctx_new_drawlist (width, height);
  CtxPDF *pdf = (CtxPDF*)ctx_calloc(1, sizeof(CtxPDF));
  CtxBackend *backend  = (CtxBackend*)pdf;
  if (width <= 0) width = 595;
  if (width <= 0) height = 842;

  pdf->width = width;
  pdf->height = height;

  backend->type = CTX_BACKEND_PDF;
  backend->destroy = (void (*)(void*))ctx_pdf_destroy;
  backend->process = ctx_pdf_process;
  backend->ctx     = ctx;
  pdf->document    = ctx_string_new("");

  pdf->path = ctx_strdup (path);
  ctx_state_init (&pdf->state);
  ctx_set_backend (ctx, (void*)pdf);
  ctx_pdf_print ("%PDF-1.4\n%ÆØÅ\n");
  //ctx_pdf_printf ("%%PDF-1.4\n%%%c%c%c%c\n", 0xe2, 0xe3, 0xcf, 0xd3);
  pdf->pages=pdf_add_object (pdf); // 1
  pdf->font = CTX_PDF_HELVETICA;
  //pdf->encoding = "/MacRomanEncoding";
  pdf->encoding = (char*)"/WinAnsiEncoding";

  ctx_pdf_print ("<</Kids ");
  pdf->kids_offset = pdf->document->length;
  ctx_pdf_print ("XXXXXXXXXX 0 R/Type/Pages/Count ");
  pdf->page_count_offset = pdf->document->length;
  ctx_pdf_print ("XXXXXXXXXX");
  ctx_pdf_print (">>");

  { // shared fontmap for all pages
    // good enough without TTF fonts
    int font[16];

    const char *font_names[]={"","Times","Helvetica","Courier","Symbol",
"Times-Bold", "Helvetica-Bold", "Courier-Bold",
"ZapfDingbats", "Times-Italic", "Helvetica-Oblique",
"Courier-Oblique", "Times-BoldItalic", "Helvetica-BoldItalic", "Courier-BoldItalic"
    };

    for (int font_no = 1; font_no <= 14; font_no++)
    {
      font[font_no]= pdf_add_object (pdf);
      ctx_pdf_printf ("<</Name/F%i/Subtype/Type1/Type/Font/BaseFont /%s /Encoding %s>>",
                      font_no, font_names[font_no], pdf->encoding);
    }

    pdf->font_map=pdf_add_object(pdf);
    ctx_pdf_print ("<<");
    for (int font_no = 1; font_no <= 14; font_no++)
      ctx_pdf_printf ("/F%i %i 0 R", font_no, font[font_no]);
    ctx_pdf_print (">>");
  }

  pdf->page_size[0] = 0;
  pdf->page_size[1] = 0;
  pdf->page_size[2] = pdf->width;
  pdf->page_size[3] = pdf->height;

  pdf_start_page (pdf);

  return ctx;
}

void
ctx_render_pdf (Ctx *ctx, const char *path)
{
  Ctx *pdf = ctx_new_pdf (path, 0, 0);
  CtxIterator iterator;
  CtxCommand *command;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0, CTX_ITERATOR_EXPAND_BITPACK);
  while ( (command = ctx_iterator_next (&iterator) ) )
    { ctx_pdf_process (pdf, command); }
  ctx_destroy (pdf);
}




static char *ctx_utf8_to_mac_roman (const uint8_t *string)
{
  CtxString *ret = ctx_string_new ("");
  if (*string)
  for (const uint8_t *utf8 = (uint8_t*)string; utf8[0]; utf8 = *utf8?(uint8_t*)ctx_utf8_skip ((char*)utf8, 1):(utf8+1))
  {
    uint8_t copy[5];

    memcpy (copy, utf8, ctx_utf8_len (utf8[0]));
    copy[ctx_utf8_len (utf8[0])]=0;
    if (copy[0] <=127)
    {
      ctx_string_append_byte (ret, copy[0]);
    }
    else
    {
      int code = 128;
      /* it would be better to to this comparison on a unicode table,
       * but this was easier to create
       */
#define C(a) \
      if (!strcmp ((char*)&copy[0], a)) { ctx_string_append_byte (ret, code); continue; }; code++
      C("Ä");C("Å");C("Ç");C("É");C("Ñ");C("Ö");C("Ü");C("á");C("à");C("â");C("ä");C("ã");C("å");C("ç");C("é");C("è");
      C("ê");C("ë");C("í");C("ì");C("î");C("ï");C("ñ");C("ó");C("ò");C("ô");C("ö");C("õ");C("ú");C("ù");C("û");C("ü");
      C("†");C("°");C("¢");C("£");C("§");C("•");C("¶");C("ß");C("®");C("©");C("™");C("´");C("¨");C("≠");C("Æ");C("Ø");
      C("∞");C("±");C("≤");C("≥");C("¥");C("µ");C("∂");C("∑");C("∏");C("π");C("∫");C("ª");C("º");C("Ω");C("æ");C("ø");
      C("¿");C("¡");C("¬");C("√");C("ƒ");C("≈");C("∆");C("«");C("»");C("…");C(" ");C("À");C("Ã");C("Õ");C("Œ");C("œ");
      C("–");C("—");C("“");C("”");C("‘");C("’");C("÷");C("◊");C("ÿ");C("Ÿ");C("⁄");C("€");C("‹");C("›");C("ﬁ");C("ﬂ");
      C("‡");C("·");C("‚");C("„");C("‰");C("Â");C("Ê");C("Á");C("Ë");C("È");C("Í");C("Î");C("Ï");C("Ì");C("Ó");C("Ô");
      C("?");C("Ò");C("Ú");C("Û");C("Ù");C("ı");C("ˆ");C("˜");C("¯");C("˘");C("˙");C("˚");C("¸");C("˝");C("˛");C("ˇ");
      ctx_string_append_byte (ret, '?');
    }
  }

  return ctx_string_dissolve (ret);
}

static char *ctx_utf8_to_windows_1252 (const uint8_t *string)
{
  CtxString *ret = ctx_string_new ("");
  if (*string)
  for (const uint8_t *utf8 = (uint8_t*)string; utf8[0]; utf8 = *utf8?(uint8_t*)ctx_utf8_skip ((char*)utf8, 1):(utf8+1))
  {
    uint8_t copy[5];

    memcpy (copy, utf8, ctx_utf8_len (utf8[0]));
    copy[ctx_utf8_len (utf8[0])]=0;
    if (copy[0] == '(' || copy[0] == ')')
    {
      ctx_string_append_byte (ret, '\\');
      ctx_string_append_byte (ret, copy[0]);
    }
    else if (copy[0] <=127)
    {
      ctx_string_append_byte (ret, copy[0]);
    }
    else
    {
      int code = 128;
      /* it would be better to to this comparison on a unicode table,
       * but this was easier to create
       */
C("€");C(" ");C("‚");C("ƒ");C("„");C("…");C("†");C("‡");C("ˆ");C("‰");C("Š");C("‹");C("Œ");C(" ");C("Ž");C(" ");
C(" ");C("‘");C("’");C("“");C("”");C("•");C("–");C("—");C("˜");C("™");C("š");C("›");C("œ");C(" ");C("ž");C("Ÿ");
C(" ");C("¡");C("¢");C("£");C("¤");C("¥");C("¦");C("§");C("¨");C("©");C("ª");C("«");C("¬");C("-");C("®");C("¯");
C("°");C("±");C("²");C("³");C("´");C("µ");C("¶");C("·");C("¸");C("¹");C("º");C("»");C("¼");C("½");C("¾");C("¿");
C("À");C("Á");C("Â");C("Ã");C("Ä");C("Å");C("Æ");C("Ç");C("È");C("É");C("Ê");C("Ë");C("Ì");C("Í");C("Î");C("Ï");
C("Ð");C("Ñ");C("Ò");C("Ó");C("Ô");C("Õ");C("Ö");C("×");C("Ø");C("Ù");C("Ú");C("Û");C("Ü");C("Ý");C("Þ");C("ß");
C("à");C("á");C("â");C("ã");C("ä");C("å");C("æ");C("ç");C("è");C("é");C("ê");C("ë");C("ì");C("í");C("î");C("ï");
C("ð");C("ñ");C("ò");C("ó");C("ô");C("õ");C("ö");C("÷");C("ø");C("ù");C("ú");C("û");C("ü");C("ý");C("þ");C("ÿ");
#undef C
      ctx_string_append_byte (ret, '?');
    }
  }
  return ctx_string_dissolve (ret);
}



#endif

int ctx_frame_ack = -1;

#if CTX_NET

#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netdb.h>

struct _CtxNet
{
   CtxBackend backend;
   int  flags;
   int  cols;
   int  rows;

   int sock; // client socket descriptor

   int in_fd;
   int out_fd;
   float fs;

   int flag_do_reset;
#if CTX_COMPRESS
   char *prev_frame;
   int   prev_frame_len;
#endif
};

//int ctx_frame_ack = -1;
#if CTX_FORMATTER

static int ctx_net_strout (CtxNet *net, const char *str)
{
  if (str)
    return write (net->out_fd, str, strlen (str));
  return 0;
}

static void ctx_net_start_frame (Ctx *ctx)
{
  CtxNet *net = (CtxNet*)ctx->backend;
  ctx_font_size (ctx, ctx_height (ctx) / net->rows);
}

#if CTX_COMPRESS
typedef struct CtxCompressDict
{
   char     str[CTX_COMPRESS_NEEDLE_SIZE];
   int      pos;
} CtxCompressDict;

static uint32_t ctx_compress_hash(const char *ptr, const char *endptr, int len)
{
  uint32_t ret = 0;
  for (int i = 0; i < len && ptr < endptr; i++)
  {
    ret = ret << (32/CTX_COMPRESS_NEEDLE_SIZE);
    ret = ret ^ (*ptr * 54321);
    ptr++;
  }
  return ret;
}

static void ctx_net_write_compressed (int fd, const char *frame, int frame_len,
                                              const char *prev_frame, int prev_frame_len)
{
  CtxCompressDict *prevdict = ctx_calloc (CTX_COMPRESS_HT_SIZE, sizeof (CtxCompressDict));
  int pos = 0;
  if (prev_frame)
  for (const char *p = prev_frame; p < prev_frame + prev_frame_len; p+=CTX_COMPRESS_NEEDLE_SIZE, pos += CTX_COMPRESS_NEEDLE_SIZE)
  {
    uint32_t hash = ctx_compress_hash (p, prev_frame + prev_frame_len, CTX_COMPRESS_NEEDLE_SIZE);
    int hpos = hash % CTX_COMPRESS_HT_SIZE;
    if (prevdict[hpos].str[0]==0)
    {
      // we want to keep the earlier occurences
      memcpy(prevdict[hpos].str, p, CTX_COMPRESS_NEEDLE_SIZE);
      prevdict[hpos].pos = pos;
    }
  }

  #define CTX_MAX_LITERAL 512
  char literal[CTX_MAX_LITERAL];
  int literal_len = 0;

  const char *p;
  for (p = frame; p < frame + frame_len - CTX_COMPRESS_NEEDLE_SIZE; p++)
  {
     uint32_t hash = ctx_compress_hash(p, frame + frame_len, CTX_COMPRESS_NEEDLE_SIZE);
     int hpos = hash % CTX_COMPRESS_HT_SIZE;

     if (prev_frame && !memcmp (prevdict[hpos].str, p, CTX_COMPRESS_NEEDLE_SIZE))
     {
       int matchlen = CTX_COMPRESS_NEEDLE_SIZE;
       int matchpos = prevdict[hpos].pos;

       // grow forwards
       while (prev_frame[matchpos + matchlen] &&
              prev_frame[matchpos + matchlen] == p[matchlen])
                matchlen++;


       // grow backwards
       int pre_match = 0;
       while (literal_len && prev_frame[matchpos-1] ==
                             p[-1-pre_match])
       {
         literal_len --;
         matchpos--;
         matchlen++;
         pre_match++;
       }

       if (literal_len)
       {
         write (fd, literal, literal_len);
         literal_len = 0;
       }

       uint8_t buf[53] = {CTX_FROM_PREV, };
       int opos = 1;
       opos += ctx_unichar_to_utf8 (matchpos+1, &buf[opos]);
       opos += ctx_unichar_to_utf8 (matchlen, &buf[opos]);
       write (fd, buf, opos);
       p--;
       p+= (matchlen-pre_match);
     }
     else
     {
       literal[literal_len++] = *p;
       if (literal_len >= CTX_MAX_LITERAL-1)
       {
         write (fd, literal, literal_len);
         literal_len = 0;
       }
     }
  }
  for (;p < frame + frame_len; p++)
  {
       literal[literal_len++] = *p;
       if (literal_len >= CTX_MAX_LITERAL-1)
       {
         write (fd, literal, literal_len);
         literal_len = 0;
       }
  }
  if (literal_len)
  {
    write (fd, literal, literal_len);
  }
  ctx_free (prevdict);
  #undef CTX_MAX_LITERAL
}

#endif

static void ctx_net_end_frame (Ctx *ctx)
{
  CtxNet *net = (CtxNet*)ctx->backend;

  if (net->flags & CTX_FLAG_SYNC)
  {
    ctx_net_strout (net, "\033[5n\n");

#if CTX_EVENTS
    ctx_frame_ack = 0;
    static int time = 0;
    int bail_time = time + 500;
    // TODO make this configurable
    //int wait_time = time + 100; // this make us aim for 10fps...
                                // we do this to avoid overwhelming uarts
    //int wait_time = time + 50; // this make us aim for 20fps
    //int wait_time = time + 25; // this make us aim for 40fps
    int wait_time = time + 33; // this make us aim for 30fps
    do {
       ctx_consume_events (net->backend.ctx);
       time = ctx_ms(ctx);
    } while (time < wait_time || (ctx_frame_ack != 1 && time < bail_time));
#endif
  } else
  {
    usleep (1000 * 50);
  }
  ctx_net_strout (net, "\033[?201h\033[H");
  if (net->flag_do_reset)
  {
    ctx_net_strout (net, "\033[2J");
    net->flag_do_reset = 0;
  }
  ctx_net_strout (net, "\033[?25l\033[?200h:\n");

#if CTX_COMPRESS
  int len;
  char *str = ctx_render_string (net->backend.ctx, 0, &len);
  if (str)
  {
    if (net->flags & CTX_FLAG_COMPRESS)
    {
      ctx_net_write_compressed (net->out_fd, str, len, net->prev_frame, net->prev_frame_len);

      if (net->prev_frame)
        ctx_free (net->prev_frame);
      net->prev_frame = str;
      net->prev_frame_len = len;
    }
    else
    {
      ctx_net_strout (net, str);
      ctx_free (str);
    }
  }
#else
  ctx_render_fd (net->backend.ctx, net->out_fd, (CtxFormatterFlag)0);//CTX_FORMATTER_FLAG_FLUSH);
#endif
  ctx_net_strout (net, " X\n");
}

void ctx_net_destroy (CtxNet *net)
{
#if CTX_EVENTS
  ctx_drain_fd (net->in_fd);
#endif
  ctx_net_strout (net, "\033[?25h"
                       "\033[?201l"
                       "\033[?47l"   // XTERM_ALTSCREEN_OFF
                       "\033[?1000l\033[?1003l" // TERMINAL_MOUSE_OFF
                       "\033[?200l"
                       "\033[?1049l");
#if CTX_EVENTS
  ctx_term_noraw (net->in_fd);
#endif
  if (net->sock)
    close (net->sock);
  ctx_free (net);
}

#if CTX_AUDIO
void ctx_ctx_pcm (Ctx *ctx);
#endif

static int ctx_net_has_data (CtxNet *net, int timeout)
{
  struct timeval tv = {0,0};
  fd_set rfds;
  FD_ZERO(&rfds);
  FD_SET(net->in_fd, &rfds);
  tv.tv_sec = 0;
  tv.tv_usec = timeout;
  return (select(net->in_fd+1, &rfds, NULL, NULL, &tv)>0);
}

static char *ctx_net_get_event (Ctx *ctx, int timeout)
{
  CtxNet *net = (CtxNet*)ctx->backend;
  int got_event = ctx_net_has_data (net, timeout);
  char buf[201];
  int length;

  if (got_event)
  for (length = 0; got_event && length < 128; length ++)
  {
    if (read (net->in_fd, &buf[length], 1) != -1)
      {
         buf[length+1] = 0;
         if (!strcmp ((char*)buf, "\033[0n"))
         {
           ctx_frame_ack = 1;
           return ctx_strdup ("ack");
         }
         else if (buf[length]=='\n')
         {
           buf[length]=0;
           return ctx_strdup (buf);
         }
      }
      got_event = ctx_net_has_data (net, timeout);
    }

  return ctx_strdup ("idle");
}

static void ctx_net_consume_events (Ctx *ctx)
{
  //int ix, iy;
  CtxNet *net = (CtxNet*)ctx->backend;
  char *event = NULL;
#if CTX_AUDIO
  //ctx_ctx_pcm (ctx);
#endif

    do {

      float x = 0, y = 0;
      int b = 0;
      int cols = 0;
      char event_type[128]="";
      event = ctx_net_get_event (ctx, 1000/60);

      if (event)
      {
      sscanf (event, "%30s %f %f %i %i", event_type, &x, &y, &b, &cols);
      if (!strcmp (event_type, "idle") ||
          !strcmp (event_type, "ack"))
       
      {
        ctx_free (event);
        event = NULL;
      }
      else if (!strcmp (event_type, "pp"))
      {
        ctx_pointer_press (ctx, x, y, b, 0);
      }
      else if (!strcmp (event_type, "pd")||
               !strcmp (event_type, "pm"))
      {
        ctx_pointer_motion (ctx, x, y, b, 0);
      }
      else if (!strcmp (event_type, "pr"))
      {
        ctx_pointer_release (ctx, x, y, b, 0);
      }
      else if (!strcmp (event_type, "message"))
      {
        ctx_incoming_message (ctx, event + strlen ("message"), 0);
      } 
      else if (!strcmp (event_type, "resize-event"))
      {
        net->rows = b;
        net->cols = cols;
        net->flag_do_reset = 1;
        ctx_set_size (ctx, x, y);
        ctx_queue_draw (ctx);
      }
      else if (!strcmp (event_type, "keyup"))
      {
        char buf[4]={ (char)x, 0 };
        ctx_key_up (ctx, (int)x, buf, 0);
      }
      else if (!strcmp (event_type, "keydown"))
      {
        char buf[4]={ (char)x, 0 };
        ctx_key_down (ctx, (int)x, buf, 0);
      }
      else
      {
        ctx_key_press (ctx, 0, event, 0);
      }

        if (event)
          ctx_free (event);
      }
    } while (event);
}


Ctx *ctx_new_net (int width, int height, int flags, const char *hostip, int port)
{
  float font_size = 12.0;
  CtxNet *net = (CtxNet*)ctx_calloc (1, sizeof (CtxNet));
  net->sock = socket (AF_INET, SOCK_STREAM,0);
  if (net->sock < 0)
  {
    fprintf (stderr, "failed to create socket\n");
    ctx_free (net);
    return NULL;
  }

  struct sockaddr_in  server_addr;
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons (port);
  server_addr.sin_addr.s_addr = inet_addr (hostip);
  int retcode = connect (net->sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
  if (retcode < 0)
  {
    fprintf(stderr, "*** ERROR - connect() failed \n");
    ctx_free (net);
    return NULL;
  }

  CtxBackend *backend = (CtxBackend*)net;

  net->in_fd = net->out_fd = net->sock;

  retcode = ctx_net_strout (net, "\033[?1049h\033[?200h\033[?201h");
  if (retcode < 0)
  {
    fprintf(stderr, "*** ERROR - initial send() failed \n");
    ctx_free (net);
    return NULL;
  }

  net->flags = flags;
  if (width <= 0 || height <= 0)
  {
    width  = ctx_terminal_width (net->in_fd, net->out_fd);
    height = ctx_terminal_height (net->in_fd, net->out_fd);
    net->cols = ctx_terminal_cols (net->in_fd, net->out_fd);
    net->rows = ctx_terminal_rows (net->in_fd, net->out_fd);
    font_size = height / net->rows;
    //fprintf (stderr, "got dim: %ix%i fs:%f rows:%i\n", width, height, font_size, net->rows);
  }
  else
  {
    net->cols   = width / 80;
    net->rows   = height / 24;
  }
  Ctx *ctx = ctx_new_drawlist (width, height);

  backend->ctx         = ctx;
  backend->start_frame = ctx_net_start_frame;
  backend->end_frame   = ctx_net_end_frame;
  backend->type    = CTX_BACKEND_CTX;
  backend->destroy = (void(*)(void *))ctx_net_destroy;
  backend->process = (void(*)(Ctx *a, const CtxCommand *c))ctx_drawlist_process;
  backend->consume_events = ctx_net_consume_events;
  ctx_set_backend (ctx, net);
  //ctx_set_size (ctx, width, height);
  ctx_font_size (ctx, font_size);
  return ctx;
}

Ctx *ctx_new_fds (int width, int height, int in_fd, int out_fd, int flags)
{
  float font_size = 12.0;
  CtxNet *net = (CtxNet*)ctx_calloc (1, sizeof (CtxNet));
  CtxBackend *backend = (CtxBackend*)net;
  net->in_fd = in_fd;
  net->out_fd = out_fd;
  
#if CTX_EVENTS
  ctx_term_raw (net->in_fd);
#endif
  //ctx_net_strout (net, "\033[?47h\033[?200h\033[?201h");
  net->flags = flags;
  if (width <= 0 || height <= 0)
  {
    width  = ctx_terminal_width (net->in_fd, net->out_fd);
    height = ctx_terminal_height (net->in_fd, net->out_fd);
    net->cols = ctx_terminal_cols (net->in_fd, net->out_fd);
    net->rows = ctx_terminal_rows (net->in_fd, net->out_fd);
    font_size = height / net->rows;
  }
  else
  {
    net->cols   = width / 80;
    net->rows   = height / 24;
  }

  Ctx *ctx = ctx_new_drawlist (width, height);
#if CTX_EVENTS
  ctx_term_raw (net->in_fd);
#endif
  ctx_net_strout (net, "\033[?1049h\n\033[?201h\n");

  backend->ctx = ctx;
  backend->start_frame = ctx_net_start_frame;
  backend->end_frame = ctx_net_end_frame;
  backend->type = CTX_BACKEND_CTX;
  backend->destroy = (void(*)(void *))ctx_net_destroy;
  backend->process = (void(*)(Ctx *a, const CtxCommand *c))ctx_drawlist_process;
  backend->consume_events = ctx_net_consume_events;
  ctx_set_backend (ctx, net);
  ctx_font_size (ctx, font_size);
  return ctx;
}

Ctx *ctx_new_ctx (int width, int height, int flags)
{
  return ctx_new_fds (width, height, STDIN_FILENO, STDOUT_FILENO, flags);
}

#endif

#endif

// the callback backend, 
//
// only set_pixels need implementing, 
//
//bugs:
// lowfi modes only work in 16bpp scanout mode
// random lockups, use mutexes?
//

#if CTX_RASTERIZER

typedef enum {
  CTX_FI_NONE     = 0,  //  0.125 -- nothing actuall
  CTX_FI_LOW      = 1,  //  0.25
  CTX_FI_HALF     = 2,  //  0.5
  CTX_FI_NORMAL   = 3,  //  1.0
  CTX_FI_SUBPIXEL = 4   //  subpixel
} CtxFidelity;

static int cb_jobs_pending (Ctx *ctx)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  int sum = 0;
  for (int i = 0; i < cb->n_jobs; i++)
    sum += (cb->jobs[i].renderer == -1);
  return sum;
}

static int cb_jobs_in_flight (Ctx *ctx)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  int sum = 0;
  for (int i = 0; i < cb->n_jobs; i++)
    sum += (cb->jobs[i].renderer != 0);
  return sum;
}

void cb_clear_jobs (Ctx *ctx)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  for (int i = 0; i < cb->n_jobs; i++)
    cb->jobs[i].renderer = 0;
  cb->n_jobs = 0;
}


static void cb_add_job (Ctx *ctx, int x0, int y0, int x1, int y1, int res, int bitmask)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  if (cb->n_jobs >= CTX_CB_MAX_JOBS)
    return;
  CtxCbJob *job = &cb->jobs[cb->n_jobs++];;
  job->renderer = CTX_JOB_PENDING;
  job->x0 = x0;
  job->y0 = y0;
  job->x1 = x1;
  job->y1 = y1;
  job->bitmask = bitmask;
  job->flags = res;
}

static int ctx_cb_kill = 0;

void ctx_cb_set_flags (Ctx *ctx, int flags)
{
  CtxCbBackend *backend_cb = (CtxCbBackend*)ctx->backend;

  backend_cb->config.flags = flags;
}

int ctx_cb_get_flags (Ctx *ctx)
{
  CtxCbBackend *backend_cb = (CtxCbBackend*)ctx->backend;
  return backend_cb->config.flags;
}

static void
ctx_cb_reset_caches (Ctx *ctx)
{
  CtxCbBackend *backend_cb = (CtxCbBackend*)ctx->backend;
  for (int i = 0; i < CTX_HASH_ROWS * CTX_HASH_COLS; i++)
    backend_cb->hashes[i]=1;
}

static inline uint16_t ctx_rgb332_to_rgb565 (uint8_t rgb, int byteswap)
{
  uint8_t red, green, blue;
  ctx_332_unpack (rgb, &red, &green, &blue);
  return ctx_565_pack (red, green, blue, byteswap);
}

void
ctx_cb_set_memory_budget (Ctx *ctx, int buffer_size)
{
  CtxCbBackend *backend_cb = (CtxCbBackend*)ctx->backend;
  backend_cb->config.buffer_size = buffer_size;
  if (backend_cb->scratch)
  {
    if (backend_cb->allocated_fb)
      ctx_free (backend_cb->scratch);
    backend_cb->allocated_fb = 0;
    backend_cb->scratch = NULL;
  }
}

static void ctx_cb_mark_damage (int w, int h, int bpp, void *buf)
{
  static int phase = 0;
  phase ++;
  if (phase > 3) phase = 0;
  if (bpp == 2)
  {
    uint16_t col = 31;
    switch (phase)
    {
      case 0: col = 31; break;
      case 1: col = 63<<5; break;
      case 2: col = 31<<(5+6); break;
      case 3: col = (31<<(5+6))+31; break;
    }
    int u,v;
    v = 0;
    for (u = 0; u < w; u++)
    { int o = (v * w + u);
      ((uint16_t*)buf)[o]=col;
    }
    v = h-1;
    for (u = 0; u < w; u++)
    { int o = (v * w + u);
      ((uint16_t*)buf)[o]=col;
    }
    u = 0;
    for (v = 0; v < h; v++)
    { int o = (v * w + u);
      ((uint16_t*)buf)[o]=col;
    }
    u = w-1;
    for (v = 0; v < h; v++)
    { int o = (v * w + u);
      ((uint16_t*)buf)[o]=col;
    }
  }
  else if (bpp == 4)
  {
    uint32_t col = 0xff0000ff;
    switch (phase)
    {
      case 0: col = 0xff0000ff; break;
      case 1: col = 0x00ff00ff; break;
      case 2: col = 0x0000ffff; break;
      case 3: col = 0xffff00ff; break;
    }
    int u,v;
    v = 0;
    for (u = 0; u < w; u++)
    { int o = (v * w + u);
      ((uint32_t*)buf)[o]=col;
    }
    v = h-1;
    for (u = 0; u < w; u++)
    { int o = (v * w + u);
      ((uint32_t*)buf)[o]=col;
    }
    u = 0;
    for (v = 0; v < h; v++)
    { int o = (v * w + u);
      ((uint32_t*)buf)[o]=col;
    }
    u = w-1;
    for (v = 0; v < h; v++)
    { int o = (v * w + u);
      ((uint32_t*)buf)[o]=col;
    }
  }
}


CtxSubPixel _ctx_subpixel_layout = CTX_SUBPIXEL_HRGB;

static int ctx_render_cb (CtxCbBackend *backend_cb, 
                          int x0, int y0,
                          int x1, int y1,
                          uint32_t active_mask,
                          int      taskno,
                          int      rno,
                          float    scale)
{
  //printf("%i:%i,%f (%i %i %i %i)\n", rno, taskno, scale, x0, y0, x1, y1);
  Ctx *ctx           = backend_cb->ctx;
  int flags          = backend_cb->config.flags;
  Ctx *rctx          = flags&CTX_FLAG_RENDER_THREAD?backend_cb->drawlist_copy:ctx;
  int buffer_size    = backend_cb->config.buffer_size;


  uint16_t *scratch_base;
  uint16_t *scratch;
  CtxPixelFormat format = backend_cb->config.format;
  int bpp            = ctx_pixel_format_bits_per_pixel (format) / 8;
  int abort          = 0;

  int subpixel = CTX_SUBPIXEL_NONE;//
  
  if (scale > 1.0)
    subpixel = _ctx_subpixel_layout;
  if (subpixel)
    scale = 3.0f;

  int width          = x1 - x0 + 1;
  int height         = y1 - y0 + 1;
#if CTX_CB_ENABLE_LOW_FI
  int byteswap;
  byteswap = (format == CTX_FORMAT_RGB565_BYTESWAPPED);
#endif


  if (!backend_cb->scratch && !backend_cb->config.fb)
  {
    backend_cb->allocated_fb = 1;
    backend_cb->scratch = (uint16_t*)ctx_malloc (buffer_size);
  }

  uint8_t *temp = NULL;


  scratch_base = backend_cb->scratch;
  int scratch_size = buffer_size;
  scratch = scratch_base + rno*(scratch_size/4);

  void (*set_pixels) (Ctx *ctx, void *user_data, 
                      int x, int y, int w, int h, void *buf) =
    backend_cb->config.set_pixels;

  void *set_pixels_user_data = backend_cb->config.set_pixels_user_data?
                                 backend_cb->config.set_pixels_user_data:
                                 backend_cb->config.user_data;


  {
    int render_height = height;
    if (width * render_height > buffer_size / bpp)
    {
       render_height = buffer_size / (width)/ bpp;
    }

      render_height = ctx_mini (render_height, y1-y0+1);
  mtx_lock (&backend_cb->mtx);
  // imposter check
  if (backend_cb->jobs[taskno].renderer != rno + 1)
  {
    mtx_unlock (&backend_cb->mtx);
    return 0;
  }
  mtx_unlock (&backend_cb->mtx);

  if (scale != 1.0f)
  {
    int needed = (width * scale + 1) * (render_height * scale + 1) * bpp;

    if (backend_cb->temp_len[rno] < needed)
    {
      if (backend_cb->temp[rno])
        ctx_free (backend_cb->temp[rno]);
      backend_cb->temp[rno] = ctx_malloc (needed);
      backend_cb->temp_len[rno] = needed;
    }
    temp = backend_cb->temp[rno];
  }

    int keep_data = ((flags & CTX_FLAG_KEEP_DATA) != 0);
    int stride = bpp * ctx->width;
    do
    {

      if (backend_cb->config.fb)
      {
      #if 1
        uint8_t *fb = (uint8_t*)backend_cb->config.fb;
        //fb += stride * y0 + x0 * bpp;
        if (temp)
        ctx_rasterizer_reinit(backend_cb->rctx[rno], temp, 0, 0, width * scale, render_height * scale, scale * width*bpp, format);
        else
        ctx_rasterizer_reinit(backend_cb->rctx[rno], fb + stride * y0 + x0 * bpp, 0, 0, width, render_height, stride, format);
        if (!keep_data)
        {
          ctx_save (backend_cb->rctx[rno]);
          ctx_compositing_mode (backend_cb->rctx[rno], CTX_COMPOSITE_CLEAR);
          ctx_paint (backend_cb->rctx[rno]);
          ctx_restore (backend_cb->rctx[rno]);
        }
        #endif
      }
      else
      {
        if (temp)
        ctx_rasterizer_reinit(backend_cb->rctx[rno], temp, 0, 0, width * scale, render_height * scale, scale * width * bpp, format);
        else
        ctx_rasterizer_reinit(backend_cb->rctx[rno], scratch, 0, 0, width * scale, render_height * scale, scale * width * bpp, format);

        if (!keep_data)
          memset (temp?temp:(uint8_t*)scratch, 0, width * bpp * render_height * scale * scale);
      }

      ctx_save (backend_cb->rctx[rno]);
      ctx_scale (backend_cb->rctx[rno], scale, scale);
      ctx_translate (backend_cb->rctx[rno], -1.0f * x0, -1.0f * y0);
      if (active_mask)
        ctx_render_ctx_masked (rctx, backend_cb->rctx[rno], active_mask);
      else
        ctx_render_ctx (rctx, backend_cb->rctx[rno]);
      ctx_restore (backend_cb->rctx[rno]);

      if (flags & CTX_FLAG_DAMAGE_CONTROL)
        ctx_cb_mark_damage (width, height, bpp, scratch);

      uint8_t *fb = (uint8_t*)backend_cb->config.fb;

      if (subpixel)// == CTX_SUBPIXEL_HRGB)
      {
         uint8_t *out = (uint8_t*)scratch;
         const int rowstride = width * bpp * 3;

         for (int y = 0; y < render_height && y + y0 < ctx->height ; y++)
         {
           uint8_t *in = temp + (y * 3 * width * 3 * bpp);
           if (fb)
             out = fb + stride * (y+y0) + x0 * bpp;

           const uint32_t w[5] = {
             (0x8/256.0) * (1<<12)/3,
             (0x4d/256.0) * (1<<12)/3,
             (0x56/256.0) * (1<<12)/3,
             (0x4d/256.0) * (1<<12)/3,
             (0x8/256.0) * (1<<12)/3};

           uint8_t *prev0 = in;
           uint8_t *prev1 = in + rowstride;
           uint8_t *prev2 = in + rowstride * 2;

           for (int x = 0; x < width; x++)
           {
             uint8_t *inp0 = in;
             uint8_t *inp1 = inp0 + rowstride;
             uint8_t *inp2 = inp1 + rowstride;

             #define IN(pos)  (inp0[pos]+inp1[pos]+inp2[pos])
             #define INP(c)    (prev0[c]+prev1[c]+prev2[c])
             #define NX(pos)  ((x<width)?IN(pos+12):IN(pos))
             out[0] = (INP(4)  * w[0] + INP(8) * w[1] + IN(0) * w[2] + IN(4) * w[3] + IN(8) * w[4]) >> 12;
             out[1] = (INP(9)  * w[0] + IN(1)  * w[1] + IN(5) * w[2] + IN(9) * w[3] + NX(1) * w[4]) >> 12;
             out[2] = (INP(10) * w[0] + IN(2)  * w[1] + IN(6) * w[2] + IN(10)* w[3] + NX(2) * w[4]) >> 12;
             #undef IN
             #undef INP
             #undef NX

             out+=bpp;
             prev0 = inp0;
             prev1 = inp1;
             prev2 = inp2;
             in+=bpp * 3;
          }
        }
      } else if (scale != 1.0f)
      {
         uint8_t *out = (uint8_t*)scratch;

         //for (int y = 0; y < render_height; y++)
         for (int y = 0; y < render_height && y + y0 < ctx->height ; y++)
         {
           if (fb) {
             out = fb + stride * (y + y0) + x0 * bpp;
           }
           for (int x = 0; x < width; x++)
           {
             uint8_t *in  = (uint8_t*) &temp[(int)(( (int)((int)(y*scale) * (int)(width * scale)  +(int)(x*scale))) * bpp)];
             for (int c = 0; c < 3; c++)
               out[c] = in[c];
             out+=bpp;
          }
        }
      } else if (temp)
      {
        assert (0);
      }

      if (backend_cb->config.fb == NULL)
        set_pixels (ctx, set_pixels_user_data, 
                    x0, y0, width, render_height, scratch);

    if (backend_cb->config.intra)
       backend_cb->config.intra (ctx, backend_cb->config.intra_user_data?
                                      backend_cb->config.intra_user_data:
                                      backend_cb->config.user_data);

      y0 += render_height;
    } while (y0 < y1 && !abort);
  }
//backend_cb->jobs[taskno].renderer = 0;
  return abort;
}

static void
ctx_cb_start_frame (Ctx *ctx)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;
#if CTX_EVENTS
  //ctx_handle_events (ctx);
#endif
  //ctx_save (ctx);
  if ((cb_backend->rctx[0]) && !(cb_backend->config.flags & CTX_FLAG_RENDER_THREAD))
  {
    for (int i = 0; i < 2; i++)
    ctx_rasterizer_init ((CtxRasterizer*)cb_backend->rctx[i]->backend,
           cb_backend->rctx[i], NULL, &cb_backend->rctx[i]->state, cb_backend->config.fb, 0, 0, ctx->width, ctx->height,
           ctx_pixel_format_get_stride (cb_backend->config.format, ctx->width), cb_backend->config.format, CTX_ANTIALIAS_DEFAULT);
  }
}

static float ctx_fi_to_scale (int fi)
{
 float scale = 1.0f;
switch (fi)
{
  case CTX_FI_NONE: scale = 0.125; break;
  case CTX_FI_LOW: scale = 0.25; break;
  case CTX_FI_HALF: scale = 0.5; break;
  case CTX_FI_NORMAL: scale = 1.0; break;
  case CTX_FI_SUBPIXEL: scale = 3.0; break;
}
return scale;
}

static void
ctx_cb_render_frame (Ctx *ctx)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;

  int width  = ctx_width (ctx);
  int height = ctx_height (ctx);

  int tile_width = width / CTX_HASH_COLS;
  int tile_height = height / CTX_HASH_ROWS;

  int tile_count = CTX_HASH_COLS * CTX_HASH_ROWS;

  Ctx *rctx = cb_backend->config.flags&CTX_FLAG_RENDER_THREAD?cb_backend->drawlist_copy:ctx;

  cb_clear_jobs (ctx);

  if (cb_backend->config.flags & CTX_FLAG_HASH_CACHE)
  {
    CtxState    *state = &rctx->state;

    CtxPixelFormat format = cb_backend->config.format;
    int bpp               = ctx_pixel_format_bits_per_pixel (format) / 8;
    int tile_dim          = tile_width * tile_height * bpp;

    CtxRasterizer *rasterizer = (CtxRasterizer*)&cb_backend->hasher;
    ctx_hasher_init (rasterizer, rctx, state, width, height, CTX_HASH_COLS, CTX_HASH_ROWS, &rctx->drawlist);
    ((CtxBackend*)rasterizer)->destroy = (CtxDestroyNotify)ctx_rasterizer_deinit;

    ctx_push_backend (rctx, rasterizer);

    int dirty_tiles = 0;
    ctx_render_ctx (rctx, rctx);

    cb_backend->max_col = -100;
    cb_backend->min_col = 100;
    cb_backend->max_row = -100;
    cb_backend->min_row = 100;

    uint32_t active_mask = 0;
    uint32_t *hashes = ((CtxHasher*)(rctx->backend))->hashes;
    int tile_no =0;
    int res_tiles[CTX_FI_SUBPIXEL+1] = {0,0,0,0,};

    int initial_fi = CTX_FI_NORMAL;
    int final_fi   = CTX_FI_NORMAL;

    if (cb_backend->config.flags & CTX_FLAG_SUBPIXEL)
    {
      final_fi = CTX_FI_SUBPIXEL;
    }
    if (cb_backend->config.flags & CTX_FLAG_LOWFI)
    {
      initial_fi = CTX_FI_HALF;
    }
  
    //initial_fi = CTX_FI_LOW;
    //final_fi = CTX_FI_NORMAL;
    //initial_fi = CTX_FI_NORMAL;
    //initial_fi = CTX_FI_NORMAL;
    //final_fi   = CTX_FI_HALF;
    //final_fi   = CTX_FI_SUBPIXEL;
    //initial_fi   = CTX_FI_NORMAL;
    //initial_fi   = CTX_FI_SUBPIXEL;
    //final_fi   = CTX_FI_SUBPIXEL;

    for (int row = 0; row < CTX_HASH_ROWS; row++)
      for (int col = 0; col < CTX_HASH_COLS; col++, tile_no++)
      {
        uint32_t new_hash = hashes[tile_no];
        if (new_hash &&
            new_hash != cb_backend->hashes[tile_no])
        {
          dirty_tiles++;
          cb_backend->res[tile_no]=CTX_FI_NONE;
        }
        if (cb_backend->res[tile_no] != final_fi)
        {
          cb_backend->max_col = ctx_maxi (cb_backend->max_col, col);
          cb_backend->max_row = ctx_maxi (cb_backend->max_row, row);
          cb_backend->min_col = ctx_mini (cb_backend->min_col, col);
          cb_backend->min_row = ctx_mini (cb_backend->min_row, row);
        }
        res_tiles[cb_backend->res[tile_no]]++;
      }

    int refinable = tile_count - res_tiles[final_fi];
    int old_flags = cb_backend->config.flags;

    // straight to render..
    if (dirty_tiles <= 2 && refinable <= 2)
    {
      initial_fi = final_fi;
    }

    ctx_pop_backend (rctx); // done with hasher

    if (dirty_tiles)
    {
      int abort = 0;
      int abortable = 1;

      tile_no = 0;

      // render row-by-row (no merging of rows)

      for (int row = 0; row < CTX_HASH_ROWS; row++)
      {
        for (int col = 0; col < CTX_HASH_COLS; col++)
           if (!abort)
        {
          tile_no = row * CTX_HASH_COLS + col;
          active_mask = 1<<tile_no;
          uint32_t new_hash = hashes[tile_no];
          int used_tiles = 1;

          if ((new_hash != cb_backend->hashes[tile_no]))
          {
            int tx0 = col * tile_width;
            int ty0 = row * tile_height;
            int tx1 = tx0 +  tile_width-1;
            int ty1 = ty0 +  tile_height-1;

            int max_tiles = (cb_backend->config.buffer_size / tile_dim);
            int cont = 1;

            /* merge horizontal adjecant dirty tiles */
            if (used_tiles < max_tiles && col + 1 < CTX_HASH_COLS) do {
              uint32_t next_new_hash = hashes[tile_no+used_tiles];
              if ((next_new_hash != cb_backend->hashes[tile_no+used_tiles])) // || (cb_backend->res[tile_no+used_tiles] != final_fi))
              {
                active_mask |= (1 << (tile_no+used_tiles));
                used_tiles ++;
                tx1 += (ctx_width (rctx)/CTX_HASH_COLS);
              }
              else
              {
                cont = 0;
              }
            } while (used_tiles < max_tiles && cont && col + used_tiles < CTX_HASH_COLS);

            if (initial_fi != final_fi)
              ctx_queue_draw (ctx);

            cb_add_job (ctx, tx0, ty0, tx1, ty1, initial_fi, active_mask);

            for (int i = 0; i < used_tiles; i ++)
            {
              cb_backend->res[tile_no + i]= initial_fi;
              cb_backend->hashes[tile_no + i] = hashes[tile_no+i];
            }
            if (!abortable)
               abort = 0;
            col += used_tiles - 1;
          }
        }
      }
    }
    else if (refinable)
    {
      int abort = 0;
      int abortable = 1;

      tile_no = 0;

         // render row-by-row (no merging of rows)

      for (int row = 0; row < CTX_HASH_ROWS; row++)
      {
        for (int col = 0; col < CTX_HASH_COLS; col++)
          if (!abort)
        {
          tile_no = row * CTX_HASH_COLS + col;
          active_mask = 1<<tile_no;
          int used_tiles = 1;


          if (cb_backend->res[tile_no] != final_fi)
          {
             int tx0 = col * tile_width;
             int ty0 = row * tile_height;
             int tx1 = tx0 +  tile_width-1;
             int ty1 = ty0 +  tile_height-1;

             int max_tiles = (cb_backend->config.buffer_size / tile_dim);
             int cont = 1;

             /* merge horizontal adjecant dirty tiles */
             if (used_tiles < max_tiles && col + 1 < CTX_HASH_COLS)
             do 
             {
               uint32_t next_new_hash = hashes[tile_no+used_tiles];
               if ((cb_backend->res[tile_no+used_tiles] != final_fi) &&
                   next_new_hash == cb_backend->hashes[tile_no+used_tiles])
               {
                 active_mask |= (1 << (tile_no+used_tiles));
                 used_tiles ++;
                 tx1 += (ctx_width (rctx)/CTX_HASH_COLS);
               }
               else
               {
                 cont = 0;
               }
             } while (used_tiles < max_tiles && cont && col + used_tiles < CTX_HASH_COLS);

             cb_add_job (ctx, tx0, ty0, tx1, ty1, final_fi, active_mask);

             for (int i = 0; i < used_tiles; i ++)
             {
               cb_backend->res[tile_no + i]=final_fi;
               cb_backend->hashes[tile_no + i] = hashes[tile_no+i];
             }
             if (!abortable)
                abort = 0;
             col += used_tiles - 1;
          }
        }
      }
    }
    cb_backend->config.flags = old_flags;
  }
  else
  {
    cb_add_job (ctx, 0, 0, ctx_width(rctx)-1, ctx_height(rctx)-1, 0, 0);
  }

  if (cb_backend->n_jobs == 1)
  {
    cb_add_job (ctx, 
                cb_backend->jobs[0].x0,
                cb_backend->jobs[0].y0,
                cb_backend->jobs[0].x1,
                cb_backend->jobs[0].y1,
                cb_backend->jobs[0].flags,
                cb_backend->jobs[0].bitmask);
    int ym = (cb_backend->jobs[0].y0 + cb_backend->jobs[0].y1)/2;
    cb_backend->jobs[0].y1 =
    cb_backend->jobs[1].y0 = ym;
  }

  for (int i = 0; i < cb_backend->n_jobs; i++)
  {
    cb_backend->jobs[i].renderer = -1;
  }

  mtx_lock (&cb_backend->mtx);
  for (int i = 0; i < cb_backend->n_jobs; i++)
  {
    if (cb_backend->jobs[i].renderer == -1)
    {
      cb_backend->jobs[i].renderer = 1;
      mtx_unlock (&cb_backend->mtx);
      float scale = ctx_fi_to_scale (cb_backend->jobs[i].flags);
      ctx_render_cb (cb_backend, 
                     cb_backend->jobs[i].x0,
                     cb_backend->jobs[i].y0,
                     cb_backend->jobs[i].x1,
                     cb_backend->jobs[i].y1,
                     cb_backend->jobs[i].bitmask,
                     i,
                     0,
                     scale);
      mtx_lock (&cb_backend->mtx);
      cb_backend->jobs[i].renderer = 0;
    }
  }

  // wait for stolen jobs
  while (cb_jobs_in_flight (ctx))
  {
    mtx_unlock (&cb_backend->mtx);
    usleep(100);
    mtx_lock (&cb_backend->mtx);
  }
  mtx_unlock (&cb_backend->mtx);

  if (cb_backend->config.update_fb)
  {
     int x0 = cb_backend->min_col * (ctx_width (ctx)/CTX_HASH_COLS);
     int x1 = (cb_backend->max_col+1) * (ctx_width (ctx)/CTX_HASH_COLS)-1;
     int y0 = cb_backend->min_row * (ctx_height (ctx)/CTX_HASH_ROWS);
     int y1 = (cb_backend->max_row+1) * (ctx_height (ctx)/CTX_HASH_ROWS)-1;
     if (x1 > x0 && y1 > y0)
     {
     cb_backend->config.update_fb (ctx, cb_backend->config.update_fb_user_data?
                                        cb_backend->config.update_fb_user_data:
                                        cb_backend->config.user_data, x0, y0, x1-x0+1, y1-y0+1
                                        );
     }
  }
}

#if CTX_PICO
#include "pico/multicore.h"
#endif

#if CTX_PICO | CTX_THREADS

#if CTX_PICO
void *core1_arg = NULL;
static void *
ctx_cb_render_thread ()
#else
static void*
ctx_cb_render_thread (CtxCbBackend *cb_backend)
#endif
{
#if CTX_PICO
  CtxCbBackend *cb_backend = core1_arg;
#endif
  Ctx *ctx = cb_backend->backend.ctx;

  mtx_lock (&cb_backend->mtx);
  if (cb_backend->config.renderer_init &&
      cb_backend->config.renderer_init (ctx, cb_backend->config.renderer_init_user_data?
                                             cb_backend->config.renderer_init_user_data:
                                             cb_backend->config.user_data))
  {
    mtx_unlock (&cb_backend->mtx);
    return NULL;
  }

  cb_backend->rendering = 0;
  mtx_unlock (&cb_backend->mtx);

  while (!ctx_cb_kill)
  {
    mtx_lock (&cb_backend->mtx);
    do
    {
      mtx_unlock (&cb_backend->mtx);
      if (cb_backend->config.renderer_idle)
        cb_backend->config.renderer_idle (ctx, cb_backend->config.renderer_idle_user_data?
                                               cb_backend->config.renderer_idle_user_data:
                                               cb_backend->config.user_data);
      usleep (500);
      mtx_lock (&cb_backend->mtx);
      if (ctx_cb_kill)
        break;
    } while (cb_backend->rendering == 0);

    if (!ctx_cb_kill && cb_backend->rendering >= 1)
    {
      int flush = (cb_backend->rendering == 2);
      mtx_unlock (&cb_backend->mtx);

      if (cb_backend->config.flags & CTX_FLAG_FULL_FB)
      {
         Ctx *rctx = cb_backend->rctx[0];
         ctx_render_ctx (cb_backend->drawlist_copy, rctx);

         if (flush && cb_backend->config.update_fb)
            cb_backend->config.update_fb (ctx, cb_backend->config.update_fb_user_data?
                                               cb_backend->config.update_fb_user_data:
                                               cb_backend->config.user_data, 0, 0, ctx->width, ctx->height);


      }
      else
      {
        mtx_lock (&cb_backend->mtx);
        cb_backend->rendering = 3;
        mtx_unlock (&cb_backend->mtx);
        ctx_cb_render_frame (ctx);
      }

      mtx_lock (&cb_backend->mtx);
      cb_backend->rendering = 0;
      mtx_unlock (&cb_backend->mtx);

    }
    else
    {
      mtx_unlock (&cb_backend->mtx);
    }
  }

  if (cb_backend->config.renderer_stop)
     cb_backend->config.renderer_stop (ctx,
        cb_backend->config.renderer_stop_user_data?
        cb_backend->config.renderer_stop_user_data:
        cb_backend->config.user_data);
  ctx_cb_kill = 0;
  return NULL;
}
#endif

#if CTX_PARSER & CTX_EVENTS
static void ctx_draw_pointer (Ctx *ctx, float x, float y, CtxCursor cursor)
{
#define CURSOR_POST " rgba 0 0 0 0.5 z preserve fill rgba 1 1 1 0.5 lineWidth 2 stroke"
    const char *drawing = "M 0 0 L 30 40 L 10 50 z" CURSOR_POST;
    ctx_save(ctx);
    ctx_translate (ctx, x, y);

    switch (cursor)
    {
      case CTX_CURSOR_UNSET: // XXX: document how this differs from none
                             //      perhaps falling back to arrow?
        break;
      case CTX_CURSOR_NONE:
        ctx_restore (ctx);
        return;
        drawing = "";
        break;
      case CTX_CURSOR_ARROW:
#if 1
        drawing = "M 0 0 L 30 40 L 10 50 z" CURSOR_POST;
#else
        ctx_move_to (ctx, 0,0);
        ctx_line_to (ctx, 30, 40);
        ctx_line_to (ctx, 10, 45);
        ctx_rgba (ctx, 0, 0, 0, 0.5);
        ctx_close_path (ctx);
        ctx_preserve (ctx);
        ctx_fill (ctx);
        ctx_rgba (ctx, 1, 1, 1, 0.5);
        ctx_line_width (ctx, 2.0);
        ctx_stroke (ctx);
        ctx_restore (ctx);
        return;
#endif
        break;
      case CTX_CURSOR_CROSSHAIR:

        drawing = "rectangle 10 -2 40 4 rectangle -50 -2 40 4 rectangle -2 -50 4 40 rectangle -2 10 4 40 z"
                   CURSOR_POST;

        break;
      case CTX_CURSOR_WAIT:
        drawing = "M -50 -50 L 50 -50 L -50 50 L 50 50 z" CURSOR_POST;

        break;
      case CTX_CURSOR_IBEAM:
        drawing = "M -5 -50 L 5 -50 5 -45 2.5 -45 2.5 45 5 45  5 50 -5 50 -5 45 -2.5 45 -2.5 -45 -5 -45 z "
                  CURSOR_POST;
        break;
      case CTX_CURSOR_HAND:
      case CTX_CURSOR_MOVE:
      case CTX_CURSOR_RESIZE_ALL:
      case CTX_CURSOR_RESIZE_N:
      case CTX_CURSOR_RESIZE_S:
      case CTX_CURSOR_RESIZE_E:
      case CTX_CURSOR_RESIZE_W:
      case CTX_CURSOR_RESIZE_NE:
      case CTX_CURSOR_RESIZE_SW:
      case CTX_CURSOR_RESIZE_NW:
      case CTX_CURSOR_RESIZE_SE:
        drawing = "M 0 0 L 50 0 L 50 50 L 0 50 rgba 1 0 0 0.5 fill";
        break;
    }

    ctx_parse (ctx, drawing);
    ctx_restore(ctx);
}
#endif



// needs lock around it
static void ctx_cb_swap_drawlists (Ctx *ctx)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;
  if (!cb_backend->drawlist_copy)
    return;
  CtxDrawlist temp = ctx->drawlist;
  ctx->drawlist = cb_backend->drawlist_copy->drawlist;
  cb_backend->drawlist_copy->drawlist = temp;
  ctx_set_size (cb_backend->drawlist_copy, ctx_width (ctx), ctx_height (ctx));
  ctx_drawlist_clear (ctx);
}

static void ctx_cb_flush_full_fb (Ctx *ctx)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;

  mtx_lock (&cb_backend->mtx);
  while (cb_backend->rendering > 0)
    {
      mtx_unlock (&cb_backend->mtx);
#if CTX_EVENTS
      ctx_clients_handle_events (ctx);
#else
      usleep (500);
#endif
      mtx_lock (&cb_backend->mtx);
    }

  ctx_cb_swap_drawlists (ctx);
  cb_backend->rendering = 1;
  mtx_unlock (&cb_backend->mtx);
}

static void ctx_cb_steal_job (Ctx *ctx, int arg)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;
      mtx_lock (&cb_backend->mtx);
  int pending;
  if ( (pending = cb_jobs_pending(ctx)))
    {
      for (int i = cb_backend->n_jobs - 1; i > 0; i--)
      {
      int steal_job = i;
      if (cb_backend->jobs[steal_job].renderer == CTX_JOB_PENDING)
      {
        //fprintf (stderr, "{%i:%i}", steal_job, arg);
        cb_backend->jobs[steal_job].renderer = 2;
        mtx_unlock (&cb_backend->mtx);
        float scale = ctx_fi_to_scale (cb_backend->jobs[steal_job].flags);
        ctx_render_cb (cb_backend, 
                       cb_backend->jobs[steal_job].x0,
                       cb_backend->jobs[steal_job].y0,
                       cb_backend->jobs[steal_job].x1,
                       cb_backend->jobs[steal_job].y1,
                       cb_backend->jobs[steal_job].bitmask,
                       i,
                       1,
                       scale);
        cb_backend->jobs[steal_job].renderer = 0;
        return;
      }
      }
    }
  mtx_unlock (&cb_backend->mtx);
}

static void ctx_cb_flush_frame (Ctx *ctx)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;

  mtx_lock (&cb_backend->mtx);

  while (cb_backend->rendering || cb_jobs_pending (ctx) || cb_jobs_in_flight (ctx))
    {
      mtx_unlock (&cb_backend->mtx);
 
      /* while waiting for renderer to be ready to accept a frame.. */

      if (cb_backend->config.fb && (cb_backend->config.flags & CTX_FLAG_RENDER_THREAD))
        ctx_cb_steal_job (ctx, 0);
#if CTX_EVENTS
      else
        ctx_clients_handle_events (ctx); // read from terminals
#endif
      mtx_lock (&cb_backend->mtx);
    }

  ctx_cb_swap_drawlists (ctx);
  cb_backend->frame_no ++;

#if CTX_EVENTS
  ctx_handle_events (ctx);
#endif

  CtxCbConfig *config = &cb_backend->config;
  if (config->flags & CTX_FLAG_FULL_FB)
  {
    for (int i = 0; i < 2; i++)
      ctx_rasterizer_init ((CtxRasterizer*)cb_backend->rctx[i]->backend,
       cb_backend->rctx[i], NULL, &cb_backend->rctx[i]->state, cb_backend->config.fb, 0, 0, ctx->width, ctx->height,
       ctx_pixel_format_get_stride (cb_backend->config.format, ctx->width), cb_backend->config.format, CTX_ANTIALIAS_DEFAULT);
  }
  cb_backend->rendering = 2;
  mtx_unlock (&cb_backend->mtx);

  // pre-emptively steal jobs
  if(1)if (cb_backend->config.fb && (cb_backend->config.flags & CTX_FLAG_RENDER_THREAD))
  {
    mtx_lock (&cb_backend->mtx);
    while (cb_backend->rendering == 2)
    {
      mtx_unlock (&cb_backend->mtx);
#if CTX_EVENTS
      ctx_clients_handle_events (ctx);
#else
      usleep (500);
#endif
      mtx_lock (&cb_backend->mtx);
    }
    mtx_unlock (&cb_backend->mtx);

    int n = cb_backend->n_jobs/3;
    for (int i = 0; i < n && i < 2; i++)
      ctx_cb_steal_job (ctx, 23);
  }
}

static void
ctx_cb_end_frame (Ctx *ctx)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)ctx->backend;

  if (cb_backend->config.flags & CTX_FLAG_SHOW_FPS)
  {
    static int64_t prev_time = 0;
    int64_t cur_time = ctx_ticks () / 1000;
    if (prev_time)
    {
      char buf[22];
      float  ms = ((cur_time-prev_time));
      float fps = 1000.0f/ms;
      static float dfps = 0.0f;
      if (fps > 0 && fps < 100)
      {
        if (fps > 10)
          dfps = dfps * 0.9f + fps * 0.1f;
        else
          dfps = dfps * 0.3f + fps * 0.7f;
      }
      sprintf (buf, "%2.1ffps", (double)dfps);

      if (cb_backend->config.windowtitle)
      {
#if CTX_EVENTS
        ctx_windowtitle (ctx, buf);
#endif
      }
      else
      {
        float em = ctx_height (ctx) * 0.08f;
        float y = em;
        ctx_save (ctx);
        ctx_font_size (ctx, em);
        ctx_rectangle (ctx, ctx_width(ctx)/2-(em*2), 0, em *4, em * 1.1f);
        ctx_rgba (ctx, 0, 0, 0, 0.7f);
        ctx_fill (ctx);
  
        ctx_rgba (ctx, 1, 1, 0, 1);

        ctx_move_to (ctx, ctx_width (ctx) * 0.5f, y);
        ctx_text_align (ctx, CTX_TEXT_ALIGN_CENTER);
        ctx_text (ctx, buf);
        ctx_reset_path (ctx);
        ctx_restore(ctx);
      }
    }
    prev_time = cur_time;
  }

#if CTX_PARSER & CTX_EVENTS
  if (cb_backend->config.flags & CTX_FLAG_POINTER)
    ctx_draw_pointer (ctx, ctx_pointer_x(ctx), ctx_pointer_y(ctx), ctx->cursor);
#endif

  //ctx_restore (ctx);

  if (cb_backend->config.flags & CTX_FLAG_RENDER_THREAD)
  {
    ctx_cb_flush_frame (ctx);
  }
  else
  {
      if (cb_backend->config.flags & CTX_FLAG_FULL_FB)
      {
         ctx_render_ctx (ctx, cb_backend->rctx[0]);
         if (cb_backend->config.update_fb)
            cb_backend->config.update_fb (ctx, cb_backend->config.update_fb_user_data?
                                               cb_backend->config.update_fb_user_data:
                                               cb_backend->config.user_data, 0, 0, ctx->width, ctx->height);
      }
      else
      {
        ctx_cb_render_frame (ctx);
      }
#if CTX_EVENTS
      ctx_handle_events (ctx);
#endif
  }
}

void ctx_cb_destroy (void *data)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)data;
  if (cb_backend->config.flags & CTX_FLAG_RENDER_THREAD)
  {
    mtx_lock (&cb_backend->mtx);
    ctx_cb_kill = 1;
    cb_backend->rendering = -1;
#if CTX_EVENTS
    Ctx *ctx = cb_backend->backend.ctx;
    do {
      mtx_unlock (&cb_backend->mtx);
      int start = ctx_ms (ctx);
      while (ctx_ms (ctx) - start < 50) {};
      mtx_lock (&cb_backend->mtx);
    } while (ctx_cb_kill == 1);
    mtx_unlock (&cb_backend->mtx);
#else
    usleep (1000 * 1000 * 10);
#endif
    ctx_destroy (cb_backend->drawlist_copy);
  }
  else
  {
    if (cb_backend->config.renderer_stop)
      cb_backend->config.renderer_stop (cb_backend->backend.ctx,
         cb_backend->config.renderer_stop_user_data?
         cb_backend->config.renderer_stop_user_data:
         cb_backend->config.user_data);
  }
  if (cb_backend->allocated_fb)
  {
    ctx_free (cb_backend->scratch);
  }
  free (data);
}

#if CTX_EVENTS
static void ctx_cb_consume_events (Ctx *ctx)
{
  CtxCbBackend *backend_cb = (CtxCbBackend*)ctx->backend;
#if CTX_PARSER
  int old_pointer_x = 0;
  int old_pointer_y = 0;
  if (backend_cb->config.flags & CTX_FLAG_POINTER)
  {
    old_pointer_x = ctx_pointer_x (ctx);
    old_pointer_y = ctx_pointer_y (ctx);
  }
#endif
  if (backend_cb->config.consume_events)
  {
    backend_cb->config.consume_events (ctx, backend_cb->config.consume_events_user_data?
                                            backend_cb->config.consume_events_user_data:
                                            backend_cb->config.user_data);
  }
#if CTX_PARSER
  if (backend_cb->config.flags & CTX_FLAG_POINTER)
  {
    int pointer_x = ctx_pointer_x (ctx);
    int pointer_y = ctx_pointer_y (ctx);
    if ((pointer_x != old_pointer_x) |
        (pointer_y != old_pointer_y))
      ctx_queue_draw (ctx);
  }
#endif
}
#endif

#define get_user_data(name) \
        (cb->config.name##_user_data?\
         cb->config.name##_user_data:\
         cb->config.user_data)

static void ctx_cb_windowtitle (Ctx *ctx, const char *utf8)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  cb->config.windowtitle (ctx, get_user_data(windowtitle), utf8);
}

static void ctx_cb_set_clipboard (Ctx *ctx, const char *utf8)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  cb->config.set_clipboard (ctx, get_user_data(set_clipboard), utf8);
}

static char *ctx_cb_get_clipboard (Ctx *ctx)
{
  CtxCbBackend *cb = (CtxCbBackend*)ctx->backend;
  return cb->config.get_clipboard (ctx, get_user_data(get_clipboard));
}

static void ctx_cb_full_set_pixels (Ctx *ctx, void *user_data, int x, int y, int w, int h, void *buf)
{
  CtxCbBackend *cb_backend = (CtxCbBackend*)user_data;
  uint8_t *out = (uint8_t*)cb_backend->config.fb;
  int bpp  = ctx_pixel_format_bits_per_pixel (cb_backend->config.format) / 8;
  uint8_t *src = (uint8_t*)buf;
  for (int scan = y; scan < y + h; scan++)
  {
    uint8_t *dst = (uint8_t*)&out[(ctx->width * scan + x)*bpp];
    for (int col = x; col < x + w; col++)
    {
      for (int b= 0; b < bpp; b++)
        *dst++ = *src++;
    }
  }
}



/* this process function is only used with full_fb flag 
 */
static void
ctx_cb_process (Ctx *ctx, const CtxCommand *command)
{
  CtxEntry *entry = (CtxEntry*)command;
#if CTX_CURRENT_PATH
  ctx_update_current_path (ctx, entry);
#endif

  if (ctx->drawlist.count + 36 + ctx_conts_for_entry (entry) > (unsigned) ctx->drawlist.size ) 
  {                     // the internal add_entry operates with 32 item headroom
    ctx_cb_flush_full_fb (ctx);
  }

  /* these functions can alter the code and coordinates of
     command that in the end gets added to the drawlist
   */
  ctx_interpret_style (&ctx->state, entry, ctx);
  ctx_interpret_transforms (&ctx->state, entry, ctx);
  ctx_interpret_pos (&ctx->state, entry, ctx);
  ctx_drawlist_add_entry (&ctx->drawlist, entry);

}

Ctx *ctx_new_cb (int width, int height, CtxCbConfig *config)
{
  Ctx          *ctx        = ctx_new_drawlist (width, height);
  CtxBackend   *backend    = (CtxBackend*)ctx_calloc (1, sizeof (CtxCbBackend));
  CtxCbBackend *cb_backend = (CtxCbBackend*)backend;

  backend->start_frame = ctx_cb_start_frame;
  backend->end_frame   = ctx_cb_end_frame;
  backend->reset_caches = ctx_cb_reset_caches;
  backend->destroy     = ctx_cb_destroy;
  backend->ctx         = ctx;

  if (config->flags & CTX_FLAG_FULL_FB)
    backend->process = ctx_cb_process;

  cb_backend->config   = *config;
  cb_backend->scratch  = (uint16_t*)config->buffer;

  ctx_set_backend (ctx, backend);

  ctx_cb_set_flags (ctx, config->flags);

  if (getenv ("CTX_SHOW_FPS"))
     cb_backend->config.flags |= CTX_FLAG_SHOW_FPS;

  cb_backend->ctx = ctx;

#if CTX_EVENTS
  backend->consume_events = ctx_cb_consume_events;
#endif
  if (config->windowtitle)
    backend->set_windowtitle = ctx_cb_windowtitle;

  if (config->get_clipboard)
    backend->get_clipboard = ctx_cb_get_clipboard;
  if (config->set_clipboard)
    backend->set_clipboard = ctx_cb_set_clipboard;

  if (config->fb)
  {
    if (!cb_backend->config.set_pixels)
    {
      cb_backend->config.set_pixels = ctx_cb_full_set_pixels;
      cb_backend->config.set_pixels_user_data = cb_backend;
    }
  }


  if (config->fb)
  {
    cb_backend->config.buffer_size = width * height * ctx_pixel_format_bits_per_pixel (cb_backend->config.format) / 8 / 2;
  }
  else
  if (!config->buffer)
  {
    int mb = config->buffer_size;
    cb_backend->config.buffer_size = 0;
    if (mb <= 0){
      if (width > 30 && height > 30)
        mb = width*height * 2;  // we do not neccesarily want it to be a full buffer
                                // by default since then hash updating can suffers with large bounding box of sparse tiles
      else
        mb = 128 * 1024;
    }
    ctx_cb_set_memory_budget (ctx, mb);
  }

#if CTX_THREADS | CTX_PICO
  if (cb_backend->config.flags & CTX_FLAG_RENDER_THREAD)
  {
    cb_backend->drawlist_copy = ctx_new_drawlist (width, height); // TODO : keep size in sync
    ctx_set_texture_cache (cb_backend->drawlist_copy, ctx);
    cb_backend->rendering = -1;
#if CTX_PICO
    core1_arg = cb_backend;
#endif

#if ESP_PLATFORM 
#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 2, 0)
    esp_pthread_cfg_t cfg = esp_pthread_get_default_config();
    cfg.stack_size = (10 * 1024);
    esp_pthread_set_cfg(&cfg);
#endif
#endif

    mtx_init (&cb_backend->mtx, mtx_plain);
#if CTX_PICO
    multicore_launch_core1(ctx_cb_render_thread);
#else

    thrd_t tid;

#if ESP_PLATFORM
#if (ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0))
    pthread_attr_t attr;          // on lower esp-idf versions the default ptread stack size should be set instead
    pthread_attr_init (&attr);
    pthread_attr_setstacksize (&attr, 10 * 1024);
    pthread_create(&tid, &attr, (void*)ctx_cb_render_thread, (void*)cb_backend);
#else
    thrd_create(&tid, (void*)ctx_cb_render_thread, (void*) cb_backend);
#endif
#else
    thrd_create(&tid, (void*(*)(void*))ctx_cb_render_thread, (void*) cb_backend);
#endif


#endif
    usleep (1000 * 20);

    if (cb_backend->config.renderer_init)
    {
       usleep (20 * 1000);
       int n = 250;
       mtx_lock (&cb_backend->mtx);
       while (cb_backend->rendering == -1 && n-- > 0){
          mtx_unlock (&cb_backend->mtx);
#if CTX_EVENTS
          int start = ctx_ms (ctx);
          while (ctx_ms (ctx) - start < 20) {};
#else
          usleep(20 * 1000);
#endif
          mtx_lock (&cb_backend->mtx);
       }
       mtx_unlock (&cb_backend->mtx);
       if (cb_backend->rendering == -1)
       {
         ctx_destroy (ctx);
         return NULL;
       }
    } else
    {
       cb_backend->rendering = 0;
    }
  }
  else
#endif
  {
    if (cb_backend->config.renderer_init)
      {
         if (cb_backend->config.renderer_init (ctx, 
                cb_backend->config.renderer_init_user_data?
                cb_backend->config.renderer_init_user_data:
                cb_backend->config.user_data
                ))
         {
           ctx_destroy (ctx);
           return NULL;
         }
      }
  }


  //if (config->flags & CTX_FLAG_FULL_FB)

  for (int i = 0; i < 2; i++)
  {
    cb_backend->rctx[i] = ctx_new_for_framebuffer (cb_backend->config.fb, ctx->width, ctx->height, ctx_pixel_format_get_stride (cb_backend->config.format, ctx->width),
                                                cb_backend->config.format);
    ctx_set_texture_source (cb_backend->rctx[i], ctx);
  }

  return ctx;
}

#if 0
/* this is a compatibility function to make porting to new ctx quicker
 * first check that things work with this and then
 * implement new API
 */
Ctx *ctx_new_cb_old (int width, int height, CtxPixelFormat format,
                     void (*set_pixels) (Ctx *ctx, void *user_data, 
                                     int x, int y, int w, int h, void *buf),
                     void *set_pixels_user_data,
                     int (*update_fb) (Ctx *ctx, void *user_data),
                     void *update_fb_user_data,
                     int   memory_budget,
                     void *buffer,
                     int   flags)
{
  CtxCbConfig config = {
    .format               = format,
    .update_fb            = (void*)update_fb, // XXX : hacky but maintains API/ABI - assuming extra args are ignored in calling convention
    .update_fb_user_data  = update_fb_user_data,
    .set_pixels           = set_pixels,
    .set_pixels_user_data = set_pixels_user_data,
    .buffer_size          = memory_budget,
    .buffer               = buffer,
    .flags                = flags,
  };
  return ctx_new_cb (width, height, &config);
}
#endif
#endif

#if !__COSMOPOLITAN__
#include <fcntl.h>
#if CTX_PTY
#include <sys/ioctl.h>
#endif
#include <signal.h>
#endif

#if CTX_KMS
#ifdef __linux__
  #include <linux/kd.h>
#endif
//#include <linux/fb.h>
//#include <linux/vt.h>
#include <sys/mman.h>
#include <libdrm/drm.h>
#include <libdrm/drm_mode.h>


typedef struct _CtxKMS CtxKMS;
struct _CtxKMS
{
   int           key_balance;
   int           key_repeat;
   int           lctrl;
   int           lalt;
   int           rctrl;

   int          fb_fd;
   char        *fb_path;
   int          fb_bits;
   int          fb_bpp;
   int          fb_mapped_size;

   int          vt;
   int          tty;
   int          is_kms;
   cnd_t        cond;
   mtx_t        mtx;
   struct drm_mode_crtc crtc;
};


#if UINTPTR_MAX == 0xffFFffFF
  #define fbdrmuint_t uint32_t
#elif UINTPTR_MAX == 0xffFFffFFffFFffFF
  #define fbdrmuint_t uint64_t
#endif

static void *ctx_fbkms_new_int (CtxKMS *fb, int *width, int *height, const char *path)
{
   struct drm_mode_modeinfo *conn_mode_buf = NULL;
   fb->fb_fd = open(path, O_RDWR | O_CLOEXEC);
   if (!fb->fb_fd)
     return NULL;
   static fbdrmuint_t res_conn_buf[20]={0}; // this is static since its contents
                                         // are used by the flip callback
   fbdrmuint_t res_fb_buf[20]={0};
   fbdrmuint_t res_crtc_buf[20]={0};
   fbdrmuint_t res_enc_buf[20]={0};
   struct   drm_mode_card_res res={0};

   if (ioctl(fb->fb_fd, DRM_IOCTL_SET_MASTER, 0))
   {
     fb->fb_fd = 0;
     return NULL;
   }

   if (ioctl(fb->fb_fd, DRM_IOCTL_MODE_GETRESOURCES, &res))
     goto cleanup;
   res.fb_id_ptr=(fbdrmuint_t)res_fb_buf;
   res.crtc_id_ptr=(fbdrmuint_t)res_crtc_buf;
   res.connector_id_ptr=(fbdrmuint_t)res_conn_buf;
   res.encoder_id_ptr=(fbdrmuint_t)res_enc_buf;
   if(ioctl(fb->fb_fd, DRM_IOCTL_MODE_GETRESOURCES, &res))
      goto cleanup;


   unsigned int i;
   conn_mode_buf = (struct drm_mode_modeinfo*)ctx_calloc(20, sizeof(struct drm_mode_modeinfo));
   for (i=0;i<res.count_connectors;i++)
   {
     fbdrmuint_t conn_prop_buf[20]={0},
                     conn_propval_buf[20]={0},
                     conn_enc_buf[20]={0};

     struct drm_mode_get_connector conn={0};

     conn.connector_id=res_conn_buf[i];

     if (ioctl(fb->fb_fd, DRM_IOCTL_MODE_GETCONNECTOR, &conn))
       goto cleanup;

     conn.modes_ptr=(fbdrmuint_t)conn_mode_buf;
     conn.props_ptr=(fbdrmuint_t)conn_prop_buf;
     conn.prop_values_ptr=(fbdrmuint_t)conn_propval_buf;
     conn.encoders_ptr=(fbdrmuint_t)conn_enc_buf;

     if (ioctl(fb->fb_fd, DRM_IOCTL_MODE_GETCONNECTOR, &conn))
       goto cleanup;

     //Check if connector is connected to a display
     if (conn.count_encoders<1 || conn.count_modes<1 || !conn.encoder_id || !conn.connection)
       continue;

     struct drm_mode_create_dumb create_dumb={0};
     struct drm_mode_map_dumb    map_dumb={0};
     struct drm_mode_fb_cmd      cmd_dumb={0};
     create_dumb.width  = conn_mode_buf[0].hdisplay;
     create_dumb.height = conn_mode_buf[0].vdisplay;
     create_dumb.bpp   = 32;
     create_dumb.flags = 0;
     create_dumb.pitch = 0;
     create_dumb.size  = 0;
     create_dumb.handle = 0;
     if (ioctl(fb->fb_fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_dumb) ||
         !create_dumb.handle)
       goto cleanup;

     cmd_dumb.width =create_dumb.width;
     cmd_dumb.height=create_dumb.height;
     cmd_dumb.bpp   =create_dumb.bpp;
     cmd_dumb.pitch =create_dumb.pitch;
     cmd_dumb.depth =24;
     cmd_dumb.handle=create_dumb.handle;
     if (ioctl(fb->fb_fd,DRM_IOCTL_MODE_ADDFB,&cmd_dumb))
       goto cleanup;

     map_dumb.handle=create_dumb.handle;
     if (ioctl(fb->fb_fd,DRM_IOCTL_MODE_MAP_DUMB,&map_dumb))
       goto cleanup;

     void *base = mmap(0, create_dumb.size, PROT_READ | PROT_WRITE, MAP_SHARED,
                       fb->fb_fd, map_dumb.offset);
     if (!base)
     {
       goto cleanup;
     }
     *width  = create_dumb.width;
     *height = create_dumb.height;

     struct drm_mode_get_encoder enc={0};
     enc.encoder_id=conn.encoder_id;
     if (ioctl(fb->fb_fd, DRM_IOCTL_MODE_GETENCODER, &enc))
        goto cleanup;

     fb->crtc.crtc_id=enc.crtc_id;
     if (ioctl(fb->fb_fd, DRM_IOCTL_MODE_GETCRTC, &fb->crtc))
        goto cleanup;

     fb->crtc.fb_id=cmd_dumb.fb_id;
     fb->crtc.set_connectors_ptr=(fbdrmuint_t)&res_conn_buf[i];
     fb->crtc.count_connectors=1;
     fb->crtc.mode=conn_mode_buf[0];
     fb->crtc.mode_valid=1;
     if (conn_mode_buf) ctx_free (conn_mode_buf);
     return base;
   }
cleanup:
   if (conn_mode_buf)
     ctx_free (conn_mode_buf);
   ioctl(fb->fb_fd, DRM_IOCTL_DROP_MASTER, 0);
   fb->fb_fd = 0;
   return NULL;
}

void *ctx_fbkms_new (CtxKMS *fb, int *width, int *height)
{
   void *ret = ctx_fbkms_new_int (fb, width, height, "/dev/dri/card0");
   if (!ret)
     ret = ctx_fbkms_new_int (fb, width, height, "/dev/dri/card1");
   return ret;
}

void ctx_fbkms_flip (CtxKMS *fb)
{
  if (!fb->fb_fd)
    return;
  ioctl(fb->fb_fd, DRM_IOCTL_MODE_SETCRTC, &fb->crtc);
}

void ctx_fbkms_close (CtxKMS *fb)
{
  if (!fb->fb_fd)
    return;
  ioctl(fb->fb_fd, DRM_IOCTL_DROP_MASTER, 0);
  close (fb->fb_fd);
  fb->fb_fd = 0;
}

static void ctx_kms_flip (CtxKMS *fb)
{
  if (fb->is_kms)
    ctx_fbkms_flip (fb);
#if 0
  else
    ioctl (fb->fb_fd, FBIOPAN_DISPLAY, &fb->vinfo);
#endif
}

void ctx_kms_destroy (CtxKMS *fb)
{
  if (fb->is_kms)
  {
    ctx_fbkms_close (fb);
  }
#ifdef __linux__
  ioctl (0, KDSETMODE, KD_TEXT);
#endif
  if (system("stty sane")){};
  //ctx_free (fb);
}

#endif

#if CTX_FB


#if !__COSMOPOLITAN__
#include <fcntl.h>
#if CTX_PTY
#include <sys/ioctl.h>
#endif
#include <signal.h>
#endif

#ifdef __linux__
  #include <linux/fb.h>
  #include <linux/vt.h>
  #include <linux/kd.h>
#endif

#ifdef __NetBSD__
  typedef uint8_t unchar;
  typedef uint8_t u_char;
  typedef uint16_t ushort;
  typedef uint32_t u_int;
  typedef uint64_t u_long;
  #include <sys/param.h>
  #include <dev/wscons/wsdisplay_usl_io.h>
  #include <dev/wscons/wsconsio.h>
  #include <dev/wscons/wsksymdef.h>
#endif

  #include <sys/mman.h>


/**/

typedef struct _CtxFbCb CtxFbCb;
struct _CtxFbCb
{
   Ctx          *ctx;

   int           key_balance;
   int           key_repeat;
   int lctrl;
   int lalt;
   int rctrl;


   int           width;
   int           height;


   uint8_t*      fb;

   char         *fb_path;
   int           fb_fd;

   int           fb_bits;
   int           fb_bpp;
   int           fb_mapped_size;

   int vt;
   int tty;


   int vt_active;

#if __linux__
   struct       fb_var_screeninfo vinfo;
   struct       fb_fix_screeninfo finfo;
#endif

#if 0
   char         *title;
   const char   *prev_title;
   int           clipboard_requested;
   char         *clipboard;
   char         *clipboard_pasted;
#endif

   CtxCursor shown_cursor;

#if CTX_KMS
   int     is_kms;
   CtxKMS  kms;
#endif
};

static CtxFbCb *ctx_fb = NULL;

static void fb_cb_set_pixels (Ctx *ctx, void *user_data, int x, int y, int w, int h, void *buf)
{
  CtxFbCb *fb = (CtxFbCb*)user_data;

  if (fb->vt_active == 0)
          return;

  int bpp = fb->fb_bpp;
  int ws = w * bpp;
  int stride = fb->width * bpp;

  uint8_t *src = (uint8_t*)buf;
  uint8_t *dst = fb->fb + stride * y + x * bpp;
  for (int scan = 0; scan < h; scan++)
  {
    memcpy (dst, src, ws);
    src += ws;
    dst += stride;
  }
  //Fb_Rect r = {x, y, w, h};
  //Fb_UpdateTexture (((CtxFbCb*)user_data)->texture, &r, buf, w * 4);
}

static void fb_cb_renderer_idle (Ctx *ctx, void *user_data)
{
//CtxFbCb *fb = (CtxFbCb*)user_data;
}

#if CTX_KMS
void *ctx_fbkms_new (CtxKMS *fb, int *width, int *height);
void ctx_fbkms_flip (CtxKMS *fb);
void ctx_fbkms_close (CtxKMS *fb);
#endif

static int fb_cb_frame_done (Ctx *ctx, void *user_data, int x, int y, int w, int h)
{
  CtxFbCb *fb = (CtxFbCb*)user_data;

#if CTX_KMS
  if (fb->is_kms)
  {
     ctx_fbkms_flip (&fb->kms);
  }
  else
#endif
  {
#ifdef __linux__
  // doing the following... and fps drops
  //__u32 dummy = 0;  
  //ioctl (fb->fb_fd, FBIO_WAITFORVSYNC, &dummy);  
    ioctl (fb->fb_fd, FBIOPAN_DISPLAY, &fb->vinfo);  
#endif
  }

  fb_cb_renderer_idle (ctx, user_data);

  return 0;
}

static void fb_cb_consume_events (Ctx *ctx, void *user_data)
{
  CtxFbCb *fb = (CtxFbCb*)user_data;
  CtxCbBackend *cb = (CtxCbBackend*)ctx_get_backend (ctx);
  for (int i = 0; i < cb->evsource_count; i++)
  {
    while (ctx_evsource_has_event (cb->evsource[i]))
    {
      char *event = ctx_evsource_get_event (cb->evsource[i]);
      if (event)
      {
        if (fb->vt_active)
        {
          ctx_key_press (ctx, 0, event, 0); // we deliver all events as key-press, the key_press handler   disambiguates
        }
        ctx_free (event);
      }
    }
  }
}

static void ctx_fb_cb_get_event_fds (Ctx *ctx, int *fd, int *count)
{
  int mice_fd = _ctx_mice_fd;
  fd[0] = STDIN_FILENO;
  if (mice_fd)
  {
    fd[1] = mice_fd;
    *count = 2;
  }
  else
  {
    *count = 1;
  }
}

static void fb_cb_renderer_stop (Ctx *ctx, void *user_data)
{
  CtxFbCb *fb = (CtxFbCb*)user_data;

#if CTX_FB_KDSETMODE
#ifdef __linux__
  ioctl (0, KDSETMODE, KD_TEXT);  
#endif
#endif
#if CTX_KMS
  if (fb->is_kms)
  {
     ctx_fbkms_close (&fb->kms);
  }
  else
#endif
  {

#ifdef __NetBSD__
    {  
     int mode = WSDISPLAYIO_MODE_EMUL;  
     ioctl (fb->fb_fd, WSDISPLAYIO_SMODE, &mode);  
    }  
#endif
    munmap (fb->fb, fb->fb_mapped_size);
    close (fb->fb_fd);  
    if (system("stty sane")){};
  }
}

#ifdef __linux__
static void fb_cb_vt_switch_cb (int sig)
{

  CtxFbCb  *fb = (CtxFbCb*)ctx_fb;
  CtxBackend *backend = (CtxBackend*)ctx_get_backend(fb->ctx);
  CtxCbBackend *cb = (CtxCbBackend*)backend;
  if (sig == SIGUSR1)
  {
    ioctl (0, VT_RELDISP, 1);
    fb->vt_active = 0;
#if CTX_FB_KDSETMODE
#ifdef __linux__
    ioctl (0, KDSETMODE, KD_TEXT);  
#endif
#endif
  }
  else
  {
    ioctl (0, VT_RELDISP, VT_ACKACQ);
    fb->vt_active = 1;
#if CTX_FB_KDSETMODE
#ifdef __linux__
    ioctl (0, KDSETMODE, KD_GRAPHICS);
#endif
#endif
    ctx_queue_draw (fb->ctx);
    for (int i =0; i<CTX_HASH_COLS * CTX_HASH_ROWS; i++)
      cb->hashes[i] = 0;
  }
}
#endif

static int fb_cb_renderer_init (Ctx *ctx, void *user_data)
{
  CtxFbCb *fb      = (CtxFbCb*)user_data;
  CtxCbBackend *cb = (CtxCbBackend*)ctx_get_backend (ctx);

  ctx_fb = (CtxFbCb*)fb;

#if CTX_KMS
  uint8_t *base = NULL;
  int kms_w = 0;
  int kms_h = 0;

  int try_kms = 0;
  if (getenv ("CTX_BACKEND") && !strcmp (getenv ("CTX_BACKEND"), "kms"))
    try_kms = 1;

  if (try_kms && (base = (uint8_t*)ctx_fbkms_new(&fb->kms, &kms_w, &kms_h)))
  {
     fb->fb = base;
     fb->width = kms_w;
     fb->height = kms_h;
     fb->is_kms = 1;
     fb->fb_bits = 32;
     fb->fb_bpp = 4;
     fb->fb_mapped_size = fb->width * 4 * fb->height;
  }
  else
#endif
  {  
#ifdef __linux__
    const char *dev_path = "/dev/fb0";  
#endif
#ifdef __NetBSD__
    const char *dev_path = "/dev/ttyE0";  
#endif
#ifdef __OpenBSD__
    const char *dev_path = "/dev/ttyC0";  
#endif
    fb->fb_fd = open (dev_path, O_RDWR);  
    if (fb->fb_fd > 0)  
      fb->fb_path = ctx_strdup (dev_path);  
    else  
    {  
#ifdef __linux__
      fb->fb_fd = open ("/dev/graphics/fb0", O_RDWR);  
      if (fb->fb_fd > 0)  
      {  
        fb->fb_path = ctx_strdup ("/dev/graphics/fb0");  
      }  
      else  
#endif
      {  
        ctx_free (fb);  
        return -1;  
      }  
    }

#ifdef __linux__
  if (ioctl(fb->fb_fd, FBIOGET_FSCREENINFO, &fb->finfo))
  {
    fprintf (stderr, "error getting fbinfo\n");
    close (fb->fb_fd);
    ctx_free (fb->fb_path);
    ctx_free (fb);
    return -1;
  }

  if (ioctl(fb->fb_fd, FBIOGET_VSCREENINFO, &fb->vinfo))
  {
     fprintf (stderr, "error getting fbinfo\n");
     close (fb->fb_fd);
     ctx_free (fb->fb_path);
     ctx_free (fb);
     return -1;
  }

  fb->width = fb->vinfo.xres;
  fb->height = fb->vinfo.yres;

  fb->fb_bits = fb->vinfo.bits_per_pixel;

  if (fb->fb_bits == 16)
    fb->fb_bits =
      fb->vinfo.red.length +
      fb->vinfo.green.length +
      fb->vinfo.blue.length;
   else if (fb->fb_bits == 8)
  {
    unsigned short red[256],  green[256],  blue[256];
  //  unsigned short original_red[256];
  //  unsigned short original_green[256];
  //  unsigned short original_blue[256];
    struct fb_cmap cmap = {0, 256, red, green, blue, NULL};
  //  struct fb_cmap original_cmap = {0, 256, original_red, original_green, original_blue, NULL};
    int i;

    /* do we really need to restore it ? */
   // if (ioctl (fb->fb_fd, FBIOPUTCMAP, &original_cmap) == -1)
   // {
   //   fprintf (stderr, "palette initialization problem %i\n", __LINE__);
   // }

    for (i = 0; i < 256; i++)
    {
      red[i]   = ((( i >> 5) & 0x7) << 5) << 8;
      green[i] = ((( i >> 2) & 0x7) << 5) << 8;
      blue[i]  = ((( i >> 0) & 0x3) << 6) << 8;
    }

        if (ioctl (fb->fb_fd, FBIOPUTCMAP, &cmap) == -1)
    {
      fprintf (stderr, "palette initialization problem %i\n", __LINE__);
    }
  }

  fb->fb_bpp = fb->vinfo.bits_per_pixel / 8;
  fb->fb_mapped_size = fb->finfo.smem_len;
#endif

#ifdef __NetBSD__
  struct wsdisplay_fbinfo finfo;

  int mode = WSDISPLAYIO_MODE_DUMBFB;
  //int mode = WSDISPLAYIO_MODE_MAPPED;
  if (ioctl (fb->fb_fd, WSDISPLAYIO_SMODE, &mode)) {
    return -1;
  }
  if (ioctl (fb->fb_fd, WSDISPLAYIO_GINFO, &finfo)) {
    fprintf (stderr, "ioctl: WSIDSPLAYIO_GINFO failed\n");
    return -1;
  }

  fb->width = finfo.width;
  fb->height = finfo.height;
  fb->fb_bits = finfo.depth;
  fb->fb_bpp = (fb->fb_bits + 1) / 8;
  fb->fb_mapped_size = fb->width * fb->height * fb->fb_bpp;


    if (fb->fb_bits == 8)
    {
      uint8_t red[256],  green[256],  blue[256];
      struct wsdisplay_cmap cmap;
      cmap.red = red;
      cmap.green = green;
      cmap.blue = blue;
      cmap.count = 256;
      cmap.index = 0;
      for (int i = 0; i < 256; i++)
      {
        red[i]   = ((( i >> 5) & 0x7) << 5);
        green[i] = ((( i >> 2) & 0x7) << 5);
        blue[i]  = ((( i >> 0) & 0x3) << 6);
      }
      ioctl (fb->fb_fd, WSDISPLAYIO_PUTCMAP, &cmap);
    }
#endif
    fb->fb = (uint8_t*)mmap (NULL, fb->fb_mapped_size, PROT_READ|PROT_WRITE, MAP_SHARED, fb->fb_fd, 0);
  }

  if (!fb->fb)
  {
    fprintf (stderr, "failed opening fb\n");
    return -1;
  }

  switch (fb->fb_bits)
  {
    case 32: cb->config.format = CTX_FORMAT_BGRA8; break;
    case 24: cb->config.format = CTX_FORMAT_RGB8; break;
    case 16: cb->config.format = CTX_FORMAT_RGB565; break;
    case 8: cb->config.format = CTX_FORMAT_RGB332; break;
  }

#if CTX_BABL
  ctx_get_contents ("file:///tmp/ctx.icc", &sdl_icc, &sdl_icc_length);  
#endif


  ctx_set_size (ctx, fb->width, fb->height);
#ifdef __linux__

#if CTX_KMS
  if (fb->is_kms == 0)
#endif
  {
    signal (SIGUSR1, fb_cb_vt_switch_cb);
    signal (SIGUSR2, fb_cb_vt_switch_cb);

    struct vt_stat st;
    if (ioctl (0, VT_GETSTATE, &st) == -1)
    {
      ctx_log ("VT_GET_MODE failed\n");
      return -1;
    }

    fb->vt = st.v_active;
    struct vt_mode mode;
    mode.mode   = VT_PROCESS;
    mode.relsig = SIGUSR1;
    mode.acqsig = SIGUSR2;
    if (ioctl (0, VT_SETMODE, &mode) < 0)
    {
      fprintf (stderr, "VT_SET_MODE on vt %i failed\n", fb->vt);
      return -1;
    }
  }
#if CTX_FB_KDSETMODE
#ifdef __linux__
    ioctl (0, KDSETMODE, KD_GRAPHICS);
#endif
#endif
#endif

  return 0;
}


Ctx *ctx_new_fb_cb (int width, int height, int flags)
{
  CtxFbCb *fb = (CtxFbCb*)ctx_calloc (1, sizeof (CtxFbCb));


  CtxCbConfig config = {
    .format         = CTX_FORMAT_RGBA8,
    .buffer_size    = 1920 * 1080 * 2,
    .flags          = flags
                    | CTX_FLAG_HASH_CACHE
                    | CTX_FLAG_RENDER_THREAD
                    | CTX_FLAG_POINTER
                   ,
    .user_data      = fb,
    .set_pixels     = fb_cb_set_pixels,
    .update_fb      = fb_cb_frame_done,
    .renderer_init  = fb_cb_renderer_init,
    .renderer_idle  = fb_cb_renderer_idle,
    .renderer_stop  = fb_cb_renderer_stop,
    .consume_events = fb_cb_consume_events,
  };

  Ctx *ctx = ctx_new_cb (width, height, &config);
  if (!ctx)
    return NULL;
  fb->ctx = ctx;

  CtxCbBackend *cb = (CtxCbBackend*)ctx_get_backend (ctx);
  EvSource *kb = NULL;

  CtxBackend *backend = (CtxBackend*)cb;
  backend->get_event_fds = ctx_fb_cb_get_event_fds;

#if CTX_RAW_KB_EVENTS
  if (!kb) kb = ctx_evsource_kb_raw_new ();
#endif
  if (!kb) kb = ctx_evsource_kb_term_new ();
  if (kb)
  {
    cb->evsource[cb->evsource_count++] = kb;
    kb->priv = fb->ctx;
  }
  EvSource *mice  = NULL;
  mice = ctx_evsource_linux_ts_new ();
#if CTX_PTY
  if (!mice)
    mice = ctx_evsource_mice_new ();
#endif
  if (mice)
  {
    cb->evsource[cb->evsource_count++] = mice;
    mice->priv = fb->ctx;
  }
  fb->vt_active = 1;

  _ctx_events_init (ctx);
  return fb->ctx;
}

#endif

#if CTX_SDL
#include <SDL.h>

/**/

typedef struct _CtxSDLCb CtxSDLCb;
struct _CtxSDLCb
{
   int           key_balance;
   int           key_repeat;
   int           lctrl;
   int           lalt;
   int           rctrl;
   int           lshift;
   int           rshift;

   SDL_Window   *window;
   SDL_Renderer *backend;
   SDL_Texture  *texture;

   int           fullscreen;
   int           prev_fullscreen;

   Ctx          *ctx;

   int           width;
   int           height;

   uint8_t *fb;

   char         *title;
   const char   *prev_title;


   int   clipboard_requested;
   char *clipboard;

   char *clipboard_pasted;

   CtxCursor shown_cursor;
};

static const char *ctx_sdl_keysym_to_name (unsigned int sym, int *r_keycode)
{
  static char buf[16]="";
  buf[ctx_unichar_to_utf8 (sym, (uint8_t*)buf)]=0;
  int scan_code = sym;
  const char *name = &buf[0];
   switch (sym)
   {
     case SDLK_RSHIFT: name="shift";scan_code = 16 ; break;
     case SDLK_LSHIFT: name="shift";scan_code = 16 ; break;
     case SDLK_LCTRL: name="control";scan_code = 17 ; break;
     case SDLK_RCTRL: name="control";scan_code = 17 ; break;
     case SDLK_LALT:  name="alt";scan_code = 18 ; break;
     case SDLK_RALT:  name="alt";scan_code = 18 ; break;
     case SDLK_CAPSLOCK: name = "capslock"; scan_code = 20 ; break;
     //case SDLK_NUMLOCK: name = "numlock"; scan_code = 144 ; break;
     //case SDLK_SCROLLLOCK: name = "scrollock"; scan_code = 145 ; break;

     case SDLK_F1:     name = "F1"; scan_code = 112; break;
     case SDLK_F2:     name = "F2"; scan_code = 113; break;
     case SDLK_F3:     name = "F3"; scan_code = 114; break;
     case SDLK_F4:     name = "F4"; scan_code = 115; break;
     case SDLK_F5:     name = "F5"; scan_code = 116; break;
     case SDLK_F6:     name = "F6"; scan_code = 117; break;
     case SDLK_F7:     name = "F7"; scan_code = 118; break;
     case SDLK_F8:     name = "F8"; scan_code = 119; break;
     case SDLK_F9:     name = "F9"; scan_code = 120; break;
     case SDLK_F10:    name = "F10"; scan_code = 121; break;
     case SDLK_F11:    name = "F11"; scan_code = 122; break;
     case SDLK_F12:    name = "F12"; scan_code = 123; break;
     case SDLK_ESCAPE: name = "escape"; break;
     case SDLK_DOWN:   name = "down"; scan_code = 40; break;
     case SDLK_LEFT:   name = "left"; scan_code = 37; break;
     case SDLK_UP:     name = "up"; scan_code = 38;  break;
     case SDLK_RIGHT:  name = "right"; scan_code = 39; break;
     case SDLK_BACKSPACE: name = "backspace"; break;
     case SDLK_SPACE:  name = "space"; break;
     case SDLK_TAB:    name = "tab"; break;
     case SDLK_DELETE: name = "delete"; scan_code = 46; break;
     case SDLK_INSERT: name = "insert"; scan_code = 45; break;
     case SDLK_RETURN:
       //if (key_repeat == 0) // return never should repeat
       name = "return";   // on a DEC like terminal
       break;
     case SDLK_HOME:     name = "home"; scan_code = 36; break;
     case SDLK_END:      name = "end"; scan_code = 35; break;
     case SDLK_PAGEDOWN: name = "page-down"; scan_code = 34; break;
     case SDLK_PAGEUP:   name = "page-up"; scan_code = 33; break;
     case ',': scan_code = 188; break;
     case '.': scan_code = 190; break;
     case '/': scan_code = 191; break;
     case '`': scan_code = 192; break;
     case '[': scan_code = 219; break;
     case '\\': scan_code = 220; break;
     case ']':  scan_code = 221; break;
     case '\'': scan_code = 222; break;
     default:
       ;
   }
   if (sym >= 'a' && sym <='z') scan_code -= 32;
   if (r_keycode)
   {
     *r_keycode = scan_code;
   }
   return name;
}

static void sdl_cb_consume_events (Ctx *ctx, void *user_data)
{
  static float x = 0.0f;
  static float y = 0.0f;
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  SDL_Event event;

  while (SDL_PollEvent (&event))
  {
    switch (event.type)
    {
      case SDL_MOUSEBUTTONDOWN:
        SDL_CaptureMouse (SDL_TRUE);
        ctx_pointer_press (ctx, event.button.x, event.button.y, event.button.button, 0);
        break;
      case SDL_MOUSEBUTTONUP:
        SDL_CaptureMouse (SDL_FALSE);
        ctx_pointer_release (ctx, event.button.x, event.button.y, event.button.button, 0);
        break;
#if 0
      case SDL_MOUSEWHEEL:
        if (event.wheel.y < 0)
          ctx_scrolled (ctx, event.wheel.mouseX, event.wheel.mouseY, CTX_SCROLL_DIRECTION_UP, 0);
        else if (event.wheel.y > 0)
          ctx_scrolled (ctx, event.wheel.mouseX, event.wheel.mouseY, CTX_SCROLL_DIRECTION_DOWN, 0);
        break;
#endif
      case SDL_MOUSEMOTION:
        //  XXX : look at mask and generate motion for each pressed
        //        button
        ctx_pointer_motion (ctx, event.motion.x, event.motion.y, 1, 0);
        x = event.motion.x;
        y = event.motion.y;
        break;
      case SDL_FINGERMOTION:
        ctx_pointer_motion (ctx, event.tfinger.x * sdl->width, event.tfinger.y * sdl->height,
            (event.tfinger.fingerId%10) + 4, 0);
        break;
      case SDL_FINGERDOWN:
        {
        static int fdowns = 0;
        fdowns ++;
        if (fdowns > 1) // the very first finger down from SDL seems to be
                        // mirrored as mouse events, later ones not - at
                        // least under wayland
        {
          ctx_pointer_press (ctx, event.tfinger.x * sdl->width, event.tfinger.y * sdl->height, 
          (event.tfinger.fingerId%10) + 4, 0);
        }
        }
        break;
      case SDL_FINGERUP:
        ctx_pointer_release (ctx, event.tfinger.x * sdl->width, event.tfinger.y * sdl->height,
          (event.tfinger.fingerId%10) + 4, 0);
        break;
#if 1
      case SDL_TEXTINPUT:
    //  if (!active)
    //    break;
        if (//!sdl->lctrl && !sdl->rctrl && !sdl->lalt 
           //&& ( (vt && vt_keyrepeat (vt) ) || (key_repeat==0) )

              !(ctx->events.modifier_state &
                                           (CTX_MODIFIER_STATE_CONTROL|
                                            CTX_MODIFIER_STATE_ALT))

           )
          {
            const char *name = event.text.text;
            int keycode = 0;
            if (!strcmp (name, " ") ) { name = "space"; }
            if (name[0] && name[1] == 0)
            {
              keycode = name[0];
              keycode = toupper (keycode);
              switch (keycode)
              {
                case '.':  keycode = 190; break;
                case ';':  keycode = 59; break;
                case ',':  keycode = 188; break;
                case '/':  keycode = 191; break;
                case '\'': keycode = 222; break;
                case '`':  keycode = 192; break;
                case '[':  keycode = 219; break;
                case ']':  keycode = 221; break;
                case '\\': keycode = 220; break;
              }
            }
            ctx_key_press (ctx, keycode, name, 0);
          }
        break;
#endif
      case SDL_KEYDOWN:
        {
          char buf[32] = "";
          const char *name = buf;
          if (!event.key.repeat)
          {
            sdl->key_balance ++;
            sdl->key_repeat = 0;
          }
          else
          {
            sdl->key_repeat ++;
          }
          int keycode;
          name = ctx_sdl_keysym_to_name (event.key.keysym.sym, &keycode);

          ctx_key_down (ctx, keycode, name, 0);

          if (ctx_utf8_strlen (name) > 1 ||
              (ctx->events.modifier_state &
                                           (CTX_MODIFIER_STATE_CONTROL|
                                            CTX_MODIFIER_STATE_ALT))
              )
          if (strcmp(name, "space"))
            ctx_key_press (ctx, keycode, name, 0);
        }
        break;
      case SDL_KEYUP:
        {
           sdl->key_balance --;
           int keycode;
           const char *name = ctx_sdl_keysym_to_name (event.key.keysym.sym, &keycode);
           ctx_key_up (ctx, keycode, name, 0);
        }
        break;
      case SDL_QUIT:
        ctx_exit (ctx);
        break;
      case SDL_DROPFILE:
        ctx_pointer_drop (ctx, x, y, 0, 0, event.drop.file);
        break;
      case SDL_DROPTEXT:
        if (!strncmp ("file://", event.drop.file, 7))
          ctx_pointer_drop (ctx, x, y, 0, 0, event.drop.file + 7);
        break;
      case SDL_WINDOWEVENT:
        if (event.window.event == SDL_WINDOWEVENT_RESIZED)
        {
          int width = event.window.data1;
          int height = event.window.data2;
          sdl->width  = width;
          sdl->height = height;
        }
        ctx_queue_draw (ctx);
        break;
    }
  }
}

static void sdl_cb_set_pixels (Ctx *ctx, void *user_data, int x, int y, int w, int h, void *buf)
{
  SDL_Rect r = {x, y, w, h};
  SDL_UpdateTexture (((CtxSDLCb*)user_data)->texture, &r, buf, w * 4);
}

static void sdl_cb_renderer_idle (Ctx *ctx, void *user_data)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;

  if (sdl->clipboard_requested)
  {
    char *tmp = SDL_GetClipboardText ();
    sdl->clipboard = ctx_strdup (tmp);
    SDL_free (tmp);
    sdl->clipboard_requested = 0;
  }
  if (sdl->clipboard_pasted)
  {
    SDL_SetClipboardText (sdl->clipboard_pasted);
    ctx_free (sdl->clipboard_pasted);
    sdl->clipboard_pasted = NULL;
  }

  if (ctx_width(ctx) != sdl->width ||
      ctx_height(ctx) != sdl->height)
  {
    CtxCbBackend *cb = (CtxCbBackend*)ctx_get_backend (ctx);
    SDL_DestroyTexture (sdl->texture);
    sdl->texture = SDL_CreateTexture (sdl->backend, SDL_PIXELFORMAT_ABGR8888,
                          SDL_TEXTUREACCESS_STREAMING, sdl->width, sdl->height);
    ctx_set_size (ctx, sdl->width, sdl->height);
    ctx_reset_caches (ctx);
    if (sdl->fb)
    {
      ctx_free (sdl->fb);
      sdl->fb = (uint8_t*)ctx_calloc (4, sdl->width * sdl->height);
      cb->config.fb = sdl->fb;
      cb->config.buffer_size = sdl->width * sdl->height * 2;
    }
  }

  if (sdl->fullscreen != sdl->prev_fullscreen)
  {
    if (sdl->fullscreen)
    {
      SDL_SetWindowFullscreen (sdl->window, SDL_WINDOW_FULLSCREEN_DESKTOP);
    }
    else
    {
      SDL_SetWindowFullscreen (sdl->window, 0);
    }
    sdl->prev_fullscreen = sdl->fullscreen;
  }

  if (sdl->prev_title != sdl->title)
  {
    SDL_SetWindowTitle (sdl->window, sdl->title);
    sdl->prev_title = sdl->title;
  }
}

static int sdl_cb_frame_done (Ctx *ctx, void *user_data, int x, int y, int width, int height)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  CtxCbBackend *cb = (CtxCbBackend*)ctx_get_backend (ctx);

  if (cb->config.fb)
  {
    SDL_Rect r = {x, y, width, height};
    SDL_UpdateTexture (sdl->texture, &r, ((uint8_t*)sdl->fb) + ((x+y * ctx->width))*4, ctx->width * 4);
  }

  SDL_RenderClear (sdl->backend);
  SDL_RenderCopy (sdl->backend, sdl->texture, NULL, NULL);
  SDL_RenderPresent (sdl->backend);

  sdl_cb_renderer_idle (ctx, user_data);

  if (sdl->shown_cursor != ctx->cursor)
  {
    sdl->shown_cursor = ctx->cursor;

    SDL_Cursor *new_cursor =  NULL;
    switch (sdl->shown_cursor)
    {
      case CTX_CURSOR_UNSET: // XXX: document how this differs from none
                             //      perhaps falling back to arrow?
        break;
      case CTX_CURSOR_NONE:
        new_cursor = NULL;
        break;
      case CTX_CURSOR_ARROW:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        break;
      case CTX_CURSOR_CROSSHAIR:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
        break;
      case CTX_CURSOR_WAIT:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAIT);
        break;
      case CTX_CURSOR_HAND:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        break;
      case CTX_CURSOR_IBEAM:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_IBEAM);
        break;
      case CTX_CURSOR_MOVE:
      case CTX_CURSOR_RESIZE_ALL:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
        break;
      case CTX_CURSOR_RESIZE_N:
      case CTX_CURSOR_RESIZE_S:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENS);
        break;
      case CTX_CURSOR_RESIZE_E:
      case CTX_CURSOR_RESIZE_W:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEWE);
        break;
      case CTX_CURSOR_RESIZE_NE:
      case CTX_CURSOR_RESIZE_SW:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENESW);
        break;
      case CTX_CURSOR_RESIZE_NW:
      case CTX_CURSOR_RESIZE_SE:
        new_cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE);
        break;
    }
    if (new_cursor)
    {
      SDL_Cursor *old_cursor = SDL_GetCursor();
      SDL_SetCursor (new_cursor);
      SDL_ShowCursor (1);
      if (old_cursor)
        SDL_FreeCursor (old_cursor);
    }
    else
    {
      SDL_ShowCursor (0);
    }
  }

  return 0;
}

static int sdl_cb_renderer_init (Ctx *ctx, void *user_data)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;

  sdl->window = SDL_CreateWindow("ctx", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
                                 sdl->width, sdl->height, SDL_WINDOW_SHOWN |SDL_WINDOW_RESIZABLE);
  //sdl->backend = SDL_CreateRenderer (sdl->window, -1, SDL_RENDERER_SOFTWARE);
  sdl->backend = SDL_CreateRenderer (sdl->window, -1, 0);
  if (!sdl->backend)
  {
     ctx_free (sdl);
     return -1;
  }
  sdl->fullscreen = 0;

  sdl->texture = SDL_CreateTexture (sdl->backend,
        SDL_PIXELFORMAT_ABGR8888,
        SDL_TEXTUREACCESS_STREAMING,
        sdl->width, sdl->height);
  if (!sdl->texture)
  {
     ctx_free (sdl);
     return -1;
  }

  SDL_StartTextInput ();
  SDL_EnableScreenSaver ();
  SDL_GL_SetSwapInterval (1);

  return 0;
}

int ctx_sdl_has_focus (Ctx *ctx)
{
  CtxSDLCb *sdl = (CtxSDLCb*)((CtxCbBackend*)(ctx_get_backend(ctx)))->config.user_data;
  return (SDL_GetWindowFlags (sdl->window) & SDL_WINDOW_INPUT_FOCUS) !=0;
}

static void sdl_cb_renderer_stop (Ctx *ctx, void *user_data)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  if (sdl->texture)
    SDL_DestroyTexture (sdl->texture);
  if (sdl->backend)
    SDL_DestroyRenderer (sdl->backend);
  if (sdl->window)
    SDL_DestroyWindow (sdl->window);
  sdl->texture = NULL;
  sdl->backend = NULL;
  sdl->window  = NULL;
  if (sdl->title)
    ctx_free (sdl->title);
  sdl->title = NULL;
  ctx_free (sdl);
}

static void sdl_cb_set_fullscreen (Ctx *ctx, void *user_data, int fullscreen)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  sdl->fullscreen = fullscreen;
}

static int sdl_cb_get_fullscreen (Ctx *ctx, void *user_data)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  return sdl->fullscreen;
}

static char *sdl_cb_get_clipboard (Ctx *ctx, void *user_data)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
#if 0
  if (sdl->clipboard)
     ctx_free (sdl->clipboard);
  sdl->clipboard = NULL;
#endif
  sdl->clipboard_requested = 1;
  while (sdl->clipboard_requested)
          usleep (1000);
  return sdl->clipboard?(char*)sdl->clipboard:(char*)"";
}

static void sdl_cb_set_clipboard (Ctx *ctx, void *user_data, const char *utf8)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  if (sdl->clipboard_pasted)
    {
       fprintf (stderr, "still contents in clipboard - leaking\n");
    }
  sdl->clipboard_pasted = ctx_strdup (utf8);
}

void sdl_cb_windowtitle (Ctx *ctx, void *user_data, const char *utf8)
{
  CtxSDLCb *sdl = (CtxSDLCb*)user_data;
  if (!sdl->title || strcmp(sdl->title, utf8))
  {
    if (sdl->title)
       ctx_free (sdl->title);
    sdl->title = ctx_strdup (utf8);
  }
}

Ctx *ctx_new_sdl_cb (int width, int height, int flags)
{
  CtxSDLCb *sdl = (CtxSDLCb*)ctx_calloc (1, sizeof (CtxSDLCb));
  if (width <= 0 || height <= 0)
  {
    width  = 640;
    height = 480;
  }

  sdl->width = width;
  sdl->height = height;

  CtxCbConfig config = {
    .format         = CTX_FORMAT_RGBA8,
    .flags          = flags
                    | CTX_FLAG_HASH_CACHE 
                  //| CTX_FLAG_LOWFI
                    //| CTX_FLAG_SUBPIXEL
                    | CTX_FLAG_RENDER_THREAD
                 // | CTX_FLAG_DAMAGE_CONTROL
                 // | CTX_FLAG_POINTER
                   ,
    .user_data      = sdl,
    .set_pixels     = sdl_cb_set_pixels,
    .update_fb      = sdl_cb_frame_done,
    .renderer_init  = sdl_cb_renderer_init,
    .renderer_idle  = sdl_cb_renderer_idle,
    .renderer_stop  = sdl_cb_renderer_stop,
    .consume_events = sdl_cb_consume_events,
    .set_fullscreen = sdl_cb_set_fullscreen,
    .get_fullscreen = sdl_cb_get_fullscreen,
    .windowtitle    = sdl_cb_windowtitle,
    .set_clipboard  = sdl_cb_set_clipboard,
    .get_clipboard  = sdl_cb_get_clipboard,
  };

  Ctx *ctx = ctx_new_cb (width, height, &config);
  if (!ctx)
    return NULL;
  sdl->ctx = ctx;
  _ctx_events_init (ctx);
  return sdl->ctx;
}

Ctx *ctx_new_sdl_cb_fb (int width, int height, int flags)
{
  CtxSDLCb *sdl = (CtxSDLCb*)ctx_calloc (1, sizeof (CtxSDLCb));
  if (width <= 0 || height <= 0)
  {
    width  = 1024;
    height = 768;
  }

  sdl->width = width;
  sdl->height = height;

  sdl->fb = (uint8_t*)ctx_calloc (4, width * height);
  CtxCbConfig config = {
    .format         = CTX_FORMAT_RGBA8,
    .flags          = flags
                    | CTX_FLAG_RENDER_THREAD
                    | CTX_FLAG_HASH_CACHE 
                  //| CTX_FLAG_LOWFI
                    //| CTX_FLAG_SUBPIXEL
                 // | CTX_FLAG_DAMAGE_CONTROL
                 // | CTX_FLAG_POINTER
                    ,
    .fb             = sdl->fb,
    .user_data      = sdl,
    .update_fb      = sdl_cb_frame_done,
    .renderer_init  = sdl_cb_renderer_init,
    .renderer_idle  = sdl_cb_renderer_idle,
    .renderer_stop  = sdl_cb_renderer_stop,
    .consume_events = sdl_cb_consume_events,
    .set_fullscreen = sdl_cb_set_fullscreen,
    .get_fullscreen = sdl_cb_get_fullscreen,
    .windowtitle    = sdl_cb_windowtitle,
    .set_clipboard  = sdl_cb_set_clipboard,
    .get_clipboard  = sdl_cb_get_clipboard,
  };

  Ctx *ctx = ctx_new_cb (width, height, &config);
  if (!ctx)
    return NULL;
  sdl->ctx = ctx;
  _ctx_events_init (ctx);
  return sdl->ctx;
}

Ctx *ctx_new_sdl_cb_fb_full (int width, int height, int flags)
{
  CtxSDLCb *sdl = (CtxSDLCb*)ctx_calloc (1, sizeof (CtxSDLCb));
  if (width <= 0 || height <= 0)
  {
    width  = 1024;
    height = 600;
  }

  sdl->width = width;
  sdl->height = height;

  sdl->fb = (uint8_t*)ctx_calloc (4, width * height);
  CtxCbConfig config = {
    .format         = CTX_FORMAT_RGBA8,
    .flags          = flags
                    | CTX_FLAG_FULL_FB
                    | CTX_FLAG_RENDER_THREAD
                 // | CTX_FLAG_LOWFI
                 // | CTX_FLAG_DAMAGE_CONTROL
                 // | CTX_FLAG_POINTER
                    ,
    .fb = sdl->fb,
    .user_data      = sdl,
    .update_fb      = sdl_cb_frame_done,
    .renderer_init  = sdl_cb_renderer_init,
    .renderer_idle  = sdl_cb_renderer_idle,
    .renderer_stop  = sdl_cb_renderer_stop,
    .consume_events = sdl_cb_consume_events,
    .set_fullscreen = sdl_cb_set_fullscreen,
    .get_fullscreen = sdl_cb_get_fullscreen,
    .windowtitle    = sdl_cb_windowtitle,
    .set_clipboard  = sdl_cb_set_clipboard,
    .get_clipboard  = sdl_cb_get_clipboard,
  };

  Ctx *ctx = ctx_new_cb (width, height, &config);
  if (!ctx)
    return NULL;
  sdl->ctx = ctx;
  _ctx_events_init (ctx);
  return sdl->ctx;
}


#endif

#ifdef EMSCRIPTEN
#include "emscripten.h"

#include <unistd.h>

int width = 512;
int height = 384;

static uint8_t *fb = NULL;
static Ctx *em_ctx = NULL;

CTX_EXPORT unsigned char *
get_fb(int w, int h) {
  if (fb)
  {
    if (width == w && height == h) return fb;
    free (fb); // this is not using the ctx allocator
               // and will thus not be part of the micropython heap budget
    fb = NULL;
  }
  width  = w;
  height = h;
  fb = calloc (w * h, 4);
  if (em_ctx) ctx_destroy (em_ctx);
  em_ctx = NULL;
  return fb;
}

EMSCRIPTEN_KEEPALIVE
float pointer_x = 0;
EMSCRIPTEN_KEEPALIVE
float pointer_y = 0;
EMSCRIPTEN_KEEPALIVE
int32_t pointer_down = 0;
int32_t pointer_was_down = 0;


static uint32_t key_queue[32];
static int key_queue_head = 0; // read head
static int key_queued = 0;

EMSCRIPTEN_KEEPALIVE
void ctx_wasm_queue_key_event (int type, int keycode)
{
  if (key_queued >= 31) return;
  int pos = (key_queue_head + key_queued) % 32;
  key_queue[pos * 2 + 0] = type;
  key_queue[pos * 2 + 1] = keycode;
  key_queued ++;
}

int ctx_wasm_get_key_event (int *type, int *keycode)
{
  if (!key_queued)
    return -1;

  *type = key_queue[key_queue_head * 2 + 0];
  *keycode = key_queue[key_queue_head * 2 + 1];

  key_queued--;
  key_queue_head++;
  key_queue_head = key_queue_head % 16;

  return 0;
}

int update_fb (Ctx *ctx, void *user_data)
{
  EM_ASM(
    var canvas = document.getElementById('c');
    var context = canvas.getContext('2d');

     if (!canvas.regevents)
     {
       canvas.onpointerdown = function (e){
          var loc = windowToCanvas (canvas, e.clientX, e.clientY);
          setValue(_pointer_x, loc.x, "float");
          setValue(_pointer_y, loc.y, "float");
          setValue(_pointer_down, 1, "i32");
          e.stopPropagate=1;
                       };
       canvas.onpointerup = function (e){
          var loc = windowToCanvas (canvas, e.clientX, e.clientY);
          setValue(_pointer_x, loc.x, "float");
          setValue(_pointer_y, loc.y, "float");
          setValue(_pointer_down, 0, "i32");
          e.stopPropagate=1;
                       };
       canvas.onpointermove = function (e){
          var loc = windowToCanvas (canvas, e.clientX, e.clientY);
          setValue(_pointer_x, loc.x, "float");
          setValue(_pointer_y, loc.y, "float");
          e.stopPropagate=1;
                       };
       canvas.onkeydown = function (e){
          _ctx_wasm_queue_key_event (1, e.keyCode);
                       e.preventDefault();
                       e.stopPropagate = 1;
                       };

       canvas.onkeyup = function (e){
          _ctx_wasm_queue_key_event (2, e.keyCode);
                       e.preventDefault();
                       e.stopPropagate = 1;
                       };
       canvas.regevents = true;
     }
  );

#ifndef __EMSCRIPTEN_PTHREADS__
   emscripten_sleep(1);
#endif

   int ret = 0;

   if (key_queued)
     while (key_queued)
   {
     int type = 0 , keycode = 0;

     ctx_wasm_get_key_event (&type, &keycode);
     switch (type)
     {
       case 1:
         ctx_key_down(ctx,keycode,NULL,0);
         ctx_key_press(ctx,keycode,NULL,0);
         ret = 1;
         break;
       case 2:
         ctx_key_up(ctx,keycode,NULL,0);
         ret = 1;
         break;
     }
   }

   if (pointer_down && !pointer_was_down)
   {
      ctx_pointer_press (ctx, pointer_x, pointer_y, 0, 0);
      ret = 1;
   } else if (!pointer_down && pointer_was_down)
   {
      ctx_pointer_release (ctx, pointer_x, pointer_y, 0, 0);
      ret = 1;
   } else if (pointer_down)
   {
      ctx_pointer_motion (ctx, pointer_x, pointer_y, 0, 0);
      ret = 1;
   }

   pointer_was_down = pointer_down;

   return ret;
}

EMSCRIPTEN_KEEPALIVE
uint8_t wasm_scratch[1024*1024*4];

CTX_EXPORT
void wctx_set_pixels (Ctx *ctx, void *user_data, int x0, int y0, int w, int h, void *buf)
{
  uint8_t *src = (uint8_t*)buf;
  int in_w = w;
  if (x0 < 0) x0 = 0;
  if (y0 < 0) y0 = 0;
  if (x0 + w > ctx_width (ctx))
  {
     fprintf (stderr, "adjusting xbounds from %i %i\n", x0, w);
     w = ctx_width (ctx) - x0;
  }
  if (y0 + h > ctx_height (ctx))
  {
     h = ctx_height (ctx) - y0;
     fprintf (stderr, "adjusting ybounds\n");
  }
  for (int i = 0; i < h; i++)
  {
    ctx_RGB565_BS_to_RGBA8 (NULL, x0, src + i * in_w * 2,
                    wasm_scratch + i * w * 4, w);
  }
  if (w <= 0 || h <= 0)
    return;

  EM_ASM(
    var x0 = $0;
    var y0 = $1;
    var w = $2;
    var h = $3;
    var canvas = document.getElementById('c');
    var context = canvas.getContext('2d');
    var _ctx = _ctx_host();
    const offset = _get_fb(canvas.width, canvas.height);
    const imgData = context.createImageData(w,h);

    const linearMem = new Uint8Array(wasmMemory.buffer, _wasm_scratch,
                                     w*h*4);

    for (let i = 0; i < w * h;i++)
    {
      //var a = linearMem[i*4+3];
      //var r = 1.0;
      //if (a!=0) r = 255.0/a;
      imgData.data[i*4+0] = linearMem[i*4+0];// * r;
      imgData.data[i*4+1] = linearMem[i*4+1];// * r;
      imgData.data[i*4+2] = linearMem[i*4+2];// * r;
      imgData.data[i*4+3] = 255;
    }
    context.putImageData(imgData,x0,y0);
  , x0,y0, w, h);

}

void ctx_wasm_reset (void)
{
  if (fb) free (fb); fb = NULL;
  em_ctx = NULL;
}

CTX_EXPORT
Ctx *ctx_host (void)
{
  int memory_budget = 64 * 1024;
  if (em_ctx) return em_ctx;

EM_ASM(
    {var canvas = document.getElementById('c');
     const offset = _get_fb(canvas.width, canvas.height);

     //var dc = document.getElementById('damagecontrol');
     //if (dc)
     //{
     //  _wasm_set_damage_control(dc.checked?1:0);
     //}
   }
);

   if (em_ctx && memory_budget)
   {
      CtxCbBackend *cb_backend = (CtxCbBackend*)em_ctx->backend;
      if (memory_budget != cb_backend->memory_budget)
      {
         ctx_cb_set_memory_budget (em_ctx, memory_budget);
         ctx_cb_set_flags (em_ctx, 0);
      }
   }



   if (!em_ctx){
      em_ctx = ctx_new_cb_old (width, height, CTX_FORMAT_RGB565_BYTESWAPPED,
                           wctx_set_pixels, 
                           NULL,
                           update_fb,
                           NULL,
                           memory_budget, NULL, 
                           0);
   }

#if 0
   if (wasm_damage_control)
   {
     int flags = ctx_cb_get_flags (em_ctx);
     flags |= CTX_FLAG_DAMAGE_CONTROL;
     ctx_cb_set_flags (em_ctx, flags);
   }
   else
   {
     int flags = ctx_cb_get_flags (em_ctx);
     flags &= ~CTX_FLAG_DAMAGE_CONTROL;
     ctx_cb_set_flags (em_ctx, flags);
   }
#endif
   return em_ctx;
}

int ctx_host_audio_init (int hz, CtxPCM format)
{
  // NYI, but added to make things link
  return 0;
}

#endif
#if CTX_TERM
#if CTX_TERMINAL_EVENTS

#if !__COSMOPOLITAN__
#include <fcntl.h>
#include <sys/ioctl.h>
#endif

typedef struct CtxTermCell
{
  char    utf8[5];
  uint8_t fg[4];
  uint8_t bg[4];

  char    prev_utf8[5];
  uint8_t prev_fg[4];
  uint8_t prev_bg[4];
} CtxTermCell;

typedef struct CtxTermLine
{
  CtxTermCell *cells;
  int maxcol;
  int size;
} CtxTermLine;

typedef enum
{
  CTX_TERM_ASCII,
  CTX_TERM_ASCII_MONO,
  CTX_TERM_SEXTANT,
  CTX_TERM_BRAILLE_MONO,
  CTX_TERM_BRAILLE,
  CTX_TERM_QUARTER,
} CtxTermMode;

struct _CtxTerm
{
   CtxBackend  backender;
   int         width;
   int         height;
   int         cols;
   int         rows;
   int         was_down;

   uint8_t    *pixels;

   Ctx        *host;
   CtxList    *lines;
   CtxTermMode mode;
};

static int ctx_term_ch = 8;
static int ctx_term_cw = 8;

void ctx_term_set (CtxTerm *term,
                      int col, int row, const char *utf8,
                      uint8_t *fg, uint8_t *bg)
{
  if (col < 1 || row < 1 || col > term->cols  || row > term->rows) return;
  while (ctx_list_length (term->lines) < row)
  {
    ctx_list_append (&term->lines, ctx_calloc (1, sizeof (CtxTermLine)));
  }
  CtxTermLine *line = (CtxTermLine*)ctx_list_nth_data (term->lines, row-1);
  assert (line);
  if (line->size < col)
  {
     int new_size = ((col + 128)/128)*128;
     line->cells = (CtxTermCell*)ctx_realloc (line->cells, line->size, sizeof (CtxTermCell) * new_size);
     memset (&line->cells[line->size], 0, sizeof (CtxTermCell) * (new_size - line->size) );
     line->size = new_size;
  }
  if (col > line->maxcol) line->maxcol = col;
  strncpy (line->cells[col-1].utf8, (char*)utf8, 4);
  memcpy  (line->cells[col-1].fg, fg, 4);
  memcpy  (line->cells[col-1].bg, bg, 4);
}

static int _ctx_term256 = 0; // XXX TODO implement autodetect for this
static long _ctx_curfg = -1;
static long _ctx_curbg = -1;

static long ctx_rgb_to_long (int r,int g, int b)
{
  return r * 256 * 256 + g * 256 + b;
}


static void ctx_term_set_fg (int red, int green, int blue)
{
  long lc = ctx_rgb_to_long (red, green, blue);
  if (lc == _ctx_curfg)
    return;
  _ctx_curfg=lc;
  if (_ctx_term256 == 0)
  {
    fprintf(stderr, "\033[38;2;%i;%i;%im", red,green,blue);
  }
  else
  {
    int gray = (int)((green /255.0f) * 24 + 0.5f);
    int r    = (int)((red/255.0f)    * 6 + 0.5f);
    int g    = (int)((green/255.0f)  * 6 + 0.5f);
    int b    = (int)((blue/255.0f)   * 6 + 0.5f);
    if (gray > 23) gray = 23;

    if (r > 5) r = 5;
    if (g > 5) g = 5;
    if (b > 5) b = 5;

    if (((int)(r/1.66)== (int)(g/1.66)) && ((int)(g/1.66) == ((int)(b/1.66))))
    {
      fprintf(stderr,"\033[38;5;%im", 16 + 216 + gray);
    }
    else
      fprintf(stderr,"\033[38;5;%im", 16 + r * 6 * 6 + g * 6  + b);
  }
}

static void ctx_term_set_bg(int red, int green, int blue)
{
  long lc = ctx_rgb_to_long (red, green, blue);
//if (lc == _ctx_curbg)
//  return;
  _ctx_curbg=lc;
  if (_ctx_term256 == 0)
  {
    fprintf(stderr,"\033[48;2;%i;%i;%im", red,green,blue);
  }
  else
  {
    int gray = (int)((green /255.0f) * 24 + 0.5f);
    int r    = (int)((red/255.0f)    * 6 + 0.5f);
    int g    = (int)((green/255.0f)  * 6 + 0.5f);
    int b    = (int)((blue/255.0f)   * 6 + 0.5f);
    if (gray > 23) gray = 23;

    if (r > 5) r = 5;
    if (g > 5) g = 5;
    if (b > 5) b = 5;

    if (((int)(r/1.66)== (int)(g/1.66)) && ((int)(g/1.66) == ((int)(b/1.66))))
    {
      fprintf(stderr,"\033[48;5;%im", 16 + 216 + gray);
    }
    else
      fprintf(stderr,"\033[48;5;%im", 16 + r * 6 * 6 + g * 6  + b);
  }
}

static int _ctx_term_force_full = 0;

void ctx_term_scanout (CtxTerm *term)
{
  int row = 1;
  fprintf (stderr,"\033[H");
//  printf ("\033[?25l");
  fprintf (stderr, "\033[0m");

  int cur_fg[3]={-1,-1,-1};
  int cur_bg[3]={-1,-1,-1};

  for (CtxList *l = term->lines; l; l = l->next)
  {
    CtxTermLine *line = (CtxTermLine*)l->data;
    for (int col = 1; col <= line->maxcol; col++)
    {
      CtxTermCell *cell = &line->cells[col-1];

      if (strcmp(cell->utf8, cell->prev_utf8) ||
          memcmp(cell->fg, cell->prev_fg, 3) ||
          memcmp(cell->bg, cell->prev_bg, 3) || _ctx_term_force_full)
      {
        if (cell->fg[0] != cur_fg[0] ||
            cell->fg[1] != cur_fg[1] ||
            cell->fg[2] != cur_fg[2])
        {
          ctx_term_set_fg (cell->fg[0], cell->fg[1], cell->fg[2]);
          cur_fg[0]=cell->fg[0];
          cur_fg[1]=cell->fg[1];
          cur_fg[2]=cell->fg[2];
        }
        if (cell->bg[0] != cur_bg[0] ||
            cell->bg[1] != cur_bg[1] ||
            cell->bg[2] != cur_bg[2])
        {
          ctx_term_set_bg (cell->bg[0], cell->bg[1], cell->bg[2]);
          cur_bg[0]=cell->bg[0];
          cur_bg[1]=cell->bg[1];
          cur_bg[2]=cell->bg[2];
        }
        fprintf (stderr, "%s", cell->utf8);
      }
      else
      {
        // TODO: accumulate succesive such to be ignored items,
        // and compress them into one, making us compress largely
        // reused screens well
        fprintf (stderr, "\033[C");
      }
      strcpy (cell->prev_utf8, cell->utf8);
      memcpy (cell->prev_fg, cell->fg, 3);
      memcpy (cell->prev_bg, cell->bg, 3);
    }
    if (row != term->rows)
      fprintf (stderr, "\n\r");
    row ++;
  }
  fprintf (stderr, "\033[0m");
  //printf ("\033[?25h");
  //
}

// xx
// xx
// xx
//

static inline int _ctx_rgba8_manhattan_diff (const uint8_t *a, const uint8_t *b)
{ // wrongly named!
  int c;
  int diff = 0;
  for (c = 0; c<3;c++)
    diff += (int)ctx_pow2(a[c]-b[c]);
  return (int)ctx_sqrtf(diff);
  return diff;
}

static inline void ctx_term_output_buf_half (uint8_t *pixels,
                          int width,
                          int height,
                          CtxTerm *term)
{
  int stride = width * 4;
  const char *sextants[]={
   " ","▘","▝","▀","▖","▌", "▞", "▛", "▗", "▚", "▐", "▜","▄","▙","▟","█",

  };
  for (int row = 0; row < height/2; row++)
    {
      for (int col = 0; col < width-3; col++)
        {
          int     unicode = 0;
          int     bitno = 0;
          uint8_t rgba[2][4] = {
                             {255,255,255,0},
                             {0,0,0,0}};
          int i = 0;

          int  rgbasum[2][4] = {0,};
          int  sumcount[2];

          int curdiff = 0;
          /* first find starting point colors */
          for (int yi = 0; yi < ctx_term_ch; yi++)
            for (int xi = 0; xi < ctx_term_cw; xi++, i++)
                {
                  int noi = (row * ctx_term_ch + yi) * stride + (col*ctx_term_cw+xi) * 4;

                  if (rgba[0][3] == 0)
                  {
                    for (int c = 0; c < 3; c++)
                      rgba[0][c] = pixels[noi + c];
                    rgba[0][3] = 255; // used only as mark of in-use
                  }
                  else
                  {
                    int diff = _ctx_rgba8_manhattan_diff (&pixels[noi], rgba[0]);
                    if (diff > curdiff)
                    {
                      curdiff = diff;
                      for (int c = 0; c < 3; c++)
                        rgba[1][c] = pixels[noi + c];
                    }
                  }

                }

          for (int iters = 0; iters < 1; iters++)
          {
                  i= 0;
          for (int i = 0; i < 4; i ++)
             rgbasum[0][i] = rgbasum[1][i]=0;
          sumcount[0] = sumcount[1] = 0;

          for (int yi = 0; yi < ctx_term_ch; yi++)
            for (int xi = 0; xi < ctx_term_cw; xi++, i++)
                {
                  int noi = (row * ctx_term_ch + yi) * stride + (col*ctx_term_cw+xi) * 4;

                  int diff1 = _ctx_rgba8_manhattan_diff (&pixels[noi], rgba[0]);
                  int diff2 = _ctx_rgba8_manhattan_diff (&pixels[noi], rgba[1]);
                  int cluster = 0;
                  if (diff1 <= diff2)
                    cluster = 0;
                  else
                    cluster = 1;
                  sumcount[cluster]++;
                  for (int c = 0; c < 3; c++)
                    rgbasum[cluster][c] += pixels[noi+c];
                }


          if (sumcount[0])
          for (int c = 0; c < 3; c++)
          {
            rgba[0][c] = rgbasum[0][c] / sumcount[0];
          }
          if (sumcount[1])
          for (int c = 0; c < 3; c++)
          {
            rgba[1][c] = rgbasum[1][c] / sumcount[1];
          }
          }

          int pixels_set = 0;
          for (int y = 0; y < ctx_term_ch; y++)
            for (int x = 0; x < ctx_term_cw; x++)
              {
                int no = (row * ctx_term_ch + y) * stride + (col*ctx_term_cw+x) * 4;
#define CHECK_IS_SET \
      (_ctx_rgba8_manhattan_diff (&pixels[no], rgba[0])< \
       _ctx_rgba8_manhattan_diff (&pixels[no], rgba[1]))

                int set = CHECK_IS_SET;
#undef CHECK_IS_SET
                if (set)
                  { unicode |=  (1<< (bitno) ); 
                    pixels_set ++; 
                  }
                bitno++;
              }
           if (pixels_set == 4)
             ctx_term_set (term, col +1, row + 1, " ",
                           rgba[1], rgba[0]);
           else
             ctx_term_set (term, col +1, row + 1, sextants[unicode],
                           rgba[0], rgba[1]);
        }
    }
}

void ctx_term_find_color_pair (CtxTerm *term, int x0, int y0, int w, int h,
                uint8_t rgba[2][4])
        //uint8_t *rgba0, uint8_t *rgba1)
{
int curdiff = 0;
int stride = term->width * 4;
uint8_t *pixels = term->pixels;
/* first find starting point colors */
for (int y = y0; y < y0 + h; y++)
  for (int x = x0; x < x0 + w; x++)
      {
        int noi = (y) * stride + (x) * 4;

        if (rgba[0][3] == 0)
        {
          for (int c = 0; c < 3; c++)
            rgba[0][c] = pixels[noi + c];
          rgba[0][3] = 255; // used only as mark of in-use
        }
        else
        {
          int diff = _ctx_rgba8_manhattan_diff (&pixels[noi], &rgba[0][0]);
          if (diff > curdiff)
          {
            curdiff = diff;
            for (int c = 0; c < 3; c++)
              rgba[1][c] = pixels[noi + c];
          }
        }
      }
          int  rgbasum[2][4] = {0,};
          int  sumcount[2];

          for (int iters = 0; iters < 1; iters++)
          {
          for (int i = 0; i < 4; i ++)
             rgbasum[0][i] = rgbasum[1][i]=0;
          sumcount[0] = sumcount[1] = 0;

          for (int y = y0; y < y0 + h; y++)
            for (int x = x0; x < x0 + w; x++)
                {
                  int noi = (y) * stride + (x) * 4;

                  int diff1 = _ctx_rgba8_manhattan_diff (&pixels[noi], rgba[0]);
                  int diff2 = _ctx_rgba8_manhattan_diff (&pixels[noi], rgba[1]);
                  int cluster = 0;
                  if (diff1 <= diff2)
                    cluster = 0;
                  else
                    cluster = 1;
                  sumcount[cluster]++;
                  for (int c = 0; c < 3; c++)
                    rgbasum[cluster][c] += pixels[noi+c];
                }


          if (sumcount[0])
          for (int c = 0; c < 3; c++)
          {
            rgba[0][c] = rgbasum[0][c] / sumcount[0];
          }
          if (sumcount[1])
          for (int c = 0; c < 3; c++)
          {
            rgba[1][c] = rgbasum[1][c] / sumcount[1];
          }
          }

}



static void ctx_term_output_buf_quarter (uint8_t *pixels,
                          int width,
                          int height,
                          CtxTerm *term)
{
  int stride = width * 4;
  const char *sextants[]={
   " ","▘","▝","▀","▖","▌", "▞", "▛", "▗", "▚", "▐", "▜","▄","▙","▟","█"

  };
  for (int row = 0; row < height/ctx_term_ch; row++)
    {
      for (int col = 0; col < width /ctx_term_cw; col++)
        {
          int     unicode = 0;
          int     bitno = 0;
          uint8_t rgba[2][4] = {
                             {255,255,255,0},
                             {0,0,0,0}};
          ctx_term_find_color_pair (term, col * ctx_term_cw,
                                    row * ctx_term_ch,
                                    ctx_term_cw,
                                    ctx_term_ch, rgba);

          int pixels_set = 0;
          for (int y = 0; y < 2; y++)
            for (int x = 0; x < ctx_term_cw; x++)
              {
                int no = (row * ctx_term_ch + y) * stride + (col*ctx_term_cw+x) * 4;
#define CHECK_IS_SET \
      (_ctx_rgba8_manhattan_diff (&pixels[no], rgba[0])< \
       _ctx_rgba8_manhattan_diff (&pixels[no], rgba[1]))

                int set = CHECK_IS_SET;
#undef CHECK_IS_SET
                if (set)
                  { unicode |=  (1<< (bitno) ); 
                    pixels_set ++; 
                  }
                bitno++;
              }
           if (pixels_set == 4)
             ctx_term_set (term, col +1, row + 1, " ",
                           rgba[1], rgba[0]);
           else
             ctx_term_set (term, col +1, row + 1, sextants[unicode],
                           rgba[0], rgba[1]);
        }
    }
}


static void ctx_term_output_buf_sextant (uint8_t *pixels,
                          int width,
                          int height,
                          CtxTerm *term)
{
  int stride = width * 4;

  const char *sextants[]={
   " ","🬀","🬁","🬂","🬃","🬄","🬅","🬆","🬇","🬈","🬉","🬊","🬋","🬌","🬍","🬎","🬏","🬐","🬑","🬒","🬓","▌","🬔","🬕","🬖","🬗","🬘","🬙","🬚","🬛","🬜","🬝","🬞","🬟","🬠","🬡","🬢","🬣","🬤","🬥","🬦","🬧","▐","🬨","🬩","🬪","🬫","🬬","🬭","🬮","🬯","🬰","🬱","🬲","🬳","🬴","🬵","🬶","🬷","🬸","🬹","🬺","🬻","█"
  };

  for (int row = 0; row < height/ctx_term_ch; row++)
    {
      for (int col = 0; col < width /ctx_term_cw; col++)
        {
          int     unicode = 0;
          int     bitno = 0;
          uint8_t rgba[2][4] = {
                             {255,255,255,0},
                             {0,0,0,0}};

          ctx_term_find_color_pair (term, col * ctx_term_cw,
                                    row * ctx_term_ch,
                                    ctx_term_cw,
                                    ctx_term_ch, rgba);

          int pixels_set = 0;
          for (int y = 0; y < ctx_term_ch; y++)
            for (int x = 0; x < ctx_term_cw; x++)
              {
                int no = (row * ctx_term_ch + y) * stride + (col*ctx_term_cw+x) * 4;
#define CHECK_IS_SET \
      (_ctx_rgba8_manhattan_diff (&pixels[no], rgba[0])< \
       _ctx_rgba8_manhattan_diff (&pixels[no], rgba[1]))

                int set = CHECK_IS_SET;
#undef CHECK_IS_SET
                if (set)
                  { unicode |=  (1<< (bitno) ); 
                    pixels_set ++; 
                  }
                bitno++;
              }

          if (pixels_set == 6)
            ctx_term_set (term, col +1, row + 1, " ",
                          rgba[1], rgba[0]);
          else
            ctx_term_set (term, col +1, row + 1, sextants[unicode], rgba[0], rgba[1]);
        }
    }
}

static void ctx_term_output_buf_ascii (uint8_t *pixels,
                          int width,
                          int height,
                          CtxTerm *term,
                          int mono)
{
  /* this is a crude ascii-mode built on a quick mapping of sexels to ascii */
  int stride = width * 4;
  const char *sextants[]={
   " ","`","'","^","🬃","`","~","\"","-","\"","'","\"","-","\"","~","^",",",";",
   "=","/","i","[","p","P","z",")","/","7","f",">","/","F",",","\\",":",":",
   "\\","\\","(","T","j","T","]","?","s","\\","<","q","_","=","=","=","c","L",
   "Q","C","a","b","J","]","m","b","d","@"
  };
  uint8_t black[4] = {0,0,0,255};
  for (int row = 0; row < height/ctx_term_ch; row++)
    {
      for (int col = 0; col < width /ctx_term_cw; col++)
        {
          int     unicode = 0;
          int     bitno = 0;
          uint8_t rgba[2][4] = {
                             {255,255,255,0},
                             {0,0,0,0}};

          ctx_term_find_color_pair (term, col * ctx_term_cw,
                                    row * ctx_term_ch,
                                    ctx_term_cw,
                                    ctx_term_ch, rgba);


          if (_ctx_rgba8_manhattan_diff (black, rgba[1]) >
              _ctx_rgba8_manhattan_diff (black, rgba[0]))
          {
            for (int c = 0; c < 4; c ++)
            {
              int tmp = rgba[0][c];
              rgba[0][c] = rgba[1][c];
              rgba[1][c] = tmp;
            }
          }
          if (mono)
          {
            rgba[1][0] = 0;
            rgba[1][1] = 0;
            rgba[1][2] = 0;
          }


          int brightest_dark_diff = _ctx_rgba8_manhattan_diff (black, rgba[0]);

          int pixels_set = 0;
          for (int y = 0; y < ctx_term_ch; y++)
            for (int x = 0; x < ctx_term_cw; x++)
              {
                int no = (row * ctx_term_ch + y) * stride + (col*ctx_term_cw+x) * 4;
#define CHECK_IS_SET \
      (_ctx_rgba8_manhattan_diff (&pixels[no], rgba[0])< \
       _ctx_rgba8_manhattan_diff (&pixels[no], rgba[1]))

                int set = CHECK_IS_SET;
#undef CHECK_IS_SET
                if (set)
                  { unicode |=  (1<< (bitno) ); 
                    pixels_set ++; 
                  }
                bitno++;
              }


           if (pixels_set == 6 && brightest_dark_diff < 40)
             ctx_term_set (term, col +1, row + 1, " ",
                           rgba[1], rgba[0]);
           else
             ctx_term_set (term, col +1, row + 1, sextants[unicode],
                           rgba[0], rgba[1]);
        }
    }
}

static void ctx_term_output_buf_braille (uint8_t *pixels,
                          int width,
                          int height,
                          CtxTerm *term,
                          int mono)
{
  int reverse = 0;
  int stride = width * 4;
  uint8_t black[4] = {0,0,0,255};
  for (int row = 0; row < height/ctx_term_ch; row++)
    {
      for (int col = 0; col < width /ctx_term_cw; col++)
        {
          int     unicode = 0;
          int     bitno = 0;
          uint8_t rgba[2][4] = {
                             {255,255,255,0},
                             {0,0,0,0}};

          ctx_term_find_color_pair (term, col * ctx_term_cw,
                                    row * ctx_term_ch,
                                    ctx_term_cw,
                                    ctx_term_ch, rgba);


          /* make darkest consistently be background  */
          if (_ctx_rgba8_manhattan_diff (black, rgba[1]) >
              _ctx_rgba8_manhattan_diff (black, rgba[0]))
          {
            for (int c = 0; c < 4; c ++)
            {
              int tmp = rgba[0][c];
              rgba[0][c] = rgba[1][c];
              rgba[1][c] = tmp;
            }
          }
          if (mono)
          {
            rgba[1][0] = 0;
            rgba[1][1] = 0;
            rgba[1][2] = 0;
          }

          //int pixels_set = 0;
          for (int x = 0; x < 2; x++)
            for (int y = 0; y < 3; y++)
              {
                int no = (row * 4 + y) * stride + (col*2+x) * 4;
#define CHECK_IS_SET \
      (_ctx_rgba8_manhattan_diff (&pixels[no], rgba[0])< \
       _ctx_rgba8_manhattan_diff (&pixels[no], rgba[1]))

                int set = CHECK_IS_SET;
                if (reverse) { set = !set; }
                if (set)
                  { unicode |=  (1<< (bitno) ); 
           //       pixels_set ++; 
                  }
                bitno++;
              }
          {
            int x = 0;
            int y = 3;
            int no = (row * 4 + y) * stride + (col*2+x) * 4;
            int setA = CHECK_IS_SET;
            no = (row * 4 + y) * stride + (col*2+x+1) * 4;
            int setB = CHECK_IS_SET;

            //pixels_set += setA;
            //pixels_set += setB;
#undef CHECK_IS_SET
            if (reverse) { setA = !setA; }
            if (reverse) { setB = !setB; }
            if (setA != 0 && setB==0)
              { unicode += 0x2840; }
            else if (setA == 0 && setB)
              { unicode += 0x2880; }
            else if ( (setA != 0) && (setB != 0) )
              { unicode += 0x28C0; }
            else
              { unicode += 0x2800; }
            char utf8[5];
            utf8[ctx_unichar_to_utf8 (unicode, (uint8_t*)utf8)]=0;

#if 0
            if (pixels_set == 8)
            {
              if (rgba[0][0] < 32 && rgba[0][1] < 32 && rgba[0][2] < 32)
              {
                ctx_term_set (term, col +1, row + 1, " ",
                                 rgba[1], rgba[0]);
                continue;
              }
            }
#endif
            {
              ctx_term_set (term, col +1, row + 1, utf8,
                               rgba[0], rgba[1]);
            }
          }
        }
    }
}


inline static int
ctx_is_half_opaque (CtxRasterizer *rasterizer)
{
  CtxGState *gstate = &rasterizer->state->gstate;
  if (gstate->source_fill.type == CTX_SOURCE_COLOR)
  {
    uint8_t ga[2];
    ctx_color_get_graya_u8 (rasterizer->state, &gstate->source_fill.color, ga);
    if ( (ga[1] * gstate->global_alpha_f) >= 127)
      return 1;
    return 0;
  }
  return gstate->global_alpha_f > 0.5f;
}

inline static void ctx_term_process (Ctx *ctx,
                                     const CtxCommand *command)
{
  CtxTerm *term = (CtxTerm*)ctx->backend;


#if CTX_BRAILLE_TEXT
  if (command->code == CTX_FILL)
  {
     CtxRasterizer *rasterizer = (CtxRasterizer*)term->host->backend;

     if (0 && ctx_is_half_opaque (rasterizer))
     {
        CtxIntRectangle shape_rect = {
          ((int)(rasterizer->col_min))/ (CTX_SUBDIV * 2),
          ((int)(rasterizer->scan_min))/ (CTX_FULL_AA * 3),
          ((int)(((int)rasterizer->col_max - rasterizer->col_min + 1))) / (CTX_SUBDIV * 2),
          ((int)(((int)rasterizer->scan_max - rasterizer->scan_min + 1)) / (CTX_FULL_AA *3) )
        };
#if 0
  CtxGState *gstate = &rasterizer->state->gstate;
       fprintf (stderr, "{%i,%i %ix%i %.2f}",
                       shape_rect.x, shape_rect.y,
                       shape_rect.width, shape_rect.height,

                       gstate->global_alpha_f
                       );
//   sleep(1);
#endif

       if (shape_rect.y > 0)
       {
       if (0){ // XXXX :
               // disabled - offset is wrong (or offset of cursor in stuff is wrong
               // trying to use ink coverage yield yet other problems..
         again:
         for (CtxList *l = rasterizer->glyphs; l; l=l?l->next:NULL)
         {
           CtxTermGlyph *glyph = (CtxTermGlyph*)l->data;


       for (int row = shape_rect.y;
            row < (shape_rect.y+(int)shape_rect.height);
            row++)
       for (int col = shape_rect.x;
            col < (shape_rect.x+(int)shape_rect.width);
            col++)

           if ((glyph->row == row) &&
               (glyph->col == col))
           {
              ctx_list_remove (&rasterizer->glyphs, glyph);
              ctx_free (glyph);
              l = NULL;goto again;
           }
         }
       }

       }
     }
  }
#endif

#if CTX_CURRENT_PATH
  ctx_update_current_path (ctx, &command->entry);
#endif

  /* we need to interpret state related things ourself to be able to respond to
   * queries.
   */
  ctx_interpret_style (&ctx->state, &command->entry, ctx);
  ctx_interpret_transforms (&ctx->state, &command->entry, ctx);
  ctx_interpret_pos_bare (&ctx->state, &command->entry, ctx);

  /* directly forward */
  ctx_process (term->host, &command->entry);
}

inline static void ctx_term_end_frame (Ctx *ctx)
{
  CtxTerm *term = (CtxTerm*)ctx->backend;
  int width =  term->width;
  int height = term->height;
  switch (term->mode)
  {
    case CTX_TERM_QUARTER:
       ctx_term_output_buf_quarter (term->pixels,
                                width, height, term);
       break;
    case CTX_TERM_ASCII:
       ctx_term_output_buf_ascii (term->pixels,
                                width, height, term, 0);
       break;
    case CTX_TERM_ASCII_MONO:
       ctx_term_output_buf_ascii (term->pixels,
                                width, height, term, 1);
       break;
    case CTX_TERM_SEXTANT:
       ctx_term_output_buf_sextant (term->pixels,
                                width, height, term);
       break;
    case CTX_TERM_BRAILLE:
       ctx_term_output_buf_braille (term->pixels,
                                width, height, term, 0);
       break;
    case CTX_TERM_BRAILLE_MONO:
       ctx_term_output_buf_braille (term->pixels,
                                width, height, term, 1);
       break;
  }
#if CTX_BRAILLE_TEXT
  CtxRasterizer *rasterizer = (CtxRasterizer*)(term->host->backend);
  // XXX instead sort and inject along with braille
  //

  //uint8_t rgba_bg[4]={0,0,0,0};
  //uint8_t rgba_fg[4]={255,0,255,255};

  for (CtxList *l = rasterizer->glyphs; l; l = l->next)
  {
    CtxTermGlyph *glyph = (CtxTermGlyph*)l->data;

    uint8_t *pixels = term->pixels;
    long rgb_sum[4]={0,0,0};
    for (int v = 0; v <  ctx_term_ch; v ++)
    for (int u = 0; u <  ctx_term_cw; u ++)
    {
      int i = ((glyph->row-1) * ctx_term_ch + v) * rasterizer->blit_width + 
              ((glyph->col-1) * ctx_term_cw + u);
      for (int c = 0; c < 3; c ++)
        rgb_sum[c] += pixels[i*4+c];
    }
    for (int c = 0; c < 3; c ++)
      glyph->rgba_bg[c] = rgb_sum[c] / (ctx_term_ch * ctx_term_cw);
    char utf8[8];
    utf8[ctx_unichar_to_utf8(glyph->unichar, (uint8_t*)utf8)]=0;
    ctx_term_set (term, glyph->col, glyph->row, 
                     utf8, glyph->rgba_fg, glyph->rgba_bg);
    ctx_free (glyph);
  }

#endif
  printf ("\033[H");
  printf ("\033[0m");
  ctx_term_scanout (term);
  printf ("\033[0m");
  fflush (NULL);
#if CTX_BRAILLE_TEXT
  while (rasterizer->glyphs)
    ctx_list_remove (&rasterizer->glyphs, rasterizer->glyphs->data);
#endif
}

void ctx_term_destroy (CtxTerm *term)
{
  while (term->lines)
  {
    ctx_free (term->lines->data);
    ctx_list_remove (&term->lines, term->lines->data);
  }
  printf ("\033[?25h"); // cursor on
  nc_at_exit ();
  ctx_free (term->pixels);
  ctx_destroy (term->host);
  ctx_free (term);
  /* we're not destoring the ctx member, this is function is called in ctx' teardown */
}

float ctx_term_get_cell_width (Ctx *ctx)
{
  return ctx_term_cw;
}

float ctx_term_get_cell_height (Ctx *ctx)
{
  return ctx_term_ch;
}


void ctx_stdin_get_event_fds (Ctx *ctx, int *fd, int *count)
{
  fd[0] = STDIN_FILENO;
  *count = 1;
}

Ctx *ctx_new_term (int width, int height)
{
  Ctx *ctx = ctx_new_drawlist (width, height);
#if CTX_RASTERIZER
  CtxTerm *term = (CtxTerm*)ctx_calloc (1, sizeof (CtxTerm));
  CtxBackend *backend = (CtxBackend*)term;
 
  const char *mode = getenv ("CTX_TERM_MODE");
  ctx_term_cw = 2;
  ctx_term_ch = 3;

  if (!mode) term->mode = CTX_TERM_SEXTANT;
  else if (!strcmp (mode, "sextant")) term->mode = CTX_TERM_SEXTANT;
  else if (!strcmp (mode, "ascii")) term->mode = CTX_TERM_ASCII_MONO;
  //else if (!strcmp (mode, "ascii-mono")) term->mode = CTX_TERM_ASCII_MONO;
  else if (!strcmp (mode, "quarter")) term->mode = CTX_TERM_QUARTER;
  //else if (!strcmp (mode, "braille")){
  //  term->mode = CTX_TERM_BRAILLE;
  //  ctx_term_ch = 4;
  //}
  else if (!strcmp (mode, "braille")){
    term->mode = CTX_TERM_BRAILLE_MONO;
    ctx_term_ch = 4;
  }
  else {
    fprintf (stderr, "recognized values for CTX_TERM_MODE:\n"
                    " sextant ascii quarter braille\n");
    exit (1);
  }

  mode = getenv ("CTX_TERM_FORCE_FULL");
  if (mode && strcmp (mode, "0") && strcmp (mode, "no"))
    _ctx_term_force_full = 1;

  fprintf (stderr, "\033[?1049h");
  fprintf (stderr, "\033[?25l"); // cursor off

  int maxwidth = ctx_terminal_cols  (STDIN_FILENO, STDOUT_FILENO) * ctx_term_cw;
  int maxheight = (ctx_terminal_rows (STDIN_FILENO, STDOUT_FILENO)) * ctx_term_ch;
  if (width <= 0 || height <= 0)
  {
    width = maxwidth;
    height = maxheight;
  }
  if (width > maxwidth) width = maxwidth;
  if (height > maxheight) height = maxheight;
  backend->ctx = ctx;
  backend->type = CTX_BACKEND_TERM;
  term->width  = width;
  term->height = height;

  term->cols = (width + 1) / ctx_term_cw;
  term->rows = (height + 2) / ctx_term_ch;
  term->lines = 0;
  term->pixels = (uint8_t*)ctx_malloc (width * height * 4);
  term->host = ctx_new_for_framebuffer (term->pixels,
                                           width, height,
                                           width * 4, CTX_FORMAT_RGBA8);
#if CTX_BRAILLE_TEXT
  ((CtxRasterizer*)term->host->backend)->term_glyphs=1;
#endif
  _ctx_mouse (ctx, NC_MOUSE_DRAG);
  ctx_set_backend (ctx, term);
  backend->process = ctx_term_process;
  backend->end_frame = ctx_term_end_frame;
  backend->destroy = (void(*)(void*))ctx_term_destroy;
  backend->consume_events = ctx_nct_consume_events;
  backend->get_event_fds = ctx_stdin_get_event_fds;
  ctx_set_size (ctx, width, height);
  ctx_font_size (ctx, ctx_term_ch); 
  ctx_font_size (term->host, ctx_term_ch); 
#endif

  return ctx;
}

#endif
#endif
#define CTX_WANT_FONT 1

static CtxFont ctx_fonts[CTX_MAX_FONTS];// = NULL;
static int     ctx_font_count = 0;
typedef struct CtxResolvedFont {uint32_t sqstr; int font_no;} CtxResolvedFont;


CtxFont *_ctx_font_from_no(int no)
{
  if (no < 0 || no>=CTX_MAX_FONTS) return 0;
  return &ctx_fonts[no];
}


static inline CtxGlyph *
_ctx_glyph_allocate (int n_glyphs)
{
  return (CtxGlyph *) ctx_malloc (sizeof (CtxGlyph) * n_glyphs);
}

CtxGlyph *
ctx_glyph_allocate (int n_glyphs)
{
  return _ctx_glyph_allocate (n_glyphs);
}

void
ctx_glyph_free     (Ctx *ctx, CtxGlyph *glyphs)
{
  if (glyphs && glyphs != &ctx->glyphs[0])
    ctx_free (glyphs);
}

int
ctx_load_font_ctx (const char *name, const void *data, int length);
#if CTX_FONT_ENGINE_HARFBUZZ
int
ctx_load_font_hb (const char *name, const char *data, int length);
#endif

#if CTX_RESOLVED_FONTS!=0
static CtxResolvedFont ctx_resolved_fonts[CTX_RESOLVED_FONTS];
#endif

static inline int ctx_font_is_monospaced (CtxFont *font)
{
#if CTX_ONE_FONT_ENGINE
  return 0; // XXX
#else
  return font->monospaced;
#endif
}


CtxFont *ctx_font_get_available (void)
{
  ctx_font_setup (NULL);
  if (ctx_font_count >= CTX_MAX_FONTS)
    { 
      fprintf (stderr, "ctx-err: too many fonts\n");
      return NULL;
    }

  for (int i = 0; i < ctx_font_count; i++)
  {
    if (ctx_fonts[i].type == CTX_FONT_TYPE_NONE)
    {
      ctx_fonts[i].font_no = i;
      return &ctx_fonts[i];
    }
  }
  ctx_fonts[ctx_font_count].font_no = ctx_font_count;

  ctx_font_count++;
  return &ctx_fonts[ctx_font_count-1];
}

// returns number of input utf8 units replaced
static inline int
_ctx_text_substitute_ligatures (Ctx *ctx, CtxFont *font,
                                uint32_t *unichar, uint32_t next_unichar, uint32_t next_next_unichar)
{
  if (font->monospaced || (!font->has_fligs))
    return 0;
  if (*unichar == 'f')
    switch (next_unichar)
    {
      case 'f':

        switch(next_next_unichar)
        {
          case 'i':
            if (ctx_glyph_lookup (ctx, 0xfb03)>0)
            {
              *unichar = 0xfb03;
              return 2;
            }
            break;
          case 'l':
            if (ctx_glyph_lookup (ctx, 0xfb04)>0)
            {
              *unichar = 0xfb04;
              return 2;
            }
            break;

          default:
            if (ctx_glyph_lookup (ctx, 0xfb00)>0)
            {
              *unichar = 0xfb00;
              return 1;
            }
        }
        break;
      case 'i':
        if (ctx_glyph_lookup (ctx, 0xfb01) > 0)
        {
          *unichar = 0xfb01;
          return 1;
        }
        break;
      case 'l': 
        if (ctx_glyph_lookup (ctx, 0xfb02) > 0)
        {
          *unichar = 0xfb02;
          return 1;
        }
        break;
      case 't': 
        if (ctx_glyph_lookup (ctx, 0xfb05) > 0)
        {
          *unichar = 0xfb05;
          return 1;
        }
        break;
    }
  return 0;
}

int
ctx_text_substitute_ligatures (Ctx *ctx, CtxFont *font,
                                uint32_t *unichar, uint32_t next_unichar, uint32_t next_next_unichar)
{
  return _ctx_text_substitute_ligatures (ctx, font, unichar, next_unichar, next_next_unichar);
}

static float
ctx_glyph_kern_ctx (CtxFont *font, Ctx *ctx, uint32_t unicharA, uint32_t unicharB);

static float
ctx_glyph_kern (Ctx *ctx, int glyphA, int unicharB)
{
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
#if CTX_ONE_FONT_ENGINE
  return ctx_glyph_kern_ctx (font, ctx, glyphA, unicharB);
#else
  if (font && font->engine && font->engine->glyph_kern)
    return font->engine->glyph_kern (font, ctx, glyphA, unicharB);
  return 0.0f;
#endif
}

int
_ctx_glyph (Ctx *ctx, int glyph_id, int stroke)
{
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
#if CTX_ONE_FONT_ENGINE
  return ctx_glyph_ctx (font, ctx, glyph_id, stroke);
#else
  return font->engine->glyph (font, ctx, glyph_id, stroke);
#endif

}

int
ctx_glyph_id (Ctx *ctx, uint32_t id, int stroke)
{
  if (ctx->frontend_text)
    return _ctx_glyph (ctx, id, stroke);

  CtxEntry commands[3]; // 3 to silence incorrect warning from static analysis
  memset (commands, 0, sizeof (commands) );
  if (stroke)
    id = id | (1<<31);
  commands[0] = ctx_u32 (CTX_GLYPH, id, 0);
  //commands[1].data.u8[4] = stroke;
  ctx_process (ctx, commands);
  return 0;
}

int
ctx_glyph_unichar (Ctx *ctx, uint32_t unichar, int stroke)
{
  return ctx_glyph_id(ctx, ctx_glyph_lookup (ctx, unichar), stroke);
}

int
ctx_glyph_lookup (Ctx *ctx, uint32_t unichar)
{
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
#if CTX_ONE_FONT_ENGINE
  return ctx_glyph_lookup_ctx2 (font, ctx, unichar);
#else
  return font->engine->glyph_lookup (font, ctx, unichar);
#endif
}

float
ctx_glyph_width (Ctx *ctx, int id) // you get to id from unichar with glyph_lookup
{
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
#if CTX_ONE_FONT_ENGINE
  return ctx_glyph_width_ctx (font, ctx, id);
#else
  return font->engine->glyph_width (font, ctx, id);
#endif
}

#if CTX_FONT_SHAPE_CACHE
typedef struct CtxShape {
  uint32_t    hash;
  const char *utf8;
  uint64_t    shaping_flags;
  CtxGlyph   *glyphs;
  int         count;
  float       width;
} CtxShape;
/*
 *
 *  return 1 if the glyphs should be freed
 */
#define SHAPE_CACHE_SIZE 4096

CtxShape *shape_cache[SHAPE_CACHE_SIZE];
#endif

CtxGlyph *_ctx_glyph_target (Ctx *ctx, int len)
{
#if CTX_FONT_SHAPE_CACHE==0
  // this no-alloc code path without caching might often be better
  if (len < CTX_SHAPE_GLYPHS)
     return ctx->glyphs;
#endif
  return _ctx_glyph_allocate (len);
}

#if CTX_FONT_ENGINE_HARFBUZZ
void
_ctx_shape_hb (Ctx         *ctx,
               CtxFont     *font,
               const char  *string,
               float       *width,
               CtxGlyph   **glyphs,
               unsigned int *ret_count);
#endif

void
ctx_shape_ctx (Ctx         *ctx,
               CtxFont     *font,
               const char  *string,
               float       *width,
               CtxGlyph   **glyphs,
               unsigned int *ret_count);

static inline void
_ctx_shape_generic (Ctx         *ctx,
                    CtxFont     *font,
                    const char  *string,
                    float       *width,
                    CtxGlyph   **glyphs,
                    unsigned int *ret_count)
{
  CtxState *state = &ctx->state;
  unsigned int glyph_count = 0;
  float font_size = state->gstate.font_size;
  float x_advance = 0;
  int len = _ctx_utf8_strlen (string) * 2 + 4;
  *glyphs = _ctx_glyph_target (ctx, len);//*ret_count);
  for (const char *utf8 = string; *utf8; utf8 = _ctx_utf8_skip (utf8, 1) )
    {
      uint32_t unichar = _ctx_utf8_to_unichar (utf8); 
      const char *nextu = _ctx_utf8_skip(utf8, 1);
      uint32_t next  = _ctx_utf8_to_unichar (nextu);
      uint32_t nextnext  = _ctx_utf8_to_unichar (_ctx_utf8_skip(nextu, 1));
      int skip_kern = 0;
      int n;
      if ((n = _ctx_text_substitute_ligatures (ctx, font, &unichar, next, nextnext)))
      {
        utf8 = _ctx_utf8_skip (utf8, n);
        skip_kern = 1;
      }

      int glyph_id = ctx_glyph_lookup (ctx, unichar);
      
      (*glyphs)[glyph_count].index = glyph_id;
      (*glyphs)[glyph_count].x     = x_advance;
      (*glyphs)[glyph_count].y     = 0;

      x_advance += (ctx_glyph_width (ctx, glyph_id)/font_size)*1.02f;

      glyph_count++;
      if (next && (!skip_kern)) {
        float k = ctx_glyph_kern (ctx, glyph_id, next);
        x_advance += k;
      }
    }
  *ret_count = glyph_count;
  *width = x_advance;
}

// returns 1 when the item is returned
// from cache/static and should not be freed
// by called -- this api is clunky
static inline int
_ctx_shape (Ctx         *ctx,
            const char  *string,
            float       *width,
            CtxGlyph   **ret_glyphs,
            int         *ret_count)
{
  CtxState *state = &ctx->state;
  CtxFont *font = &ctx_fonts[state->gstate.font];

#if CTX_FONT_SHAPE_CACHE
  uint32_t hash = ctx_strhash (string);
  hash ^= (uint32_t)(size_t)(font);
  int hpos = hash & (SHAPE_CACHE_SIZE-1);
  if (shape_cache[hpos] && !strcmp (shape_cache[hpos]->utf8, string) && shape_cache[hpos]->hash == hash)
  {
     ret_cached:
     if (ret_glyphs) *ret_glyphs = shape_cache[hpos]->glyphs;
     if (ret_count) *ret_count= shape_cache[hpos]->count;
     if (width) *width = shape_cache[hpos]->width;
     return 1;
  }
#endif
  unsigned int glyph_count = 0;
  float x_advance = 0.0;
  CtxGlyph *glyphs = NULL;

#if CTX_FONT_ENGINE_HARFBUZZ
  if (font->type == CTX_FONT_TYPE_HB)
  {
    _ctx_shape_hb (ctx, font, string, &x_advance, &glyphs, &glyph_count);
  }
  else
#endif
  if (font->type == CTX_FONT_TYPE_CTX)
  {
    ctx_shape_ctx (ctx, font, string, &x_advance, &glyphs, &glyph_count);
  }
  else
  {
    _ctx_shape_generic (ctx, font, string, &x_advance, &glyphs, &glyph_count);
  }

#define CTX_CACHE_SHAPE_MAX_STRLEN   8

#if CTX_FONT_SHAPE_CACHE
  int do_cache = (strlen(string)<CTX_CACHE_SHAPE_MAX_STRLEN);

  // todo: evict existing cached item

  if (shape_cache[hpos]==0 && do_cache)
  {
     shape_cache[hpos] = ctx_calloc(sizeof (CtxShape), 1);
     shape_cache[hpos]->utf8 = ctx_strdup(string);
     shape_cache[hpos]->glyphs = glyphs;
     shape_cache[hpos]->count = glyph_count;
     shape_cache[hpos]->width = x_advance;
     shape_cache[hpos]->hash = hash;
     goto ret_cached;
  }
#endif

  if (width) *width = x_advance;
  if (ret_count) *ret_count = glyph_count;
  if (ret_glyphs) *ret_glyphs = glyphs;
  else
    ctx_glyph_free (ctx, glyphs); // this checks if it is ctx->glyphs


  return glyphs == ctx->glyphs;
}

#if CTX_ONE_FONT_ENGINE
float
ctx_text_width (Ctx        *ctx,
                const char *string)
{
  float sum = 0.0;
  if (!string)
    return 0.0f;
  CtxState *state = &ctx->state;
  float font_size = state->gstate.font_size;
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
  for (const char *utf8 = string; *utf8; utf8 = _ctx_utf8_skip (utf8, 1) )
    {
      uint32_t unichar = _ctx_utf8_to_unichar (utf8); 
      const char *nextu = _ctx_utf8_skip(utf8, 1);
      uint32_t next  = _ctx_utf8_to_unichar (nextu);
      uint32_t nextnext  = _ctx_utf8_to_unichar (_ctx_utf8_skip(nextu, 1));
      int skip_kern = 0;
      int n;
      if ((n = _ctx_text_substitute_ligatures (ctx, font, &unichar, next, next)))
      {
        utf8 = _ctx_utf8_skip (utf8, n);
        skip_kern = 1;
      }
      int glyph_id = ctx_glyph_lookup(ctx, unichar);
      sum += ctx_glyph_width (ctx, glyph_id);
      if (next &(!skip_kern)) sum += ctx_glyph_kern (ctx, glyph_id, next) * font_size;
    }
  return sum;
}
#else
float
ctx_text_width (Ctx        *ctx,
                const char *string)
{
  float sum = 0.0;
  if (!string)
    return 0.0f;
  _ctx_shape (ctx, string, &sum, NULL, NULL);
  return sum * ctx->state.gstate.font_size;
}
#endif

static void
_ctx_glyphs (Ctx     *ctx,
             CtxGlyph *glyphs,
             int       n_glyphs,
             int       stroke)
{
  CtxState *state = &ctx->state;
  float font_size = state->gstate.font_size;
  for (int i = 0; i < n_glyphs; i++)
    {
      ctx_move_to (ctx, glyphs[i].x * font_size, glyphs[i].y * font_size);
      ctx_glyph_id (ctx, glyphs[i].index, stroke);
    }
}


#define CTX_MAX_WORD_LEN 128


#if CTX_ONE_FONT_ENGINE
void
_ctx_text (Ctx        *ctx,
           const char *string,
           int         stroke,
           int         visible)
{
  char word[CTX_MAX_WORD_LEN];
  int word_len = 0;
  CtxState *state = &ctx->state;
  float font_size = state->gstate.font_size;
  CtxFont *font = &ctx_fonts[state->gstate.font];
  float x = ctx->state.x;
  word[word_len]=0;
  switch ( (int) ctx_state_get (state, SQZ_textAlign) )
    //switch (state->gstate.text_align)
    {
      case CTX_TEXT_ALIGN_START:
      case CTX_TEXT_ALIGN_LEFT:
        break;
      case CTX_TEXT_ALIGN_CENTER:
        x -= ctx_text_width (ctx, string) /2;
        break;
      case CTX_TEXT_ALIGN_END:
      case CTX_TEXT_ALIGN_RIGHT:
        x -= ctx_text_width (ctx, string);
        break;
    }
  float y = ctx->state.y;
  float baseline_offset = 0.0f;
  switch ( (int) ctx_state_get (state, SQZ_textBaseline) )
    {
      case CTX_TEXT_BASELINE_HANGING:
        /* XXX : crude */
        baseline_offset = font_size  * 0.55f;
        break;
      case CTX_TEXT_BASELINE_TOP:
        /* XXX : crude */
        baseline_offset = font_size  * 0.7f;
        break;
      case CTX_TEXT_BASELINE_BOTTOM:
        baseline_offset = -font_size * 0.1f;
        break;
      case CTX_TEXT_BASELINE_ALPHABETIC:
      case CTX_TEXT_BASELINE_IDEOGRAPHIC:
        baseline_offset = 0.0f;
        break;
      case CTX_TEXT_BASELINE_MIDDLE:
        baseline_offset = font_size * 0.25f;
        break;
    }
  float x0 = x;
  float x1 = x + 10000.0f;
  
  float wrap_left = ctx_get_wrap_left (ctx);
  float wrap_right = ctx_get_wrap_right (ctx);
  if (wrap_left != wrap_right)
  {
    x0 = wrap_left;
  }

  if (*string)
  for (const char *utf8 = string; utf8 && ( (utf8==string ) || utf8[-1]); utf8 = *utf8?_ctx_utf8_skip (utf8, 1):NULL)
    {
      if (*utf8 == '\n' ||
          *utf8 == ' ' ||
          *utf8 == '\0')
        {
          float word_width = 0.0;
          word[word_len]=0;
          word_width = ctx_text_width (ctx, word);

          if (wrap_left != wrap_right &&
              x + word_width >= wrap_right)
          {
            y += font_size * ctx_get_line_height (ctx);
            x = x0;
          }

          for (const char *bp = &word[0]; *bp; bp = _ctx_utf8_skip (bp, 1))
          {
            uint32_t unichar      = _ctx_utf8_to_unichar (bp);
            const char *next_utf8 = _ctx_utf8_skip (bp, 1);
            uint32_t next_unichar = *next_utf8?_ctx_utf8_to_unichar (next_utf8):0;
            uint32_t nextnext  = _ctx_utf8_to_unichar (ctx_utf8_skip(next_utf8, 1));

            int n;
            if (n = _ctx_text_substitute_ligatures (ctx, font, &unichar, next_unichar, nextnext));
              bp += n;

            int glyph_id = ctx_glyph_lookup (ctx, unichar);
            float glyph_width = ctx_glyph_width (ctx, glyph_id);
            if (x + glyph_width >= x1)
            {
              y += font_size * ctx_get_line_height (ctx);
              x = x0;
            }
            if (visible)
            {
              ctx_move_to (ctx, x, y + baseline_offset);
              _ctx_glyph (ctx, glyph_id, stroke);
            }
            x += glyph_width;
            if (next_unichar)
              x += ctx_glyph_kern (ctx, glyph_id, next_unichar) * font_size;
          }

          if (*utf8 == '\n')
          {
            y += font_size * ctx_get_line_height (ctx);
            x = x0;
          }
          else if (*utf8 == ' ')
          {
            x += ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, ' '));
          }
          word_len=0;
          word[word_len]=0;
        }
      else
      {
        int len = _ctx_utf8_len (*utf8);
        for (int i = 0; i < len; i++)
        {
          if (word_len + 1 < CTX_MAX_WORD_LEN-1)
            word[word_len++]=utf8[i];
        }
      }

    }
  if (!visible)
    { ctx->state.x =x; ctx->state.y=y; }
  else
    { ctx_move_to (ctx, x, y); }
}

#else
void
_ctx_text (Ctx        *ctx,
           const char *string,
           int         stroke,
           int         visible)
{
  char word[CTX_MAX_WORD_LEN];
  int word_len = 0;
  CtxState *state = &ctx->state;
  float font_size = state->gstate.font_size;
  float x = ctx->state.x;
  word[word_len]=0;
  switch ( (int) ctx_state_get (state, SQZ_textAlign) )
    //switch (state->gstate.text_align)
    {
      case CTX_TEXT_ALIGN_START:
      case CTX_TEXT_ALIGN_LEFT:
        break;
      case CTX_TEXT_ALIGN_CENTER:
        x -= ctx_text_width (ctx, string) /2;
        break;
      case CTX_TEXT_ALIGN_END:
      case CTX_TEXT_ALIGN_RIGHT:
        x -= ctx_text_width (ctx, string);
        break;
    }
  float y = ctx->state.y;
  float baseline_offset = 0.0f;
  switch ( (int) ctx_state_get (state, SQZ_textBaseline) )
    {
      case CTX_TEXT_BASELINE_HANGING:
        /* XXX : crude */
        baseline_offset = font_size  * 0.55f;
        break;
      case CTX_TEXT_BASELINE_TOP:
        /* XXX : crude */
        baseline_offset = font_size  * 0.7f;
        break;
      case CTX_TEXT_BASELINE_BOTTOM:
        baseline_offset = -font_size * 0.1f;
        break;
      case CTX_TEXT_BASELINE_ALPHABETIC:
      case CTX_TEXT_BASELINE_IDEOGRAPHIC:
        baseline_offset = 0.0f;
        break;
      case CTX_TEXT_BASELINE_MIDDLE:
        baseline_offset = font_size * 0.25f;
        break;
    }
  float x0 = x;
  
  float wrap_left = ctx_get_wrap_left (ctx);
  float wrap_right = ctx_get_wrap_right (ctx);
  if (wrap_left != wrap_right)
  {
    x0 = wrap_left;
  }

  if (*string)
  for (const char *utf8 = string; utf8 && ( (utf8==string ) || utf8[-1]); utf8 = *utf8?_ctx_utf8_skip (utf8, 1):NULL)
    {
      if (*utf8 == '\n' ||
          *utf8 == ' ' ||
          *utf8 == '\0')
        {
          float word_width = 0.0;
          word[word_len]=0;
          int n_glyphs = 0;
          CtxGlyph *glyphs = NULL;
          int cached = _ctx_shape (ctx, word, &word_width, &glyphs, &n_glyphs);

          if (wrap_left != wrap_right &&
              x + word_width * font_size >= wrap_right)
          {
            y += font_size * ctx_get_line_height (ctx);
            x = x0;
          }

          if (glyphs)
          {
            if (visible)
            {
              ctx_save (ctx);
              ctx_translate (ctx, x, y + baseline_offset);
              ctx_glyphs (ctx, glyphs, n_glyphs);
              ctx_restore (ctx);
            }
            if (!cached)
              ctx_glyph_free (ctx, glyphs);
          }
          x += word_width * font_size;

          if (*utf8 == '\n')
          {
            y += font_size * ctx_get_line_height (ctx);
            x = x0;
          }
          else if (*utf8 == ' ')
          {
            x += ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, ' '));
          }
          word_len=0;
          word[word_len]=0;
        }
      else
      {
        int len = _ctx_utf8_len (*utf8);
        for (int i = 0; i < len; i++)
        {
          if (word_len + 1 < CTX_MAX_WORD_LEN-1)
            word[word_len++]=utf8[i];
        }
      }

    }
  if (!visible)
    { ctx->state.x =x; ctx->state.y=y; }
  else
    { ctx_move_to (ctx, x, y); }
}
#endif


// expects origin to be at the origin of the shaped
// cluster
void
ctx_glyphs (Ctx        *ctx,
            CtxGlyph   *glyphs,
            int         n_glyphs)
{
  _ctx_glyphs (ctx, glyphs, n_glyphs, 0);
}

void
ctx_glyphs_stroke (Ctx        *ctx,
                   CtxGlyph   *glyphs,
                   int         n_glyphs)
{
  _ctx_glyphs (ctx, glyphs, n_glyphs, 1);
}

void
ctx_text (Ctx        *ctx,
          const char *string)
{
  if (!string)
    return;
  if (ctx->frontend_text)
  {
    _ctx_text (ctx, string, 0, 1);
    return;
  }
  ctx_process_cmd_str (ctx, CTX_TEXT, string, 0, 0);
  _ctx_text (ctx, string, 0, 0);
}

int
ctx_font_get_vmetrics (Ctx     *ctx,
                       CtxFont *font,
                       float   *ascent,
                       float   *descent,
                       float   *linegap);


int
ctx_font_get_vmetrics (Ctx *ctx,
                       CtxFont *font,
                       float   *ascent,
                       float   *descent,
                       float   *linegap)
{
#if CTX_ONE_FONT_ENGINE==0
  if (font->engine && font->engine->get_vmetrics)
  {
    font->engine->get_vmetrics (font, ascent, descent, linegap);
    return 0;
  }
#endif
  if (ascent)  *ascent  = 0.8f;
  if (descent) *descent = 0.2f;
  if (linegap) *linegap = 1.2f;
  return 0;
}

int
ctx_font_extents (Ctx *ctx,
                  float *ascent,
                  float *descent,
                  float *line_gap)
{
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
  return ctx_font_get_vmetrics (ctx, font, ascent, descent, line_gap);
}

static const char *ctx_font_get_name (CtxFont *font)
{
  if (!font || !font->engine) return "-";
#if CTX_ONE_FONT_ENGINE
  return ctx_font_get_name_ctx (font);
#else
  return font->engine->get_name (font);
#endif
}

static int _ctx_resolve_font_exact (const char *name)
{
  int ret = -1;
#if CTX_RESOLVED_FONTS!=0
  uint32_t sqstr = ctx_strhash (name);
  int pos = sqstr % CTX_RESOLVED_FONTS;
  int tries = 0;
  while (ctx_resolved_fonts[pos].sqstr && tries < CTX_RESOLVED_FONTS)
  {
    if (ctx_resolved_fonts[pos].sqstr == sqstr)
      return ctx_resolved_fonts[pos].font_no;
    pos++;
    pos %= CTX_RESOLVED_FONTS;
    tries++;
  }
#endif

  for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
    {
      if (!ctx_strcmp (ctx_font_get_name (&ctx_fonts[i]), name) )
        { ret = i; }
    }
  return ret;
}

const char *ctx_get_font_name (Ctx *ctx, int no)
{
  if (no >= 0 && no < ctx_font_count)
    return ctx_font_get_name (&ctx_fonts[no]);
  return NULL;
}


static int _ctx_resolve_font (const char *name)
{
  int ret = -1;
#if CTX_RESOLVED_FONTS!=0
  uint32_t sqstr = ctx_strhash (name);
  int pos = sqstr % CTX_RESOLVED_FONTS;
  int tries = 0;
  while (ctx_resolved_fonts[pos].sqstr && tries < CTX_RESOLVED_FONTS)
  {
    if (ctx_resolved_fonts[pos].sqstr == sqstr)
      return ctx_resolved_fonts[pos].font_no;
    pos++;
    pos %= CTX_RESOLVED_FONTS;
    tries++;
  }
#endif

  char temp[ctx_strlen (name)+8];
  /* first we look for exact */
  for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
    {
      if (!ctx_strcmp (ctx_font_get_name (&ctx_fonts[i]), name) )
        { ret = i; }
    }
  /* ... and substring matches for passed in string */
  for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
    {
      if (ctx_strstr (ctx_font_get_name (&ctx_fonts[i]), name) )
        { ret = i; }
    }

  if (ret < 0)
  {
  /* then we normalize some names */
  if (!strncmp (name, "Helvetica", 9))
  {
     memset(temp,0,sizeof(temp));
     strncpy (temp, name + 4, sizeof(temp)-1);
     memcpy (temp, "Arrrr", 5);  // this matches Arial and Arimo
     name = temp;
  }
  else if (!strncmp (name, "Monospace", 9))
  {
     memset(temp,0,sizeof(temp));
     strncpy (temp, name + 2, sizeof(temp)-1);
     memcpy (temp, "Courier", 7); 
     name = temp;
  }
  else if (!strncmp (name, "Mono ", 5))
  {
    memset(temp,0,sizeof(temp));
    strncpy (temp+ 3, name, sizeof(temp)-1-3);
    memcpy (temp, "Courier ", 8); 
    name = temp;
  }
  else if (!strcmp (name, "Mono"))
  {
    name = "Courier";
  }
  }

  /* first we look for exact of mangled */
  for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
    {
      if (!ctx_strcmp (ctx_font_get_name (&ctx_fonts[i]), name) )
        { ret = i; }
    }
  /* ... and substring matches for passed in string */
  for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
    {
      if (ctx_strstr (ctx_font_get_name (&ctx_fonts[i]), name) )
        { ret = i; }
    }

  /* then attempt more fuzzy matching
   */
  if (ret < 0 ) {
    char *subname = (char*)name;
    int namelen = 0; 
    if (strchr (subname, ' '))
    {
      subname = (char*)strchr (subname, ' ');
      namelen = subname - name;
      subname++;
    }
    for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
    {
      const char *font_name = ctx_font_get_name (&ctx_fonts[i]);
      if ((font_name[0]==name[0] &&
          font_name[1]==name[1] &&
          font_name[namelen] == name[namelen])
          || (namelen == 0 && ctx_strstr (font_name, subname)))
        ret = i;
    }
  }

  /* then we look for a match of the substring after the first
   * space
   */
  if (ret < 0 && strchr (name, ' '))
  {
     char *subname = (char*)strchr (name, ' ');
     for (int i = 0; ret < 0 && i < ctx_font_count; i ++)
     {
       const char *font_name = ctx_font_get_name (&ctx_fonts[i]);
       if (ctx_strstr (font_name, subname) )
         { ret = i; }
     }
  }
#if CTX_RESOLVED_FONTS!=0
  if (ret >=0 && ctx_resolved_fonts[pos].sqstr == 0)
  {
    ctx_resolved_fonts[pos].sqstr = sqstr;
    ctx_resolved_fonts[pos].font_no = ret;
  }
#endif
  return ret;
}

int ctx_resolve_font (const char *name)
{
  int ret = _ctx_resolve_font (name);
  if (ret >= 0)
    { return ret; }
  if (!ctx_strcmp (name, "regular") )
    {
      int ret = _ctx_resolve_font ("sans");
      if (ret >= 0) { return ret; }
      ret = _ctx_resolve_font ("serif");
      if (ret >= 0) { return ret; }
    }
  return 0;
}

#if !( defined(CTX_FONT_0) ||\
       defined(CTX_FONT_1) ||\
       defined(CTX_FONT_2) ||\
       defined(CTX_FONT_3) ||\
       defined(CTX_FONT_4) ||\
       defined(CTX_FONT_5) ||\
       defined(CTX_FONT_6) ||\
       defined(CTX_FONT_7) ||\
       defined(CTX_FONT_8) ||\
       defined(CTX_FONT_9) ||\
       defined(CTX_FONT_10) ||\
       defined(CTX_FONT_11) ||\
       defined(CTX_FONT_12) ||\
       defined(CTX_FONT_13) ||\
       defined(CTX_FONT_14) ||\
       defined(CTX_FONT_15) ||\
       defined(CTX_FONT_16))
#define CTX_FONT_0   ctx_load_font_ctx("sans-ctx", ctx_font_ascii, sizeof (ctx_font_ascii))
#endif

void ctx_font_setup (Ctx *ctx)
{
  static int initialized = 0;
  if (initialized) { 
    if (ctx)
      ctx->fonts = ctx_fonts;
    return;
  }
  initialized = 1;

  if (ctx)
    ctx->fonts = ctx_fonts;

  ctx_font_count = 0; 

#if CTX_FONT_ENGINE_CTX_FS
  if (getenv ("CTX_FONT_LIVE_PATH"))
  {
    if (getenv ("CTX_FONT_LIVE_NAME"))
      ctx_load_font_ctx_fs (getenv ("CTX_FONT_LIVE_NAME"), getenv ("CTX_FONT_LIVE_PATH"), 0);
    else
      ctx_load_font_ctx_fs ("Arrrr Regular", getenv ("CTX_FONT_LIVE_PATH"),0);
  }
#endif

#if CTX_FONT_ENGINE_CTX

#ifdef CTX_FONT_0
  CTX_FONT_0;
#endif
#ifdef CTX_FONT_1
  CTX_FONT_1;
#endif
#ifdef CTX_FONT_2
  CTX_FONT_2;
#endif
#ifdef CTX_FONT_3
  CTX_FONT_3;
#endif
#ifdef CTX_FONT_4
  CTX_FONT_4;
#endif
#ifdef CTX_FONT_5
  CTX_FONT_5;
#endif
#ifdef CTX_FONT_6
  CTX_FONT_6;
#endif
#ifdef CTX_FONT_7
  CTX_FONT_7;
#endif
#ifdef CTX_FONT_8
  CTX_FONT_8;
#endif
#ifdef CTX_FONT_9
  CTX_FONT_9;
#endif
#ifdef CTX_FONT_10
  CTX_FONT_10;
#endif
#ifdef CTX_FONT_11
  CTX_FONT_11;
#endif
#ifdef CTX_FONT_12
  CTX_FONT_12;
#endif
#ifdef CTX_FONT_13
  CTX_FONT_13;
#endif
#ifdef CTX_FONT_14
  CTX_FONT_14;
#endif
#ifdef CTX_FONT_15
  CTX_FONT_15;
#endif
#ifdef CTX_FONT_16
  CTX_FONT_16;
#endif
#endif
}

static float
ctx_glyph_kern_inferred (CtxFont *font, Ctx *ctx, uint32_t unicharA, uint32_t unicharB)
{
  int      a_glyphs=0;
  float    a_width=0.0f;
  int      b_glyphs=0;
  float    b_width=0.0f;
  int      ab_glyphs=0;
  float    ab_width=0.0f;
  char     tmp[16];
  memset(tmp, 0, sizeof (tmp));
  ctx_unichar_to_utf8 (unicharB, (uint8_t*)tmp);

  _ctx_shape (ctx, tmp, &b_width, NULL, &b_glyphs);
  memset(tmp, 0, sizeof (tmp));
  ctx_unichar_to_utf8 (unicharA, (uint8_t*)tmp);
  _ctx_shape (ctx, tmp, &a_width, NULL, &a_glyphs);

  ctx_unichar_to_utf8 (unicharB, (uint8_t*)tmp + strlen(tmp));
  _ctx_shape (ctx, tmp, &ab_width, NULL, &ab_glyphs);

  if (ab_glyphs == a_glyphs + b_glyphs)
  {
    return (ab_width - (a_width + b_width));
  }
  return 0.0f;
}

#if CTX_FONTGEN & CTX_FONT_ENGINE_HARFBUZZ

typedef struct CtxFontGenerator
{
  Ctx *ctx;
  int font_no;
  CtxDrawlist output_font;
  uint32_t glyphs[65536];
  unsigned int n_glyphs;
  uint32_t incoming_glyphs[65536];
  unsigned int n_incoming_glyphs;
} CtxFontGenerator;

static void
ctx_fontgen_add_glyph_real (CtxFontGenerator *gen, uint32_t glyph)
{
  Ctx *ctx = gen->ctx;
  for (unsigned int i = 0; i < gen->n_glyphs; i++)
  {
    if (gen->glyphs[i] == glyph)
      return;
  }
  ctx_start_frame (ctx);
  ctx_font (ctx, ctx_get_font_name (NULL, gen->font_no));
  ctx_font_size (ctx, CTX_BAKE_FONT_SIZE);
  ctx_move_to (ctx, 0, 0);
  if (ctx_glyph_unichar (ctx, glyph, 0))
    return;
  if (ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, glyph)) <= 0)
    return;
  gen->glyphs[gen->n_glyphs++] = glyph;
  if (ctx->drawlist.count > 5)
    ctx_drawlist_compact (&ctx->drawlist);
  uint32_t args[2] = {glyph, ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, glyph)) * 256};
  ctx_drawlist_add_u32 (&gen->output_font, CTX_DEFINE_GLYPH, args);

  for (unsigned int i = 1; i < ctx->drawlist.count - 1; i++)
  {
    CtxEntry *entry = &ctx->drawlist.entries[i];
    args[0] = entry->data.u32[0];
    args[1] = entry->data.u32[1];
    ctx_drawlist_add_u32 (&gen->output_font, entry->code, &args[0]);
  }
}


static void
ctx_fontgen_add_glyph (CtxFontGenerator *gen, uint32_t glyph)
{
  Ctx *ctx = gen->ctx;
  if (ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, glyph)) <= 0)
    return;
  for (unsigned int i = 0; i < gen->n_incoming_glyphs; i++)
  {
    if (gen->incoming_glyphs[i] == glyph)
      return;
  }
  gen->incoming_glyphs[gen->n_incoming_glyphs++] = glyph;
}

static int ctx_fontgen_compare_glyphs (const void*a, const void *b)
{
  uint32_t au = ((uint32_t*)a)[0];
  uint32_t bu = ((uint32_t*)b)[0];
  return au - bu;
}

static void
ctx_fontgen_real_add_glyphs (CtxFontGenerator *gen)
{
  qsort (gen->incoming_glyphs, gen->n_incoming_glyphs, sizeof (uint32_t),
         ctx_fontgen_compare_glyphs);
  for (unsigned int i = 0; i < gen->n_incoming_glyphs; i++)
    if (gen->incoming_glyphs[i] &&
        gen->incoming_glyphs[i]!='\r' &&
        gen->incoming_glyphs[i]!='\t' &&
        gen->incoming_glyphs[i]!=2 &&
        gen->incoming_glyphs[i]!='\b')
      ctx_fontgen_add_glyph_real (gen, gen->incoming_glyphs[i]);
}

static int ctx_fontgen_find_glyph (CtxDrawlist *drawlist, uint32_t unichar)
{
  for (unsigned int i = 0; i < drawlist->count; i++)
  {
    if (drawlist->entries[i].code == CTX_DEFINE_GLYPH &&
        drawlist->entries[i].data.u32[0] == unichar)
    {
       return i;
       // XXX this could be prone to insertion of valid header
       // data in included bitmaps.. is that an issue?
    }
  }
  fprintf (stderr, "Eeeek %i\n", unichar);
  return -1;
}


void ctx_generate_font (const char  *path,
                        FILE        *out,
                        const char  *name,
                        const char  *license,
                        const char  *utf8_glyphs,
                        int          binary)
{
  CtxFontGenerator *gen = ctx_calloc (sizeof (CtxFontGenerator), 1);
  
  int font_no = gen->font_no = ctx_load_font_hb (NULL, path, -2);
  Ctx *ctx = gen->ctx = ctx_new (1000, 1000, "drawlist");
  ctx_set_frontend_text (ctx, 1);
  _ctx_set_transformation (ctx, CTX_TRANSFORMATION_RELATIVE);

  const char *font_name = ctx_get_font_name (NULL, font_no);
  ctx_font (ctx, font_name);

  if (!strcmp (font_name, "Roboto"))
    font_name = "Roboto Regular";

  if (utf8_glyphs == NULL || !strcmp (utf8_glyphs, "all"))
    for (int glyph = 0; glyph < 65536*7.5; glyph++)
      ctx_fontgen_add_glyph (gen, glyph);
  if (utf8_glyphs)
  {
  if (strstr (utf8_glyphs, "ascii"))
    for (int glyph = 0; glyph < 127; glyph++)
      ctx_fontgen_add_glyph (gen, glyph);
  if (strstr (utf8_glyphs, "latin1"))
    for (int glyph = 0; glyph < 256; glyph++)
      ctx_fontgen_add_glyph (gen, glyph);
  if (strstr (utf8_glyphs, "greek"))
    for (int glyph = 0x0370; glyph < 0x03ff; glyph++)
      ctx_fontgen_add_glyph (gen, glyph);
  if (strstr (utf8_glyphs, "cyrillic"))
    for (int glyph = 0x0400; glyph < 0x04ff; glyph++)
      ctx_fontgen_add_glyph (gen, glyph);
  }

  if (utf8_glyphs)
  for (const char *p = utf8_glyphs; *p; p = _ctx_utf8_skip (p, 1))
    ctx_fontgen_add_glyph (gen, _ctx_utf8_to_unichar (p));

  {
    CtxEntry entry;
    entry.code = CTX_DEFINE_FONT;
    entry.data.u8[0] = CTX_SUBDIV;
    entry.data.u8[1] = CTX_BAKE_FONT_SIZE;
    entry.data.u32[1] = 23; // length
    ctx_drawlist_add_single (&gen->output_font, &entry);
  }

  char temp_name[256];
  sprintf (temp_name, " %s", font_name);
  ctx_drawlist_add_data (&gen->output_font, temp_name, strlen(temp_name)+1);

  if (!license)
  {
  if (strstr (path, "Roboto-"))
  {
    license = " Apache Licence, Version 2.0\nCopyright 2014 Christian Robertson - Apache 2";
  }

  if (strstr (path, "Carlito-"))
  {
    license = " Apache License, Version 2.0\nCopyright 2013 Łukasz Dziedzic";
  }

  if (strstr (path, "Arimo-") ||
      strstr (path, "Tinos-") ||
      strstr (path, "Cousine-"))
  {
    license = " Apache License, Version 2.0\nCopyright 2013 Steve Matteson";
  }

  if (strstr (path, "Caladea-"))
  {
    license = " Apache License, Verison 2.0\nCopyright 2014 Carolina Giovagnoli and Andres Torresi";
  }
  }

  if (license)
    ctx_drawlist_add_data (&gen->output_font, license, strlen(license)+1);

  ctx_fontgen_real_add_glyphs (gen);

  ctx_font (ctx, ctx_get_font_name (NULL, gen->font_no));
  ctx_font_size (ctx, CTX_BAKE_FONT_SIZE);
  for (unsigned int i = 0; i < gen->n_glyphs; i++)
    for (unsigned int j = 0; j < gen->n_glyphs; j++)
    {
      float kerning = ctx_glyph_kern_inferred (NULL, ctx, gen->glyphs[i], gen->glyphs[j]);
      if (fabsf(kerning) > 0.001)
      {
        CtxCommand command; 
        //fprintf(stderr, "got kern!\n");
        unsigned int pos = ctx_fontgen_find_glyph (&gen->output_font, gen->glyphs[i]);
        pos ++;
        while (pos < gen->output_font.count &&
               gen->output_font.entries[pos].code != CTX_DEFINE_GLYPH)
          pos++;

        command.code = CTX_KERNING_PAIR;
        command.kern.glyph_before = gen->glyphs[i];
        command.kern.glyph_after = gen->glyphs[j];
        command.kern.amount = kerning * 256;
        ctx_drawlist_insert_entry (&gen->output_font, pos, (CtxEntry*)&command);
      }
    }

  ctx_destroy (gen->ctx);

  gen->output_font.entries[0].data.u32[1] = gen->output_font.count;

  if (!binary)
  {
  fprintf (out, "#ifndef CTX_FONT_%s\n", name);
  fprintf (out, "/* glyph index: \n");
  int col = 0;
  for (unsigned int i = 0; i < gen->output_font.count; i++)
  {
    CtxEntry *entry = &gen->output_font.entries[i];
    if (entry->code == '@')
    {
       char buf[44]={0,0,0,0,0};
       ctx_unichar_to_utf8 (entry->data.u32[0], (uint8_t*)buf);
       switch (buf[0])
       {
         case '\\':
           fprintf (out, "\\");
         break;
         default:
           fprintf (out, "%s", buf);
       }
       col++;
       if (col > 73)
       {
         col = 0;
         fprintf (out, "\n  ");
       }
    }
  }

  fprintf (out, "  */\n");

  fprintf (out, "static const struct __attribute__ ((packed)) {uint8_t code; uint32_t a; uint32_t b;}\n"
                "ctx_font_%s[]={\n", name);

  for (unsigned int i = 0; i < gen->output_font.count; i++)
  {
    CtxEntry *entry = &gen->output_font.entries[i];
        
    if (entry->code == 15)
    {
      fprintf (out, "{%i, 0x%08x, 0x%08x},", entry->code,
                                       0, // XXX : why did it contain garbage?
                                       entry->data.u32[1]);
    }
    else if (entry->code > 32 && entry->code < 127)
    {
      fprintf (out, "{'%c', 0x%08x, 0x%08x},", entry->code,
                                         entry->data.u32[0],
                                         entry->data.u32[1]);
    }
    else
    {
      fprintf (out, "{%i, 0x%08x, 0x%08x},", entry->code,
                                       entry->data.u32[0],
                                       entry->data.u32[1]);
    }
    if (entry->code == '@')
    {
       char buf[44]={0,0,0,0,0};
       ctx_unichar_to_utf8 (entry->data.u32[0], (uint8_t*)buf);
       switch (buf[0])
       {
         case '\\':
           fprintf (out, "/*       \\         x-advance: %f */", entry->data.u32[1]/256.0);
         break;
         default:
           fprintf (out, "/*        %s        x-advance: %f */", buf, entry->data.u32[1]/256.0);
       }
    }
    else if (entry->code == 15)
    {
      fprintf (out, "/* length:%i CTX_SUBDIV:%i CTX_BAKE_FONT_SIZE:%i */",
              entry->data.u32[1],
              entry->data.u8[0],
              entry->data.u8[1]);
    }
    else if (entry->code == '(')
    {
      char *str = (char*)(entry+1);
      fprintf (out, "/*");
      for (int i = 0; str[i]; i++)
      {
        if (str[i] == '\n')
                fprintf (out, "\n                                ");
        else
                fprintf (out, "%c", str[i]);
      }
      fprintf (out, "*/");
    }
    else if (entry->code == '[')
    {
      char buf[44]={0,0,0,0,0};
      fprintf (out, "/*kerning  ");
      ctx_unichar_to_utf8 (entry->data.u16[0], (uint8_t*)buf);
      fprintf (out, "%s ", buf);
      ctx_unichar_to_utf8 (entry->data.u16[1], (uint8_t*)buf);
      fprintf (out, "%s : %f ", buf, entry->data.s32[1] / 256.0f );
      fprintf (out, "*/");
    }
    else
    {
    }
    fprintf (out, "\n");
  }
    fprintf (out, "};\n");
    fprintf (out, "#define ctx_font_%s_name \"%s\"\n", name, font_name);
    fprintf (out, "#endif\n");
  }
  else
  {
  for (unsigned int i = 0; i < gen->output_font.count; i++)
  {
    CtxEntry *entry = &gen->output_font.entries[i];
    for (int c = 0; c <  (int)sizeof (CtxEntry); c++)
      fprintf (out, "%c",((uint8_t*)(entry))[c]);
  }
  }
  ctx_free (gen);
}
#else
void ctx_generate_font (const char  *path,
                        FILE        *out,
                        const char  *name,
                        const char  *license,
                        const char  *utf8_glyphs,
                        int          binary)
{
}
#endif // CTX_FONTGEN

void  ctx_font_unload        (int font_no)
{
  if (font_no < 0 || font_no >= ctx_font_count)
    return;

  if (ctx_fonts[font_no].engine &&
      ctx_fonts[font_no].engine->unload)
  {
    ctx_fonts[font_no].engine->unload (&ctx_fonts[font_no]);
  }
  ctx_fonts[font_no].engine = NULL;
  ctx_fonts[font_no].type = CTX_FONT_TYPE_NONE;
  ctx_fonts[font_no].monospaced = 0;
  ctx_fonts[font_no].has_fligs = 0;
  if (ctx_fonts[font_no].path)
    ctx_free (ctx_fonts[font_no].path);
  ctx_fonts[font_no].path = NULL;
}


#if CTX_FONTS_FROM_FILE
int ctx_load_font_ctx_file (const char *name, const char *path);
int ctx_load_font_file (Ctx *ctx, const char *name, const char *path)
{
  int fno;
  if ((fno=_ctx_resolve_font_exact (name))>=0)
  {
    if (ctx_fonts[fno].path && !strcmp (ctx_fonts[fno].path, path))
      return fno;

    ctx_wait_for_renderer (ctx);
    if (access(path, R_OK) != F_OK)
      return -1;
    ctx_font_unload (fno);
  }
  else
  {
    if (access(path, R_OK) != F_OK)
      return -1;
  }

  int ret = -1;
#if CTX_FONT_ENGINE_HARFBUZZ
  if (  (!strcmp (".ttf", path + strlen(path)-4)) ||
        (!strcmp (".otf", path + strlen(path)-4)) ||
        (!strcmp (".TTF", path + strlen(path)-4)) ||
        (!strcmp (".OTF", path + strlen(path)-4)))
  {
    ret = ctx_load_font_hb (name, path, -2);
    ctx_fonts[fno].path = ctx_strdup (path);
    return ret;
  }
#endif
#if CTX_FONT_ENGINE_CTX
    ret = ctx_load_font_ctx_file (name, path);
    ctx_fonts[fno].path = ctx_strdup (path);
#endif

  return ret;
}
#endif

int ctx_load_font (Ctx *ctx, const char *name, const char *data, unsigned int length)
{
  if (!data || length < 4) return -1;
#if CTX_FONT_ENGINE_HARFBUZZ
  if (!strncmp (data, "OTTO", 4))
    return ctx_load_font_hb (name, data, length);
#endif

#if CTX_FONT_ENGINE_CTX
  {
    int ret = ctx_load_font_ctx (name, data, length);
    if (ret >= 0)
      ctx_fonts[ret].ctx.free_data = 1;
    return ret;
  }
#endif
  return -1;
}

#if CTX_FONT_ENGINE_CTX

static inline int ctx_font_get_length (CtxFont *font)
{
   return font->ctx.data->data.u32[1];
}

static int ctx_glyph_find (Ctx *ctx, CtxFont *font, uint32_t unichar)
{
  int length = ctx_font_get_length (font);
  for (int i = 0; i < length; i++)
    {
      CtxEntry *entry = (CtxEntry *) &font->ctx.data[i];
      if (entry->code == CTX_DEFINE_GLYPH && entry->data.u32[0] == unichar)
        { return i; }
    }
  return 0;
}

static void
ctx_font_get_vmetrics_ctx (CtxFont *font,
                           float   *ascent,
                           float   *descent,
                           float   *linegap)
{
  if (ascent)  *ascent=0.8f;
  if (descent) *descent=0.2f;
  if (linegap) *linegap=1.2f;
}

static inline uint32_t
ctx_glyph_find_next (CtxFont *font, Ctx *ctx, int offset)
{
  int length = ctx_font_get_length (font);
  for (int i = offset; i < length; i++)
  {
    CtxEntry *entry = (CtxEntry *) &font->ctx.data[i];
    if (entry->code == CTX_DEFINE_GLYPH)
    {
      return entry->data.u32[0];
    }
  }
  return 0;
}

static int ctx_glyph_lookup_ctx (CtxFont *font, Ctx *ctx, uint32_t unichar)
{
#if CTX_GLYPH_CACHE
  uint32_t hash = ((((size_t)(font) * 23) ^ unichar) * 17) %
            (CTX_GLYPH_CACHE_SIZE);
  if (ctx)
  {
    if (ctx->glyph_index_cache[hash].font == font &&
        ctx->glyph_index_cache[hash].unichar == unichar)
          return ctx->glyph_index_cache[hash].offset;
  }
#endif

  int start = 0;
  int end = ctx_font_get_length (font);
  int max_iter = 14;

  do {
    int middle = (start + end) / 2;

    uint32_t middle_glyph = ctx_glyph_find_next (font, ctx, middle);

    if (unichar  == middle_glyph)
    {
      for (int i = middle; i < end; i++)
      {
        CtxEntry *entry = (CtxEntry *) &font->ctx.data[i];
        if (entry->code == CTX_DEFINE_GLYPH)
          break;
        middle++;
      }
#if CTX_GLYPH_CACHE
       if (ctx)
       {
         ctx->glyph_index_cache[hash].font    = font;
         ctx->glyph_index_cache[hash].unichar = unichar;
         ctx->glyph_index_cache[hash].offset  = middle;
       }
#endif
       return middle;
    }
    else if (unichar < middle_glyph)
    {
       end = middle;
    } else
    {
       start = middle;
    }

    if (start == end)
    {
      return -1;
    }
  } while (max_iter -- > 0);

  return -1;
}

static float
ctx_glyph_kern_ctx (CtxFont *font, Ctx *ctx, uint32_t first_kern, uint32_t unicharB)
{
  int length = ctx_font_get_length (font);
  for (int i = first_kern + 1; i < length; i++)
    {
      CtxEntry *entry = (CtxEntry *) &font->ctx.data[i];
      if (entry->code == CTX_KERNING_PAIR)
        {
          if (entry->data.u16[1] == unicharB //&& entry->data.u16[0] == unicharA
          )
            { 
               return entry->data.s32[1] / 256.0f; 
            }
        }
      if (entry->code == CTX_DEFINE_GLYPH)
        return 0.0f;
    }
  return 0.0f;
}

static float
ctx_glyph_width_ctx (CtxFont *font, Ctx *ctx, int id)
{
  float font_size = 1.0f;
  if (ctx)
  {
    CtxState *state = &ctx->state;
    font_size = state->gstate.font_size;
  }
  int   start     = id;
  if (start < 0)
    { return 0.0; }  // XXX : fallback

#if CTX_EVENTS
  if (ctx && ctx_backend_type (ctx) == CTX_BACKEND_TERM && 
                  ctx_fabsf(3.0f - font_size) < 0.03f 
                  )
    return 2.0f;
#endif

  int length = ctx_font_get_length (font);
  if (start < length)
    {
      CtxEntry *entry = (CtxEntry *) &font->ctx.data[start];
      if (entry->code == CTX_DEFINE_GLYPH)
        //if (entry->data.u32[0] == (unsigned) unichar)
          { return (entry->data.u32[1] / 256.0f * font_size / CTX_BAKE_FONT_SIZE); }
    }
  return 0.0;
}

static int
ctx_glyph_drawlist (CtxFont *font, Ctx *ctx, CtxDrawlist *drawlist, int id, int stroke)
{
  CtxState *state = &ctx->state;
  CtxIterator iterator;
  float origin_x = state->x;
  float origin_y = state->y;
  ctx_current_point (ctx, &origin_x, &origin_y);
  int in_glyph = 0;
  float font_size = state->gstate.font_size;
  int start = 0;
#if CTX_ONE_FONT_ENGINE==0
  if (font->type == CTX_FONT_TYPE_CTX)
#endif
  {
  start = id;
  ctx_iterator_init (&iterator, drawlist, start, CTX_ITERATOR_EXPAND_BITPACK);
  CtxCommand *command; 
  void  (*process)  (Ctx *ctx, const CtxCommand *entry) = ctx->process;

  while ( (command= ctx_iterator_next (&iterator) ) )
    {
      CtxEntry *entry = &command->entry;
      if (in_glyph)
        {
          if (entry->code == CTX_DEFINE_GLYPH)
            {
              if (stroke)
                { ctx_stroke (ctx); }
              else
                {
#if CTX_RASTERIZER
#if CTX_ENABLE_SHADOW_BLUR
      if (ctx->backend && ((CtxRasterizer*)(ctx->backend))->in_shadow)
      {
        ctx_rasterizer_shadow_fill ((CtxRasterizer*)ctx->backend);
      }
      
#endif
#endif
         ctx_fill (ctx); 
               
                }
              ctx_restore (ctx);
              return 0;
            }
          process (ctx, (CtxCommand*)entry);
        }
      else if (entry->code == CTX_DEFINE_GLYPH )//&& entry->data.u32[0] == (unsigned)unichar)
        {
          in_glyph = 1;
          ctx_save (ctx);
          ctx_translate (ctx, origin_x, origin_y);
          ctx_move_to (ctx, 0, 0);
          ctx_reset_path (ctx);
          ctx_scale (ctx, font_size / CTX_BAKE_FONT_SIZE,
                     font_size / CTX_BAKE_FONT_SIZE);
        }
    }
  if (stroke)
    { ctx_stroke (ctx);
    }
  else
    { 
    
#if CTX_RASTERIZER
#if CTX_ENABLE_SHADOW_BLUR
      if (ctx->backend && ((CtxRasterizer*)(ctx->backend))->in_shadow)
      {
        ctx_rasterizer_shadow_fill ((CtxRasterizer*)ctx->backend);
      }
      
#endif
#endif
      {
         ctx_fill (ctx); 
      }
    }
  ctx_restore (ctx);
  }
  return -1;
}

static int
ctx_glyph_ctx (CtxFont *font, Ctx *ctx, int glyph_id, int stroke)
{
  CtxDrawlist drawlist;
  drawlist.entries = font->ctx.data;
  int length = ctx_font_get_length (font);

  if (glyph_id >= length || glyph_id < 0)
    return -1;

  drawlist.count = length;
  drawlist.size  = length;
  drawlist.flags = CTX_DRAWLIST_DOESNT_OWN_ENTRIES;
  return ctx_glyph_drawlist (font, ctx, &drawlist, glyph_id, stroke);
}

#if 0
uint32_t ctx_glyph_no (Ctx *ctx, int no)
{
  CtxFont *font = &ctx_fonts[ctx->state.gstate.font];
  if (no < 0 || no >= font->ctx.glyphs)
    { return 0; }
  return font->ctx.index[no*2]; // needs index
}
#endif

static void ctx_font_init_ctx (CtxFont *font)
{
}

static void ctx_font_unload_ctx (CtxFont *font)
{
  if (font->ctx.free_data)
    ctx_free (font->ctx.data);
  font->ctx.data = NULL;
  if (font->ctx.name)
    ctx_free ((void*)font->ctx.name);
  font->ctx.name = NULL;
  font->ctx.free_data = 0;
}

static const char *ctx_font_get_name_ctx (CtxFont *font)
{
  if (font->ctx.name)
    return font->ctx.name;
  return ((char*)(font->ctx.data+2))+1;
}


#if CTX_ONE_FONT_ENGINE==0
static CtxFontEngine ctx_font_engine_ctx =
{
  ctx_glyph_ctx,
  ctx_glyph_width_ctx,
  ctx_glyph_kern_ctx,
  ctx_glyph_lookup_ctx,
  ctx_font_unload_ctx,
  ctx_font_get_name_ctx,
  ctx_font_get_vmetrics_ctx,
};
#endif

int
ctx_load_font_ctx (const char *name, const void *data, int length)
{
  if (length % sizeof (CtxEntry) )
    { return -1; }
  CtxFont *font = ctx_font_get_available ();
  if (!font)
    return -1;

#if CTX_ONE_FONT_ENGINE==0
  font->type = CTX_FONT_TYPE_CTX;
  font->engine = &ctx_font_engine_ctx;
#endif
  font->ctx.name = name?ctx_strdup (name):NULL;
  font->ctx.data = (CtxEntry *) data;
  //font->ctx.length = length / sizeof (CtxEntry);
  ctx_font_init_ctx (font);

#if CTX_ONE_FONT_ENGINE==0
  if (font->engine->glyph_width (font, NULL, ctx_glyph_lookup_ctx (font, NULL, 'O')) ==
      font->engine->glyph_width (font, NULL, ctx_glyph_lookup_ctx (font, NULL, 'I')))
  {
    font->monospaced = 1;
  }
  else
    font->monospaced = 0;
#endif

  font->has_fligs = (ctx_glyph_lookup_ctx (font, NULL, 0xfb00)>=0 ||
                     ctx_glyph_lookup_ctx (font, NULL, 0xfb01)>=0 ||
                     ctx_glyph_lookup_ctx (font, NULL, 0xfb02)>=0 ||
                     ctx_glyph_lookup_ctx (font, NULL, 0xfb03));
  return font->font_no;
}
CtxFont *_ctx_font_from_no(int no);

#if CTX_FONTS_FROM_FILE
int
ctx_load_font_ctx_file (const char *name, const char *path)
{
  ctx_font_setup (NULL);
  uint8_t *contents = NULL;
  long length = 0;
  ctx_get_contents (path, &contents, &length);
  if (!contents)
    {
      ctx_log ( "File load failed\n");
      return -1;
    }
  int ret = ctx_load_font_ctx (name, contents, length);
  if (ret >= 0)
    _ctx_font_from_no(ret)->ctx.free_data = 1;
  return ret;
}
#endif


void
ctx_shape_ctx (Ctx         *ctx,
               CtxFont     *font,
               const char  *string,
               float       *width,
               CtxGlyph   **glyphs,
               unsigned int *ret_count)
{
  CtxState *state = &ctx->state;
  unsigned int glyph_count = 0;
  float font_size = state->gstate.font_size;
  float x_advance = 0;
  int len = _ctx_utf8_strlen (string) * 2 + 4;
  *glyphs = _ctx_glyph_target (ctx, len);
  for (const char *utf8 = string; *utf8; utf8 = _ctx_utf8_skip (utf8, 1) )
    {
      uint32_t unichar = _ctx_utf8_to_unichar (utf8); 
      const char *nextu = _ctx_utf8_skip(utf8, 1);
      uint32_t next  = _ctx_utf8_to_unichar (nextu);
      uint32_t nextnext  = _ctx_utf8_to_unichar (_ctx_utf8_skip(nextu, 1));
      int skip_kern = 0;
      int n;
      if ((n = ctx_text_substitute_ligatures (ctx, font, &unichar, next, nextnext)))
      {
        utf8 = _ctx_utf8_skip (utf8, n);
        skip_kern = 1;
      }

      int glyph_id = ctx_glyph_lookup_ctx (font, ctx, unichar);
      
      (*glyphs)[glyph_count].index = glyph_id;
      (*glyphs)[glyph_count].x     = x_advance;
      (*glyphs)[glyph_count].y     = 0;

      x_advance += (ctx_glyph_width_ctx (font, ctx, glyph_id)/font_size)*1.02f;

      glyph_count++;
      if (next && (!skip_kern)) {
        float k = ctx_glyph_kern_ctx (font, ctx, glyph_id, next);
        x_advance += k;
      }
    }
  *ret_count = glyph_count;
  *width = x_advance;
}


#endif

#if CTX_FONT_ENGINE_HARFBUZZ
typedef struct CtxHb {
  Ctx  *ctx;
  float scale;
} CtxHb;

static int ctx_glyph_lookup_hb (CtxFont *font, Ctx *ctx, uint32_t unichar)
{
  hb_codepoint_t glyph_id;
  if (hb_font_get_glyph (font->hb.font, unichar, 0, &glyph_id))
    return glyph_id;
  return -1;
}

void
_ctx_shape_hb (Ctx         *ctx,
               CtxFont     *font,
               const char  *string,
               float       *width,
               CtxGlyph   **glyphs,
               unsigned int *ret_count)
{
  float x_advance = 0;
  hb_buffer_t *buf = hb_buffer_create();
  hb_buffer_add_utf8 (buf, string, -1, 0, -1);
  hb_buffer_guess_segment_properties (buf);
  hb_shape (font->hb.font,buf, NULL, 0);
  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos (buf, ret_count);
  hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions (buf, ret_count);
  *glyphs = _ctx_glyph_target (ctx, *ret_count);
  for (unsigned int i = 0; i < *ret_count; i++)
  {
    (*glyphs)[i].index = glyph_info[i].codepoint;
    (*glyphs)[i].x     = (glyph_pos[i].x_offset + x_advance) * font->hb.scale;
    (*glyphs)[i].y     = glyph_pos[i].y_offset * font->hb.scale;;
    x_advance += glyph_pos[i].x_advance * 1.02f; // XXX eeeeeek fudge!
  }
  x_advance *= font->hb.scale;
  hb_buffer_destroy (buf);
  if (width)
    *width = x_advance;
}

static float
ctx_glyph_width_hb (CtxFont *font, Ctx *ctx, int glyph_id)
{
  float font_size = 10.0f;
  if (ctx)
  {
    CtxState *state = &ctx->state;
    font_size = state->gstate.font_size;
  }
  if (glyph_id < 0)
     return 0.0f;
  return hb_font_get_glyph_h_advance (font->hb.font, glyph_id) *
                                      font_size * font->hb.scale;
}

static int
ctx_glyph_hb (CtxFont *font, Ctx *ctx, int glyph_id, int stroke)
{
  CtxState *state = &ctx->state;
  float font_size = state->gstate.font_size;
  float origin_x = state->x;
  float origin_y = state->y;

  if (glyph_id < 0)
     return 0;
  ctx_current_point (ctx, &origin_x, &origin_y);
  ctx_translate (ctx, origin_x, origin_y);

  CtxHb ctxhb = {ctx, font_size * font->hb.scale};

#if HB_VERSION_MAJOR >= 7
  hb_font_draw_glyph (font->hb.font, glyph_id, font->hb.draw_funcs, &ctxhb);
#else
  hb_font_get_glyph_shape (font->hb.font, glyph_id, font->hb.draw_funcs, &ctxhb);
#endif
  if (stroke)
    ctx_stroke (ctx);
  else
    ctx_fill (ctx);

  ctx_translate (ctx, -origin_x, -origin_y);
  return 0;
}



static void ctx_font_unload_hb (CtxFont *font)
{
  //int pos = font->font_no;
  hb_blob_destroy (font->hb.blob);
  hb_face_destroy (font->hb.face);
  hb_font_destroy (font->hb.font);
  hb_draw_funcs_destroy (font->hb.draw_funcs);
#if HB_VERSION_MAJOR >= 7
  hb_paint_funcs_destroy (font->hb.paint_funcs);
#endif
}

static const char *ctx_font_get_name_hb (CtxFont *font)
{
  return font->hb.name;
}

static CtxFontEngine ctx_font_engine_hb =
{
  ctx_glyph_hb,
  ctx_glyph_width_hb,
  NULL, // kern
  ctx_glyph_lookup_hb,
  ctx_font_unload_hb,
  ctx_font_get_name_hb,
  NULL // vmetrics
};


static void
ctx_hb_close_path (hb_draw_funcs_t *df, CtxHb *c,
                   hb_draw_state_t *ds,    
                   void *data)
{
  //ctx_close_path (c->ctx);
}

static void
ctx_hb_move_to (hb_draw_funcs_t *df, CtxHb *c,
                hb_draw_state_t *ds,    
                float to_x, float to_y,
                void *data)
{
  ctx_move_to (c->ctx, to_x * c->scale, -to_y * c->scale);
}

static void
ctx_hb_line_to (hb_draw_funcs_t *df, CtxHb *c,
                hb_draw_state_t *ds,    
                float to_x, float to_y,
                void *data)
{
  float scale = c->scale;
  ctx_line_to (c->ctx, to_x * scale, -to_y * scale);
}

static void
ctx_hb_quadratic_to (hb_draw_funcs_t *df, CtxHb *c,
                     hb_draw_state_t *ds,
                     float control_x, float control_y,
                     float to_x, float to_y,
                     void *data)
{
  float scale = c->scale;
  ctx_quad_to (c->ctx, control_x * scale, -control_y * scale, to_x * scale, -to_y * scale);
}

static void
ctx_hb_cubic_to (hb_draw_funcs_t *df, CtxHb *c,
                 hb_draw_state_t *ds,
                 float control1_x, float control1_y,
                 float control2_x, float control2_y,
                 float to_x, float to_y,
                 void *data)
{
  float scale = c->scale;
  ctx_curve_to (c->ctx, control1_x * scale, -control1_y * scale,
                        control2_x * scale, -control2_y * scale,
                        to_x * scale, -to_y *scale);
}

int
ctx_load_font_hb (const char *name, const char *data, int length)
{
  CtxFont *font = ctx_font_get_available ();
  if (!font) return -1;

  font->type = CTX_FONT_TYPE_HB;
  if (length == -2)
    font->hb.blob = hb_blob_create_from_file (data);
  else
    font->hb.blob = hb_blob_create (data, length, HB_MEMORY_MODE_READONLY, ctx_free, NULL);
  font->hb.face = hb_face_create(font->hb.blob, 0);
  font->hb.font = hb_font_create(font->hb.face);

  font->engine = &ctx_font_engine_hb;
  hb_draw_funcs_t *funcs = hb_draw_funcs_create ();
#if HB_VERSION_MAJOR >= 7
  hb_paint_funcs_t *pfuncs = hb_paint_funcs_create ();
  if (name == NULL)
  {
    font->hb.name = ctx_malloc (64);
    unsigned int text_size = 63;
    hb_ot_name_get_utf8 (font->hb.face, HB_OT_NAME_ID_FULL_NAME, HB_LANGUAGE_INVALID, &text_size, (char*)font->hb.name);
  }
  else
  {
    font->hb.name = ctx_strdup (name);
  }
  font->hb.paint_funcs = pfuncs;
#endif

  font->hb.draw_funcs = funcs;

  hb_draw_funcs_set_move_to_func (funcs, (hb_draw_move_to_func_t) ctx_hb_move_to, NULL, NULL);
  hb_draw_funcs_set_line_to_func (funcs, (hb_draw_line_to_func_t) ctx_hb_line_to, NULL, NULL);
  hb_draw_funcs_set_quadratic_to_func (funcs, (hb_draw_quadratic_to_func_t) ctx_hb_quadratic_to, NULL, NULL);
  hb_draw_funcs_set_cubic_to_func (funcs, (hb_draw_cubic_to_func_t) ctx_hb_cubic_to, NULL, NULL);
  hb_draw_funcs_set_close_path_func (funcs, (hb_draw_close_path_func_t) ctx_hb_close_path, NULL, NULL);
  hb_font_set_scale (font->hb.font, CTX_BAKE_FONT_SIZE * 256, CTX_BAKE_FONT_SIZE * 256);
  font->hb.scale = 1.0f / (CTX_BAKE_FONT_SIZE * 256);

#if 0
  hb_font_extents_t extents;
  hb_font_get_h_extents (font->hb.font, &extents);
#endif

#if 0
  fprintf (stderr, "font: %s\n", font->hb.name);

  int named_count = hb_ot_var_get_named_instance_count (font->hb.face);
  fprintf (stderr, "  named: %i\n", named_count);
  for (int i = 0; i< named_count; i++)
  {
    hb_ot_name_id_t id =  hb_ot_var_named_instance_get_subfamily_name_id (font->hb.face, i);
    char name[64];
    unsigned int text_size = 63;
    hb_ot_name_get_utf8 (font->hb.face, id, HB_LANGUAGE_INVALID, &text_size, (char*)name);
    fprintf (stderr, "  subname %i: %s\n", i, name);
  }

  int axes_count = hb_ot_var_get_axis_count(font->hb.face);
  fprintf (stderr, "  axes: %i\n", axes_count);
  hb_ot_var_axis_info_t axes_array[axes_count];
  hb_ot_var_get_axis_infos(font->hb.face, 0, &axes_count, axes_array);

  for (int i = 0; i < axes_count; i++)
    fprintf (stderr, "  axe: %i   min: %f max: %f default: %f   tag:%c%c%c%c\n", 
       i, axes_array[i].min_value,
       axes_array[i].max_value,
       axes_array[i].default_value,
       (axes_array[i].tag >> 24) & 0xff,
       (axes_array[i].tag >> 16) & 0xff,
       (axes_array[i].tag >> 8) & 0xff,
       (axes_array[i].tag) & 0xff
       );
#endif

  if (font->engine->glyph_width (font, NULL, ctx_glyph_lookup_hb (font, NULL, 'O')) ==
      font->engine->glyph_width (font, NULL, ctx_glyph_lookup_hb (font, NULL, 'I')))
    font->monospaced = 1;

  return font->font_no;
}

#endif

#if CTX_FONT_ENGINE_CTX_FS

static float
ctx_glyph_width_ctx_fs (CtxFont *font, Ctx *ctx, uint32_t unichar)
{
  CtxState *state = &ctx->state;
  char path[1024];
  sprintf (path, "%s/%010x", font->ctx_fs.path, (uint32_t)unichar);
  uint8_t *data = NULL;
  long int len_bytes = 0;
  ctx_get_contents (path, &data, &len_bytes);
  float ret = 0.0;
  float font_size = state->gstate.font_size;
  if (data){
    Ctx *glyph_ctx = ctx_new_drawlist (100, 100);
    ctx_parse (glyph_ctx, (char*)data);
    for (uint32_t i = 0; i < glyph_ctx->drawlist.count; i++)
    {
      CtxEntry *e = &glyph_ctx->drawlist.entries[i];
      if (e->code == CTX_DEFINE_GLYPH)
        ret = e->data.u32[1] / 256.0f * font_size / CTX_BAKE_FONT_SIZE;
    }
    ctx_free (data);
    ctx_destroy (glyph_ctx);
  }
  return ret;
}

static int
ctx_glyph_ctx_fs (CtxFont *font, Ctx *ctx, uint32_t unichar, int stroke)
{
  char path[1024];
  sprintf (path, "file://%s/%010x", font->ctx_fs.path, unichar);
  uint8_t *data = NULL;
  long int len_bytes = 0;
  ctx_get_contents (path, &data, &len_bytes);

  if (data){
    Ctx *glyph_ctx = ctx_new_drawlist (100, 100);
    ctx_parse (glyph_ctx, (char*)data);
    int ret = ctx_glyph_drawlist (font, ctx, &(glyph_ctx->drawlist),
                                  unichar, stroke);
    ctx_free (data);
    ctx_destroy (glyph_ctx);
    return ret;
  }
  return -1;
}

int
ctx_load_font_ctx_fs (const char *name, const void *data, int length);

static int ctx_glyph_lookup_ctx_fs (CtxFont *font, Ctx *ctx, uint32_t unichar)
{ return unichar;
}

static const char *ctx_font_get_name_ctx_fs (CtxFont *font)
{
  return font->ctx_fs.name;
}

static CtxFontEngine ctx_font_engine_ctx_fs =
{
  ctx_glyph_ctx_fs,
  ctx_glyph_width_ctx_fs,
  NULL, // kern
  ctx_glyph_lookup_ctx_fs,
  NULL,
  ctx_font_get_name_ctx_fs,
  NULL // vmetrics
};

int
ctx_load_font_ctx_fs (const char *name, const void *path, int length) // length is ignored
{
  CtxFont *font = ctx_font_get_available ();
  if (!font) return -1;

  font->type = CTX_FONT_TYPE_FS;
  font->ctx_fs.name = strdup (name);
  font->ctx_fs.path = ctx_strdup (path);
  int path_len = ctx_strlen (path);
  if (font->ctx_fs.path[path_len-1] == '/')
   font->ctx_fs.path[path_len-1] = 0;
  font->engine = &ctx_font_engine_ctx_fs;
  return font->font_no;
}

#endif

#if CTX_FORMATTER

typedef struct _CtxFormatter  CtxFormatter;
struct _CtxFormatter 
{
  void *target; // FILE
  int   longform;
  int   indent;
  int   pos;
  void (*add_str)(CtxFormatter *formatter, const char *str, int len);
};

static inline void ctx_formatter_addstr (CtxFormatter *formatter, const char *str, int len)
{
  formatter->add_str (formatter, str, len);
  formatter->pos += len;
}

#if 0
static inline void ctx_formatter_addstrf (CtxFormatter *formatter, const char *format, ...)
{
   va_list ap;
   size_t needed;
   char *buffer;
   va_start (ap, format);
   needed = vsnprintf (NULL, 0, format, ap) + 1;
   buffer = (char*) ctx_malloc (needed);
   va_end (ap);
   va_start (ap, format);
   vsnprintf (buffer, needed, format, ap);
   va_end (ap);
   ctx_formatter_addstr (formatter, buffer, -1);
   ctx_free (buffer);
}
#endif


static void
ctx_print_int (CtxFormatter *formatter, int val, int strip_zero)
{
  char buf[64];
  char *bp = &buf[0];
  int remainder;
  if (val < 0)
  {
    buf[0]='-';
    bp++;
    remainder = -val;
  }
  else
  remainder = val;

  int len = 0;
  do {
    int digit = remainder % 10;
    bp[len++] = digit + '0';
    remainder /= 10;
  } while (remainder);

  bp[len]=0;
  for (int i = 0; i < len/2; i++)
  {
    int tmp = bp[i];
    bp[i] = bp[len-1-i];
    bp[len-1-i] = tmp;
  }
  len += (val < 0);
  if (strip_zero)
    for (int i = len-1; i; i--)
    {
      if (buf[i]=='0'){ buf[i] = 0;len--;}
      else break;
    }
  ctx_formatter_addstr (formatter, buf, len);
}

static void
ctx_print_float (CtxFormatter *formatter, float val)
{
  if (val < 0.0f)
  {
    ctx_formatter_addstr (formatter, "-", 1);
    val = -val;
  }
  int remainder = ((int)(val*10000))%10000;
  if (remainder % 10 > 5)
    remainder = remainder/10+1;
  else
    remainder /= 10;

  if (!formatter->longform && ((((int)val))==0) && (remainder))
  {
    // 
  }
  else
  {
    ctx_print_int (formatter, (int)val, 0);
  }


  if (remainder)
  {
    ctx_formatter_addstr (formatter, ".", 1);
    if (remainder < 10)
      ctx_formatter_addstr (formatter, "0", 1);
    if (remainder < 100)
      ctx_formatter_addstr (formatter, "0", 1);
    ctx_print_int (formatter, remainder, 1);
  }
}

static void _ctx_stream_addstr (CtxFormatter *formatter, const char *str, int len)
{
  if (!str || len == 0)
  {
    return;
  }
  if (len < 0) len = ctx_strlen (str);
  fwrite (str, len, 1, (FILE*)formatter->target);
}

static void _ctx_fd_addstr (CtxFormatter *formatter, const char *str, int len)
{
  if (!str || len == 0)
  {
    return;
  }
  if (len < 0) len = ctx_strlen (str);
  write ((size_t)formatter->target, str, len);
}


void _ctx_string_addstr (CtxFormatter *formatter, const char *str, int len)
{
  if (!str || len == 0)
    return;
  if (len < 0) len = ctx_strlen (str);
  ctx_string_append_data ((CtxString*)(formatter->target), str, len);
}

static void _ctx_print_endcmd (CtxFormatter *formatter)
{
  if (formatter->longform)
    ctx_formatter_addstr (formatter, ");\n", 3);
}

static void _ctx_indent (CtxFormatter *formatter)
{
  for (int i = 0; i < formatter->indent; i++)
    ctx_formatter_addstr (formatter, "  ", 2);
}

const char *_ctx_code_to_name (int code)
{
      switch (code)
        {
          case CTX_REL_LINE_TO_X4:           return "relLinetoX4"; break;
          case CTX_REL_LINE_TO_REL_CURVE_TO: return "relLineToRelCurveTo"; break;
          case CTX_REL_CURVE_TO_REL_LINE_TO: return "relCurveToRelLineTo"; break;
          case CTX_REL_CURVE_TO_REL_MOVE_TO: return "relCurveToRelMoveTo"; break;
          case CTX_REL_LINE_TO_X2:           return "relLineToX2"; break;
          case CTX_MOVE_TO_REL_LINE_TO:      return "moveToRelLineTo"; break;
          case CTX_REL_LINE_TO_REL_MOVE_TO:  return "relLineToRelMoveTo"; break;
          case CTX_FILL_MOVE_TO:             return "fillMoveTo"; break;
          case CTX_REL_QUAD_TO_REL_QUAD_TO:  return "relQuadToRelQuadTo"; break;
          case CTX_REL_QUAD_TO_S16:          return "relQuadToS16"; break;

          case CTX_SET_KEY:              return "setParam"; break;
          case CTX_COLOR:                return "setColor"; break;
          case CTX_DEFINE_GLYPH:         return "defineGlyph"; break;
          case CTX_DEFINE_FONT:          return "defineFont"; break;
          case CTX_KERNING_PAIR:         return "kerningPair"; break;
          case CTX_SET_PIXEL:            return "setPixel"; break;
          case CTX_GLOBAL_ALPHA:         return "globalAlpha"; break;
          case CTX_TEXT:                 return "text"; break;
          case CTX_SAVE:                 return "save"; break;
          case CTX_RESTORE:              return "restore"; break;
          case CTX_STROKE_SOURCE:        return "strokeSource"; break;
          case CTX_NEW_PAGE:             return "newPage"; break;
          case CTX_START_GROUP:          return "startGroup"; break;
          case CTX_END_GROUP:            return "endGroup"; break;
          case CTX_RECTANGLE:            return "rectangle"; break;
          case CTX_ROUND_RECTANGLE:      return "roundRectangle"; break;
          case CTX_LINEAR_GRADIENT:      return "linearGradient"; break;
          case CTX_CONIC_GRADIENT:       return "conicGradient"; break;
          case CTX_RADIAL_GRADIENT:      return "radialGradient"; break;
          case CTX_GRADIENT_STOP:        return "gradientAddStop"; break;
          case CTX_VIEW_BOX:             return "viewBox"; break;
          case CTX_MOVE_TO:              return "moveTo"; break;
          case CTX_LINE_TO:              return "lineTo"; break;
          case CTX_RESET_PATH:           return "resetPath"; break;
          case CTX_REL_MOVE_TO:          return "relMoveTo"; break;
          case CTX_REL_LINE_TO:          return "relLineTo"; break;
          case CTX_FILL:                 return "fill"; break;
          case CTX_PAINT:                return "paint"; break;
          case CTX_APPLY_TRANSFORM:      return "transform"; break;
          case CTX_SOURCE_TRANSFORM:     return "sourceTransform"; break;
          case CTX_REL_ARC_TO:           return "relArcTo"; break;
          case CTX_GLYPH:                return "glyph"; break;
          case CTX_TEXTURE:              return "texture"; break;
          case CTX_DEFINE_TEXTURE:       return "defineTexture"; break;
          case CTX_IDENTITY:             return "identity"; break;
          case CTX_CLOSE_PATH:           return "closePath"; break;
          case CTX_PRESERVE:             return "preserve"; break;
          case CTX_START_FRAME:          return "startFrame"; break;
          case CTX_END_FRAME:            return "endFrame"; break;
          case CTX_FONT:                 return "font"; break;
          case CTX_STROKE:               return "stroke"; break;
          case CTX_CLIP:                 return "clip"; break;
          case CTX_ARC:                  return "arc"; break;
          case CTX_SCALE:                return "scale"; break;
          case CTX_TRANSLATE:            return "translate"; break;
          case CTX_ROTATE:               return "rotate"; break;
          case CTX_ARC_TO:               return "arcTo"; break;
          case CTX_CURVE_TO:             return "curveTo"; break;
          case CTX_REL_CURVE_TO:         return "relCurveTo"; break;
          case CTX_REL_QUAD_TO:          return "relQuadTo"; break;
          case CTX_QUAD_TO:              return "quadTo"; break;
          case CTX_SMOOTH_TO:            return "smoothTo"; break;
          case CTX_REL_SMOOTH_TO:        return "relSmoothTo"; break;
          case CTX_SMOOTHQ_TO:           return "smoothqTo"; break;
          case CTX_REL_SMOOTHQ_TO:       return "relSmoothqTo"; break;
          case CTX_HOR_LINE_TO:          return "horLineTo"; break;
          case CTX_VER_LINE_TO:          return "verLineTo"; break;
          case CTX_REL_HOR_LINE_TO:      return "relHorLineTo"; break;
          case CTX_REL_VER_LINE_TO:      return "relVerLineTo"; break;
          case CTX_COMPOSITING_MODE:     return "compositingMode"; break;
          case CTX_BLEND_MODE:           return "blendMode"; break;
          case CTX_EXTEND:               return "extend"; break;
          case CTX_TEXT_ALIGN:           return "textAlign"; break;
          case CTX_TEXT_BASELINE:        return "textBaseline"; break;
          case CTX_TEXT_DIRECTION:       return "textDirection"; break;
          case CTX_FONT_SIZE:            return "fontSize"; break;
          case CTX_MITER_LIMIT:          return "miterLimit"; break;
          case CTX_LINE_JOIN:            return "lineJoin"; break;
          case CTX_LINE_CAP:             return "lineCap"; break;
          case CTX_LINE_WIDTH:           return "lineWidth"; break;
          case CTX_LINE_DASH_OFFSET:     return "lineDashOffset"; break;
          case CTX_STROKE_POS:           return "strokePos"; break;
          case CTX_FEATHER:              return "feather"; break;
          case CTX_LINE_HEIGHT:          return "lineHeight";break;
          case CTX_WRAP_LEFT:            return "wrapLeft"; break;
          case CTX_WRAP_RIGHT:           return "wrapRight"; break;
          case CTX_IMAGE_SMOOTHING:      return "imageSmoothing"; break;
          case CTX_SHADOW_BLUR:          return "shadowBlur";  break;
          case CTX_FILL_RULE:            return "fillRule"; break;
        }
      return NULL;
}

static void _ctx_print_name (CtxFormatter *formatter, int code)
{
#define CTX_VERBOSE_NAMES 1
#if CTX_VERBOSE_NAMES
  if (formatter->longform)
    {
      const char *name = NULL;
      _ctx_indent (formatter);
      //switch ((CtxCode)code)
      name = _ctx_code_to_name (code);
      if (name)
        {
          ctx_formatter_addstr (formatter, name, -1);
          ctx_formatter_addstr (formatter, " (", 2);
          if (code == CTX_SAVE)
            { formatter->indent ++; }
          else if (code == CTX_RESTORE)
            { formatter->indent --; }
          return;
        }
    }
#endif
  {
    char name[3];
    name[0]=CTX_SET_KEY;
    name[2]='\0';
    switch (code)
      {
        case CTX_GLOBAL_ALPHA:      name[1]='a'; break;
        case CTX_TEXT_BASELINE:     name[1]='b'; break;
        case CTX_LINE_CAP:          name[1]='c'; break;
        case CTX_TEXT_DIRECTION:    name[1]='d'; break;
        case CTX_EXTEND:            name[1]='e'; break;
        case CTX_FONT_SIZE:         name[1]='f'; break;
        case CTX_LINE_JOIN:         name[1]='j'; break;
        case CTX_MITER_LIMIT:       name[1]='l'; break;
        case CTX_COMPOSITING_MODE:  name[1]='m'; break;
        case CTX_STROKE_POS:        name[1]='p'; break;
        case CTX_FEATHER:           name[1]='F'; break;
        case CTX_FILL_RULE:         name[1]='r'; break;
        case CTX_SHADOW_BLUR:       name[1]='s'; break;
        case CTX_TEXT_ALIGN:        name[1]='t'; break;
        case CTX_LINE_WIDTH:        name[1]='w'; break;
        case CTX_SHADOW_OFFSET_X:   name[1]='x'; break;
        case CTX_SHADOW_OFFSET_Y:   name[1]='y'; break;
        case CTX_BLEND_MODE:        name[1]='B'; break;
        case CTX_SHADOW_COLOR:      name[1]='C'; break;
        case CTX_LINE_DASH_OFFSET:  name[1]='D'; break;
        case CTX_LINE_HEIGHT:       name[1]='H'; break;
        case CTX_WRAP_LEFT:         name[1]='L'; break;
        case CTX_WRAP_RIGHT:        name[1]='R'; break;
        case CTX_IMAGE_SMOOTHING:   name[1]='S'; break;
        default:
          name[0] = code;
          name[1] = 0;
          break;
      }
    ctx_formatter_addstr (formatter, name, -1);
    if (formatter->longform)
      ctx_formatter_addstr (formatter, " (", 2);
    else if (ctx_arguments_for_code (code)<1 || ctx_arguments_for_code(code)>8)
      ctx_formatter_addstr (formatter, " ", 1);
  }
}

static void
ctx_print_entry_enum (CtxFormatter *formatter, CtxEntry *entry, int args)
{
  _ctx_print_name (formatter, entry->code);
  for (int i = 0; i <  args; i ++)
    {
      int val = ctx_arg_u8 (i);
      if (i>0)
        { 
          ctx_formatter_addstr (formatter, " ", 1);
        }
#if CTX_VERBOSE_NAMES
      if (formatter->longform)
        {
          const char *str = NULL;
          switch (entry->code)
            {
              case CTX_TEXT_BASELINE:
                switch (val)
                  {
                    case CTX_TEXT_BASELINE_ALPHABETIC: str = "alphabetic"; break;
                    case CTX_TEXT_BASELINE_TOP:        str = "top";        break;
                    case CTX_TEXT_BASELINE_BOTTOM:     str = "bottom";     break;
                    case CTX_TEXT_BASELINE_HANGING:    str = "hanging";    break;
                    case CTX_TEXT_BASELINE_MIDDLE:     str = "middle";     break;
                    case CTX_TEXT_BASELINE_IDEOGRAPHIC:str = "ideographic";break;
                  }
                break;
              case CTX_TEXT_ALIGN:
                switch (val)
                  {
                    case CTX_TEXT_ALIGN_LEFT:   str = "left"; break;
                    case CTX_TEXT_ALIGN_RIGHT:  str = "right"; break;
                    case CTX_TEXT_ALIGN_START:  str = "start"; break;
                    case CTX_TEXT_ALIGN_END:    str = "end"; break;
                    case CTX_TEXT_ALIGN_CENTER: str = "center"; break;
                  }
                break;
              case CTX_LINE_CAP:
                switch (val)
                  {
                    case CTX_CAP_NONE:   str = "none"; break;
                    case CTX_CAP_ROUND:  str = "round"; break;
                    case CTX_CAP_SQUARE: str = "square"; break;
                  }
                break;
              case CTX_LINE_JOIN:
                switch (val)
                  {
                    case CTX_JOIN_MITER: str = "miter"; break;
                    case CTX_JOIN_ROUND: str = "round"; break;
                    case CTX_JOIN_BEVEL: str = "bevel"; break;
                  }
                break;
              case CTX_FILL_RULE:
                switch (val)
                  {
                    case CTX_FILL_RULE_WINDING:  str = "winding"; break;
                    case CTX_FILL_RULE_EVEN_ODD: str = "evenodd"; break;
                  }
                break;
              case CTX_EXTEND:
                switch (val)
                  {
                    case CTX_EXTEND_NONE:    str = "none"; break;
                    case CTX_EXTEND_PAD:     str = "pad"; break;
                    case CTX_EXTEND_REPEAT:  str = "repeat"; break;
                    case CTX_EXTEND_REFLECT: str = "reflect"; break;
                  }
                break;
              case CTX_BLEND_MODE:
                val = ctx_arg_u32 (i);
                switch (val)
                  {
            case CTX_BLEND_NORMAL:      str = "normal"; break;
            case CTX_BLEND_MULTIPLY:    str = "multiply"; break;
            case CTX_BLEND_SCREEN:      str = "screen"; break;
            case CTX_BLEND_OVERLAY:     str = "overlay"; break;
            case CTX_BLEND_DARKEN:      str = "darken"; break;
            case CTX_BLEND_LIGHTEN:     str = "lighten"; break;
            case CTX_BLEND_COLOR_DODGE: str = "colorDodge"; break;
            case CTX_BLEND_COLOR_BURN:  str = "colorBurn"; break;
            case CTX_BLEND_HARD_LIGHT:  str = "hardLight"; break;
            case CTX_BLEND_SOFT_LIGHT:  str = "softLight"; break;
            case CTX_BLEND_DIFFERENCE:  str = "difference"; break;
            case CTX_BLEND_EXCLUSION:   str = "exclusion"; break;
            case CTX_BLEND_HUE:         str = "hue"; break;
            case CTX_BLEND_SATURATION:  str = "saturation"; break;
            case CTX_BLEND_COLOR:       str = "color"; break; 
            case CTX_BLEND_LUMINOSITY:  str = "luminosity"; break;
                  }
                break;
              case CTX_COMPOSITING_MODE:
                val = ctx_arg_u32 (i);
                switch (val)
                  {
              case CTX_COMPOSITE_SOURCE_OVER: str = "sourceOver"; break;
              case CTX_COMPOSITE_COPY: str = "copy"; break;
              case CTX_COMPOSITE_CLEAR: str = "clear"; break;
              case CTX_COMPOSITE_SOURCE_IN: str = "sourceIn"; break;
              case CTX_COMPOSITE_SOURCE_OUT: str = "sourceOut"; break;
              case CTX_COMPOSITE_SOURCE_ATOP: str = "sourceAtop"; break;
              case CTX_COMPOSITE_DESTINATION: str = "destination"; break;
              case CTX_COMPOSITE_DESTINATION_OVER: str = "destinationOver"; break;
              case CTX_COMPOSITE_DESTINATION_IN: str = "destinationIn"; break;
              case CTX_COMPOSITE_DESTINATION_OUT: str = "destinationOut"; break;
              case CTX_COMPOSITE_DESTINATION_ATOP: str = "destinationAtop"; break;
              case CTX_COMPOSITE_XOR: str = "xor"; break;
                  }

               break;
            }
          if (str)
            {
              ctx_formatter_addstr (formatter, str, -1);
            }
          else
            {
              ctx_print_int (formatter, val, 0);
            }
        }
      else
#endif
        {
          ctx_print_int (formatter, val, 0);
        }
    }
  _ctx_print_endcmd (formatter);
}

#if 0
static void
ctx_print_a85 (CtxFormatter *formatter, uint8_t *data, int length)
{
  char *tmp = (char*)ctx_malloc (ctx_a85enc_len (length));
  ctx_a85enc (data, tmp, length);
  ctx_formatter_addstr (formatter, " ~", 2);
  ctx_formatter_addstr (formatter, tmp, -1);
  ctx_formatter_addstr (formatter, "~ ", 2);
  ctx_free (tmp);
}
#endif

static void
ctx_print_yenc (CtxFormatter *formatter, uint8_t *data, int length)
{
  char *tmp = (char*)ctx_malloc (length * 2 + 2);// worst case scenario
  int enclength = ctx_yenc ((char*)data, tmp, length);
  data[enclength]=0;
  ctx_formatter_addstr (formatter, " =", 2);
  ctx_formatter_addstr (formatter, tmp, enclength);
  ctx_formatter_addstr (formatter, "=y ", 2);
  ctx_free (tmp);
}

static void
ctx_print_escaped_string (CtxFormatter *formatter, const char *string)
{
  if (!string) { return; }
  for (int i = 0; string[i]; i++)
    {
      switch (string[i])
        {
          case '"':
            ctx_formatter_addstr (formatter, "\\\"", 2);
            break;
          case '\\':
            ctx_formatter_addstr (formatter, "\\\\", 2);
            break;
          case '\n':
            ctx_formatter_addstr (formatter, "\\n", 2);
            break;
          default:
            ctx_formatter_addstr (formatter, &string[i], 1);
        }
    }
}


static void
ctx_print_entry (CtxFormatter *formatter, CtxEntry *entry, int args)
{
  _ctx_print_name (formatter, entry->code);
  for (int i = 0; i <  args; i ++)
    {
      float val = ctx_arg_float (i);
      if (i>0 /* && val >= 0.0f */)
        {
          if (formatter->longform)
            {
              ctx_formatter_addstr (formatter, ", ", 2);
            }
          else
            {
              ctx_formatter_addstr (formatter, " ", 1);
            }
        }
      ctx_print_float (formatter, val);
    }
  _ctx_print_endcmd (formatter);
}

static void
ctx_print_glyph (CtxFormatter *formatter, CtxEntry *entry, int args)
{
  _ctx_print_name (formatter, entry->code);
  ctx_print_int (formatter, entry->data.u32[0], 0);
  _ctx_print_endcmd (formatter);
}

static void
ctx_formatter_process (void *user_data, CtxCommand *c);


static void
ctx_formatter_process (void *user_data, CtxCommand *c)
{
  CtxEntry *entry = &c->entry;
  CtxFormatter *formatter = (CtxFormatter*)user_data;

  switch (entry->code)
  //switch ((CtxCode)(entry->code))
    {
      case CTX_GLYPH:
        ctx_print_glyph (formatter, entry, 1);
        break;
      case CTX_LINE_TO:
      case CTX_REL_LINE_TO:
      case CTX_SCALE:
      case CTX_TRANSLATE:
      case CTX_MOVE_TO:
      case CTX_REL_MOVE_TO:
      case CTX_SMOOTHQ_TO:
      case CTX_REL_SMOOTHQ_TO:
        ctx_print_entry (formatter, entry, 2);
        break;
      case CTX_TEXTURE:
        _ctx_print_name (formatter, entry->code);
        ctx_formatter_addstr (formatter, "\"", -1);
        ctx_print_escaped_string (formatter, c->texture.eid);
        ctx_formatter_addstr (formatter, "\", ", 2);
        ctx_print_float (formatter, c->texture.x);
        ctx_formatter_addstr (formatter, ", ", 2);
        ctx_print_float (formatter, c->texture.y);
        ctx_formatter_addstr (formatter, " ", 1);
        _ctx_print_endcmd (formatter);
        break;

      case CTX_DEFINE_TEXTURE:
        {
        _ctx_print_name (formatter, entry->code);
        ctx_formatter_addstr (formatter, "\"", 1);
        ctx_print_escaped_string (formatter, c->define_texture.eid);
        ctx_formatter_addstr (formatter, "\", ", 2);
        ctx_print_int (formatter, c->define_texture.width, 0);
        ctx_formatter_addstr (formatter, ", ", 2);
        ctx_print_int (formatter, c->define_texture.height, 0);
        ctx_formatter_addstr (formatter, ", ", 2);
        ctx_print_int (formatter, c->define_texture.format, 0);
        ctx_formatter_addstr (formatter, ", ", 2);

        uint8_t *pixel_data = ctx_define_texture_pixel_data (entry);
#if 1

        int stride = ctx_pixel_format_get_stride ((CtxPixelFormat)c->define_texture.format, c->define_texture.width);
        int data_len = stride * c->define_texture.height;
        if (c->define_texture.format == CTX_FORMAT_YUV420)
          data_len = c->define_texture.height * c->define_texture.width +
                       2*(c->define_texture.height/2) * (c->define_texture.width/2);
        //fprintf (stderr, "encoding %i bytes\n", c->define_texture.height *stride);
        //ctx_print_a85 (formatter, pixel_data, c->define_texture.height * stride);
        ctx_print_yenc (formatter, pixel_data, data_len);
#else
        ctx_formatter_addstrf (formatter, "\"", 1);
        ctx_print_escaped_string (formatter, pixel_data);
        ctx_formatter_addstrf (formatter, "\" ");

#endif

        _ctx_print_endcmd (formatter);
        }
        break;

      case CTX_REL_ARC_TO:
      case CTX_ARC_TO:
        ctx_print_entry (formatter, entry, 7);
        break;
      case CTX_ROUND_RECTANGLE:
        ctx_print_entry (formatter, entry, 5);
        break;
      case CTX_CURVE_TO:
      case CTX_REL_CURVE_TO:
      case CTX_ARC:
      case CTX_RADIAL_GRADIENT:
        ctx_print_entry (formatter, entry, 6);
        break;
      case CTX_APPLY_TRANSFORM:
      case CTX_SOURCE_TRANSFORM:
        ctx_print_entry (formatter, entry, 9);
        break;
      case CTX_CONIC_GRADIENT:
      case CTX_QUAD_TO:
      case CTX_RECTANGLE:
      case CTX_REL_QUAD_TO:
      case CTX_LINEAR_GRADIENT:
      case CTX_VIEW_BOX:
      case CTX_SMOOTH_TO:
      case CTX_REL_SMOOTH_TO:
        ctx_print_entry (formatter, entry, 4);
        break;
      case CTX_FONT_SIZE:
      case CTX_MITER_LIMIT:
      case CTX_ROTATE:
      case CTX_LINE_WIDTH:
      case CTX_LINE_DASH_OFFSET:
      case CTX_STROKE_POS:
      case CTX_FEATHER:
      case CTX_LINE_HEIGHT:
      case CTX_WRAP_LEFT:
      case CTX_WRAP_RIGHT:
      case CTX_GLOBAL_ALPHA:
      case CTX_SHADOW_BLUR:
      case CTX_SHADOW_OFFSET_X:
      case CTX_SHADOW_OFFSET_Y:
      case CTX_VER_LINE_TO:
      case CTX_HOR_LINE_TO:
      case CTX_REL_VER_LINE_TO:
      case CTX_REL_HOR_LINE_TO:
        ctx_print_entry (formatter, entry, 1);
        break;
#if 0
      case CTX_SET:
        _ctx_print_name (formatter, entry->code);
        switch (c->set.key_hash)
        {
           case SQZ_x: ctx_formatter_addstrf (formatter, " 'x' "); break;
           case SQZ_y: ctx_formatter_addstrf (formatter, " 'y' "); break;
           case SQZ_width: ctx_formatter_addstrf (formatter, " width "); break;
           case SQZ_height: ctx_formatter_addstrf (formatter, " height "); break;
           default:
             ctx_formatter_addstrf (formatter, " %d ", c->set.key_hash);
        }
        ctx_formatter_addstrf (formatter, "\"", 1);
        ctx_print_escaped_string (formatter, (char*)c->set.utf8);
        ctx_formatter_addstrf (formatter, "\"", 1);
        _ctx_print_endcmd (formatter);
        break;
#endif
      case CTX_COLOR:
        if (1)//formatter->longform)
          {
            _ctx_indent (formatter);
            int model = (int) c->set_color.model;
            const char *suffix="";
            if (model & 512)
            {
              model = model & 511;
              suffix = "S";
            }
            switch (model)
              {
                case CTX_GRAY:
                  ctx_formatter_addstr (formatter, "gray", 4);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);

                  ctx_print_float (formatter, c->graya.g);
                  break;
                case CTX_GRAYA:
                  ctx_formatter_addstr (formatter, "graya", 5);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);

                  ctx_print_float (formatter, c->graya.g);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->graya.a);
                  break;
                case CTX_RGBA:
                  if (c->rgba.a != 1.0f)
                  {
                    ctx_formatter_addstr (formatter, "rgba", 4);
                    ctx_formatter_addstr (formatter, suffix, -1);
                    ctx_formatter_addstr (formatter, " ", 1);

                    ctx_print_float (formatter, c->rgba.r);
                    ctx_formatter_addstr (formatter, " ", 1);
                    ctx_print_float (formatter, c->rgba.g);
                    ctx_formatter_addstr (formatter, " ", 1);
                    ctx_print_float (formatter, c->rgba.b);
                    ctx_formatter_addstr (formatter, " ", 1);
                    ctx_print_float (formatter, c->rgba.a);
                    break;
                  }
                  /* FALLTHROUGH */
                case CTX_RGB:
                  if (c->rgba.r == c->rgba.g && c->rgba.g == c->rgba.b)
                  {
                    ctx_formatter_addstr (formatter, "gray", 4);
                    ctx_formatter_addstr (formatter, suffix, -1);
                    ctx_formatter_addstr (formatter, " ", 1);

                    ctx_print_float (formatter, c->rgba.r);
                    ctx_formatter_addstr (formatter, " ", 1);
                    break;
                  }
                  ctx_formatter_addstr (formatter, "rgb", 3);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.r);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.g);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.b);
                  break;
                case CTX_DRGB:
                  ctx_formatter_addstr (formatter, "drgb", 4);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);

                  ctx_print_float (formatter, c->rgba.r);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.g);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.b);
                  break;
                case CTX_DRGBA:
                  ctx_formatter_addstr (formatter, "drgba", 5);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);

                  ctx_print_float (formatter, c->rgba.r);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.g);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.b);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->rgba.a);
                  break;
                case CTX_CMYK:
                  ctx_formatter_addstr (formatter, "cmyk", 4);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);

                  ctx_print_float (formatter, c->cmyka.c);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.m);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.y);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.k);
                  break;
                case CTX_CMYKA:
                  ctx_formatter_addstr (formatter, "cmyk", 5);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.c);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.m);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.y);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.k);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.a);
                  break;
                case CTX_DCMYK:
                  ctx_formatter_addstr (formatter, "dcmyk", 6);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.c);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.m);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.y);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.k);
                  break;
                case CTX_DCMYKA:
                  ctx_formatter_addstr (formatter, "dcmyka", 7);
                  ctx_formatter_addstr (formatter, suffix, -1);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.c);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.m);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.y);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.k);
                  ctx_formatter_addstr (formatter, " ", 1);
                  ctx_print_float (formatter, c->cmyka.a);
                  break;
              }
          }
        else
          {
            ctx_print_entry (formatter, entry, 1);
          }
        break;
      case CTX_SET_RGBA_U8:
        if (formatter->longform)
            _ctx_indent (formatter);

        if (ctx_arg_u8(3)==255)
        {
          int components = 3;
          if (
            (ctx_arg_u8 (0) ==
            ctx_arg_u8 (1)) &&
            (ctx_arg_u8 (1) ==
             ctx_arg_u8 (2)))
          {
            components = 1;
          }

        ctx_formatter_addstr (formatter, components==1?"gray":"rgb", -1);
        if (formatter->longform)
            ctx_formatter_addstr (formatter, " (", -1);

        for (int c = 0; c < components; c++)
          {
            if (c)
              {
                if (formatter->longform)
                  ctx_formatter_addstr (formatter, ", ", 2);
                else
                  ctx_formatter_addstr (formatter, " ", 1);
              }
            ctx_print_float (formatter, ctx_u8_to_float (ctx_arg_u8 (c) ) );
          }

        }
        else
        {

        ctx_formatter_addstr (formatter, "rgba", -1);
        if (formatter->longform)
            ctx_formatter_addstr (formatter, " (", -1);

        for (int c = 0; c < 4; c++)
          {
            if (c)
              {
                if (formatter->longform)
                  ctx_formatter_addstr (formatter, ", ", 2);
                else
                  ctx_formatter_addstr (formatter, " ", 1);
              }
            ctx_print_float (formatter, ctx_u8_to_float (ctx_arg_u8 (c) ) );
          }
        }
        _ctx_print_endcmd (formatter);
        break;
      case CTX_SET_PIXEL:
#if 0
        ctx_set_pixel_u8 (d_ctx,
                          ctx_arg_u16 (2), ctx_arg_u16 (3),
                          ctx_arg_u8 (0),
                          ctx_arg_u8 (1),
                          ctx_arg_u8 (2),
                          ctx_arg_u8 (3) );
#endif
        break;
      case CTX_FILL:
      case CTX_PAINT:
      case CTX_START_FRAME:
      case CTX_STROKE:
      case CTX_IDENTITY:
      case CTX_CLIP:
      case CTX_RESET_PATH:
      case CTX_CLOSE_PATH:
      case CTX_SAVE:
      case CTX_PRESERVE:
      case CTX_START_GROUP:
      case CTX_NEW_PAGE:
      case CTX_END_GROUP:
      case CTX_RESTORE:
      case CTX_STROKE_SOURCE:
        ctx_print_entry (formatter, entry, 0);
        break;
      case CTX_TEXT_ALIGN:
      case CTX_TEXT_BASELINE:
      case CTX_TEXT_DIRECTION:
      case CTX_FILL_RULE:
      case CTX_LINE_CAP:
      case CTX_LINE_JOIN:
      case CTX_COMPOSITING_MODE:
      case CTX_BLEND_MODE:
      case CTX_EXTEND:
      case CTX_IMAGE_SMOOTHING:
        ctx_print_entry_enum (formatter, entry, 1);
        break;
      case CTX_GRADIENT_STOP:
        _ctx_print_name (formatter, entry->code);
        ctx_print_float (formatter, ctx_arg_float (0));
        for (int c = 0; c < 4; c++)
          {
            ctx_formatter_addstr (formatter, " ", 1);
            ctx_print_float (formatter, ctx_u8_to_float (ctx_arg_u8 (4+c) ) );
          }
        _ctx_print_endcmd (formatter);
        break;
      case CTX_TEXT:
      case CTX_FONT:
        _ctx_print_name (formatter, entry->code);
        ctx_formatter_addstr (formatter, "\"", 1);
        ctx_print_escaped_string (formatter, ctx_arg_string() );
        ctx_formatter_addstr (formatter, "\"", 1);
        _ctx_print_endcmd (formatter);
        break;
      case CTX_CONT:
      case CTX_DATA:
      case CTX_DATA_REV:
      case CTX_END_FRAME:
        break;

      case CTX_DEFINE_FONT:
        _ctx_print_name (formatter, entry->code);
        ctx_formatter_addstr (formatter, "\"", 1);
        ctx_print_escaped_string (formatter, ctx_arg_string());
        ctx_formatter_addstr (formatter, "\"", 1);
        _ctx_print_endcmd (formatter);
        // XXX: todo, also print license if present
        break;

      case CTX_KERNING_PAIR:
        _ctx_print_name (formatter, entry->code);
        ctx_formatter_addstr (formatter, "\"", 1);
        {
           uint8_t utf8[16];
           utf8[ctx_unichar_to_utf8 (c->kern.glyph_before, utf8)]=0;
           ctx_print_escaped_string (formatter, (char*)utf8);
           ctx_formatter_addstr (formatter, "\", \"", -1);
           utf8[ctx_unichar_to_utf8 (c->kern.glyph_after, utf8)]=0;
           ctx_print_escaped_string (formatter, (char*)utf8);
           ctx_formatter_addstr (formatter, "\", ", 3);
           ctx_print_float (formatter, c->kern.amount/256.0f);
           ctx_print_escaped_string (formatter, (char*)utf8);
        }
        _ctx_print_endcmd (formatter);
        break;

      case CTX_DEFINE_GLYPH:
        _ctx_print_name (formatter, entry->code);
        ctx_formatter_addstr (formatter, "\"", 1);
        {
           uint8_t utf8[16];
           utf8[ctx_unichar_to_utf8 (entry->data.u32[0], utf8)]=0;
           ctx_print_escaped_string (formatter, (char*)utf8);
           ctx_formatter_addstr (formatter, "\", ", 3);
           ctx_print_float (formatter, entry->data.u32[1]/256.0f);
        }
        _ctx_print_endcmd (formatter);
        break;
    }
}

void
ctx_render_stream (Ctx *ctx, FILE *stream, CtxFormatterFlag flags)
{
  CtxIterator iterator;
  CtxFormatter formatter;
  int flush = ((flags & CTX_FORMATTER_FLAG_FLUSH) != 0);
  formatter.target= stream;
  formatter.longform = ((flags & CTX_FORMATTER_FLAG_LONGFORM) != 0);
  formatter.indent = 0;
  formatter.add_str = _ctx_stream_addstr;
  CtxCommand *command;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0,
                     CTX_ITERATOR_EXPAND_BITPACK);
  int old_pos = 0;
  int accumulated = 0;
  while ( (command = ctx_iterator_next (&iterator) ) )
    { ctx_formatter_process (&formatter, command); 
      int added = formatter.pos - old_pos;
      old_pos = formatter.pos;
      accumulated += added;
      if (flush && accumulated > 30)
      {
        fflush (stream);
        usleep (1000 * 20); /* this flushing and waiting should not be neccesary*/
        accumulated = 0;
      }
    }
  fwrite ("\n", 1, 1, stream);
  if (flush)
    fflush (stream);
}

void
ctx_render_fd (Ctx *ctx, int fd, CtxFormatterFlag flags)
{
  CtxIterator iterator;
  CtxFormatter formatter;
  formatter.target   = (void*)((size_t)fd);
  formatter.longform = ((flags & CTX_FORMATTER_FLAG_LONGFORM) != 0);
  formatter.indent   = 0;
  formatter.add_str  = _ctx_fd_addstr;
  CtxCommand *command;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0,
                     CTX_ITERATOR_EXPAND_BITPACK);
  while ( (command = ctx_iterator_next (&iterator) ) )
    { ctx_formatter_process (&formatter, command); }
  write (fd, "\n", 1);
}

char *
ctx_render_string (Ctx *ctx, CtxFormatterFlag flags, int *retlen)
{
  CtxString *string = ctx_string_new ("");
  CtxIterator iterator;
  CtxFormatter formatter;
  formatter.target= string;
  formatter.longform = ((flags & CTX_FORMATTER_FLAG_LONGFORM) != 0);
  formatter.indent = 0;
  formatter.add_str = _ctx_string_addstr;
  CtxCommand *command;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0,
                     CTX_ITERATOR_EXPAND_BITPACK);
  while ( (command = ctx_iterator_next (&iterator) ) )
    { ctx_formatter_process (&formatter, command); }
  char *ret = string->str;
  if (retlen)
    *retlen = string->length;
  ctx_string_free (string, 0);
  return ret;
}


#endif

#include <ctype.h>
#include <sys/stat.h>

CtxList *registered_contents = NULL;

// SQZ_cx
// SQZ_cy
// SQZ_rx
// SQZ_ry
// SQZ_c
// SQZ_r

CTX_EXPORT int
ctx_width (Ctx *ctx)
{
  return ctx->width;
}
CTX_EXPORT int
ctx_height (Ctx *ctx)
{
  return ctx->height;
}

CtxState *ctx_get_state (Ctx *ctx)
{
  return &ctx->state;
}

void ctx_dirty_rect (Ctx *ctx, int *x, int *y, int *width, int *height)
{
  if ( (ctx->state.ink_min_x > ctx->state.ink_max_x) ||
       (ctx->state.ink_min_y > ctx->state.ink_max_y) )
    {
      if (x) { *x = 0; }
      if (y) { *y = 0; }
      if (width) { *width = 0; }
      if (height) { *height = 0; }
      return;
    }
  if (ctx->state.ink_min_x < 0)
    { ctx->state.ink_min_x = 0; }
  if (ctx->state.ink_min_y < 0)
    { ctx->state.ink_min_y = 0; }
  if (x) { *x = ctx->state.ink_min_x; }
  if (y) { *y = ctx->state.ink_min_y; }
  if (width) { *width = ctx->state.ink_max_x - ctx->state.ink_min_x + 1; }
  if (height) { *height = ctx->state.ink_max_y - ctx->state.ink_min_y + 1; }
}

#if CTX_CURRENT_PATH
static CtxIterator *
ctx_temp_path_iterator (Ctx *ctx, CtxDrawlist *path)
{
  CtxIterator *iterator = &ctx->current_path_iterator;
  ctx_iterator_init (iterator, path, 0, CTX_ITERATOR_EXPAND_BITPACK);
  return iterator;
}

CtxDrawlist *
ctx_current_path (Ctx *ctx)
{
  CtxDrawlist *drawlist = (CtxDrawlist*)ctx_calloc (1, sizeof (CtxDrawlist) + 
                              ctx->current_path.count * sizeof (CtxEntry));
  drawlist->entries = (CtxEntry*)(&drawlist[1]);
  drawlist->size = drawlist->count = ctx->current_path.count;
  drawlist->flags = CTX_DRAWLIST_DOESNT_OWN_ENTRIES;
  if (drawlist->count)
    memcpy (drawlist->entries, ctx->current_path.entries,
            drawlist->count * sizeof (CtxEntry));
  return drawlist;
}

void
ctx_path_extents_path (Ctx *ctx, float *ex1, float *ey1, float *ex2, float *ey2, CtxDrawlist *path)
{
  float minx = 50000.0;
  float miny = 50000.0;
  float maxx = -50000.0;
  float maxy = -50000.0;
  float x = 0;
  float y = 0;

  CtxIterator *iterator = ctx_temp_path_iterator (ctx, path);
  CtxCommand *command;

  while ((command = ctx_iterator_next (iterator)))
  {
     int got_coord = 0;
     switch (command->code)
     {
        // XXX missing some segment types
        case CTX_LINE_TO:
        case CTX_MOVE_TO:
          x = command->move_to.x;
          y = command->move_to.y;
          got_coord++;
          break;
        case CTX_REL_LINE_TO:
        case CTX_REL_MOVE_TO:
          x += command->line_to.x;
          y += command->line_to.y;
          got_coord++;
          break;
        case CTX_CURVE_TO:
          x = command->curve_to.x;
          y = command->curve_to.y;
          got_coord++;
          break;
        case CTX_REL_CURVE_TO:
          x += command->rel_curve_to.x;
          y += command->rel_curve_to.y;
          got_coord++;
          break;
        case CTX_ARC:
          minx = ctx_minf (minx, command->arc.x - command->arc.radius);
          miny = ctx_minf (miny, command->arc.y - command->arc.radius);
          maxx = ctx_maxf (maxx, command->arc.x + command->arc.radius);
          maxy = ctx_maxf (maxy, command->arc.y + command->arc.radius);

          break;
        case CTX_RECTANGLE:
        case CTX_ROUND_RECTANGLE:
          x = command->rectangle.x;
          y = command->rectangle.y;
          minx = ctx_minf (minx, x);
          miny = ctx_minf (miny, y);
          maxx = ctx_maxf (maxx, x);
          maxy = ctx_maxf (maxy, y);

          x += command->rectangle.width;
          y += command->rectangle.height;
          got_coord++;
          break;
        default:
          break;
     }
          //fprintf(stderr, "[%c]", command->code);
    if (got_coord)
    {
      minx = ctx_minf (minx, x);
      miny = ctx_minf (miny, y);
      maxx = ctx_maxf (maxx, x);
      maxy = ctx_maxf (maxy, y);
    }
  }

  if (ex1) *ex1 = minx;
  if (ey1) *ey1 = miny;
  if (ex2) *ex2 = maxx;
  if (ey2) *ey2 = maxy;
}
#endif

void
ctx_path_extents (Ctx *ctx, float *ex1, float *ey1, float *ex2, float *ey2)
{
#if CTX_CURRENT_PATH
  ctx_path_extents_path (ctx, ex1, ey1, ex2, ey2, &ctx->current_path);
#endif
}



static inline void
ctx_gstate_push (CtxState *state)
{
  if (state->gstate_no + 1 >= CTX_MAX_STATES)
    { return; }
  state->gstate_stack[state->gstate_no] = state->gstate;
  state->gstate_no++;
  ctx_state_set (state, SQZ_newState, 0.0f);
  state->has_clipped=0;
}

static inline void
ctx_gstate_pop (CtxState *state)
{
  if (state->gstate_no <= 0)
    { return; }
  state->gstate = state->gstate_stack[state->gstate_no-1];
  state->gstate_no--;
}

void
ctx_close_path (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_CLOSE_PATH);
}


CTX_EXPORT void
ctx_get_image_data (Ctx *ctx, int sx, int sy, int sw, int sh,
                    CtxPixelFormat format, int dst_stride,
                    uint8_t *dst_data)
{
   // XXX : TODO implement for cb - backend
   if (0)
   {
   }
#if CTX_RASTERIZER
   else if (ctx_backend_type (ctx) == CTX_BACKEND_RASTERIZER)
   {
     CtxRasterizer *rasterizer = (CtxRasterizer*)ctx->backend;
     if (rasterizer->format->pixel_format == format)
     {
       if (dst_stride <= 0) dst_stride = ctx_pixel_format_get_stride (format, sw);
       int bytes_per_pix = rasterizer->format->bpp/8;
       int y = 0;
       for (int v = sy; v < sy + sh; v++, y++)
       {
         int x = 0;
         for (int u = sx; u < sx + sw; u++, x++)
         {
            uint8_t* src_buf = (uint8_t*)rasterizer->buf;
            memcpy (&dst_data[y * dst_stride + x * bytes_per_pix], &src_buf[v * rasterizer->blit_stride + u * bytes_per_pix], bytes_per_pix);
         }
       }
       return;
     }
   }
#endif
#if CTX_RASTERIZER
   else
   {
     Ctx *rasterizer = ctx_new_for_framebuffer (dst_data, sw, sh, dst_stride, format);
     ctx_translate (rasterizer, sx, sy);
     ctx_render_ctx (ctx, rasterizer);
     ctx_destroy (rasterizer);
   }
#endif
}

void ctx_screenshot (Ctx *ctx, const char *output_path)
{
#if CTX_IMAGE_WRITE
  uint32_t width = ctx_width (ctx);
  uint32_t height = ctx_height (ctx);
  uint8_t *buf = (uint8_t*)ctx_malloc (width * height * 4);
  ctx_get_image_data (ctx, 0, 0, width, height,
                      CTX_FORMAT_RGBA8, width *4,
                      buf);
  ctx_write_png (output_path, width, height, 4, buf);
  ctx_free (buf);
#endif
}

void
ctx_put_image_data (Ctx *ctx, int w, int h, int stride, int format,
                    uint8_t *data,
                    int ox, int oy,
                    int dirtyX, int dirtyY,
                    int dirtyWidth, int dirtyHeight)
{
   char eid[65]="";
   ctx_save (ctx);
   ctx_identity (ctx);
   ctx_define_texture (ctx, NULL, w, h, stride, format, data, eid);
   if (eid[0])
   {
     // XXX set compositor to source
     ctx_compositing_mode (ctx, CTX_COMPOSITE_COPY);
     ctx_draw_texture_clipped (ctx, eid, ox, oy, w, h, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
   }
   ctx_restore (ctx);
}

/* checking if an eid is valid also sets the frame for it
 */
static int ctx_eid_valid (Ctx *ctx, const char *eid, int *w, int *h)
{
  ctx = ctx->texture_cache;
  CtxList *to_remove = NULL;
  int ret = 0;
  for (CtxList *l = ctx->eid_db; l; l = l->next)
  {
    CtxEidInfo *eid_info = (CtxEidInfo*)l->data;
    if (ctx->frame - eid_info->frame >= 2)
            /* XXX XXX XXX this breaks texture caching since
             *   it is wrong in some cases where more frames
             *   have passed?
             */
    {
      ctx_list_prepend (&to_remove, eid_info);
    }
    else if (!ctx_strcmp (eid_info->eid, eid) &&
             ctx->frame - eid_info->frame < 2)
    {
      eid_info->frame = ctx->frame;
      if (w) *w = eid_info->width;
      if (h) *h = eid_info->height;
      ret = 1;
    }
  }
  while (to_remove)
  {
    CtxEidInfo *eid_info = (CtxEidInfo*)to_remove->data;
    ctx_list_remove (&ctx->eid_db, eid_info);
    ctx_list_remove (&to_remove, eid_info);
    ctx_free (eid_info->eid);
    ctx_free (eid_info);
  }
  return ret;
}

void ctx_drop_eid (Ctx *ctx, const char *eid)
{
  ctx = ctx->texture_cache;
  CtxList *to_remove = NULL;
  for (CtxList *l = ctx->eid_db; l; l = l->next)
  {
    CtxEidInfo *eid_info = (CtxEidInfo*)l->data;
    if (!ctx_strcmp (eid_info->eid, eid))
    {
      ctx_list_prepend (&to_remove, eid_info);
    }
  }
  while (to_remove)
  {
    CtxEidInfo *eid_info = (CtxEidInfo*)to_remove->data;
    ctx_list_remove (&ctx->eid_db, eid_info);
    ctx_list_remove (&to_remove, eid_info);
    ctx_free (eid_info->eid);
    ctx_free (eid_info);
  }

  for (int i = 0; i <  CTX_MAX_TEXTURES; i++)
  {
    if (ctx->texture[i].data &&
        ctx->texture[i].eid  &&
        !ctx_strcmp (ctx->texture[i].eid, eid))
    {
      ctx->texture[i].eid[0]='?';
    }
  }
}


void ctx_texture (Ctx *ctx, const char *eid, float x, float y)
{
  int eid_len = ctx_strlen (eid);
  char ascii[41]="";
  if (eid_len > 50)
  {
    CtxSHA1 *sha1 = ctx_sha1_new ();
    uint8_t hash[20]="";
    ctx_sha1_process (sha1, (uint8_t*)eid, eid_len);
    ctx_sha1_done (sha1, hash);
    ctx_sha1_free (sha1);
    const char *hex="0123456789abcdef";
    for (int i = 0; i < 20; i ++)
    {
       ascii[i*2]=hex[hash[i]/16];
       ascii[i*2+1]=hex[hash[i]%16];
    }
    ascii[40]=0;
    eid=ascii;
  }

  if (ctx_eid_valid (ctx, eid, 0, 0))
    ctx_process_cmd_str_float (ctx, CTX_TEXTURE, eid, x, y);
}
int
ctx_textureclock (Ctx *ctx)
{
   return ctx->frame;
}

void
ctx_set_textureclock (Ctx *ctx, int textureclock)
{
   ctx->frame = textureclock;
}

static void ctx_define_texture_full (Ctx *ctx,
                         const char *eid,
                         int width, int height, int stride, int format, void *data,
                         char *ret_eid, int steal_data)
{
  uint8_t hash[20]="";
  char ascii[41]="";
  int dst_stride = width;

  dst_stride = ctx_pixel_format_get_stride ((CtxPixelFormat)format, width);
  if (stride <= 0)
    stride = dst_stride;

  int data_len;
 
  if (format == CTX_FORMAT_YUV420)
  data_len = width * height + ((width/2) * (height/2)) * 2;
  else
  data_len = height * dst_stride;

  if (eid == NULL)
  {
    CtxSHA1 *sha1 = ctx_sha1_new ();
    uint8_t *src = (uint8_t*)data;
    for (int y = 0; y < height; y++)
    {
       ctx_sha1_process (sha1, src, dst_stride);
       src += stride;
    }
    ctx_sha1_done (sha1, hash);
    ctx_sha1_free (sha1);
    const char *hex="0123456789abcdef";
    for (int i = 0; i < 20; i ++)
    {
       ascii[i*2]   = hex[hash[i]/16];
       ascii[i*2+1] = hex[hash[i]%16];
    }
    ascii[40]=0;
    eid = ascii;
  }

  int eid_len = ctx_strlen (eid);

  if (eid_len > 50)
  {
    CtxSHA1 *sha1 = ctx_sha1_new ();
    uint8_t hash[20] = "";
    ctx_sha1_process (sha1, (uint8_t*)eid, eid_len);
    ctx_sha1_done (sha1, hash);
    ctx_sha1_free (sha1);
    const char *hex="0123456789abcdef";
    for (int i = 0; i < 20; i ++)
    {
       ascii[i*2]  = hex[hash[i]/16];
       ascii[i*2+1]= hex[hash[i]%16];
    }
    ascii[40] = 0;
    eid = ascii;
    eid_len = 40;
  }

  if (ret_eid)
  {
    strcpy (ret_eid, eid);
    ret_eid[64]=0;
  }

  int redefine = 0;
  int valid = ctx_eid_valid (ctx, eid, 0, 0); // marks it as valid
                                             
  if (valid && (eid[0] == '!') && ctx->texture_cache)
  {
    for (int i = 0; i < CTX_MAX_TEXTURES; i++)
    {
      CtxBuffer *buffer = &(ctx->texture_cache->texture[i]);
      if (buffer->data &&
          buffer->eid &&
          (!strcmp (eid, buffer->eid)) &&
          (buffer->width == width) &&
          (buffer->height == height) &&
          (buffer->stride == stride) &&
          (buffer->format->pixel_format == format))
      {
        memcpy (buffer->data, data, data_len);
        ctx_texture (ctx, eid, 0.0f, 0.0f);
        return;
      }
    }
    ctx_drop_eid (ctx, eid);
    redefine = 1;
  }

  if ((!redefine) && valid)
  {
    ctx_texture (ctx, eid, 0.0f, 0.0f);
  }
  else

  {
    int do_texture = 0;
#if CTX_RASTERIZER
    if (ctx_backend_type (ctx->texture_cache) == CTX_BACKEND_RASTERIZER)
    {
       ctx_rasterizer_define_texture (
                (CtxRasterizer*)ctx->texture_cache->backend,
                eid, width, height, format, (unsigned char*)data, steal_data);
       do_texture = 1;
    }
    else
#endif
    {
      CtxEntry *commands;
      int command_size = 1 + (data_len+1+1)/9 + 1 + (eid_len+1+1)/9 + 1 +   8;
      if (ctx->backend && (void*)ctx->backend->process != (void*)ctx_drawlist_process)
      {
         commands = (CtxEntry*)ctx_calloc (command_size, sizeof (CtxEntry));
      }
      else
      {
         commands = NULL;
         ctx_drawlist_resize (&ctx->drawlist, ctx->drawlist.count + command_size);
         commands = &(ctx->drawlist.entries[ctx->drawlist.count]);
         memset (commands, 0, sizeof (CtxEntry) * command_size);
      }
      commands[0] = ctx_u32 (CTX_DEFINE_TEXTURE, width, height);
      commands[1].data.u16[0] = format;
  
      int pos = 2;
  
      commands[pos].code        = CTX_DATA;
      commands[pos].data.u32[0] = eid_len;
      commands[pos].data.u32[1] = (eid_len+1+1)/9 + 1;
      memcpy ((char *) &commands[pos+1].data.u8[0], eid, eid_len);
      ((char *) &commands[pos+1].data.u8[0])[eid_len]=0;
  
      pos = 2 + 1 + ctx_conts_for_entry (&commands[2]);
      commands[pos].code        = CTX_DATA;
      commands[pos].data.u32[0] = data_len;
      commands[pos].data.u32[1] = (data_len+1+1)/9 + 1;
      {
        uint8_t *src = (uint8_t*)data;
        uint8_t *dst = &commands[pos+1].data.u8[0];
  #if 1
        memcpy (dst, src, data_len);
  #else
        for (int y = 0; y < height; y++)
        {
           memcpy (dst, src, dst_stride);
           src += stride;
           dst += dst_stride;
        }
  #endif
      }
      ((char *) &commands[pos+1].data.u8[0])[data_len]=0;
  
      if (ctx->backend && (void*)ctx->backend->process != (void*)ctx_drawlist_process)
      {
        ctx_process (ctx, commands);
        ctx_free (commands);
      }
      else
      {
         ctx->drawlist.count += ctx_conts_for_entry (commands) + 1;
      }
    }

    {
      CtxEidInfo *eid_info = (CtxEidInfo*)ctx_calloc (1, sizeof (CtxEidInfo));
      eid_info->width      = width;
      eid_info->height     = height;
      eid_info->frame      = ctx->texture_cache->frame;
      eid_info->eid        = ctx_strdup (eid);
      ctx_list_append (&ctx->texture_cache->eid_db, eid_info);
    }

    if (do_texture)
      ctx_texture (ctx, eid, 0.0f, 0.0f);
  }
}

void ctx_define_texture (Ctx *ctx,
                         const char *eid,
                         int width, int height, int stride, int format, void *data,
                         char *ret_eid)
{
  ctx_define_texture_full (ctx,
                         eid,
                         width, height, stride, format, data,
                         ret_eid, 0);
}
#if CTX_STB_IMAGE
#ifndef STBI_INCLUDE_STB_IMAGE_H 
#include "stb_image.h"
#endif
#endif

void
ctx_texture_load (Ctx *ctx, const char *path, int *tw, int *th, char *reid)
{
  const char *eid = path;
  if (strstr (path, ".svg") == strrchr(path, '.'))return;
  char ascii[41]="";
  int eid_len = ctx_strlen (eid);
  if (eid_len > 50)
  {
    CtxSHA1 *sha1 = ctx_sha1_new ();
    uint8_t hash[20]="";
    ctx_sha1_process (sha1, (uint8_t*)eid, eid_len);
    ctx_sha1_done (sha1, hash);
    ctx_sha1_free (sha1);
    const char *hex="0123456789abcdef";
    for (int i = 0; i < 20; i ++)
    {
       ascii[i*2]=hex[hash[i]/16];
       ascii[i*2+1]=hex[hash[i]%16];
    }
    ascii[40]=0;
    eid = ascii;
  }

  if (ctx_eid_valid (ctx, eid, tw, th))
  {
     if (reid)
     {
       strcpy (reid, eid);
     }
     return;
  }

#if CTX_STB_IMAGE
  CtxPixelFormat pixel_format = CTX_FORMAT_RGBA8;
  int w, h, components;
  unsigned char *pixels = NULL;

#if 0
  if (path[0] == '/' || !strncmp (path, "file://", 7))
  {
    pixels = stbi_load (path + (path[0]=='/'?0:7), &w, &h, &components, 0);
  }
  else
#endif
  {
    unsigned char *data = NULL;
    long length = 0;
    ctx_get_contents (path, &data, &length);
    if (data)
    {
       pixels = stbi_load_from_memory (data, length, &w, &h, &components, 0);
       ctx_free (data);
    }
  }


  if (pixels)
  {
    switch (components)
    {
      case 1: pixel_format = CTX_FORMAT_GRAY8;  break;
      case 2: pixel_format = CTX_FORMAT_GRAYA8; break;
      case 3: pixel_format = CTX_FORMAT_RGB8;   break;
      case 4: pixel_format = CTX_FORMAT_RGBA8;
        for (int i = 0; i < w * h; i++)
          ctx_RGBA8_associate_alpha (&pixels[i * 4]);
      break;
    }
    if (tw) *tw = w;
    if (th) *th = h;
    ctx_define_texture_full (ctx, eid, w, h, w * components, pixel_format, pixels, reid, 1);
  }
  else
  {
    fprintf (stderr, "texture loading problem for %s\n", path);
  }
#endif
}

void
ctx_draw_texture_clipped  (Ctx *ctx, const char *eid,
                           float x, float y,
                           float width, float height,
                           float clip_x, float clip_y,
                           float clip_width, float clip_height)
{
  int tex_width  = 0;
  int tex_height = 0;
  if (ctx_eid_valid (ctx, eid , &tex_width, &tex_height))
  {
    if (width < 0 && height > 0)
    {
      width = height * (tex_width / tex_height);
    }
    else if (height <0 && height > 0)
    {
      height = width * (tex_height / tex_width);
    }
    else if (width <0 && height <0)
    {
      width = tex_width;
      height = tex_height;
    }

    {
      if (clip_width>0) tex_width = (int)clip_width;
      if (clip_height>0) tex_height = (int)clip_height;
      ctx_rectangle (ctx, x, y, width, height);
      ctx_save (ctx);
      
      ctx_texture (ctx, eid, 0,0);//x-(clip_x) * (width/tex_width), y-clip_y * (height
      ctx_translate (ctx, (x-(clip_x) * (width/tex_width)), (y-clip_y * (height
/tex_height)));
      ctx_scale (ctx, (width/tex_width), (height/tex_height));
      ctx_fill (ctx);
      ctx_restore (ctx);
    }
  }
}

void ctx_draw_texture (Ctx *ctx, const char *eid, float x, float y, float w, float h)
{
  ctx_draw_texture_clipped (ctx, eid, x, y, w, h, 0,0,0,0);
}

#if CTX_CSS

typedef struct _CtxSvgCache CtxSvgCache;
struct _CtxSvgCache
{
  uint32_t     path_id;
  float        viewbox[4];
  float        width;
  float        height;
  Ctx         *drawlist;
  int          last_used_frame;
  CtxSvgCache *next;
};

CtxSvgCache *ctx_svg_cache = NULL;


static void ctx_draw_svg_clipped (Ctx *ctx, const char *path, float x, float y, float w, float h, float sx, float sy, float swidth, float sheight)
{
    ctx_save (ctx);

#if 0
    // should match HTML 2d context specs for raster images
    if (swidth > 0.1f || sheight > 0.1f)
    {
      ctx_rectangle (ctx, sx, sy, swidth, sheight);
      ctx_clip (ctx);
    }
#endif

    uint32_t path_id = ctx_strhash (path);
    CtxSvgCache *cached = NULL;

    for(cached = ctx_svg_cache; cached; cached = cached->next)
        if (cached->path_id == path_id)
          break;

    int textureclock = ctx_textureclock (ctx);

    if (!cached)
    {
      /* evict expired cached svg sprites */
      {
        CtxSvgCache *prev = NULL;

        for (CtxSvgCache *iter = ctx_svg_cache; iter; iter=iter->next)
        {
          if (textureclock - iter->last_used_frame >= CTX_SVG_FREE_AGE)
          {
            if (prev)
            {
              prev->next = iter->next;
            }
            else
            {
              ctx_svg_cache = iter->next;
            }

            ctx_destroy (iter->drawlist);
            ctx_free (iter);

            iter = prev ? prev : ctx_svg_cache;
          }
          else
          {
            prev = iter;
          }
        }
      }

      unsigned char *contents = NULL;
      long length = 0;
      ctx_get_contents (path, &contents, &length);
      if (contents)
      {
        cached = ctx_calloc (1, sizeof (CtxSvgCache));
        cached->path_id = path_id;
        cached->next = ctx_svg_cache;
        cached->drawlist = ctx_new_drawlist (-1, -1);
        Css *css= css_new (cached->drawlist);
        //float width, height;
        css_xml_extent (css, contents, &cached->width, &cached->height, &cached->viewbox[0], &cached->viewbox[1], &cached->viewbox[2], &cached->viewbox[3]);
        css_xml_render (css, NULL/*uri*/, NULL /* http(s) fetch cb*/, NULL, NULL, NULL, (char*)contents);
        css_destroy (css);
        ctx_free (contents);
        ctx_svg_cache = cached;
     }
    }

    if (cached)
    {
      float factor,
      factor_h = h / cached->viewbox[3];
      factor = w / cached->viewbox[2];
      if (factor_h < factor) factor = factor_h;

      ctx_translate (ctx, x, y);
      ctx_scale (ctx, factor, factor);
      ctx_translate (ctx, -cached->viewbox[0], -cached->viewbox[1]);
      ctx_render_ctx (cached->drawlist, ctx);
      cached->last_used_frame = textureclock;
    }
    ctx_restore (ctx);
}
#endif

void ctx_draw_image_clipped (Ctx *ctx, const char *path, float x, float y, float w, float h, float sx, float sy, float swidth, float sheight)
{
#if CTX_CSS
  if (!strcmp (path + strlen(path) - 4, ".svg"))
  {
    ctx_draw_svg_clipped (ctx, path, x, y, w, h, sx, sy, swidth, sheight);
  }
  else
#endif
  {
    char reteid[65];
    int width, height;
    ctx_texture_load (ctx, path, &width, &height, reteid);
    if (reteid[0])
    {
      ctx_draw_texture_clipped (ctx, reteid, x, y, w, h, sx, sy, swidth, sheight);
    }
  }
}

void
ctx_draw_image (Ctx *ctx, const char *path, float x, float y, float w, float h)
{
  ctx_draw_image_clipped (ctx, path, x, y, w, h, 0,0,0,0);
}

void
ctx_set_pixel_u8 (Ctx *ctx, uint16_t x, uint16_t y, uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
  CtxEntry command = ctx_u8 (CTX_SET_PIXEL, r, g, b, a, 0, 0, 0, 0);
  command.data.u16[2]=x;
  command.data.u16[3]=y;
  ctx_process (ctx, &command);
}

void
ctx_conic_gradient (Ctx *ctx, float cx, float cy, float start_angle, float cycles)
{
  CtxEntry command[2]=
  {
    ctx_f (CTX_CONIC_GRADIENT, cx, cy),
    ctx_f (CTX_CONT,           start_angle, cycles)
  };
  ctx_process (ctx, command);
}

void
ctx_linear_gradient (Ctx *ctx, float x0, float y0, float x1, float y1)
{
  CtxEntry command[2]=
  {
    ctx_f (CTX_LINEAR_GRADIENT, x0, y0),
    ctx_f (CTX_CONT,            x1, y1)
  };
  ctx_process (ctx, command);
}

void
ctx_radial_gradient (Ctx *ctx, float x0, float y0, float r0, float x1, float y1, float r1)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_RADIAL_GRADIENT, x0, y0),
    ctx_f (CTX_CONT,            r0, x1),
    ctx_f (CTX_CONT,            y1, r1)
  };
  ctx_process (ctx, command);
}

void ctx_preserve (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_PRESERVE);
}

void ctx_paint (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_PAINT);
}

void ctx_fill (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_FILL);
}

void ctx_stroke (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_STROKE);
}

#if CTX_EVENTS
static void
ctx_event_free (void *event, void *user_data)
{
  CtxEvent *e = (CtxEvent*)event;

  if (!e->ctx->events.ctx_get_event_enabled)
  {
// XXX : we are leaking a string!!!!
//    without this, consuming events
//    is broken for clients polling events
//
//  we could append them to a list that is freed when starting a new frame?
//
    if (e->string)
      ctx_free ((char*)e->string);
  }
  ctx_free (event);
}

void
ctx_collect_events (CtxEvent *event, void *data, void *data2)
{
  Ctx *ctx = (Ctx*)data;
  CtxEvent *copy;
  if (event->type == CTX_KEY_PRESS && !ctx_strcmp (event->string, "idle"))
    return;
  copy = (CtxEvent*)ctx_malloc (sizeof (CtxEvent));
  *copy = *event;
  if (copy->string)
    copy->string = ctx_strdup (event->string);
  ctx_list_append_full (&ctx->events.events, copy, ctx_event_free, NULL);
}
#endif


CTX_EXPORT float
ctx_start_frame (Ctx *ctx)
{
  ctx_drawlist_clear (ctx);
  ctx_state_init (&ctx->state);

  if (ctx->backend && ctx->backend->start_frame)
    ctx->backend->start_frame (ctx);

#if CTX_EVENTS
  ctx_list_free (&ctx->events.items);
  ctx->events.last_item = NULL;

  ctx_clear_bindings (ctx);
  if (ctx->events.ctx_get_event_enabled)
  {
    ctx_listen_full (ctx, 0,0,0,0,
                     CTX_KEY_PRESS, _ctx_bindings_key_press, ctx, ctx,
                     NULL, NULL);

    ctx_listen_full (ctx, 0,0,0,0,
                     CTX_KEY_UP, ctx_collect_events, ctx, ctx,
                     NULL, NULL);
    ctx_listen_full (ctx, 0,0,0,0,
                     CTX_KEY_DOWN, ctx_collect_events, ctx, ctx,
                     NULL, NULL);

    ctx_listen_full (ctx, 0, 0, ctx->width, ctx->height,
                     (CtxEventType)(CTX_PRESS|CTX_RELEASE|CTX_MOTION),
                     ctx_collect_events, ctx, ctx,
                     NULL, NULL);
  }
  ctx->dirty = 0;
#endif

  {
    static int64_t prev_time = 0;
    int64_t cur_time = ctx_ticks ();
    float elapsed = 0.0f;
    if (prev_time)
      elapsed = (cur_time-prev_time)/(1000.0f*1000.0f);
    prev_time = cur_time;
    return elapsed;
  }
}

void ctx_reset_path (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_RESET_PATH);
}

void ctx_clip (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_CLIP);
}

void
ctx_set (Ctx *ctx, uint32_t key_hash, const char *string, int len);

void ctx_save (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_SAVE);
}

void ctx_restore (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_RESTORE);
}

void ctx_new_page (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_NEW_PAGE);
}

void ctx_start_group (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_START_GROUP);
}

void ctx_end_group (Ctx *ctx)
{
  CTX_PROCESS_VOID (CTX_END_GROUP);
}

void ctx_line_width (Ctx *ctx, float x)
{
  if (ctx->state.gstate.line_width != x)
    CTX_PROCESS_F1 (CTX_LINE_WIDTH, x);
}

float ctx_get_miter_limit (Ctx *ctx)
{
  return ctx->state.gstate.miter_limit;
}

float ctx_get_line_dash_offset (Ctx *ctx)
{
  return ctx->state.gstate.line_dash_offset;
}

void ctx_line_dash_offset (Ctx *ctx, float x)
{
  if (ctx->state.gstate.line_dash_offset != x)
    CTX_PROCESS_F1 (CTX_LINE_DASH_OFFSET, x);
}

float ctx_get_stroke_pos (Ctx *ctx)
{
  return ctx->state.gstate.stroke_pos;
}

void ctx_stroke_pos (Ctx *ctx, float x)
{
  CTX_PROCESS_F1 (CTX_STROKE_POS, x);
}

float ctx_get_feather (Ctx *ctx)
{
  return ctx->state.gstate.feather;
}

void ctx_feather (Ctx *ctx, float x)
{
  CTX_PROCESS_F1 (CTX_FEATHER, x);
}

void ctx_line_height (Ctx *ctx, float x)
{
  CTX_PROCESS_F1 (CTX_LINE_HEIGHT, x);
}

void ctx_wrap_left (Ctx *ctx, float x)
{
  CTX_PROCESS_F1 (CTX_WRAP_LEFT , x);
}

void ctx_wrap_right (Ctx *ctx, float x)
{
  CTX_PROCESS_F1 (CTX_WRAP_RIGHT, x);
}

int ctx_get_image_smoothing (Ctx *ctx)
{
  return ctx->state.gstate.image_smoothing;
}

void ctx_image_smoothing (Ctx *ctx, int enabled)
{
  if (ctx_get_image_smoothing (ctx) != enabled)
    CTX_PROCESS_U8 (CTX_IMAGE_SMOOTHING, enabled);
}

void ctx_line_dash (Ctx *ctx, const float *dashes, int count)
{
  ctx_process_cmd_str_with_len (ctx, CTX_LINE_DASH, (char*)(dashes), count, 0, count * 4);
}

void ctx_shadow_blur (Ctx *ctx, float x)
{
#if CTX_ENABLE_SHADOW_BLUR
  if (ctx->state.gstate.shadow_blur != x)
#endif
    CTX_PROCESS_F1 (CTX_SHADOW_BLUR, x);
}

void ctx_shadow_rgba (Ctx *ctx, float r, float g, float b, float a)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_SHADOW_COLOR, CTX_RGBA, r),
    ctx_f (CTX_CONT, g, b),
    ctx_f (CTX_CONT, a, 0)
  };
  ctx_process (ctx, command);
}

void ctx_shadow_offset_x (Ctx *ctx, float x)
{
#if CTX_ENABLE_SHADOW_BLUR
  if (ctx->state.gstate.shadow_offset_x != x)
#endif
    CTX_PROCESS_F1 (CTX_SHADOW_OFFSET_X, x);
}

void ctx_shadow_offset_y (Ctx *ctx, float x)
{
#if CTX_ENABLE_SHADOW_BLUR
  if (ctx->state.gstate.shadow_offset_y != x)
#endif
    CTX_PROCESS_F1 (CTX_SHADOW_OFFSET_Y, x);
}

void
ctx_global_alpha (Ctx *ctx, float global_alpha)
{
  if (global_alpha < 0.0f) global_alpha = 0.0f;
  else if (global_alpha > 1.0f) global_alpha = 1.0f;
  if (ctx->state.gstate.global_alpha_f != global_alpha)
    CTX_PROCESS_F1 (CTX_GLOBAL_ALPHA, global_alpha);
}

float
ctx_get_global_alpha (Ctx *ctx)
{
  return ctx->state.gstate.global_alpha_f;
}

void
ctx_font_size (Ctx *ctx, float x)
{
  CTX_PROCESS_F1 (CTX_FONT_SIZE, x);
}

float ctx_get_font_size  (Ctx *ctx)
{
  return ctx->state.gstate.font_size;
}

void
ctx_miter_limit (Ctx *ctx, float limit)
{
  CTX_PROCESS_F1 (CTX_MITER_LIMIT, limit);
}

float ctx_get_line_width (Ctx *ctx)
{
  return ctx->state.gstate.line_width;
}

void
_ctx_font (Ctx *ctx, const char *name)
{
  ctx->state.gstate.font = ctx_resolve_font (name);
}

#if 0
void
ctx_set (Ctx *ctx, uint32_t key_hash, const char *string, int len)
{
  if (len <= 0) len = ctx_strlen (string);
  ctx_process_cmd_str (ctx, CTX_SET, string, key_hash, len);
}

const char *
ctx_get (Ctx *ctx, const char *key)
{
  static char retbuf[32];
  int len = 0;
  CTX_PROCESS_U32(CTX_GET, ctx_strhash (key), 0);
  while (read (STDIN_FILENO, &retbuf[len], 1) != -1)
    {
      if(retbuf[len]=='\n')
        break;
      retbuf[++len]=0;
    }
  return retbuf;
}
#endif

void
ctx_font_family (Ctx *ctx, const char *name)
{
  if (ctx->frontend_text)
    _ctx_font (ctx, name);
  else
    ctx_process_cmd_str (ctx, CTX_FONT, name, 0, 0);
}

void
ctx_font (Ctx *ctx, const char *family_name)
{
  // should also parse size - on top of what ctx_font_family does
  ctx_font_family (ctx, family_name);
}

const char *
ctx_get_font (Ctx *ctx)
{
  return ctx_get_font_name (ctx, ctx->state.gstate.font);
}

void ctx_line_to (Ctx *ctx, float x, float y)
{
  if (ctx->state.has_moved <= 0)
    { CTX_PROCESS_F (CTX_MOVE_TO, x, y); }
  else
    { CTX_PROCESS_F (CTX_LINE_TO, x, y); }
}

void ctx_move_to (Ctx *ctx, float x, float y)
{
  CTX_PROCESS_F (CTX_MOVE_TO,x,y);
}

void ctx_curve_to (Ctx *ctx, float x0, float y0,
                   float x1, float y1,
                   float x2, float y2)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_CURVE_TO, x0, y0),
    ctx_f (CTX_CONT,     x1, y1),
    ctx_f (CTX_CONT,     x2, y2)
  };
  ctx_process (ctx, command);
}

void ctx_round_rectangle (Ctx *ctx,
                          float x0, float y0,
                          float w, float h,
                          float radius)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_ROUND_RECTANGLE, x0, y0),
    ctx_f (CTX_CONT,            w, h),
    ctx_f (CTX_CONT,            radius, 0)
  };
  ctx_process (ctx, command);
}

void ctx_view_box (Ctx *ctx,
                   float x0, float y0,
                   float w, float h)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_VIEW_BOX, x0, y0),
    ctx_f (CTX_CONT,     w, h)
  };
  ctx_process (ctx, command);
}

void ctx_rectangle (Ctx *ctx,
                    float x0, float y0,
                    float w, float h)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_RECTANGLE, x0, y0),
    ctx_f (CTX_CONT,      w, h)
  };
  ctx_process (ctx, command);
}

void ctx_rel_line_to (Ctx *ctx, float x, float y)
{
  if (!ctx->state.has_moved)
    { return; }
  CTX_PROCESS_F (CTX_REL_LINE_TO,x,y);
}

void ctx_rel_move_to (Ctx *ctx, float x, float y)
{
  if (!ctx->state.has_moved)
    {
      CTX_PROCESS_F (CTX_MOVE_TO,x,y);
      return;
    }
  CTX_PROCESS_F (CTX_REL_MOVE_TO,x,y);
}

CtxLineJoin ctx_get_line_join (Ctx *ctx)
{
  return ctx->state.gstate.line_join;
}

CtxCompositingMode ctx_get_compositing_mode (Ctx *ctx)
{
  return ctx->state.gstate.compositing_mode;
}

CtxBlend ctx_get_blend_mode (Ctx *ctx)
{
  return ctx->state.gstate.blend_mode;
}

CtxExtend ctx_get_extend (Ctx *ctx)
{
  return ctx->state.gstate.extend;
}

CtxTextAlign ctx_get_text_align  (Ctx *ctx)
{
  return (CtxTextAlign)ctx_state_get (&ctx->state, SQZ_textAlign);
}

float ctx_get_wrap_left        (Ctx *ctx)
{
  return ctx_state_get (&ctx->state, SQZ_wrapLeft);
}
float ctx_get_wrap_right       (Ctx *ctx)
{
  return ctx_state_get (&ctx->state, SQZ_wrapRight);
}

float ctx_get_line_height      (Ctx *ctx)
{
  return ctx_state_get (&ctx->state, SQZ_lineHeight);
}

CtxTextBaseline ctx_get_text_baseline (Ctx *ctx)
{
  return (CtxTextBaseline)ctx_state_get (&ctx->state, SQZ_textBaseline);
}

CtxLineCap ctx_get_line_cap (Ctx *ctx)
{
  return ctx->state.gstate.line_cap;
}

CtxFillRule ctx_get_fill_rule (Ctx *ctx)
{
  return ctx->state.gstate.fill_rule;
}

void ctx_line_cap (Ctx *ctx, CtxLineCap cap)
{
  if (ctx->state.gstate.line_cap != cap)
    CTX_PROCESS_U8 (CTX_LINE_CAP, cap);
}

void ctx_fill_rule (Ctx *ctx, CtxFillRule fill_rule)
{
  if (ctx->state.gstate.fill_rule != fill_rule)
    CTX_PROCESS_U8 (CTX_FILL_RULE, fill_rule);
}

void ctx_line_join (Ctx *ctx, CtxLineJoin join)
{
  if (ctx->state.gstate.line_join != join)
    CTX_PROCESS_U8 (CTX_LINE_JOIN, join);
}

void ctx_blend_mode (Ctx *ctx, CtxBlend mode)
{
#if CTX_BLENDING_AND_COMPOSITING
  if (ctx->state.gstate.blend_mode != mode)
    CTX_PROCESS_U32 (CTX_BLEND_MODE, mode, 0);
#endif
}

void ctx_extend (Ctx *ctx, CtxExtend extend)
{
  if (ctx->state.gstate.extend != extend)
    CTX_PROCESS_U32 (CTX_EXTEND, extend, 0);
}

void ctx_compositing_mode (Ctx *ctx, CtxCompositingMode mode)
{
  if (ctx->state.gstate.compositing_mode != mode)
    CTX_PROCESS_U32 (CTX_COMPOSITING_MODE, mode, 0);
}

void ctx_text_align (Ctx *ctx, CtxTextAlign text_align)
{
  CTX_PROCESS_U8 (CTX_TEXT_ALIGN, text_align);
}

void ctx_text_baseline (Ctx *ctx, CtxTextBaseline text_baseline)
{
  CTX_PROCESS_U8 (CTX_TEXT_BASELINE, text_baseline);
}

void ctx_text_direction (Ctx *ctx, CtxTextDirection text_direction)
{
  CTX_PROCESS_U8 (CTX_TEXT_DIRECTION, text_direction);
}

void
ctx_rel_curve_to (Ctx *ctx,
                  float x0, float y0,
                  float x1, float y1,
                  float x2, float y2)
{
  if (!ctx->state.has_moved)
    { return; }
  CtxEntry command[3]=
  {
    ctx_f (CTX_REL_CURVE_TO, x0, y0),
    ctx_f (CTX_CONT, x1, y1),
    ctx_f (CTX_CONT, x2, y2)
  };
  ctx_process (ctx, command);
}

void
ctx_rel_quad_to (Ctx *ctx,
                 float cx, float cy,
                 float x,  float y)
{
  if (!ctx->state.has_moved)
    { return; }
  CtxEntry command[2]=
  {
    ctx_f (CTX_REL_QUAD_TO, cx, cy),
    ctx_f (CTX_CONT, x, y)
  };
  ctx_process (ctx, command);
}

void
ctx_quad_to (Ctx *ctx,
             float cx, float cy,
             float x,  float y)
{
  if (!ctx->state.has_moved)
    { return; }
  CtxEntry command[2]=
  {
    ctx_f (CTX_QUAD_TO, cx, cy),
    ctx_f (CTX_CONT, x, y)
  };
  ctx_process (ctx, command);
}

void ctx_arc (Ctx  *ctx,
              float x0, float y0,
              float radius,
              float angle1, float angle2,
              int   direction)
{
  CtxEntry command[3]=
  {
    ctx_f (CTX_ARC, x0, y0),
    ctx_f (CTX_CONT, radius, angle1),
    ctx_f (CTX_CONT, angle2, direction)
  };
  ctx_process (ctx, command);
}

static int ctx_coords_equal (float x1, float y1, float x2, float y2, float tol)
{
  float dx = x2 - x1;
  float dy = y2 - y1;
  return dx*dx + dy*dy < tol*tol;
}

static float
ctx_point_seg_dist_sq (float x, float y,
                       float vx, float vy, float wx, float wy)
{
  float l2 = ctx_pow2 (vx-wx) + ctx_pow2 (vy-wy);
  if (l2 < 0.0001f)
    { return ctx_pow2 (x-vx) + ctx_pow2 (y-vy); }
  float t = ( (x - vx) * (wx - vx) + (y - vy) * (wy - vy) ) / l2;
  t = ctx_maxf (0, ctx_minf (1, t) );
  float ix = vx + t * (wx - vx);
  float iy = vy + t * (wy - vy);
  return ctx_pow2 (x-ix) + ctx_pow2 (y-iy);
}

static void
ctx_normalize (float *x, float *y)
{
  float length = ctx_hypotf ( (*x), (*y) );
  if (length > 1e-6f)
    {
      float r = 1.0f / length;
      *x *= r;
      *y *= r;
    }
}

void
ctx_arc_to (Ctx *ctx, float x1, float y1, float x2, float y2, float radius)
{
  // XXX : should partially move into rasterizer to preserve comand
  //       even if an arc preserves all geometry, just to ensure roundtripping
  //       of data
  /* from nanovg - but not quite working ; uncertain if arc or wrong
   * transfusion is the cause.
   */
  float x0 = ctx->state.x;
  float y0 = ctx->state.y;
  float dx0,dy0, dx1,dy1, a, d, cx,cy, a0,a1;
  int dir;
  if (!ctx->state.has_moved)
    { return; }
  if (1)
    {
      // Handle degenerate cases.
      if (ctx_coords_equal (x0,y0, x1,y1, 0.5f) ||
          ctx_coords_equal (x1,y1, x2,y2, 0.5f) ||
          ctx_point_seg_dist_sq (x1,y1, x0,y0, x2,y2) < 0.5f ||
          radius < 0.5f)
        {
          ctx_line_to (ctx, x1,y1);
          return;
        }
    }
  // Calculate tangential circle to lines (x0,y0)-(x1,y1) and (x1,y1)-(x2,y2).
  dx0 = x0-x1;
  dy0 = y0-y1;
  dx1 = x2-x1;
  dy1 = y2-y1;
  ctx_normalize (&dx0,&dy0);
  ctx_normalize (&dx1,&dy1);
  a = ctx_acosf (dx0*dx1 + dy0*dy1);
  d = radius / ctx_tanf (a/2.0f);
#if 0
  if (d > 10000.0f)
    {
      ctx_line_to (ctx, x1, y1);
      return;
    }
#endif
  if ( (dx1*dy0 - dx0*dy1) > 0.0f)
    {
      cx = x1 + dx0*d + dy0*radius;
      cy = y1 + dy0*d + -dx0*radius;
      a0 = ctx_atan2f (dx0, -dy0);
      a1 = ctx_atan2f (-dx1, dy1);
      dir = 0;
    }
  else
    {
      cx = x1 + dx0*d + -dy0*radius;
      cy = y1 + dy0*d + dx0*radius;
      a0 = ctx_atan2f (-dx0, dy0);
      a1 = ctx_atan2f (dx1, -dy1);
      dir = 1;
    }
  ctx_arc (ctx, cx, cy, radius, a0, a1, dir);
}

void
ctx_rel_arc_to (Ctx *ctx, float x1, float y1, float x2, float y2, float radius)
{
  x1 += ctx->state.x;
  y1 += ctx->state.y;
  x2 += ctx->state.x;
  y2 += ctx->state.y;
  ctx_arc_to (ctx, x1, y1, x2, y2, radius);
}

CTX_EXPORT void
ctx_end_frame (Ctx *ctx)
{
  if (ctx->backend && ctx->backend->end_frame)
    ctx->backend->end_frame (ctx);
  ctx->frame++;
  if (ctx->texture_cache != ctx)
    ctx->texture_cache->frame++;
  ctx_drawlist_clear (ctx);
  ctx_state_init (&ctx->state);
}

////////////////////////////////////////

void
ctx_interpret_style (CtxState *state, const CtxEntry *entry, void *data)
{
  const CtxCommand *c = (CtxCommand *) entry;
  switch (entry->code)
    {
      case CTX_LINE_HEIGHT:
        ctx_state_set (state, SQZ_lineHeight, ctx_arg_float (0) );
        break;
      case CTX_WRAP_LEFT:
        ctx_state_set (state, SQZ_wrapLeft, ctx_arg_float (0) );
        break;
      case CTX_WRAP_RIGHT:
        ctx_state_set (state, SQZ_wrapRight, ctx_arg_float (0) );
        break;
      case CTX_LINE_DASH_OFFSET:
        state->gstate.line_dash_offset = ctx_arg_float (0);
        break;
      case CTX_STROKE_POS:
        state->gstate.stroke_pos = ctx_arg_float (0);
        break;
      case CTX_FEATHER:
        state->gstate.feather = ctx_arg_float (0);
        break;
      case CTX_LINE_WIDTH:
        state->gstate.line_width = ctx_arg_float (0);
        break;
#if CTX_ENABLE_SHADOW_BLUR
      case CTX_SHADOW_BLUR:
        state->gstate.shadow_blur = ctx_arg_float (0);
        break;
      case CTX_SHADOW_OFFSET_X:
        state->gstate.shadow_offset_x = ctx_arg_float (0);
        break;
      case CTX_SHADOW_OFFSET_Y:
        state->gstate.shadow_offset_y = ctx_arg_float (0);
        break;
#endif
      case CTX_LINE_CAP:
        state->gstate.line_cap = (CtxLineCap) ctx_arg_u8 (0);
        break;
      case CTX_FILL_RULE:
        state->gstate.fill_rule = (CtxFillRule) ctx_arg_u8 (0);
        break;
      case CTX_LINE_JOIN:
        state->gstate.line_join = (CtxLineJoin) ctx_arg_u8 (0);
        break;
      case CTX_COMPOSITING_MODE:
        state->gstate.compositing_mode = (CtxCompositingMode) ctx_arg_u32 (0);
        break;
#if CTX_BLENDING_AND_COMPOSITING
      case CTX_BLEND_MODE:
        state->gstate.blend_mode = (CtxBlend) ctx_arg_u32 (0);
        break;
#endif
      case CTX_EXTEND:
        state->gstate.extend = (CtxExtend) ctx_arg_u32 (0);
        break;
      case CTX_TEXT_ALIGN:
        ctx_state_set (state, SQZ_textAlign, ctx_arg_u8 (0) );
        break;
      case CTX_TEXT_BASELINE:
        ctx_state_set (state, SQZ_textBaseline, ctx_arg_u8 (0) );
        break;
      case CTX_TEXT_DIRECTION:
        ctx_state_set (state, SQZ_textDirection, ctx_arg_u8 (0) );
        break;
      case CTX_GLOBAL_ALPHA:
        state->gstate.global_alpha_u8 = ctx_float_to_u8 (ctx_arg_float (0) );
        state->gstate.global_alpha_f = ctx_arg_float (0);
        break;
      case CTX_FONT_SIZE:
        state->gstate.font_size = ctx_arg_float (0);
        break;
      case CTX_MITER_LIMIT:
        state->gstate.miter_limit = ctx_arg_float (0);
        break;
      case CTX_COLOR_SPACE:
        /* move this out of this function and only do it in rasterizer? XXX */
        ctx_rasterizer_colorspace_icc (state, (CtxColorSpace)c->colorspace.space_slot,
                                              (const unsigned char*)c->colorspace.data,
                                              c->colorspace.data_len);
        break;
      case CTX_IMAGE_SMOOTHING:
        state->gstate.image_smoothing = c->entry.data.u8[0];
        break;
      case CTX_STROKE_SOURCE:
        state->source = 1;
        state->gstate.source_stroke.type = CTX_SOURCE_COLOR;
        break;

      case CTX_FONT:
        state->gstate.font = ctx_resolve_font (ctx_arg_string());
        break;

      case CTX_COLOR:
        {
          int is_stroke = (state->source != 0);
          CtxSource *source = is_stroke ?
                                &state->gstate.source_stroke:
                                &state->gstate.source_fill;
          state->source = 0;

          source->type = CTX_SOURCE_COLOR;
         
          //float components[5]={c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, c->cmyka.a};
          switch ( ((int) ctx_arg_float (0)) & 511) // XXX remove 511 after stroke source is complete
            {
              case CTX_RGB:
                ctx_color_set_rgba (state, &source->color, c->rgba.r, c->rgba.g, c->rgba.b, 1.0f);
                break;
              case CTX_RGBA:
                ctx_color_set_rgba (state, &source->color, c->rgba.r, c->rgba.g, c->rgba.b, c->rgba.a);
                break;
              case CTX_DRGBA:
                ctx_color_set_drgba (state, &source->color, c->rgba.r, c->rgba.g, c->rgba.b, c->rgba.a);
                break;
#if CTX_ENABLE_CMYK
              case CTX_CMYKA:
                ctx_color_set_cmyka (state, &source->color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, c->cmyka.a);
                break;
              case CTX_CMYK:
                ctx_color_set_cmyka (state, &source->color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, 1.0f);
                break;
              case CTX_DCMYKA:
                ctx_color_set_dcmyka (state, &source->color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, c->cmyka.a);
                break;
              case CTX_DCMYK:
                ctx_color_set_dcmyka (state, &source->color, c->cmyka.c, c->cmyka.m, c->cmyka.y, c->cmyka.k, 1.0f);
                break;
#endif
              case CTX_GRAYA:
                ctx_color_set_graya (state, &source->color, c->graya.g, c->graya.a);
                break;
              case CTX_GRAY:
                ctx_color_set_graya (state, &source->color, c->graya.g, 1.0f);
                break;
            }
        }
        break;
      case CTX_SET_RGBA_U8:
        //ctx_source_deinit (&state->gstate.source);
        //state->gstate.source_fill.type = CTX_SOURCE_COLOR;
        {
          int is_stroke = (state->source != 0);
          CtxSource *source = is_stroke ?
                                &state->gstate.source_stroke:
                                &state->gstate.source_fill;
          state->source = 0;

          source->type = CTX_SOURCE_COLOR;

          ctx_color_set_RGBA8 (state, &source->color,
                               ctx_arg_u8 (0),
                               ctx_arg_u8 (1),
                               ctx_arg_u8 (2),
                               ctx_arg_u8 (3) );
        }
        //for (int i = 0; i < 4; i ++)
        //  state->gstate.source.color.rgba[i] = ctx_arg_u8(i);
        break;
      //case CTX_TEXTURE:
      //  state->gstate.source.type = CTX_SOURCE_
      //  break;
      case CTX_CONIC_GRADIENT:
        {
          int is_stroke = (state->source != 0);
          CtxSource *source = is_stroke ?
                                &state->gstate.source_stroke:
                                &state->gstate.source_fill;
          state->source = 0;

          source->conic_gradient.x = ctx_arg_float (0);
          source->conic_gradient.y = ctx_arg_float (1);
          source->conic_gradient.start_angle = ctx_arg_float (2);
          source->conic_gradient.cycles = ctx_arg_float (3);
          source->type = CTX_SOURCE_CONIC_GRADIENT;
          source->transform = state->gstate.transform;
          ctx_matrix_invert (&source->transform);
        }
        break;
      case CTX_LINEAR_GRADIENT:
        {
          int is_stroke = (state->source != 0);
          CtxSource *source = is_stroke ?
                                &state->gstate.source_stroke:
                                &state->gstate.source_fill;
          state->source = 0;

          float x0 = ctx_arg_float (0);
          float y0 = ctx_arg_float (1);
          float x1 = ctx_arg_float (2);
          float y1 = ctx_arg_float (3);
          float dx, dy, length, start, end;

          length = ctx_hypotf (x1-x0,y1-y0);
          dx = (x1-x0) / length;
          dy = (y1-y0) / length;
          start = (x0 * dx + y0 * dy) / length;
          end =   (x1 * dx + y1 * dy) / length;
          float rdelta = (end-start)!=0.0f?1.0f/(end - start):1.0f;
          float rdelta_div_length_recip = rdelta/length;
          source->linear_gradient.length = length;
          source->linear_gradient.dx_scaled = dx * rdelta_div_length_recip;
          source->linear_gradient.dy_scaled = dy * rdelta_div_length_recip;
          source->linear_gradient.start_scaled = start * rdelta;
          source->type = CTX_SOURCE_LINEAR_GRADIENT;
          source->transform = state->gstate.transform;
          ctx_matrix_invert (&source->transform);
        }
        break;
      case CTX_RADIAL_GRADIENT:
        {
          int is_stroke = (state->source != 0);
          CtxSource *source = is_stroke ?
                                &state->gstate.source_stroke:
                                &state->gstate.source_fill;
          state->source = 0;

          float x0 = ctx_arg_float (0);
          float y0 = ctx_arg_float (1);
          float r0 = ctx_arg_float (2);
          float x1 = ctx_arg_float (3);
          float y1 = ctx_arg_float (4);
          float r1 = ctx_arg_float (5);
          source->radial_gradient.x0 = x0;
          source->radial_gradient.y0 = y0;
          source->radial_gradient.r0 = r0;
          source->radial_gradient.x1 = x1;
          source->radial_gradient.y1 = y1;
          source->radial_gradient.r1 = r1;
          source->radial_gradient.rdelta = (r1 - r0) != 0.0f ? 1.0f/(r1-r0):0.0f;
          source->type      = CTX_SOURCE_RADIAL_GRADIENT;
          source->transform = state->gstate.transform;
          ctx_matrix_invert (&source->transform);
        }
        break;
    }
}

void
ctx_interpret_transforms (CtxState *state, const CtxEntry *entry, void *data)
{
  switch (entry->code)
    {
      case CTX_SAVE:
        ctx_gstate_push (state);
        break;
      case CTX_RESTORE:
#if CTX_GSTATE_PROTECT
        if (state->gstate_no <= state->gstate_waterlevel)
        {
          //fprintf (stderr, "ctx: restore without corresponding save\n");
        }
#endif
        ctx_gstate_pop (state);
        break;
      case CTX_IDENTITY:
        _ctx_matrix_identity (&state->gstate.transform);
        _ctx_transform_prime (state);
        break;
      case CTX_TRANSLATE:
        ctx_matrix_translate (&state->gstate.transform,
                              ctx_arg_float (0), ctx_arg_float (1) );
        _ctx_transform_prime (state);
        break;
      case CTX_SCALE:
        {
          float sx = ctx_arg_float (0);
          float sy = ctx_arg_float (1);

          // XXX: move these checks to parser - to reduce overhead with
          //      data that is not untrusted?
          if (ctx_fabsf(sx) < 0.000001f)
            sx = 0.000001f;
          if (ctx_fabsf(sy) < 0.000001f)
            sy = 0.000001f;
          ctx_matrix_scale (&state->gstate.transform, sx, sy);
          _ctx_transform_prime (state);
        }
        break;
      case CTX_ROTATE:
        ctx_matrix_rotate (&state->gstate.transform, ctx_arg_float (0) );
        _ctx_transform_prime (state);
        break;
      case CTX_APPLY_TRANSFORM:
        {
          CtxMatrix m;
          ctx_matrix_set (&m,
                          ctx_arg_float (0), ctx_arg_float (1),
                          ctx_arg_float (2), ctx_arg_float (3),
                          ctx_arg_float (4), ctx_arg_float (5),
                          ctx_arg_float (6), ctx_arg_float (7),
                          ctx_arg_float (8));
          _ctx_matrix_multiply (&state->gstate.transform,
                                &state->gstate.transform, &m); // XXX verify order
          _ctx_transform_prime (state);
        }
#if 0
        ctx_matrix_set (&state->gstate.transform,
                        ctx_arg_float (0), ctx_arg_float (1),
                        ctx_arg_float (2), ctx_arg_float (3),
                        ctx_arg_float (4), ctx_arg_float (5) );
#endif
        break;
    }
}

/*
 * this transforms the contents of entry according to ctx->transformation
 */
void
ctx_interpret_pos_transform (CtxState *state, CtxEntry *entry, void *data)
{
  CtxCommand *c = (CtxCommand *) entry;
  float start_x = state->x;
  float start_y = state->y;
  switch (entry->code)
    {
      case CTX_MOVE_TO:
      case CTX_LINE_TO:
        {
          float x = c->c.x0;
          float y = c->c.y0;
          if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
            {
              _ctx_user_to_device (state, &x, &y);
              ctx_arg_float (0) = x;
              ctx_arg_float (1) = y;
            }
        }
        break;
      case CTX_ARC:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
          {
            float temp;
            _ctx_user_to_device (state, &c->arc.x, &c->arc.y);
            temp = 0;
            _ctx_user_to_device_distance (state, &c->arc.radius, &temp);
          }
        break;
      case CTX_LINEAR_GRADIENT:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
        {
        _ctx_user_to_device (state, &c->linear_gradient.x1, &c->linear_gradient.y1);
        _ctx_user_to_device (state, &c->linear_gradient.x2, &c->linear_gradient.y2);
        }
        break;
      case CTX_CONIC_GRADIENT:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
        {
        _ctx_user_to_device (state, &c->conic_gradient.x, &c->conic_gradient.y);
        }
        break;
      case CTX_RADIAL_GRADIENT:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
        {
          float temp;
          _ctx_user_to_device (state, &c->radial_gradient.x1, &c->radial_gradient.y1);
          temp = 0;
          _ctx_user_to_device_distance (state, &c->radial_gradient.r1, &temp);
          _ctx_user_to_device (state, &c->radial_gradient.x2, &c->radial_gradient.y2);
          temp = 0;
          _ctx_user_to_device_distance (state, &c->radial_gradient.r2, &temp);
        }
        break;
      case CTX_CURVE_TO:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
          {
            for (int c = 0; c < 3; c ++)
              {
                float x = entry[c].data.f[0];
                float y = entry[c].data.f[1];
                _ctx_user_to_device (state, &x, &y);
                entry[c].data.f[0] = x;
                entry[c].data.f[1] = y;
              }
          }
        break;
      case CTX_QUAD_TO:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
          {
            for (int c = 0; c < 2; c ++)
              {
                float x = entry[c].data.f[0];
                float y = entry[c].data.f[1];
                _ctx_user_to_device (state, &x, &y);
                entry[c].data.f[0] = x;
                entry[c].data.f[1] = y;
              }
          }
        break;
      case CTX_REL_MOVE_TO:
      case CTX_REL_LINE_TO:
        if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
          {
            for (int c = 0; c < 1; c ++)
              {
                float x = state->x;
                float y = state->y;
                _ctx_user_to_device (state, &x, &y);
                entry[c].data.f[0] = x;
                entry[c].data.f[1] = y;
              }
            if (entry->code == CTX_REL_MOVE_TO)
              { entry->code = CTX_MOVE_TO; }
            else
              { entry->code = CTX_LINE_TO; }
          }
        break;
      case CTX_REL_CURVE_TO:
        {
          float nx = state->x + ctx_arg_float (4);
          float ny = state->y + ctx_arg_float (5);
          if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
            {
              for (int c = 0; c < 3; c ++)
                {
                  float x = nx + entry[c].data.f[0];
                  float y = ny + entry[c].data.f[1];
                  _ctx_user_to_device (state, &x, &y);
                  entry[c].data.f[0] = x;
                  entry[c].data.f[1] = y;
                }
              entry->code = CTX_CURVE_TO;
            }
        }
        break;
      case CTX_REL_QUAD_TO:
        {
          float nx = state->x + ctx_arg_float (2);
          float ny = state->y + ctx_arg_float (3);
          if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) )
            {
              for (int c = 0; c < 2; c ++)
                {
                  float x = nx + entry[c].data.f[0];
                  float y = ny + entry[c].data.f[1];
                  _ctx_user_to_device (state, &x, &y);
                  entry[c].data.f[0] = x;
                  entry[c].data.f[1] = y;
                }
              entry->code = CTX_QUAD_TO;
            }
        }
        break;
    }
  if ((((Ctx *) (data) )->transformation & CTX_TRANSFORMATION_RELATIVE))
    {
      int components = 0;
      _ctx_user_to_device (state, &start_x, &start_y);
      switch (entry->code)
        {
          case CTX_MOVE_TO:
            //if (state->has_moved) { components = 1; }
            break;
          case CTX_LINE_TO:
            components = 1;
            break;
          case CTX_CURVE_TO:
            components = 3;
            break;
          case CTX_QUAD_TO:
            components = 2;
            break;
        }
      if (components)
        {
          for (int c = 0; c < components; c++)
            {
              entry[c].data.f[0] -= start_x;
              entry[c].data.f[1] -= start_y;
            }
          switch (entry->code)
            {
              case CTX_MOVE_TO:
                entry[0].code = CTX_REL_MOVE_TO;
                break;
              case CTX_LINE_TO:
                entry[0].code = CTX_REL_LINE_TO;
                break;
              case CTX_CURVE_TO:
                entry[0].code = CTX_REL_CURVE_TO;
                break;
              case CTX_QUAD_TO:
                entry[0].code = CTX_REL_QUAD_TO;
                break;
            }
        }
    }
}

void
ctx_interpret_pos_bare (CtxState *state, const CtxEntry *entry, void *data)
{
  switch (entry->code)
    {
      case CTX_START_FRAME:
        ctx_state_init (state);
        state->has_moved = 0;
        break;
      case CTX_CLIP:
      case CTX_RESET_PATH:
      case CTX_FILL:
      case CTX_STROKE:
        state->has_moved = 0;
        break;
      case CTX_CLOSE_PATH:
      case CTX_CLOSE_PATH2:
        state->x = state->first_x;
        state->y = state->first_y;
        state->has_moved = -1;
        break;
      case CTX_MOVE_TO:
      case CTX_LINE_TO:
        state->x = ctx_arg_float (0);
        state->y = ctx_arg_float (1);
        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
        break;
      case CTX_CURVE_TO:
        state->x = ctx_arg_float (4);
        state->y = ctx_arg_float (5);
        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
        break;
      case CTX_QUAD_TO:
        state->x = ctx_arg_float (2);
        state->y = ctx_arg_float (3);
        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
        break;
      case CTX_ARC:
        state->x = ctx_arg_float (0) + ctx_cosf (ctx_arg_float (4) ) * ctx_arg_float (2);
        state->y = ctx_arg_float (1) + ctx_sinf (ctx_arg_float (4) ) * ctx_arg_float (2);
        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
        break;
      case CTX_REL_MOVE_TO:
      case CTX_REL_LINE_TO:
        state->x += ctx_arg_float (0);
        state->y += ctx_arg_float (1);

        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
        break;
      case CTX_REL_CURVE_TO:
        state->x += ctx_arg_float (4);
        state->y += ctx_arg_float (5);
        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
        break;
      case CTX_REL_QUAD_TO:
        state->x += ctx_arg_float (2);
        state->y += ctx_arg_float (3);
        if (state->has_moved<=0)
        {
          state->first_x = state->x;
          state->first_y = state->y;
          state->has_moved = 1;
        }
    }
}

void
ctx_interpret_pos (CtxState *state, CtxEntry *entry, void *data)
{
  if ( ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_SCREEN_SPACE) ||
       ( ( (Ctx *) (data) )->transformation & CTX_TRANSFORMATION_RELATIVE) )
    {
      ctx_interpret_pos_transform (state, entry, data);
    }
  ctx_interpret_pos_bare (state, entry, data);
}

#if CTX_BABL
void ctx_colorspace_babl (CtxState   *state,
                          CtxColorSpace  icc_slot,
                          const Babl *space);
#endif

#ifndef CTX_TEXT_WRAP
#define CTX_TEXT_WRAP 1
#endif

void
ctx_state_init (CtxState *state)
{
  char *stringpool = state->stringpool;
  int stringpool_size = state->stringpool_size;
  memset (state, 0, sizeof (CtxState) );
  state->stringpool = stringpool;
  state->stringpool_size = stringpool_size;
  state->gstate.global_alpha_u8 = 255;
  state->gstate.global_alpha_u8 = 255;
  state->gstate.global_alpha_f  = 1.0;
  state->gstate.font_size       = 32; // default HTML canvas is 10px sans
  state->gstate.line_width      = 2.0;
  state->gstate.image_smoothing = 1;
  state->gstate.source_stroke.type = CTX_SOURCE_INHERIT_FILL;
  ctx_color_set_graya (state, &state->gstate.source_fill.color, 1.0f, 1.0f);
  ctx_state_set (state, SQZ_lineHeight, 1.0f);
#if CTX_TEXT_WRAP
  ctx_state_set (state, SQZ_wrapLeft, 0.0f);
  ctx_state_set (state, SQZ_wrapRight, 0.0f);
#endif

  state->ink_min_x              = 8192;
  state->ink_min_y              = 8192;
  state->ink_max_x              = -8192;
  state->ink_max_y              = -8192;
  _ctx_matrix_identity (&state->gstate.transform);
#if CTX_ENABLE_CM
#if CTX_BABL
  //ctx_colorspace_babl (state, CTX_COLOR_SPACE_USER_RGB,   babl_space ("sRGB"));
  //ctx_colorspace_babl (state, CTX_COLOR_SPACE_DEVICE_RGB, babl_space ("ACEScg"));
#endif
#endif
}

void _ctx_set_transformation (Ctx *ctx, int transformation)
{
  ctx->transformation = transformation;
}
static void ctx_setup (Ctx *ctx);

#if CTX_SIMD
void ctx_simd_setup (void);
#endif
static void
_ctx_init (Ctx *ctx)
{
  static int done_first_run = 0;
  ctx_setup (ctx);

  if (!done_first_run)
  {
#if CTX_BABL
    babl_init ();
#endif
    done_first_run = 1;
#if CTX_SIMD
    ctx_simd_setup ();
#endif
#if CTX_U8_TO_FLOAT_LUT
    for (int i = 0; i <256;i++)
      ctx_u8_float[i] = i/255.0f;
#endif
  }

  ctx_state_init (&ctx->state);

#if CTX_CURRENT_PATH
  ctx->current_path.flags |= CTX_DRAWLIST_CURRENT_PATH;
#endif
  //ctx->transformation |= (CtxTransformation) CTX_TRANSFORMATION_SCREEN_SPACE;
  //ctx->transformation |= (CtxTransformation) CTX_TRANSFORMATION_RELATIVE;
#if CTX_BITPACK
  ctx->drawlist.flags |= CTX_TRANSFORMATION_BITPACK;
#endif
  ctx->texture_cache = ctx;

  ctx_font_setup (ctx);
}


#if CTX_DRAWLIST_STATIC
static Ctx ctx_state;
#endif

void ctx_push_backend (Ctx *ctx,
                       void *backend)
{
  if (ctx->backend_pushed)
    fprintf (stderr, "double push\n");
  ctx->backend_pushed = ctx->backend;
  ctx->backend = (CtxBackend*)backend;
  if (ctx->backend->process == NULL)
    ctx->backend->process = (void(*)(Ctx*,const CtxCommand*))ctx_drawlist_process;
  ctx->process = ctx->backend->process;
}


void ctx_pop_backend (Ctx *ctx)
{
  if (!ctx->backend_pushed)
    fprintf (stderr, "backend pop without push\n");
  if (ctx->backend && ctx->backend->destroy)
    ctx->backend->destroy (ctx->backend);
  ctx->backend = ctx->backend_pushed;
  ctx->backend_pushed = NULL;
  ctx->process = ctx->backend->process;
}

void ctx_set_backend (Ctx  *ctx,
                       void *backend)
{
  if (ctx->backend && ctx->backend->destroy)
    ctx->backend->destroy (ctx->backend);
  ctx->backend = (CtxBackend*)backend;
  if (ctx->backend->process == NULL)
    ctx->backend->process = (void(*)(Ctx*,const CtxCommand*))ctx_drawlist_process;
  ctx->process = ctx->backend->process;
}

void *ctx_get_backend (Ctx *ctx)
{
  return ctx->backend;
}


Ctx *
ctx_new_drawlist (int width, int height)
{
#if CTX_DRAWLIST_STATIC
  Ctx *ctx = &ctx_state;
#else
  Ctx *ctx = (Ctx *) ctx_malloc (sizeof (Ctx) );
#endif
  memset (ctx, 0, sizeof (Ctx) );
  _ctx_init (ctx);

  ctx_set_backend (ctx, ctx_drawlist_backend_new ());
  ctx_set_size (ctx, width, height);
  return ctx;
}

/* used by micro-controller backends */
Ctx *ctx_host (void);

CTX_EXPORT Ctx *
ctx_new (int width, int height, const char *backend)
{
  Ctx * ret = NULL;
#if CTX_EVENTS
  if (backend && !ctx_strcmp (backend, "drawlist"))
#endif
  {
    ret = ctx_new_drawlist (width, height);
  }
#if CTX_EVENTS
  else
    ret = ctx_new_ui (width, height, backend);
#endif
  return ret;
}

void
ctx_drawlist_deinit (CtxDrawlist *drawlist)
{
#if !CTX_DRAWLIST_STATIC
  if (drawlist->entries && ! (drawlist->flags & CTX_DRAWLIST_DOESNT_OWN_ENTRIES) )
    {
      ctx_free (drawlist->entries); 
    }
#endif
  drawlist->entries = NULL;
  drawlist->size = 0;
}


static void ctx_deinit (Ctx *ctx)
{
#if CTX_EVENTS
  ctx_events_deinit (ctx);
#endif

  if (ctx->backend)
    {
      if (ctx->backend->destroy)
        ctx->backend->destroy (ctx->backend);
      ctx->backend    = NULL;
    }
  ctx_drawlist_deinit (&ctx->drawlist);
#if CTX_CURRENT_PATH
  ctx_drawlist_deinit (&ctx->current_path);
#endif

  for (int no = 0; no < CTX_MAX_TEXTURES; no++)
    ctx_buffer_deinit (&ctx->texture[no]);
}

CTX_EXPORT void
ctx_destroy (Ctx *ctx)
{
  if (!ctx)
    { return; }

   if ((ctx_backend_type(ctx) != CTX_BACKEND_DRAWLIST) &&
       //(ctx_backend_type(ctx) != CTX_BACKEND_RASTERIZER) &&
       (ctx_backend_type(ctx) != CTX_BACKEND_HASHER) 

        && _ctx_depth)
   {
     _ctx_depth--;
     return;
   }

   if (ctx->state.stringpool)
   {
     ctx_free (ctx->state.stringpool);
     ctx->state.stringpool = NULL;
     ctx->state.stringpool_size = 0;
   }

#if CTX_VT
  while (ctx_clients (ctx))
    ctx_client_remove (ctx, (CtxClient*)ctx_clients(ctx)->data);
#endif

#if 0
#if CTX_PICO || CTX_ESP
   if (ctx == ctx_host ())
      return;
#endif
#endif

  while (ctx->deferred) 
  {
    void *command = ctx->deferred->data;
    ctx_list_remove (&ctx->deferred, command);
    free (command);
  }


#if CTX_EVENTS
  ctx_clear_bindings (ctx);
  while (ctx->events.idles)
  {
    CtxIdleCb *item = (CtxIdleCb*)ctx->events.idles->data;
    ctx_remove_idle (ctx, item->id);
  }

#endif
  ctx_deinit (ctx);
#if !CTX_DRAWLIST_STATIC
  ctx_free (ctx);
#endif
}


Ctx *
ctx_new_for_drawlist (int width, int height, void *data, size_t length)
{
  Ctx *ctx = ctx_new_drawlist (width, height);
  ctx->drawlist.flags   |= CTX_DRAWLIST_DOESNT_OWN_ENTRIES;
  ctx->drawlist.entries  = (CtxEntry *) data;
  ctx->drawlist.count    = length / sizeof (CtxEntry);
  return ctx;
}


static void ctx_setup (Ctx *ctx)
{
  ctx_font_setup (ctx);
}

void
ctx_render_ctx (Ctx *ctx, Ctx *d_ctx)
{
  CtxIterator iterator;
  CtxCommand *command;
  d_ctx->bail = 0;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0,
                     0);
  void  (*process)  (Ctx *ctx, const CtxCommand *entry) = d_ctx->process;
  while ( (command = (CtxCommand*)ctx_iterator_next (&iterator) ) )
    process (d_ctx, command);
}

void
ctx_render_ctx_masked (Ctx *ctx, Ctx *d_ctx, uint32_t mask)
{
  CtxIterator iterator;
  CtxCommand *command;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0, 0);
  void  (*process)  (Ctx *ctx, const CtxCommand *entry) = d_ctx->process;
  uint32_t active_mask = 0xffffffff;

  while ( (command = (CtxCommand*)ctx_iterator_next (&iterator) ) )
    {
       d_ctx->bail = ((active_mask & mask) == 0);
       process (d_ctx, command);

       switch (command->code)
       {
         case CTX_FILL:
         case CTX_STROKE:
         case CTX_CLIP:
         case CTX_TEXT:
         case CTX_GLYPH:
           active_mask = command->entry.data.u32[1];
       }
    }
}

void
ctx_render_ctx_textures (Ctx *ctx, Ctx *d_ctx)
{
  CtxIterator iterator;
  CtxCommand *command;
  ctx_iterator_init (&iterator, &ctx->drawlist, 0,
                     CTX_ITERATOR_EXPAND_BITPACK);
  while ( (command = ctx_iterator_next (&iterator) ) )
    {
       switch (command->code)
       {
         default:
                 //fprintf (stderr, "[%c]", command->code);
                 break;
         case CTX_TEXTURE:
             //fprintf (stderr, "t:%s\n", command->texture.eid);
             ctx_process (d_ctx, &command->entry);
             break;
         case CTX_DEFINE_TEXTURE:
             //fprintf (stderr, "d:%s\n", command->define_texture.eid);
             ctx_process (d_ctx, &command->entry);
           break;
       }
    }
}

void ctx_exit (Ctx *ctx)
{
  ctx->exit++;
}

int  ctx_has_exited (Ctx *ctx)
{
  return (ctx->exit != 0);
}

void ctx_reset_has_exited (Ctx *ctx)
{
  ctx->exit = 0;
}

int ctx_pixel_format_bits_per_pixel (CtxPixelFormat format)
{
  const CtxPixelFormatInfo *info = ctx_pixel_format_info (format);
  if (info)
    return info->bpp;
  return -1;
}

int ctx_pixel_format_get_stride (CtxPixelFormat format, int width)
{
  const CtxPixelFormatInfo *info = ctx_pixel_format_info (format);
  if (info)
  {
    switch (info->bpp)
    {
      case 0:
      case 1:
        return (width + 7)/8;
      case 2:
        return (width + 3)/4;
      case 4:
        return (width + 1)/2;
      default:
        return width * (info->bpp / 8);
    }
  }
  return width;
}

int ctx_pixel_format_ebpp (CtxPixelFormat format)
{
  const CtxPixelFormatInfo *info = ctx_pixel_format_info (format);
  if (info)
    return info->ebpp;
  return -1;
}

int ctx_pixel_format_components (CtxPixelFormat format)
{
  const CtxPixelFormatInfo *info = ctx_pixel_format_info (format);
  if (info)
    return info->components;
  return -1;
}

void ctx_set_texture_source (Ctx *ctx, Ctx *texture_source)
{
  ((CtxRasterizer*)ctx->backend)->texture_source = texture_source;
}

void ctx_set_texture_cache (Ctx *ctx, Ctx *texture_cache)
{
  ctx->texture_cache = texture_cache;
}

#if CTX_EVENTS
void         ctx_set_cursor (Ctx *ctx, CtxCursor cursor)
{
  if (ctx->cursor != cursor)
  {
    ctx_queue_draw (ctx);
    ctx->cursor = cursor;
  }
}
CtxCursor    ctx_get_cursor (Ctx *ctx)
{
  return ctx->cursor;
}

static char *ctx_fb_clipboard = NULL;
static void ctx_headless_set_clipboard (Ctx *ctx, const char *text)
{
  if (ctx_fb_clipboard)
    ctx_free (ctx_fb_clipboard);
  ctx_fb_clipboard = NULL;
  if (text)
  {
    ctx_fb_clipboard = ctx_strdup (text);
  }
}

static char *ctx_headless_get_clipboard (Ctx *ctx)
{
  if (ctx_fb_clipboard) return ctx_strdup (ctx_fb_clipboard);
  return ctx_strdup ("");
}


void ctx_set_clipboard (Ctx *ctx, const char *text)
{
  if (ctx->backend && ctx->backend->set_clipboard)
  {
    ctx->backend->set_clipboard (ctx, text);
    return;
  }
  ctx_headless_set_clipboard (ctx, text);
}

void ctx_internal_clipboard (Ctx *ctx, int internal_clipboard)
{
  if (internal_clipboard)
  {
    if (ctx->backend)
    {
       ctx->backend->set_clipboard = NULL;
       ctx->backend->get_clipboard = NULL;
    }
  }
}

void ctx_windowtitle (Ctx *ctx, const char *text)
{
  if (ctx->backend && ctx->backend->set_windowtitle)
  {
    ctx->backend->set_windowtitle (ctx, text);
    return;
  }
}

char *ctx_get_clipboard (Ctx *ctx)
{
  if (ctx->backend && ctx->backend->get_clipboard)
  {
    return ctx->backend->get_clipboard (ctx);
  }
  return ctx_headless_get_clipboard (ctx);
}

void ctx_reset_caches (Ctx *ctx)
{
  if (ctx->backend && ctx->backend->reset_caches)
    return ctx->backend->reset_caches (ctx);
}

void ctx_set_transform (Ctx *ctx, float a, float b, float c, float d, float e, float f, float g, float h, float i)
{
  ctx_identity (ctx);
  ctx_apply_transform (ctx, a, b, c, d, e, f, g, h, i);
}

#endif

#if CTX_GET_CONTENTS

#if CTX_CURL
#include <curl/curl.h>
static size_t
ctx_string_append_callback (void *contents, size_t size, size_t nmemb, void *userp)
{
  CtxString *string = (CtxString*)userp;
  ctx_string_append_data ((CtxString*)string, (char*)contents, size * nmemb);
  return size * nmemb;
}

#endif

#if CSS_HAVE_FS
int css_static_get_contents (const char *path, char **contents, long *length);
#endif

int
ctx_get_contents2 (const char     *uri,
                   unsigned char **contents,
                   long           *length,
                   long            max_len)
{
  char *temp_uri = NULL; // XXX XXX breaks with data uri's
  int   success  = -1;

  if (uri[0] == '/')
  {
    temp_uri = (char*) ctx_malloc (ctx_strlen (uri) + 8);
    sprintf (temp_uri, "file://%s", uri);
    uri = temp_uri;
  }

  if (strchr (uri, '#'))
  {
    if (temp_uri == NULL)
      uri = temp_uri = strdup (uri);
   strchr (uri, '#')[0]=0;
  }

  for (CtxList *l = registered_contents; l; l = l->next)
  {
    CtxFileContent *c = (CtxFileContent*)l->data;
    if (!ctx_strcmp (c->path, uri))
    {
      contents = (unsigned char**) ctx_malloc (c->length+1);
      contents[c->length]=0;
      if (length) *length = c->length;
      ctx_free (temp_uri);
      return 0;
    }
  }

  if (!strncmp (uri, "file://", 5))
  {
    if (strchr (uri, '?'))
     strchr (uri, '?')[0]=0;
  }

  if (!strncmp (uri, "file://", 7))
    success = CTX_LOAD_FILE (uri + 7, contents, length, max_len);
#if CSS_HAVE_FS
  else if (!strncmp (uri, "itk:", 4))
  {
    success = css_static_get_contents (uri, (char**)contents, length);
  }
#endif
  else
  {
#if CTX_CURL
  CURL *curl = curl_easy_init ();
  CURLcode res;

  curl_easy_setopt(curl, CURLOPT_URL, uri);
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    CtxString *string = ctx_string_new ("");

      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ctx_string_append_callback);
   /* we pass our 'chunk' struct to the callback function */
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)string);

  curl_easy_setopt(curl, CURLOPT_USERAGENT, "ctx/0.0");

   res = curl_easy_perform(curl);
  /* check for errors */
  if(res != CURLE_OK) {
          fprintf(stderr, "curl_easy_perform() failed: %s\n",
            curl_easy_strerror(res));
     curl_easy_cleanup (curl);
  }
  else
  {
     *contents = (unsigned char*)string->str;
     *length = string->length;
     ctx_string_free (string, 0);
     curl_easy_cleanup (curl);
     success = 0;
  }
#else
    success = CTX_LOAD_FILE (uri, contents, length, max_len);
#endif
  }
  ctx_free (temp_uri);
  return success;
}


int
ctx_get_contents (const char     *uri,
                  unsigned char **contents,
                  long           *length)
{
  return ctx_get_contents2 (uri, contents, length, 1024*1024*1024);
}

#if CTX_MAGIC

typedef struct CtxMagicEntry {
  int is_text;
  const char *mime_type;
  const char *ext1;
  int len;
  uint8_t magic[16];
} CtxMagicEntry;

static const CtxMagicEntry ctx_magics[]={
  {0, "image/bmp",  ".bmp", 0, {0}},
  {0, "image/png",  ".png", 8, {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a}},
  {0, "image/jpeg", ".jpg", 8,  {0xff, 0xd8, 0xff, 0xdb, 0xff, 0xd8, 0xff, 0xe0}},
  {0, "image/jpeg", ".jpg", 4,  {0xff, 0xd8, 0xff, 0xe0}},
  {0, "image/jpeg", ".jpg", 4,  {0xff, 0xd8, 0xff, 0xee}},
  {0, "image/jpeg", ".jpg", 4,  {0xff, 0xd8, 0xff, 0xe1}},
  {0, "image/jpeg", ".jpeg", 8, {0xff, 0xd8, 0xff, 0xdb, 0xff, 0xd8, 0xff, 0xe0}},

  {0, "image/psd", ".psd", 4,  {0x38, 0x42, 0x50, 0x53}},
  {0, "image/gif",  ".gif", 6, {0x47, 0x49, 0x46, 0x38, 0x37, 0x61}},
  {0, "image/gif",  ".gif", 6, {0x47, 0x49, 0x46, 0x38, 0x39, 0x61}},
  {0, "image/exr",  ".exr", 4, {0x76, 0x2f, 0x31, 0x01}},
  {0, "video/mpeg", ".mpg", 4, {0x00, 0x00, 0x01, 0xba}},
  {0, "application/blender", ".blend", 8, {0x42, 0x4c,0x45,0x4e,0x44,0x45,0x52}},
  {0, "application/x-sharedlib", ".elf", 4, {0x7f, 'E','L','F'}},
  {0, "image/xcf",  ".xcf", 8, {0x67, 0x69,0x6d,0x70,0x20,0x78,0x63,0x66}},
  {0, "application/bzip2", ".bz2", 3, {0x42, 0x5a, 0x68}},
  {0, "application/gzip", ".gz", 2, {0x1f, 0x8b}},
  {0, "application/zip", ".zip", 4, {0x50, 0x4b, 0x03, 0x04}},
  {0, "application/zip", ".zip", 4, {0x50, 0x4b, 0x05, 0x06}},
  {0, "application/rar", ".rar", 6, {0x52, 0x61, 0x72, 0x1a, 0x07, 0x00}},
  {0, "application/rar", ".rar", 7, {0x52, 0x61, 0x72, 0x1a, 0x07, 0x01, 0x00}},
  {1, "text/x-csrc", ".c", 0, {0,}},
  {1, "text/x-chdr", ".h", 0, {0,}},
  {1, "text/css", ".css", 0, {0x0}},

  {0, "application/gzip", ".z", 2, {0x1f, 0x9d}},

  {0, "application/dos-mz", ".exe", 2, {0x4d, 0x5a}},

  {1, "text/csv", ".csv", 0, {0x0}},
  {1, "text/html", ".htm", 0, {0x0}},
  {1, "text/html", ".html", 0, {0x0}},
  {1, "image/svg+xml", ".svg", 0, {0x0}},
  {1, "text/x-makefile", "makefile", 0, {0x0}},
  {1, "application/atom+xml", ".atom", 0, {0x0}},
  {1, "application/rdf+xml", ".rdf", 0, {0x0}},
  {1, "application/javascript", ".js", 0, {0x0}},
  {1, "application/json", ".json", 0, {0x0}},
  {0, "application/octet-stream", ".bin", 0, {0x0}},
  {0, "application/x-object", ".o", 0, {0x0}},
  {1, "text/utf-8", ".txt", 0, {0xef, 0xbb, 0xbf}}, // utf8 bom
  {1, "text/x-python", ".py", 0, {0x0}},
  {1, "text/x-perl", ".pl", 0, {0x0}},
  {1, "text/x-perl", ".pm", 0, {0x0}},
  {1, "application/x-shellscript", ".sh", 2, {0x23, 0x21}}, // #!
  {0, "application/pdf", ".pdf", 0, {0x0}},
  {0, "application/ctx", ".ctx", 0, {0x0}},
  {0, "application/wasm", ".wasm", 0, {0x00, 0x61, 0x73, 0x6d}},
  {1, "text/xml", ".xml",     0, {0x0}},
  {0, "video/mp4", ".mp4",    7, {0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6f}},
  {0, "video/matroska", ".mkv", 4, {0x1a, 0x45, 0xdf, 0xa3}},
  {0, "video/ogg", ".ogv",    0, {0x0}},
  {0, "audio/flac", ".flac",  0, {0x66, 0x4c, 0x61, 0x43}},
  {0, "audio/sp-midi", ".mid",  4, {0x4d, 0x54, 0x68, 0x64}},
  {0, "audio/x-wav", ".wav",  4, {0x52, 0x49, 0x46, 0x46}},
  {0, "audio/ogg", ".ogg",    4, {0x4f, 0x67, 0x67, 0x53}},
  {0, "audio/ogg", ".opus",   0, {0x0}},
  {0, "audio/protracker", ".mod",   0, {0x0}},
  {0, "audio/screamtracker", ".s3m",   0, {0x0}},
  {0, "audio/ogg", ".oga",    0, {0x0}},
  {0, "audio/mpeg", ".mp1",   0, {0x0}},
  {0, "audio/m3u", ".m3u",    0, {0x0}},
  {0, "audio/mpeg", ".mp2",   0, {0x0}},
  {0, "audio/mpeg", ".mp3",   0, {0x0}},
  {0, "audio/mpeg", ".m4a",   0, {0x0}},
  {0, "audio/mpeg", ".mpga",  0, {0x0}},
  {0, "audio/mpeg", ".mpega", 0, {0x0}},
  {0, "font/otf", ".otf", 0,{0x0}},
  {0, "font/ttf", ".ttf", 5,{0x0, 0x01, 0x00, 0x00, 0x00}},
  // inode-directory
};

int ctx_path_is_dir (const char *path)
{
  struct stat stat_buf;
  if (!path || path[0]==0) return 0;
  stat (path, &stat_buf);
  return S_ISDIR (stat_buf.st_mode);
}

static int ctx_path_is_exec (const char *path)
{
  struct stat stat_buf;
  if (!path || path[0]==0) return 0;
  stat (path, &stat_buf);
  return stat_buf.st_mode & 0x1;
}

int ctx_media_matched_content = 0;
const char *ctx_guess_media_type (const char *path, const char *content, int len)
{
  const char *extension_match = NULL;
  ctx_media_matched_content = 0;
  if (path && strrchr (path, '.'))
  {
    char *pathdup = ctx_strdup (strrchr(path, '.'));
    for (int i = 0; pathdup[i]; i++) pathdup[i]=tolower(pathdup[i]);
    for (unsigned int i = 0; i < sizeof (ctx_magics)/sizeof(ctx_magics[0]);i++)
    {
      if (ctx_magics[i].ext1 && !ctx_strcmp (ctx_magics[i].ext1, pathdup))
      {
        extension_match = ctx_magics[i].mime_type;
      }
    }
    ctx_free (pathdup);
  }

  if (len > 16)
  {
    for (unsigned int i = 0; i < sizeof (ctx_magics)/sizeof(ctx_magics[0]);i++)
    {
       if (ctx_magics[i].len) // skip extension only matches
       if (!memcmp (content, ctx_magics[i].magic, ctx_magics[i].len))
       {
         ctx_media_matched_content = 1;
         return ctx_magics[i].mime_type;
       }
    }
  }

  if (extension_match && !ctx_strcmp (extension_match, "application/ctx"))
  {
    //if (!ctx_path_is_exec (path))
    //  extension_match = NULL;
  }

  if (extension_match) return extension_match;


  int non_ascii=0;
  for (int i = 0; i < len; i++)
  {
    int p = content[i];
    if (p > 127) non_ascii = 1;
    if (p < ' ' && (p!='\n')) non_ascii = 1;
    if (p == 0) non_ascii = 1;
  }
  if (non_ascii)
    return "application/octet-stream";
  return "text/plain";
}


const char *ctx_path_get_media_type (const char *path)
{
  char *content = NULL;
  long length = 0;

  if (strchr(path, ':'))
  {
    path = strchr (path, ':') + 1;
    if (path[0]=='/')path++;
    if (path[0]=='/')path++;
  }

#if 0
  /* XXX : code duplication, factor out in separate fun */
  if (path && strrchr (path, '.'))
  {
    char *pathdup = ctx_strdup (strrchr(path, '.'));
    for (int i = 0; pathdup[i]; i++) pathdup[i]=tolower(pathdup[i]);
    for (unsigned int i = 0; i < sizeof (ctx_magics)/sizeof(ctx_magics[0]);i++)
    {
      if (ctx_magics[i].ext1 && !ctx_strcmp (ctx_magics[i].ext1, pathdup))
      {
        ctx_free (pathdup);
        return ctx_magics[i].mime_type;
      }
    }
    ctx_free (pathdup);
  }
#endif
  if (ctx_path_is_dir (path))
    return "inode/directory";

  ctx_get_contents2 (path, (uint8_t**)&content, &length, 128);
  if (content)
  {
  const char *guess = ctx_guess_media_type (path, content, length);
  ctx_free (content);
  return guess;
  }
  return "application/none";
}

int ctx_media_type_is_text (const char *media_type)
{
  for (unsigned int i = 0; i < sizeof (ctx_magics)/sizeof(ctx_magics[0]);i++)
    if (media_type == ctx_magics[i].mime_type)
       return ctx_magics[i].is_text;
  for (unsigned int i = 0; i < sizeof (ctx_magics)/sizeof(ctx_magics[0]);i++)
    if (!strcmp (media_type,  ctx_magics[i].mime_type))
       return ctx_magics[i].is_text;
  if (!strcmp (media_type, "text/plain"))
    return 1;
  return 0;
}

CtxMediaTypeClass ctx_media_type_class (const char *media_type)
{
  CtxMediaTypeClass ret = CTX_MEDIA_TYPE_NONE;
  if (!media_type) return ret;
  if (!ret){
    ret = CTX_MEDIA_TYPE_IMAGE;
    if (media_type[0]!='i')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[1]!='m')ret = CTX_MEDIA_TYPE_NONE;
    /*
    if (media_type[2]!='a')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[3]!='g')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[4]!='e')ret = 0;*/
  }
  if (!ret){
    ret = CTX_MEDIA_TYPE_VIDEO;
    if (media_type[0]!='v')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[1]!='i')ret = CTX_MEDIA_TYPE_NONE;
    /*
    if (media_type[2]!='d')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[3]!='e')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[4]!='o')ret = CTX_MEDIA_TYPE_NONE;*/
  }
  if (!ret){
    ret = CTX_MEDIA_TYPE_AUDIO;
    if (media_type[0]!='a')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[1]!='u')ret = CTX_MEDIA_TYPE_NONE;
    /*
    if (media_type[2]!='d')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[3]!='i')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[4]!='o')ret = CTX_MEDIA_TYPE_NONE;*/
  }
  if (!ret){
    ret = CTX_MEDIA_TYPE_TEXT;
    if (media_type[0]!='t')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[1]!='e')ret = CTX_MEDIA_TYPE_NONE;
    /*
    if (media_type[2]!='x')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[3]!='t')ret = CTX_MEDIA_TYPE_NONE;*/
  }
  if (!ret){
    ret = CTX_MEDIA_TYPE_APPLICATION;
    if (media_type[0]!='a')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[1]!='p')ret = CTX_MEDIA_TYPE_NONE;
    /*
    if (media_type[2]!='p')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[3]!='l')ret = CTX_MEDIA_TYPE_NONE;*/
  }
  if (!ret){
    ret = CTX_MEDIA_TYPE_INODE;
    if (media_type[0]!='i')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[1]!='n')ret = CTX_MEDIA_TYPE_NONE;
    /*
    if (media_type[2]!='o')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[3]!='d')ret = CTX_MEDIA_TYPE_NONE;
    if (media_type[4]!='e')ret = CTX_MEDIA_TYPE_NONE;*/
  }
  return ret;
}
#endif

#else
int
ctx_get_contents (const char     *uri,
                  unsigned char **contents,
                  long           *length)
{
  *contents = NULL;
  *length = -1;
  return -1;
//ctx_get_contents2 (uri, contents, length, 1024*1024*1024);
}

#endif


void
ctx_current_point (Ctx *ctx, float *x, float *y)
{
  float user_x = 0.0f, user_y = 0.0f;
  if (!ctx)
    { 
      if (x) { *x = 0.0f; }
      if (y) { *y = 0.0f; }
    }
#if CTX_RASTERIZER_X
  if (ctx->backend && ctx->backend->process == ctx_rasterizer_process)
    {
      user_x = ((CtxRasterizer *) (ctx->backend) )->x;
      user_y = ((CtxRasterizer *) (ctx->backend) )->y;
    }
  else
#endif
    {
      user_x = ctx->state.x;
      user_y = ctx->state.y;
    }


  if (x) *x = user_x;
  if (y) *y = user_y;
}



float ctx_x (Ctx *ctx)
{
  float x = 0, y = 0;
  ctx_current_point (ctx, &x, &y);
  return x;
}

float ctx_y (Ctx *ctx)
{
  float x = 0, y = 0;
  ctx_current_point (ctx, &x, &y);
  return y;
}

static CtxBackendType __ctx_backend_type (Ctx *ctx)
{
  if (!ctx)
    return CTX_BACKEND_NONE;
  CtxBackend *backend = ctx->backend;
  if (backend == NULL)
    return CTX_BACKEND_NONE;
#if CTX_RASTERIZER
  else if (backend->destroy == (void*) ctx_cb_destroy) return CTX_BACKEND_CB;
#endif
#if CTX_NET
  else if (backend->destroy == (void*) ctx_net_destroy) return CTX_BACKEND_CTX;
#endif
#if CTX_TERMINAL_EVENTS
#if CTX_TERM
  else if (backend->destroy == (void*) ctx_term_destroy) return CTX_BACKEND_TERM;
#endif
#endif
#if CTX_RASTERIZER
  else if (backend->process == (void*) ctx_hasher_process) return CTX_BACKEND_HASHER;
#endif
#if CTX_RASTERIZER
  else if (backend->destroy == (void*) ctx_rasterizer_destroy) return CTX_BACKEND_RASTERIZER;
#endif
  return CTX_BACKEND_NONE;
}

CtxBackendType ctx_backend_type (Ctx *ctx)
{
  CtxBackend *backend = ctx->backend;
  CtxBackendType internal = backend->type;

  if (!internal)
  {
    CtxBackendType computed = __ctx_backend_type (ctx);
    backend->type = computed;
    //fprintf (stderr, "did a caching set of %i\n", computed);
    return computed;
  }

  return internal;
}

void ctx_wait_for_renderer (Ctx *ctx)
{
  if (ctx_backend_type (ctx) == CTX_BACKEND_CB)
  {
    CtxBackend  * backend = (CtxBackend*)ctx->backend;
    CtxCbBackend* cb      = (CtxCbBackend*)backend;
    while (cb->rendering != 0)
    {
      usleep (2 * 1000);
    }
  }
}

void ctx_set_fullscreen (Ctx *ctx, int val)
{
  if (ctx_backend_type (ctx) == CTX_BACKEND_CB)
  {
    CtxBackend  * backend = (CtxBackend*)ctx->backend;
    CtxCbBackend* cb      = (CtxCbBackend*)backend;
    if (cb->config.set_fullscreen)
    {
        cb->config.set_fullscreen (ctx, 
                        cb->config.set_fullscreen_user_data?
                        cb->config.set_fullscreen_user_data:
                        cb->config.user_data,

                        val);
        ctx_queue_draw (ctx);
    }
  }
}

int ctx_get_fullscreen (Ctx *ctx)
{
  if (ctx_backend_type (ctx) == CTX_BACKEND_CB)
  {
    CtxBackend  * backend = (CtxBackend*)ctx->backend;
    CtxCbBackend* cb      = (CtxCbBackend*)backend;
    if (cb->config.get_fullscreen)
        return cb->config.get_fullscreen (ctx, 
                        cb->config.get_fullscreen_user_data?
                        cb->config.get_fullscreen_user_data:
                        cb->config.user_data);
  }
  return 0;
}

const CtxPixelFormatInfo *ctx_pixel_formats =
#if CTX_COMPOSITE && CTX_SIMD_BUILD==0
ctx_pixel_formats_generic;
#else
NULL;
#endif

const CtxPixelFormatInfo *
ctx_pixel_format_info (CtxPixelFormat format)
{
  if (!ctx_pixel_formats)
  {
    assert (0);
    return NULL;
  }
  for (unsigned int i = 0; ctx_pixel_formats[i].pixel_format; i++)
    {
      if (ctx_pixel_formats[i].pixel_format == format)
        {
          return &ctx_pixel_formats[i];
        }
    }
  //assert (0);
  return NULL;
}


#if CTX_RASTERIZER

void ctx_rasterizer_rasterize_edges_generic (CtxRasterizer *rasterizer, const int fill_rule);

void (*ctx_rasterizer_rasterize_edges) (CtxRasterizer *rasterizer, const int fill_rule) =
      ctx_rasterizer_rasterize_edges_generic;

void ctx_composite_setup_generic (CtxRasterizer *rasterizer);
void (*ctx_composite_setup) (CtxRasterizer *rasterizer) =
      ctx_composite_setup_generic;

#if CTX_FAST_FILL_RECT
void ctx_composite_fill_rect_generic (CtxRasterizer *rasterizer,
                           float        x0,
                           float        y0,
                           float        x1,
                           float        y1,
                           uint8_t      cov);

void (*ctx_composite_fill_rect) (CtxRasterizer *rasterizer,
                           float        x0,
                           float        y0,
                           float        x1,
                           float        y1,
                           uint8_t      cov) =
      ctx_composite_fill_rect_generic;
#if CTX_FAST_STROKE_RECT
void ctx_composite_stroke_rect_generic (CtxRasterizer *rasterizer,
                           float        x0,
                           float        y0,
                           float        x1,
                           float        y1,
                           float        line_width);

void (*ctx_composite_stroke_rect) (CtxRasterizer *rasterizer,
                           float          x0,
                           float          y0,
                           float          x1,
                           float          y1,
                           float          line_width) =
      ctx_composite_stroke_rect_generic;
#endif
#endif

#endif


CTX_EXPORT  void
ctx_logo (Ctx *ctx, float x, float y, float dim)
{
     //float width = ctx_width (ctx);
     //float height = ctx_height (ctx);
     ctx_save (ctx);
     ctx_translate (ctx, x, y);//
                               //width/2, height/2);

     //if (width < height) height = width;
     
     ctx_scale (ctx, dim, dim);
     ctx_translate (ctx, -0.5f, -0.5f);
     ctx_reset_path (ctx);
     ctx_rgba(ctx,1,1,1,0.4f);
     ctx_move_to(ctx,0.43956786f,0.90788066f);
     ctx_rel_curve_to(ctx,0.0195929f,0.0102943f,0.0716181f,0.0218038f,0.10361884f,-0.0167646f);
     ctx_line_to (ctx,0.93768705f,0.37887837f);
     ctx_rel_curve_to (ctx,  0.019925f,-0.0342044f,-0.00963f,-0.0544608f,-0.0308834f,-0.0508084f);
     ctx_rel_curve_to (ctx,-0.17965502f,0.0285588f,-0.35466092f,-0.055125f,-0.45096394f,-0.21253089f);
     ctx_rel_curve_to (ctx, -0.0176003f,-0.02988716f, -0.0594422f,-0.01560777f,-0.0594422f,0.0139473f);
     ctx_rel_curve_to (ctx, 0, 0.0591101f,0.003321f,0.49845135f,0.001991f, 0.70699722f);
     ctx_rel_curve_to (ctx, 0.00039042f, 0.0283487f,0.0157362f,0.0529866f,0.0408456f,0.070733f);
     ctx_fill (ctx);

     ctx_move_to (ctx, 0.39772584f,0.91850721f);
     ctx_rel_line_to (ctx, -0.0664159f, 0);
     ctx_rel_curve_to (ctx, -0.15408489f,0, -0.27894675f,-0.12486192f, -0.27894675f,-0.2789468f);
     ctx_rel_curve_to (ctx, 0,-0.15408489f, 0.12486186f,-0.27861466f, 0.27894675f,-0.27894675f);
     ctx_rel_line_to (ctx, 0.18585599f,0.0000662f);
     ctx_rel_curve_to (ctx, 0.0111839f,0.00017138f, 0.0158287f,0.001542f, 0.0263337f,0.0134822f);
     ctx_rel_curve_to (ctx, 0.11733258f,0.14373102f, 0.3018009f,0.36870115f, 0.3942639f,0.49195316f);
     ctx_rel_curve_to (ctx, 0.0185394f,0.0332794f, -0.0106225f,0.0505515f, -0.0228143f,0.0505207f);

     ctx_linear_gradient (ctx, 0.0525f, 0, 0.9905f, 0);
     ctx_gradient_add_stop_rgba (ctx, 0.0f, 1.0f, 1.0f, 0.66f, 1.0f);
     ctx_gradient_add_stop_rgba (ctx, 0.2f, 1.0f, 0.66f, 0.0f, 1.0f);
     ctx_gradient_add_stop_rgba (ctx, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f);
     ctx_gradient_add_stop_rgba (ctx, 1.0f, 0.4f, 0.0f, 0.53f, 1.0f);
     ctx_fill (ctx);
     


     ctx_linear_gradient(ctx, 0.697f, 0.17f, 0.4318f, 0.884f);
     ctx_gradient_add_stop_rgba (ctx, 0, 0.26f, 0.26f, 1, 1.0f);
     ctx_gradient_add_stop_rgba (ctx, 0.3f, 0, 1, 1, 0.4f);
     ctx_gradient_add_stop_rgba (ctx, 1.0f, 0, 1, 0.26f,1.0f);
     
     ctx_move_to(ctx,0.43956786f,0.90788066f);
     ctx_rel_curve_to(ctx,0.0195929f,0.0102943f,0.0716181f,0.0218038f,0.10361884f,-0.0167646f);
     ctx_line_to (ctx,0.93768705f,0.37887837f);
     ctx_rel_curve_to (ctx,  0.019925f,-0.0342044f,-0.00963f,-0.0544608f,-0.0308834f,-0.0508084f);
     ctx_rel_curve_to (ctx,-0.17965502f,0.0285588f,-0.35466092f,-0.055125f,-0.45096394f,-0.21253089f);
     ctx_rel_curve_to (ctx, -0.0176003f,-0.02988716f, -0.0594422f,-0.01560777f,-0.0594422f,0.0139473f);
     ctx_rel_curve_to (ctx, 0, 0.0591101f,0.003321f,0.49845135f,0.001991f, 0.70699722f);
     ctx_rel_curve_to (ctx, 0.00039042f, 0.0283487f,0.0157362f,0.0529866f,0.0408456f,0.070733f);
     ctx_fill (ctx);
     
     ctx_restore (ctx);
}

void
ctx_clip_extents (Ctx *ctx, float *x0, float *y0,
                           float *x1, float *y1)
{
   CtxGState *gstate = &ctx->state.gstate;
   if(x0)*x0 = gstate->clip_min_x;
   if(y0)*y0 = gstate->clip_min_y;
   if(x1)*x1 = gstate->clip_max_x;
   if(y1)*y1 = gstate->clip_max_y;
}

typedef struct CtxDeferredCommand {
  uint32_t name;
  int offset;
  int is_rect;
} CtxDeferredCommand;

static CtxDeferredCommand *deferred_new (Ctx *ctx, const char *name)
{
   CtxDeferredCommand *deferred = (CtxDeferredCommand*)calloc (1, sizeof (CtxDeferredCommand));
   if (name)
     deferred->name = ctx_strhash (name);
   deferred->offset = ctx->drawlist.count;
   ctx_list_prepend (&ctx->deferred, deferred);
   return deferred;
}

void ctx_deferred_move_to (Ctx *ctx, const char *name, float x, float y)
{
   deferred_new (ctx, name);
   ctx_move_to (ctx, x, y);
}

void ctx_deferred_rel_move_to (Ctx *ctx, const char *name, float x, float y)
{
   deferred_new (ctx, name);
   ctx_rel_move_to (ctx, x, y);
}

void ctx_deferred_rel_line_to (Ctx *ctx, const char *name, float x, float y)
{
   deferred_new (ctx, name);
   ctx_rel_line_to (ctx, x, y);
}

void ctx_deferred_scale (Ctx *ctx, const char *name, float x, float y)
{
   deferred_new (ctx, name);
   ctx_scale (ctx, x, y);
}

void ctx_deferred_translate (Ctx *ctx, const char *name, float x, float y)
{
   deferred_new (ctx, name);
   ctx_translate (ctx, x, y);
}

void ctx_deferred_rectangle   (Ctx *ctx, const char *name,
                               float x, float y,
                               float width, float height)
{
   CtxDeferredCommand *deferred = deferred_new (ctx, name);
   deferred->is_rect = 1;
   ctx_rectangle (ctx, x, y, width, height);
}

static CtxList *ctx_deferred_commands (Ctx *ctx, const char *name, int *ret_count)
{
  CtxList *matching = NULL;
  uint32_t name_id = ctx_strhash (name);
  int count = 0;
  for (CtxList *l = ctx->deferred; l; l = l->next)
  {
    CtxDeferredCommand *command = (CtxDeferredCommand*)l->data;
    if (name)
    {
       if (command->name == name_id)
       {
         ctx_list_prepend (&matching, command);
         count ++;
       }
    }
    else
    {
       if (command->name == 0)
       {
         ctx_list_prepend (&matching, command);
         count ++;
       }
    }
  }
  if (ret_count)
    *ret_count = count;
  return matching;
}

#if 0
void ctx_resolve_rel_line_to  (Ctx *ctx, const char *name,
                               void (*set_dim) (void *userdata,
                                                const char *name,
                                                int         count,
                                                float *x,
                                                float *y),
                               void *userdata)
{
  int count = 0;
  CtxList *matching = ctx_deferred_commands (ctx, name, &count);
  while (matching)
  {
    CtxDeferredCommand *command = matching->data;

    float x = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.x;
    float y = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.y;

    set_dim (userdata, name, count, &x, &y);

    ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.x = x;
    ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.y = y;

    ctx_list_remove (&ctx->deferred, command);
    ctx_list_remove (&matching, command);
    free (command);
  }
}

void ctx_resolve_rectangle    (Ctx *ctx, const char *name,
                               void (*set_dim) (void *userdata,
                                                const char *name,
                                                int         count,
                                                float *x,
                                                float *y,
                                                float *width,
                                                float *height),
                               void *userdata)
{
  int count = 0;
  CtxList *matching = ctx_deferred_commands (ctx, name, &count);
  while (matching)
  {
    CtxDeferredCommand *command = matching->data;

    float x = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.x;
    float y = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.y;
    float w = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.width;
    float h = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.height;

    set_dim (userdata, name, count, &x, &y, &w, &h);

    ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.x = x;
    ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.y = y;
    ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.width = w;
    ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.height = h;
    ctx_list_remove (&ctx->deferred, command);
    ctx_list_remove (&matching, command);
    free (command);
  }
}
#endif

void ctx_resolve (Ctx *ctx, const char *name,
                            void (*resolve) (Ctx        *ctx,
                                             void       *userdata,
                                             const char *name,
                                             int         count,
                                             float      *x,
                                             float      *y,
                                             float      *width,  // ignored
                                             float      *height),// for non-rect
                             void *userdata)
{
  int count = 0;
  CtxList *matching = ctx_deferred_commands (ctx, name, &count);
  while (matching)
  {
    CtxDeferredCommand *command = (CtxDeferredCommand*)matching->data;

    float x, y, w = 0, h = 0;
    if (command->is_rect)
    {
      x = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.x;
      y = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.y;
      w = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.width;
      h = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.height;
    }
    else
    {
      x = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.x;
      y = ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.y;
    }

    resolve (ctx, userdata, name, count, &x, &y, &w, &h);

    if (command->is_rect)
    {
      ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.x = x;
      ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.y = y;
      ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.width = w;
      ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rectangle.height = h;
    }
    else
    {
      ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.x = x;
      ((CtxCommand*)&ctx->drawlist.entries[command->offset])->rel_line_to.y = y;
    }
    ctx_list_remove (&ctx->deferred, command);
    ctx_list_remove (&matching, command);
    free (command);
  }
}

void ctx_write_png (const char *dst_path, int w, int h, int num_chans, void *data)
{
#if CTX_IMAGE_WRITE
  size_t len = 0;
  char *buf = tdefl_write_image_to_png_file_in_memory (data, w, h, num_chans, &len);
  if (buf)
  {
    FILE *f = fopen (dst_path, "w");
    fwrite (buf, len, 1, f);
    fclose (f);
    mz_free (buf);
  }
#endif
}

const char *
ctx_str_decode (uint32_t number)
{
  static char temp[16];
  return squoze32_utf8_decode (number, temp);
}

uint32_t ctx_strhash(const char *str)
{
  return squoze32_utf8 (str, strlen (str));
}

#if CTX_AUDIO
void vt_audio_task (VT *vt, int click);
#endif

void ctx_wait_frame (Ctx *ctx, VT *vt)
{
  if (ctx_backend_type (ctx) == CTX_BACKEND_CB)
  {
    CtxCbBackend *cb = (CtxCbBackend*)(ctx->backend);
    int max_wait    = 500;
    int wait_frame  = cb->frame_no - (cb->rendering)*((cb->config.flags & CTX_FLAG_RENDER_THREAD) != 0);//cb->rendering;
    while (wait_frame < cb->frame_no &&
           max_wait-- > 0)
    {
#if CTX_AUDIO
      usleep (10);
      if (vt)
      {
        vt_audio_task (vt, 0);
      }
#else
      usleep (10);
#endif
    }
  }
  else
  {
    int max_wait    = 500;
    while (max_wait-- > 0)
    {
      usleep (1);
    }
  }
}


#if CTX_GSTATE_PROTECT
void ctx_gstate_protect   (Ctx *ctx)
{
    if (ctx->state.gstate_waterlevel)
    {
      //fprintf (stderr, "ctx: save restore limit already set (%i)\n", ctx->state.gstate_waterlevel);
      return;
    }
    ctx->state.gstate_waterlevel = ctx->state.gstate_no;
}

void ctx_gstate_unprotect (Ctx *ctx)
{
  if (ctx->state.gstate_waterlevel != ctx->state.gstate_no)
  {
    unsigned int count = ctx->state.gstate_waterlevel - ctx->state.gstate_no;
    //fprintf (stderr, "ctx: %i missing restores\n", count);
    while (count)
    {
      ctx_restore (ctx);
      count --;
    }
  }
  ctx->state.gstate_waterlevel = 0;
}
#endif


void ctx_set_frontend_text (Ctx *ctx, int frontend_text)
{
  ctx->frontend_text = frontend_text;
}

int       ctx_get_major_version (void)
{
  return CTX_VERSION_MAJOR;
}

int       ctx_get_minor_version (void)
{
  return CTX_VERSION_MINOR;
}

int       ctx_get_micro_version (void)
{
  return CTX_VERSION_MICRO;
}

int ctx_sdl_has_focus (Ctx *ctx);
void sdl_cb_windowtitle (Ctx *ctx, void *user_data, const char *utf8);

int ctx_has_focus (Ctx *ctx)
{
#if CTX_SDL
  // TODO : make dispatch of this generic / hookable for cb-backend at least?
  if (ctx_backend_type (ctx) == CTX_BACKEND_CB)
  {
    CtxCbBackend *cb = (CtxCbBackend*)ctx_get_backend(ctx);
    if (cb->config.windowtitle == sdl_cb_windowtitle)
        return ctx_sdl_has_focus (ctx);
  }
#endif
  return 1;
}

#if CTX_SIMD
#if CTX_X86_64
#include <xmmintrin.h>
void ctx_simd_setup_x86_64_v2 (void);
void ctx_simd_setup_x86_64_v3 (void);
void ctx_simd_setup (void)
{
  // this would also affect other code..
  //_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
  //_mm_setcsr(_mm_getcsr() | 0x8040);
  switch (ctx_x86_64_level())
  {
    default:
    case 0:
    case 1: break;
    case 2: ctx_simd_setup_x86_64_v2 ();break;
    case 3: ctx_simd_setup_x86_64_v3 ();break;
  }
}
#else // must be arm if we have SIMD enabled and are not x86_64
void ctx_simd_setup_arm_neon (void);
int ctx_arm_has_neon (int *armv);

void ctx_simd_setup (void)
{
  if (ctx_arm_has_neon (NULL))
    ctx_simd_setup_arm_neon ();
}
#endif
#endif
#ifndef MRG_UTF8_H
#define MRG_UTF8_H

#if !__COSMOPOLITAN__
#include <string.h>
#include <stdint.h>
#endif

static inline int mrg_utf8_len (const unsigned char first_byte)
{
  if      ((first_byte & 0x80) == 0)
    return 1; /* ASCII */
  else if ((first_byte & 0xE0) == 0xC0)
    return 2;
  else if ((first_byte & 0xF0) == 0xE0)
    return 3;
  else if ((first_byte & 0xF8) == 0xF0)
    return 4;
  return 1;
}

static inline const char *mrg_utf8_skip (const char *s, int utf8_length)
{
   int count;
   if (!s)
     return NULL;
   for (count = 0; *s; s++)
   {
     if ((*s & 0xC0) != 0x80)
       count++;
     if (count == utf8_length+1)
       return s;
   }
   return s;
}

int          mrg_unichar_to_utf8       (unsigned int   ch,
                                        unsigned char *dest);
unsigned int mrg_utf8_to_unichar       (unsigned char *utf8);

//////////////////////////////////////////////////////////////////////////////////

// Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
// See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.

#define UTF8_ACCEPT 0
#define UTF8_REJECT 1

static const uint8_t utf8d[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
};

static inline uint32_t
utf8_decode(uint32_t* state, uint32_t* codep, uint32_t byte) {
  uint32_t type = utf8d[byte];

  *codep = (*state != UTF8_ACCEPT) ?
    (byte & 0x3fu) | (*codep << 6) :
    (0xff >> type) & (byte);

  *state = utf8d[256 + *state*16 + type];
  return *state;
}

#endif
#if CTX_VT

/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef VT_LINE_H
#define VT_LINE_H

#include "ctx.h"

#ifndef CTX_UNLIKELY
#define CTX_UNLIKELY(x)    __builtin_expect(!!(x), 0)
#define CTX_LIKELY(x)      __builtin_expect(!!(x), 1)
#endif
#ifndef CTX_MAX
#define CTX_MAX(a,b) (((a)>(b))?(a):(b))
#endif


#if CTX_VT_STYLE_SIZE==32
typedef uint32_t vt_style_t;
#else
typedef uint64_t vt_style_t;
#endif

struct _VtLine
{
  CtxString string;
  /* line extends string, permitting string ops to operate on it  */

  vt_style_t *style;

  void      *ctx; // each line can have an attached ctx context;
  #if CTX_DECOMPRESSOR
  char      *ctx_prev_frame;
  int        ctx_prev_frame_length;
  CtxString *ctx_frame;
  #endif
  int        style_size;

  void     *ctx_copy; // each line can have an attached ctx context;
  // clearing should be brutal enough to unset the context of the current
  // at least in alt-screen mode
  int       double_width;
  int       double_height_top;
  int       double_height_bottom;
  int       contains_proportional;
  float     xscale;
  float     yscale;
  float     y_offset;
  int       in_scrolling_region;
  int       wrapped;

  /*  XXX:  needs refactoring to a CtxList of links/images */
  void     *images[4];
  int       image_col[4];
  float     image_X[4]; // 0.0 - 1.0 offset in cell
  float     image_Y[4];
  int       image_rows[4];
  int       image_cols[4];
  int       image_subx[4];
  int       image_suby[4];
  int       image_subw[4];
  int       image_subh[4];
};


static inline uint64_t vt_line_get_style (VtLine *string, int pos)
{
  if (string->string.is_line==0)
    return 0;
  if (pos < 0 || pos >= string->style_size)
    return 0;
  return string->style[pos];
}

#if !__COSMOPOLITAN__
#include <stdlib.h>
#endif

static inline void vt_line_set_style (VtLine *string, int pos, uint64_t style)
{
  if (string->string.is_line==0)
    return;
  if (pos < 0 || pos >= 512)
    return;
  if (pos >= string->style_size)
    {
      int new_size = pos + 16;
      string->style = (vt_style_t*)ctx_realloc (string->style, string->style_size * sizeof (vt_style_t), new_size * sizeof (vt_style_t) );
      memset (&string->style[string->style_size], 0, (new_size - string->style_size) * sizeof (vt_style_t) );
      string->style_size = new_size;
    }
  string->style[pos] = style;
}

static inline void vt_line_clear_style (VtLine *string)
{
  if (string->string.is_line==0)
    return;
  if (string->style)
  {
    memset (string->style, 0, string->style_size * sizeof (vt_style_t) );
  }
}

VtLine *vt_line_new_with_size (const char *initial, int initial_size);
VtLine *vt_line_new (const char *initial);

static inline void        vt_line_free           (VtLine *line, int freealloc)
{
  CtxString *string = (CtxString*)line;

#if 1
  //if (string->is_line)
  {
    VtLine *line = (VtLine*)string;
    if (line->style)
      { ctx_free (line->style); }
    if (line->ctx)
      { ctx_destroy ((Ctx*)line->ctx); }
    if (line->ctx_copy)
      { ctx_destroy ((Ctx*)line->ctx_copy); }
  }
#endif

  ctx_string_free (string, freealloc);
}
static inline const char *vt_line_get            (VtLine *line)
{
  CtxString *string = (CtxString*)line;
  return ctx_string_get (string);
}
static inline uint32_t    vt_line_get_unichar    (VtLine *line, int pos)
{
  CtxString *string = (CtxString*)line;
  return ctx_string_get_unichar (string, pos);
}
static inline int         vt_line_get_length     (VtLine *line)
{
  CtxString *string = (CtxString*)line;
  return ctx_string_get_length (string);
}
static inline int         vt_line_get_utf8length     (VtLine *line)
{
  CtxString *string = (CtxString*)line;
  return ctx_string_get_utf8length (string);
}
static inline void        vt_line_set            (VtLine *line, const char *new_string)
{
  CtxString *string = (CtxString*)line;
  ctx_string_set (string, new_string);
}
static inline void        vt_line_clear          (VtLine *line)
{
  CtxString *string = (CtxString*)line;
  ctx_string_clear (string);
  vt_line_clear_style ((VtLine*)string);
  if (line->ctx)
    { ctx_destroy ((Ctx*)line->ctx); }
  line->ctx = NULL;
  if (line->ctx_copy)
    { ctx_destroy ((Ctx*)line->ctx_copy); }
  line->ctx_copy = NULL;
}
#if 0
static inline void        vt_line_append_str     (VtLine *line, const char *str)
{
  CtxString *string = (CtxString*)line;
  ctx_string_append_str (string, str);
}

static inline void _ctx_string_append_byte (CtxString *string, char  val)
{
  if (CTX_LIKELY((val & 0xC0) != 0x80))
    { string->utf8_length++; }
  if (CTX_UNLIKELY(string->length + 2 >= string->allocated_length))
    {
      char *old = string->str;
      string->allocated_length = CTX_MAX (string->allocated_length * 2, string->length + 2);
      string->str = (char*)ctx_realloc (old, string->allocated_length);
    }
  string->str[string->length++] = val;
  string->str[string->length] = '\0';
}
#endif

#if 0
static inline void        vt_line_append_byte    (VtLine *line, char  val)
{
  CtxString *string = (CtxString*)line;
  _ctx_string_append_byte (string, val);
}
static inline void        vt_line_append_string  (VtLine *line, CtxString *string2)
{
  CtxString *string = (CtxString*)line;
  ctx_string_append_string (string, string2);
}
#endif

static inline void        vt_line_append_unichar (VtLine *line, unsigned int unichar)
{
  CtxString *string = (CtxString*)line;
  ctx_string_append_unichar (string, unichar);
}

#if 0

static inline void vt_line_append_data    (VtLine *line, const char *data, int len)
{
  CtxString *string = (CtxString*)line;
  ctx_string_append_data (string, data, len);
}
static inline void vt_line_append_utf8char (VtLine *line, const char *str)
{
  CtxString *string = (CtxString*)line;
  ctx_string_append_utf8char (string, str);
}
#endif

static inline void vt_line_insert_utf8    (VtLine *line, int pos, const char *new_glyph)
{
  if (pos < 0) return;
  CtxString *string = (CtxString*)line;
  ctx_string_insert_utf8 (string, pos, new_glyph);
  int len = vt_line_get_utf8length (line);

  // TODO : do a memmove instead?
  for (int i = pos; i < len; i++)
    vt_line_set_style (line, i, vt_line_get_style (line, i-1));
}

static inline void vt_line_insert_unichar (VtLine *line, int pos, uint32_t new_glyph)
{
  if (pos < 0) return;
  CtxString *string = (CtxString*)line;
  ctx_string_insert_unichar (string, pos, new_glyph);
  int len = vt_line_get_utf8length (line);
  // TODO : do a memmove instead?
  for (int i = pos; i < len; i++)
    vt_line_set_style (line, i, vt_line_get_style (line, i-1));
}
static inline void vt_line_replace_unichar (VtLine *line, int pos, uint32_t unichar)
{
  CtxString *string = (CtxString*)line;
  ctx_string_replace_unichar (string, pos, unichar);
}
static inline void vt_line_replace_utf8   (VtLine *line, int pos, const char *new_glyph)
{
  CtxString *string = (CtxString*)line;
  ctx_string_replace_utf8 (string, pos, new_glyph);
}


static inline void vt_line_remove (VtLine *line, int pos)
{ 
  CtxString *string = (CtxString*)line;
  ctx_string_remove (string, pos);

  for (int i = pos; i < line->style_size-2; i++)
  {
    line->style[i] = line->style[i+1];
  }
}


#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#endif
#endif
#if CTX_VT

/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */


#ifndef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE
#endif

#if !__COSMOPOLITAN__
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#endif

int ctx_unichar_to_utf8 (uint32_t  ch, uint8_t  *dest);
#define mrg_unichar_to_utf8 ctx_unichar_to_utf8
void ctx_string_init (CtxString *string, int initial_size);

VtLine *vt_line_new_with_size (const char *initial, int initial_size)
{
  VtLine *line = ctx_calloc (sizeof (VtLine), 1);
  CtxString *string = (CtxString*)line;
  ctx_string_init (string, initial_size);
  if (initial)
    { ctx_string_append_str (string, initial); }
  line->style = ctx_calloc (sizeof (vt_style_t), initial_size);
  line->style_size = initial_size;
  string->is_line = 1;
  return line;
}

VtLine *vt_line_new (const char *initial)
{
  return vt_line_new_with_size (initial, 8);
}
#endif

typedef struct VtPty
{
  int        pty; //    0 if thread
  pid_t      pid; //    0 if thread
  int        done;

  void      *userdata;

  uint8_t   *shm;
  int        shm_size;
} VtPty;



ssize_t vtpty_read     (void *vtpty, void *buf, size_t count);
ssize_t vtpty_write    (void *vtpty, const void *buf, size_t count);
void    vtpty_resize   (void *vtpty, int cols, int rows,
                        int px_width, int px_height);
int     vtpty_waitdata (void  *vtpty, int timeout);
#define MAX_COLS 2048 // used for tabstops


typedef struct AudioState
{
  int action;
  int samplerate; // 8000
  int channels;   // 1
  int bits;       // 8
  int type;       // 'u'    u-law  f-loat  s-igned u-nsigned
  int buffer_size; // desired size of audiofragment in frames
  // (both for feeding SDL and as desired chunking
  //  size)


  int mic;        // <- should
  //    request permisson,
  //    and if gotten, start streaming
  //    audio packets in the incoming direction
  //
  int encoding;   // 'a' ascci85 'b' base64
  int compression; // '0': none , 'z': zlib   'o': opus(reserved)

  int frames;

  uint8_t *data;
  int      data_size;
} AudioState;

typedef struct GfxState
{
  int action;
  int id;
  int buf_width;
  int buf_height;
  int format;
  int compression;
  int transmission;
  int multichunk;
  int buf_size;
  int x;
  int y;
  int w;
  int h;
  int x_cell_offset;
  int y_cell_offset;
  int columns;
  int rows;
  int z_index;
  int _delete;

  uint8_t *data;
  int   data_size;
} GfxState;

struct _VT
{
  VtPty     vtpty;
  int       empty_count;
  int       id;
  unsigned char buf[24 * 1024]; // maximum size to process at once
  int       keyrepeat;
  int       lastx;
  int       lasty;
  int       result;
  //SDL_Rect   dirty;
  float     dirtpad;
  float     dirtpad1;
  float     dirtpad2;
  float     dirtpad3;
  Ctx *ctx; // used for recomputing based on font size
  CtxClient *client;

  ssize_t (*write)   (void *serial_obj, const void *buf, size_t count);
  ssize_t (*read)    (void *serial_obj, void *buf, size_t count);
  int     (*waitdata)(void *serial_obj, int timeout);
  void    (*resize)  (void *serial_obj, int cols, int rows, int px_width, int px_height);


  char     *title;
  void    (*state) (VT *vt, int byte);

  AudioState audio; // < want to move this one level up and share impl
  GfxState   gfx;

  CtxList   *saved_lines;
  int       in_alt_screen;
  int       had_alt_screen;
  int       saved_line_count;
  char      *arg_copy;
  CtxList   *lines;
  int       line_count;
  CtxList   *scrollback;
  CtxList   *limbo;
  int       scrollback_count;
  int       leds[4];
  uint64_t  cstyle;

  uint8_t   fg_color[3];
  uint8_t   bg_color[3];

  int       in_smooth_scroll;
  int       smooth_scroll;
  float     scroll_offset;
  int       debug;
  int       bell;
  int       origin;
  int       at_line_home;
  int       charset[4];
  int       saved_charset[4];
  int       shifted_in;
  int       reverse_video;
  int       echo;
  int       bracket_paste;
  int       ctx_events;
  int       font_is_mono;
  int       palette_no;
  int       has_blink; // if any of the set characters are blinking
  // updated on each draw of the screen
  
  int can_launch;

  int unit_pixels;
  int mouse;
  int mouse_drag;
  int mouse_all;
  int mouse_decimal;

#if CTX_PTY
  uint8_t    utf8_holding[64];
#else
  uint8_t    utf8_holding[4]; /* only 4 needed for utf8 - but it's purpose
                                 is also overloaded for ctx journal command
                                 buffering , and the bigger sizes for the svg-like
                                 ctx parsing mode */
#endif
  int        utf8_expected_bytes;
  int        utf8_pos;


  int        ref_len;
  char       reference[16];
  int        in_prev_match;
  CtxParser *ctxp;
  // text related data
  float      letter_spacing;

  float      word_spacing;
  float      font_stretch;  // horizontal expansion
  float      font_size_adjust;
  // font-variant
  // font-weight
  // text-decoration

  int        encoding;  // 0 = utf8 1=pc vga 2=ascii

  int        local_editing; /* terminal operates without pty  */

  int        insert_mode;
  int        autowrap;
  int        justify;
  int        cursor_x;
  int        cursor_y;
  int        cols;
  int        rows;
  VtLine    *current_line;


  int        cr_on_lf;
  int        cursor_visible;
  int        scrollbar_visible;
  int        saved_x;
  int        saved_y;
  uint32_t   saved_style;
  int        saved_origin;
  int        cursor_key_application;
  int        margin_top;
  int        margin_bottom;
  int        margin_left;
  int        margin_right;

  int        left_right_margin_mode;

  int        scrollback_limit;
  float      scroll;
  int        scroll_on_input;
  int        scroll_on_output;

  char       *argument_buf;
  int        argument_buf_len;
  int        argument_buf_cap;
  uint8_t    tabs[MAX_COLS];
  int        inert;

  int        width;
  int        height;

  float      cw; // cell width
  float      ch; // cell height
  float      font_to_cell_scale;
  float      font_size; // when set with set_font_size, cw and ch are recomputed
  float      line_spacing; // using line_spacing

  float      baseline; // where in cell to draw baseline - default to 0.78
  float      scale_x;
  float      scale_y;

  int        ctx_pos;  // 1 is graphics above text, 0 or -1 is below text
  Ctx       *root_ctx; /* only used for knowledge of top-level dimensions */

  int        blink_state;

  FILE      *log;

  int cursor_down;

  int select_begin_col;
  int select_begin_row;
  int select_start_col;
  int select_start_row;
  int select_end_col;
  int select_end_row;
  int select_begin_x;
  int select_begin_y;
  int select_active;

  int popped;


  /* used to make runs of background on one line be drawn
   * as a single filled rectangle
   */
  int   bg_active;
  float bg_x0;
  float bg_y0;
  float bg_width;
  float bg_height;
  uint8_t bg_rgba[4];

  uint64_t size_age;


  int        enable_ligatures;
  CtxString *word;
  int        word_length;
  int        word_bold;
  int        word_italic;
  float      word_x;
  float      word_y;
  float      word_scale_x;
  float      word_scale_y;
  float      word_offset_y;
  uint8_t    word_rgb[3];
  int        word_col;


  char       cbuf[16];
  int        clen;

};


// add vt_new_cb - suitable for hooking up to generic stdout/stdin callbacks
VT *vt_new (const char *command, int width, int height, float font_size, float line_spacing, int id, int can_launch);
VT *vt_new_argv (char **argv, int width, int height, float font_size, float line_spacing, int id, int can_launch);
VT *vt_new_thread (void (*start_routine)(void *userdata), void *userdata,
                   int width, int height, float font_size, float line_spacing, int id, int can_launch);


void vt_open_log (VT *vt, const char *path);

int         ctx_vt_had_alt_screen (VT *vt);
void        vt_set_px_size        (VT *vt, int width, int height);
void        vt_set_term_size      (VT *vt, int cols, int rows);

float       vt_cw                 (VT *vt);
float       vt_ch                 (VT *vt);
void        vt_set_font_size      (VT *vt, float font_size);
float       vt_get_font_size      (VT *vt);
void        vt_set_line_spacing   (VT *vt, float line_spacing);

int         vt_keyrepeat          (VT *vt);

int         vt_get_result         (VT *vt);
int         vt_is_done            (VT *vt);
int         vt_poll               (VT *vt, int timeout);
long        vt_rev                (VT *vt);
void        vt_destroy            (VT *vt);
int         vt_has_blink (VT *vt);

/* this is how mrg/mmm based key-events are fed into the vt engine
 */
void        vt_feed_keystring     (VT *vt, CtxEvent *event, const char *str);

void        vt_paste              (VT *vt, const char *str);

/* not needed when passing a commandline for command to
 * run, but could be used for injecting commands, or
 * output from stored shell commands/sessions to display
 */
void        vt_feed_byte          (VT *vt, int byte);


#if CTX_PTY
#define DEFAULT_SCROLLBACK   (1<<10)
#else
#define DEFAULT_SCROLLBACK   (1)
#endif
#define DEFAULT_ROWS         24
#define DEFAULT_COLS         80

int         vt_get_line_count       (VT *vt);

pid_t       vt_get_pid              (VT *vt);

const char *vt_get_line             (VT *vt, int no);

void        vt_set_scrollback_lines (VT *vt, int scrollback_lines);
int         vt_get_scrollback_lines (VT *vt);

void        vt_set_scroll           (VT *vt, int scroll);
int         vt_get_scroll           (VT *vt);

int         vt_get_cols             (VT *vt);
int         vt_get_rows             (VT *vt);

char       *vt_get_selection        (VT *vt);
int         vt_get_cursor_x         (VT *vt);
int         vt_get_cursor_y         (VT *vt);

void        vt_draw                 (VT *vt, Ctx *ctx, double x, double y, int has_focus);
#if 0
void        vt_register_events      (VT *vt, Ctx *ctx, double x0, double y0);
#endif

void        vt_rev_inc              (VT *vt);

int         vt_mic (VT *vt);
void        vt_set_ctx (VT *vt, Ctx *ctx);  /* XXX: rename, this sets the parent/global ctx  */


int         vt_get_local (VT *vt);           // this is a hack for the settings tab
void        vt_set_local (VT *vt, int local);


typedef enum VtMouseEvent
{
  VT_MOUSE_MOTION = 0,
  VT_MOUSE_PRESS,
  VT_MOUSE_DRAG,
  VT_MOUSE_RELEASE,
} VtMouseEvent;

void vt_mouse (VT *vt, CtxEvent *event, VtMouseEvent type, int button, int x, int y, int px_x, int px_y);

static ssize_t vt_write (VT *vt, const void *buf, size_t count)
{
  if (!vt->write) { return 0; }
  return vt->write (&vt->vtpty, buf, count);
}
static ssize_t vt_read (VT *vt, void *buf, size_t count)
{
  if (!vt->read) { return 0; }
  return vt->read (&vt->vtpty, buf, count);
}
static int vt_waitdata (VT *vt, int timeout)
{
  if (!vt->waitdata) { return 0; }
  return vt->waitdata (&vt->vtpty, timeout);
}
static void vt_resize (VT *vt, int cols, int rows, int px_width, int px_height)
{
  if (vt && vt->resize)
    { vt->resize (&vt->vtpty, cols, rows, px_width, px_height); }
}

void vt_set_palette(int color_no, uint8_t red, uint8_t green, uint8_t blue);
void vt_set_title (VT *vt, const char *new_title);

int vt_special_glyph (Ctx *ctx, VT *vt, float x, float y, float cw, float ch, int unichar, uint8_t red, uint8_t green, uint8_t blue);

/* atty - audio interface and driver for terminals
 * Copyright (C) 2020 Øyvind Kolås <pippin@gimp.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>. 
 */


//#ifndef EMSCRIPTEN
//#undef uncompress
//#include <zlib.h>
//#endif

#if CTX_AUDIO
#if CTX_SDL
#include <SDL.h>

void vt_feed_audio (VT *vt, void *samples, int bytes);

void vt_feed_audio (VT *vt, void *samples, int bytes);

static void mic_callback(void*     userdata,
                         uint8_t * stream,
                         int       len);

void sdl_audio_init ();

void vt_audio_task (VT *vt, int click);

void vt_bell (VT *vt);


void terminal_queue_pcm (int16_t sample_left, int16_t sample_right);

void vt_audio (VT *vt, const char *command);
#endif
#endif

/* atty - audio interface and driver for terminals
 * Copyright (C) 2020 Øyvind Kolås <pippin@gimp.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>. 
 */


//#ifndef EMSCRIPTEN
//#undef uncompress
//#include <zlib.h>
//#endif

#if CTX_AUDIO
#if CTX_SDL
#include <SDL.h>

static int ydec (const void *srcp, void *dstp, int count)
{
  const char *src = srcp;
  char *dst = dstp;
  int out_len = 0;
  for (int i = 0; i < count; i ++)
  {
    int o = src[i];
    switch (o)
    {
      case '=':
              i++;
              o = src[i];
              o = (o-42-64) % 256;
              break;
      case '\n':
      case '\033':
      case '\r':
      case '\0':
              break;
      default:
              o = (o-42) % 256;
              break;
    }
    dst[out_len++] = o;
  }
  dst[out_len]=0;
  return out_len;
}

#if CTX_SDL
static SDL_AudioDeviceID speaker_device = 0;
#endif

//#define AUDIO_CHUNK_SIZE 512

// our pcm queue is currently always 16 bit
// signed stereo

static int16_t pcm_queue[1<<18];
static int     pcm_write_pos = 0;
static int     pcm_read_pos  = 0;

void terminal_queue_pcm (int16_t sample_left, int16_t sample_right)
{
  if (pcm_write_pos >= (1<<18)-1)
  {
    /*  TODO  :  fix cyclic buffer */
    pcm_write_pos = 0;
    pcm_read_pos  = 0;
  }
  pcm_queue[pcm_write_pos++]=sample_left;
  pcm_queue[pcm_write_pos++]=sample_right;
}

float click_volume = 0.05;

void vt_feed_audio (VT *vt, void *samples, int bytes);
int mic_device = 0;   // when non 0 we have an active mic device


/*  https://jonathanhays.me/2018/11/14/mu-law-and-a-law-compression-tutorial/
 */


void vt_feed_audio (VT *vt, void *samples, int bytes)
{
  char buf[256];
  AudioState *audio = &vt->audio;
  uint8_t *data = samples;
  int frames = bytes / (audio->bits/8) / audio->channels;

  if (audio->compression == 'z')
  {
    unsigned long len = bytes * 1.2;//compressBound(bytes);
    data = ctx_malloc (len);
    int z_result = compress (data, &len, samples, len);
    if (z_result != Z_OK)
    {
      const char *buf = "\033_Ao=z;zlib error2\033\\";
      vt_write (vt, buf, strlen(buf));
      data = samples;
    }
    else
    {
      bytes = len;
    }
  }

  char *encoded = ctx_malloc (bytes * 2);
  encoded[0]=0;
  if (audio->encoding == 'a')
  {
    ctx_a85enc (data, encoded, bytes);
  }
  else /* if (audio->encoding == 'b')  */
  {
    ctx_bin2base64 (data, bytes, encoded);
  }

  sprintf (buf, "\033[_Af=%i;", frames);
  vt_write (vt, buf, strlen (buf));
  vt_write (vt, encoded, strlen(encoded));
  ctx_free (encoded);

  if (data != samples)
    ctx_free (data);

  //vt_write (vt, samples, bytes);
  buf[0]='\033';
  buf[1]='\\';
  buf[2]=0;
  vt_write (vt, buf, 2);
}

static const char MuLawCompressTable[256] =
{
   0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
   4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
};


unsigned char LinearToMuLawSample(int16_t sample)
{
  const int cBias = 0x84;
  const int cClip = 32635;
  int sign = (sample >> 8) & 0x80;

  if (sign)
    sample = (int16_t)-sample;

  if (sample > cClip)
    sample = cClip;

  sample = (int16_t)(sample + cBias);

  int exponent = (int)MuLawCompressTable[(sample>>7) & 0xFF];
  int mantissa = (sample >> (exponent+3)) & 0x0F;

  int compressedByte = ~ (sign | (exponent << 4) | mantissa);

  return (unsigned char)compressedByte;
}

#define MIC_BUF_LEN 40960

uint8_t mic_buf[MIC_BUF_LEN];
int     mic_buf_pos = 0;

static void mic_callback(void*     userdata,
                         uint8_t * stream,
                         int       len)
{
  AudioState *audio = userdata;
  int16_t *sstream = (void*)stream;
  int frames;
  int channels = audio->channels;

  frames = len / 2;

  if (audio->bits == 8)
  {
    if (audio->type == 'u')
    {
      for (int i = 0; i < frames; i++)
      {
        for (int c = 0; c < channels; c++)
        {
          mic_buf[mic_buf_pos++] = LinearToMuLawSample (sstream[i]);
          if (mic_buf_pos >= MIC_BUF_LEN - 4)
            mic_buf_pos = 0;
        }
      }
    }
    else
    {
      for (int i = 0; i < frames; i++)
      {
        for (int c = 0; c <  audio->channels; c++)
        {
          mic_buf[mic_buf_pos++] = (sstream[i]) / 256;
          if (mic_buf_pos >= MIC_BUF_LEN - 4)
            mic_buf_pos = 0;
        }
      }
    }
  }
  else
  {
    for (int i = 0; i < frames; i++)
    {
      for (int c = 0; c < audio->channels; c++)
      {
        *((int16_t*)(&mic_buf[mic_buf_pos])) = (sstream[i]);
        mic_buf_pos+=2;
        if (mic_buf_pos >= MIC_BUF_LEN - 4)
          mic_buf_pos = 0;
      }
    }
  }
}

static long int ticks (void)
{
  struct timeval tp;
  gettimeofday(&tp, NULL);
  return tp.tv_sec * 1000 + tp.tv_usec / 1000;
}

static long int silence_start = 0;

void sdl_audio_init ()
{
  static int done = 0;
  if (!done)
  {
#if CTX_SDL
  if (SDL_Init(SDL_INIT_AUDIO) < 0)
  {
    fprintf (stderr, "sdl audio init fail\n");
  }
#endif
  done = 1;
  }
}

void vt_audio_task (VT *vt, int click)
{
  if (!vt) return;
  AudioState *audio = &vt->audio;
#if CTX_SDL

  if (audio->mic)
  {
    if (mic_device == 0)
    {
      SDL_AudioSpec spec_want, spec_got;
      sdl_audio_init ();

      spec_want.freq     = audio->samplerate;
      spec_want.channels = 1;
      spec_want.format   = AUDIO_S16;
      spec_want.samples  = audio->buffer_size;
      spec_want.callback = mic_callback;
      spec_want.userdata = audio;
      mic_device = SDL_OpenAudioDevice(SDL_GetAudioDeviceName(0, SDL_TRUE), 1, &spec_want, &spec_got, 0);

      SDL_PauseAudioDevice(mic_device, 0);
    }

    if (mic_buf_pos)
    {
      SDL_LockAudioDevice (mic_device);
      vt_feed_audio (vt, mic_buf, mic_buf_pos);
      mic_buf_pos = 0;
      SDL_UnlockAudioDevice (mic_device);
    }
  }
  else
  {
    if (mic_device)
    {
      SDL_PauseAudioDevice(mic_device, 1);
      SDL_CloseAudioDevice(mic_device);
      mic_device = 0;
    }
  }

  int free_frames = audio->buffer_size - SDL_GetQueuedAudioSize(speaker_device);
  int queued = (pcm_write_pos - pcm_read_pos)/2; // 2 for stereo
  //if (free_frames > 6) free_frames -= 4;
  int frames = queued;

  if (frames > free_frames) frames = free_frames;
  if (frames > 0)
  {
    if (speaker_device == 0)
    {
      SDL_AudioSpec spec_want, spec_got;
      sdl_audio_init ();

       spec_want.freq = audio->samplerate;
       if (audio->bits == 8 && audio->type == 'u')
       {
         spec_want.format = AUDIO_S16;
         spec_want.channels = 2;
       }
       else if (audio->bits == 8 && audio->type == 's')
       {
         spec_want.format = AUDIO_S8;
         spec_want.channels = audio->channels;
       }
       else if (audio->bits == 16 && audio->type == 's')
       {
         spec_want.format = AUDIO_S16;
         spec_want.channels = audio->channels;
       }
       else
       {
         spec_want.format = AUDIO_S16; // XXX  : error
         spec_want.channels = audio->channels;
       }

       /* In SDL we always set 16bit stereo, but with the
        * requested sample rate.
        */
      spec_want.format = AUDIO_S16;
      spec_want.channels = 2;

      spec_want.samples = audio->buffer_size;
      spec_want.callback = NULL;

      speaker_device = SDL_OpenAudioDevice (NULL, 0, &spec_want, &spec_got, 0);
      if (!speaker_device){
        fprintf (stderr, "sdl openaudiodevice fail\n");
      }
      SDL_PauseAudioDevice (speaker_device, 0);
    }

#if 0
    {
       int i;
       unsigned char *b = (void*)(&pcm_queue[pcm_read_pos]);
       for (i = 0; i < frames * 4; i++)
       {
         if ((b[i] > ' ') && (b[i] <= '~'))
           fprintf (stderr, "[%c]", b[i]);
         else
           fprintf (stderr, "[%i]", b[i]);
       }
    }
#endif
    SDL_QueueAudio (speaker_device, (void*)&pcm_queue[pcm_read_pos], frames * 4);
    pcm_read_pos += frames*2;
    silence_start = ticks();
  }
  else
  {
    if (speaker_device &&  (ticks() - silence_start >  2000))
    {
      SDL_PauseAudioDevice(speaker_device, 1);
      SDL_CloseAudioDevice(speaker_device);
      speaker_device = 0;
    }
  }
#endif
}

void terminal_queue_pcm (int16_t sample_left, int16_t sample_right);

static unsigned char const vt_bell_audio[] = {
#if 1
  0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
#else
  0x7e, 0xfe, 0x7e, 0x7d, 0x7e, 0x7e, 0x7e, 0x7d, 0x7e, 0x7e, 0x7e, 0xff,
  0xff, 0xfe, 0xfe, 0x7e, 0xff, 0xfe, 0xfd, 0xfd, 0xfe, 0xfe, 0xfd, 0xfd,
  0xfe, 0xfe, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7d, 0x7d,
  0xfe, 0x7e, 0x7e, 0x7e, 0x7e, 0xfd, 0xfd, 0x7e, 0x7e, 0xfd, 0xfe, 0xfe,
  0xfe, 0x7d, 0x7d, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0xfe, 0xfe, 0xff, 0xfe,
  0xfe, 0xfe, 0x7d, 0x7c, 0xfb, 0xfa, 0xfc, 0xfd, 0xfc, 0x76, 0x75, 0xfa,
  0xfb, 0x7b, 0xfc, 0xef, 0xf6, 0x77, 0x6d, 0x7b, 0xf8, 0x78, 0x78, 0xfa,
  0xf7, 0xfd, 0xfd, 0xfc, 0xfc, 0xfa, 0xf5, 0xf7, 0x7d, 0x7b, 0x78, 0x77,
  0x7c, 0x6f, 0x7b, 0xf5, 0xfb, 0x7b, 0x7c, 0x78, 0x76, 0xea, 0xf2, 0x6d,
  0xfd, 0xed, 0x7a, 0x6d, 0x6e, 0x71, 0xfe, 0x76, 0x6d, 0xfb, 0xef, 0x7e,
  0xfa, 0xef, 0xec, 0xed, 0xf8, 0xf0, 0xea, 0xf9, 0x70, 0x7c, 0x7c, 0x6b,
  0x6d, 0x75, 0xfb, 0xf1, 0xf9, 0xfe, 0xec, 0xea, 0x7c, 0x75, 0xff, 0xfb,
  0x7d, 0x77, 0x7a, 0x71, 0x6e, 0x6c, 0x6e, 0x7b, 0x7e, 0x7a, 0x7c, 0xf4,
  0xf9, 0x7b, 0x7b, 0xfa, 0xfe, 0x73, 0x79, 0xfe, 0x7b, 0x76, 0xfe, 0xf3,
  0xf9, 0x76, 0x77, 0x7e, 0x7e, 0x7d, 0x7c, 0xf9, 0xee, 0xf2, 0x7d, 0xf8,
  0xec, 0xee, 0xf7, 0xfa, 0xf7, 0xf6, 0xfd, 0x77, 0x75, 0x7b, 0xfa, 0xfe,
  0x78, 0x79, 0x7c, 0x76, 0x7e, 0xf7, 0xfb, 0xf5, 0xf6, 0x75, 0x6f, 0x74,
  0x6e, 0x6e, 0x6d, 0x6c, 0x7a, 0xf9, 0x75, 0x77, 0xf4, 0xf0, 0xf0, 0xf1,
  0xef, 0xf3, 0xf6, 0xfd, 0xfc, 0xfb, 0xfd, 0xfc, 0xf6, 0xf8, 0xfb, 0xf9,
  0xfa, 0xfd, 0xfb, 0xfc, 0x7a, 0x7c, 0x77, 0x75, 0x78, 0x7a, 0x7a, 0x78,
  0x7a, 0xfa, 0xf9, 0x7c, 0xff, 0xfb, 0x7d, 0x77, 0x73, 0x6c, 0x6e, 0x7b,
  0xfc, 0xfe, 0x7e, 0xfb, 0xf1, 0xeb, 0xee, 0xf6, 0xf6, 0xef, 0xf7, 0x7c,
  0x76, 0x76, 0x7b, 0x7a, 0x7b, 0x73, 0x73, 0x7c, 0x79, 0x70, 0x79, 0xfb,
  0xfd, 0xf8, 0xf9, 0xfc, 0xfc, 0xf8, 0xfb, 0xff, 0xfc, 0xf9, 0x75, 0x6f,
  0x74, 0xfe, 0xff, 0xfd, 0x7d, 0xf5, 0xef, 0xee, 0xf8, 0xfd, 0xfd, 0xf3,
  0xfa, 0xfe, 0xfe, 0x7c, 0x77, 0x7a, 0xfb, 0x79, 0x7e, 0x7b, 0xfd, 0x6d,
  0xfc, 0x7a, 0xf0, 0x74, 0xee, 0x79, 0xea, 0x79, 0xf9, 0x6d, 0xf7, 0x71,
  0x79, 0x76, 0x7c, 0x77, 0x6f, 0xf3, 0x6c, 0xe8, 0x67, 0xe3, 0x5e, 0xdc,
  0x58, 0xd8, 0x4e, 0xce, 0x46, 0xc5, 0x40, 0x67, 0xba, 0x49, 0xac, 0x26,
  0xba, 0x3e, 0xc5, 0xc8, 0x2b, 0xa8, 0x32, 0xbd, 0xe4, 0x3e, 0xb7, 0x3b,
  0xb7, 0x3a, 0x33, 0xab, 0x3f, 0xc8, 0x46, 0x5f, 0xb7, 0x69, 0xd4, 0x3d,
  0xc0, 0x4c, 0xf2, 0xdb, 0x3b, 0xdd, 0x69, 0xc5, 0x5f, 0xd8, 0xd8, 0xda,
  0xc6, 0x39, 0xba, 0x3f, 0x35, 0xb3, 0x3e, 0xbb, 0x4a, 0x4a, 0xe7, 0x60,
  0xae, 0x2c, 0xcb, 0x53, 0x45, 0xaf, 0x2a, 0xae, 0x3e, 0x4a, 0xae, 0x2a,
  0xad, 0x38, 0xcc, 0xbb, 0x36, 0xae, 0x2c, 0xc6, 0xce, 0x38, 0xb1, 0x2f,
  0xb9, 0x54, 0x7c, 0xb3, 0x28, 0xae, 0x3d, 0xcf, 0xbb, 0x2e, 0xb4, 0x41,
  0xc6, 0x78, 0x39, 0xbc, 0x41, 0xc8, 0x59, 0x5b, 0xc7, 0x43, 0xbc, 0x45,
  0xf3, 0xdc, 0x69, 0xd6, 0x48, 0xc9, 0x4e, 0xd9, 0x59, 0x61, 0xde, 0x4b,
  0xc9, 0x44, 0xc8, 0xf5, 0x43, 0xc5, 0x37, 0xba, 0x65, 0x4d, 0xc8, 0x31,
  0xaf, 0x47, 0xdb, 0xd6, 0x36, 0xad, 0x37, 0xbb, 0x61, 0x3a, 0xae, 0x2d,
  0xb4, 0x47, 0x49, 0xb2, 0x30, 0xac, 0x3a, 0xcd, 0xbc, 0x2e, 0xaf, 0x32,
  0xbd, 0xd7, 0x34, 0xaf, 0x32, 0xbb, 0x55, 0x4a, 0xb4, 0x30, 0xbb, 0x40,
  0xeb, 0xbf, 0x39, 0xba, 0x3a, 0xd6, 0xd3, 0x48, 0xc0, 0x3b, 0xce, 0x5e,
  0xe7, 0xd3, 0x46, 0xcb, 0x4c, 0xce, 0x74, 0x7e, 0x7e, 0x55, 0xcf, 0x44,
  0xc4, 0x5b, 0x7c, 0xd3, 0x3f, 0xbc, 0x44, 0xcb, 0xfa, 0x46, 0xb9, 0x37,
  0xb8, 0x51, 0x54, 0xbe, 0x33, 0xb1, 0x3d, 0xce, 0xc4, 0x34, 0xaf, 0x2f,
  0xbd, 0xf8, 0x37, 0xb0, 0x2d, 0xb1, 0x4c, 0x4a, 0xb3, 0x2c, 0xb0, 0x3c,
  0xe4, 0xbf, 0x2f, 0xaf, 0x35, 0xc0, 0xdb, 0x39, 0xb3, 0x31, 0xbb, 0x5d,
  0x4c, 0xb8, 0x37, 0xb9, 0x48, 0xe8, 0xc7, 0x3d, 0xba, 0x43, 0xce, 0xdd,
  0x52, 0xc6, 0x46, 0xce, 0x55, 0xdf, 0xe8, 0x52, 0xd5, 0x48, 0xca, 0x4d,
  0xef, 0x68, 0x4c, 0xc7, 0x42, 0xc2, 0x49, 0x78, 0xce, 0x3e, 0xb9, 0x3c,
  0xc8, 0xef, 0x43, 0xb7, 0x35, 0xb8, 0x4a, 0x53, 0xb8, 0x32, 0xaf, 0x3b,
  0xde, 0xc1, 0x34, 0xaf, 0x32, 0xc3, 0xde, 0x3b, 0xaf, 0x2e, 0xb6, 0x4e,
  0x48, 0xb4, 0x2e, 0xb2, 0x3d, 0xf0, 0xbf, 0x33, 0xb2, 0x37, 0xc8, 0xd9,
  0x3d, 0xb5, 0x36, 0xbc, 0x56, 0x4f, 0xbc, 0x39, 0xbc, 0x47, 0xf6, 0xcf,
  0x44, 0xbf, 0x46, 0xce, 0x68, 0x5b, 0xd0, 0x4a, 0xcc, 0x4d, 0xd3, 0x60,
  0x6a, 0xcf, 0x49, 0xc8, 0x45, 0xd0, 0x7b, 0x58, 0xc3, 0x3c, 0xbf, 0x48,
  0xe2, 0xc9, 0x3b, 0xb7, 0x39, 0xc5, 0xdb, 0x40, 0xb6, 0x31, 0xb9, 0x50,
  0x50, 0xb9, 0x2f, 0xb3, 0x3b, 0xdc, 0xbf, 0x33, 0xaf, 0x32, 0xc1, 0xd6,
  0x3b, 0xb0, 0x2f, 0xb8, 0x54, 0x4a, 0xb6, 0x30, 0xb4, 0x3f, 0xfd, 0xc0,
  0x36, 0xb5, 0x39, 0xcc, 0xd9, 0x41, 0xb9, 0x39, 0xc2, 0x59, 0x57, 0xc1,
  0x3e, 0xc2, 0x49, 0xe2, 0xd7, 0x4c, 0xcb, 0x47, 0xcf, 0x5b, 0xec, 0xe0,
  0x53, 0xcb, 0x4b, 0xca, 0x55, 0xf6, 0xdb, 0x48, 0xc0, 0x43, 0xc9, 0x5f,
  0x54, 0xc0, 0x3c, 0xbb, 0x43, 0xe8, 0xc8, 0x39, 0xb5, 0x39, 0xc6, 0xde,
  0x3d, 0xb4, 0x32, 0xba, 0x4f, 0x4c, 0xb9, 0x30, 0xb2, 0x3c, 0xec, 0xc1,
  0x33, 0xaf, 0x35, 0xc4, 0xd7, 0x3a, 0xb2, 0x31, 0xba, 0x56, 0x48, 0xb9,
  0x33, 0xb7, 0x44, 0x7e, 0xc3, 0x39, 0xb7, 0x3d, 0xcd, 0xe3, 0x42, 0xbd,
  0x3d, 0xc2, 0x58, 0x5d, 0xcb, 0x43, 0xc4, 0x4c, 0xd8, 0xf8, 0x58, 0xcd,
  0x4c, 0xcb, 0x4e, 0xda, 0x71, 0x5c, 0xcc, 0x46, 0xc4, 0x49, 0xdc, 0xdc,
  0x46, 0xbe, 0x3d, 0xc4, 0x59, 0x53, 0xbe, 0x38, 0xb8, 0x41, 0xe1, 0xc5,
  0x39, 0xb3, 0x38, 0xc4, 0xde, 0x3d, 0xb2, 0x32, 0xb9, 0x4e, 0x4b, 0xb7,
  0x30, 0xb3, 0x3d, 0xf2, 0xbf, 0x33, 0xb1, 0x36, 0xc9, 0xd9, 0x3a, 0xb4,
  0x33, 0xbc, 0x58, 0x49, 0xba, 0x36, 0xb9, 0x46, 0x7e, 0xc8, 0x3c, 0xba,
  0x3f, 0xcd, 0xe8, 0x4b, 0xc1, 0x41, 0xc7, 0x57, 0xfe, 0xd3, 0x4e, 0xc9,
  0x4d, 0xd0, 0x5e, 0x7c, 0xda, 0x4e, 0xca, 0x47, 0xcd, 0x5b, 0x68, 0xcc,
  0x40, 0xbf, 0x42, 0xd2, 0xe4, 0x42, 0xbd, 0x3a, 0xbf, 0x56, 0x50, 0xbd,
  0x36, 0xb6, 0x40, 0xe2, 0xc5, 0x36, 0xb2, 0x37, 0xc5, 0xde, 0x3c, 0xb3,
  0x32, 0xba, 0x52, 0x4a, 0xb7, 0x31, 0xb4, 0x3f, 0xef, 0xbf, 0x34, 0xb2,
  0x39, 0xc8, 0xd3, 0x3c, 0xb6, 0x37, 0xbe, 0x5c, 0x4c, 0xbd, 0x39, 0xbc,
  0x49, 0xf2, 0xcc, 0x3f, 0xbf, 0x44, 0xcf, 0xfd, 0x51, 0xca, 0x48, 0xcb,
  0x54, 0xe4, 0xeb, 0x57, 0xcf, 0x4d, 0xcc, 0x4f, 0xe0, 0xee, 0x51, 0xc7,
  0x44, 0xc6, 0x4f, 0x78, 0xcc, 0x3f, 0xbd, 0x3e, 0xce, 0xe5, 0x42, 0xba,
  0x38, 0xbe, 0x50, 0x4f, 0xbb, 0x35, 0xb6, 0x3e, 0xe8, 0xc2, 0x36, 0xb2,
  0x37, 0xc6, 0xda, 0x3c, 0xb3, 0x32, 0xba, 0x55, 0x4a, 0xb7, 0x33, 0xb5,
  0x41, 0x7e, 0xbf, 0x37, 0xb4, 0x3b, 0xcd, 0xd8, 0x3e, 0xb8, 0x39, 0xc2,
  0x5b, 0x4f, 0xc0, 0x3c, 0xbf, 0x4a, 0xee, 0xd1, 0x47, 0xc5, 0x47, 0xd0,
  0x68, 0x63, 0xd0, 0x4d, 0xcd, 0x4e, 0xd6, 0x67, 0x68, 0xd6, 0x4b, 0xc9,
  0x4a, 0xd1, 0x6e, 0x52, 0xc5, 0x3f, 0xc0, 0x4b, 0xfd, 0xcb, 0x3d, 0xba,
  0x3d, 0xcc, 0xe2, 0x41, 0xb8, 0x37, 0xbc, 0x53, 0x4e, 0xba, 0x34, 0xb6,
  0x3f, 0xee, 0xc1, 0x36, 0xb2, 0x38, 0xc8, 0xd6, 0x3c, 0xb3, 0x34, 0xbc,
  0x58, 0x49, 0xb9, 0x34, 0xb7, 0x44, 0x73, 0xc3, 0x38, 0xb7, 0x3d, 0xce,
  0xd9, 0x40, 0xbc, 0x3c, 0xc5, 0x5e, 0x55, 0xc6, 0x40, 0xc3, 0x4d, 0xe5,
  0xde, 0x4d, 0xca, 0x4b, 0xce, 0x5c, 0xfa, 0xe1, 0x54, 0xcd, 0x4d, 0xcd,
  0x56, 0xf3, 0xd9, 0x4a, 0xc4, 0x44, 0xcb, 0x67, 0x53, 0xc3, 0x3d, 0xbe,
  0x48, 0xf0, 0xca, 0x3c, 0xb8, 0x3b, 0xca, 0xdf, 0x3f, 0xb7, 0x36, 0xbc,
  0x54, 0x4c, 0xb9, 0x34, 0xb6, 0x40, 0xf7, 0xc1, 0x36, 0xb3, 0x39, 0xca,
  0xd6, 0x3c, 0xb4, 0x35, 0xbe, 0x5b, 0x49, 0xba, 0x36, 0xba, 0x47, 0x6f,
  0xc5, 0x3b, 0xba, 0x3f, 0xd2, 0xdd, 0x46, 0xbe, 0x3f, 0xc9, 0x5c, 0x5d,
  0xcc, 0x47, 0xc8, 0x4e, 0xdd, 0xf5, 0x5a, 0xd1, 0x4e, 0xcf, 0x52, 0xde,
  0x7d, 0x5c, 0xcf, 0x49, 0xc9, 0x4d, 0xdd, 0xde, 0x49, 0xc1, 0x3f, 0xc6,
  0x5d, 0x53, 0xc0, 0x3b, 0xbc, 0x46, 0xeb, 0xc8, 0x3b, 0xb7, 0x3b, 0xc8,
  0xde, 0x3e, 0xb6, 0x35, 0xbb, 0x57, 0x4c, 0xb9, 0x34, 0xb6, 0x42, 0xff,
  0xc1, 0x36, 0xb4, 0x3a, 0xcc, 0xd7, 0x3d, 0xb7, 0x37, 0xbf, 0x5e, 0x4a,
  0xbc, 0x38, 0xbc, 0x4a, 0x6e, 0xc9, 0x3e, 0xbe, 0x43, 0xd5, 0xe2, 0x4b,
  0xc5, 0x45, 0xcb, 0x5e, 0x6e, 0xd6, 0x4e, 0xcd, 0x51, 0xd7, 0x65, 0x74,
  0xdc, 0x54, 0xcd, 0x4d, 0xd1, 0x5e, 0x6b, 0xcf, 0x46, 0xc4, 0x47, 0xd7,
  0xe3, 0x48, 0xbe, 0x3d, 0xc3, 0x58, 0x54, 0xbe, 0x39, 0xba, 0x43, 0xee,
  0xc7, 0x3a, 0xb6, 0x3a, 0xc9, 0xdc, 0x3e, 0xb5, 0x35, 0xbd, 0x57, 0x4b,
  0xb9, 0x34, 0xb7, 0x43, 0x6f, 0xc1, 0x38, 0xb6, 0x3c, 0xcf, 0xd3, 0x3e,
  0xb8, 0x3a, 0xc3, 0x64, 0x4c, 0xbe, 0x3c, 0xbf, 0x4d, 0x72, 0xcc, 0x42,
  0xc1, 0x48, 0xd9, 0xed, 0x51, 0xcc, 0x4b, 0xcf, 0x5a, 0xef, 0xe8, 0x59,
  0xd3, 0x50, 0xd1, 0x58, 0xe1, 0xec, 0x56, 0xcc, 0x49, 0xca, 0x55, 0x7c,
  0xcf, 0x44, 0xbf, 0x43, 0xcf, 0xe5, 0x47, 0xbc, 0x3b, 0xbf, 0x56, 0x52,
  0xbe, 0x38, 0xb9, 0x42, 0xee, 0xc6, 0x39, 0xb6, 0x3a, 0xca, 0xdc, 0x3d,
  0xb6, 0x36, 0xbd, 0x59, 0x4a, 0xba, 0x35, 0xb9, 0x45, 0x6b, 0xc2, 0x39,
  0xb8, 0x3d, 0xd2, 0xd5, 0x3f, 0xbb, 0x3c, 0xc6, 0x69, 0x4f, 0xc1, 0x3f,
  0xc3, 0x50, 0x7d, 0xd0, 0x49, 0xc8, 0x4c, 0xd8, 0x7d, 0x5d, 0xd4, 0x4f,
  0xd2, 0x57, 0xde, 0x6e, 0x69, 0xda, 0x50, 0xcd, 0x4e, 0xd6, 0x71, 0x59,
  0xca, 0x44, 0xc5, 0x4d, 0xf3, 0xce, 0x41, 0xbd, 0x3f, 0xcd, 0xe5, 0x45,
  0xbb, 0x3a, 0xbf, 0x55, 0x51, 0xbd, 0x37, 0xb9, 0x43, 0xf1, 0xc5, 0x39,
  0xb6, 0x3b, 0xcc, 0xd9, 0x3d, 0xb7, 0x37, 0xbf, 0x5d, 0x49, 0xbb, 0x37,
  0xba, 0x48, 0x69, 0xc4, 0x3b, 0xba, 0x40, 0xd5, 0xd7, 0x42, 0xbd, 0x3f,
  0xc9, 0x69, 0x52, 0xc7, 0x44, 0xc7, 0x52, 0xfa, 0xda, 0x4f, 0xcd, 0x4f,
  0xd8, 0x66, 0x72, 0xdf, 0x59, 0xd4, 0x52, 0xd6, 0x5d, 0xef, 0xde, 0x4f,
  0xca, 0x49, 0xce, 0x64, 0x5a, 0xc8, 0x40, 0xc1, 0x4a, 0xec, 0xcd, 0x3f,
  0xbc, 0x3e, 0xcc, 0xe5, 0x43, 0xba, 0x39, 0xbe, 0x55, 0x4f, 0xbc, 0x37,
  0xb9, 0x43, 0xf8, 0xc4, 0x39, 0xb6, 0x3b, 0xcd, 0xd7, 0x3e, 0xb7, 0x38,
  0xc0, 0x60, 0x4b, 0xbc, 0x39, 0xbc, 0x4b, 0x6b, 0xc6, 0x3d, 0xbd, 0x43,
  0xd9, 0xda, 0x47, 0xc1, 0x42, 0xcd, 0x66, 0x5a, 0xcd, 0x48, 0xcc, 0x54,
  0xe9, 0xe9, 0x59, 0xd5, 0x54, 0xd5, 0x5c, 0xe4, 0xfb, 0x61, 0xd4, 0x4f,
  0xcd, 0x51, 0xdf, 0xe3, 0x4e, 0xc5, 0x45, 0xca, 0x5e, 0x5b, 0xc6, 0x3e,
  0xbf, 0x48, 0xea, 0xcc, 0x3e, 0xbb, 0x3d, 0xcb, 0xe4, 0x42, 0xba, 0x38,
  0xbe, 0x56, 0x4e, 0xbc, 0x37, 0xb9, 0x44, 0x7b, 0xc4, 0x39, 0xb7, 0x3c,
  0xcf, 0xd7, 0x3e, 0xb9, 0x3a, 0xc2, 0x62, 0x4c, 0xbd, 0x3b, 0xbe, 0x4d,
  0x6b, 0xc9, 0x3f, 0xbf, 0x46, 0xd9, 0xde, 0x4b, 0xc5, 0x47, 0xce, 0x63,
  0x65, 0xd3, 0x4e, 0xcf, 0x55, 0xdf, 0x74, 0x67, 0xdc, 0x55, 0xd3, 0x54,
  0xda, 0x68, 0x67, 0xd5, 0x4c, 0xca, 0x4d, 0xdc, 0xe7, 0x4d, 0xc4, 0x42,
  0xc8, 0x5b, 0x59, 0xc4, 0x3d, 0xbe, 0x47, 0xec, 0xcc, 0x3d, 0xba, 0x3d,
  0xcc, 0xe1, 0x42, 0xba, 0x39, 0xbf, 0x5a, 0x4f, 0xbc, 0x38, 0xba, 0x46,
  0x7d, 0xc5, 0x3b, 0xb9, 0x3e, 0xd0, 0xd8, 0x40, 0xbb, 0x3c, 0xc5, 0x63,
  0x4d, 0xc0, 0x3d, 0xc1, 0x4e, 0x6e, 0xcd, 0x44, 0xc4, 0x49, 0xdb, 0xec,
  0x50, 0xcc, 0x4a, 0xd1, 0x5c, 0x7b, 0xde, 0x56, 0xd2, 0x54, 0xd8, 0x62,
  0xf2, 0xe2, 0x58, 0xcf, 0x4e, 0xd0, 0x5d, 0x72, 0xd3, 0x4a, 0xc5, 0x49,
  0xd6, 0xe8, 0x4b, 0xc0, 0x3f, 0xc5, 0x5b, 0x58, 0xc2, 0x3c, 0xbd, 0x47,
  0xee, 0xca, 0x3d, 0xba, 0x3d, 0xcd, 0xdf, 0x41, 0xba, 0x3a, 0xc0, 0x5b,
  0x4d, 0xbd, 0x39, 0xbc, 0x48, 0x73, 0xc6, 0x3c, 0xbb, 0x3f, 0xd4, 0xd9,
  0x43, 0xbd, 0x3e, 0xc8, 0x67, 0x50, 0xc4, 0x40, 0xc4, 0x51, 0x7b, 0xd1,
  0x4a, 0xc8, 0x4d, 0xd9, 0xf6, 0x5c, 0xd0, 0x51, 0xd2, 0x5c, 0xe8, 0xf2,
  0x62, 0xd8, 0x55, 0xd4, 0x56, 0xe1, 0x7c, 0x59, 0xcf, 0x49, 0xcc, 0x53,
  0x7a, 0xd4, 0x46, 0xc4, 0x45, 0xd5, 0xef, 0x49, 0xc0, 0x3d, 0xc5, 0x57,
  0x55, 0xc2, 0x3b, 0xbd, 0x47, 0xed, 0xc9, 0x3d, 0xb9, 0x3e, 0xcc, 0xdb,
  0x43, 0xb9, 0x3b, 0xc0, 0x61, 0x4f, 0xbd, 0x3b, 0xbc, 0x4b, 0x75, 0xc6,
  0x3d, 0xbc, 0x43, 0xd7, 0xd9, 0x45, 0xbf, 0x40, 0xcc, 0x68, 0x54, 0xc9,
  0x44, 0xca, 0x53, 0x7d, 0xda, 0x4d, 0xce, 0x4f, 0xdb, 0x6d, 0x68, 0xdd,
  0x55, 0xd6, 0x56, 0xdc, 0x67, 0x71, 0xde, 0x53, 0xce, 0x4f, 0xd6, 0x6e,
  0x5c, 0xcc, 0x47, 0xc7, 0x4f, 0xef, 0xd0, 0x45, 0xbf, 0x44, 0xcf, 0xe6,
  0x48, 0xbe, 0x3d, 0xc3, 0x5a, 0x54, 0xc0, 0x3b, 0xbc, 0x47, 0xfa, 0xc9,
  0x3c, 0xba, 0x3e, 0xd0, 0xdc, 0x41, 0xbb, 0x3b, 0xc4, 0x5f, 0x4d, 0xbf,
  0x3c, 0xbf, 0x4c, 0x6d, 0xc9, 0x3f, 0xbe, 0x46, 0xda, 0xdc, 0x49, 0xc3,
  0x45, 0xce, 0x6b, 0x5b, 0xcd, 0x4a, 0xcd, 0x57, 0xee, 0xe4, 0x58, 0xd4,
  0x54, 0xd9, 0x60, 0xf1, 0xed, 0x5f, 0xd7, 0x53, 0xd3, 0x5a, 0xeb, 0xe1,
  0x52, 0xca, 0x4b, 0xce, 0x68, 0x5c, 0xc9, 0x44, 0xc4, 0x4e, 0xec, 0xce,
  0x43, 0xbe, 0x42, 0xcf, 0xe4, 0x47, 0xbd, 0x3c, 0xc3, 0x5b, 0x50, 0xbf,
  0x3b, 0xbd, 0x48, 0x73, 0xc8, 0x3c, 0xbb, 0x3f, 0xd4, 0xda, 0x41, 0xbc,
  0x3d, 0xc7, 0x67, 0x4d, 0xc0, 0x3d, 0xc2, 0x4f, 0x68, 0xcb, 0x42, 0xc2,
  0x4a, 0xdd, 0xdd, 0x4d, 0xc7, 0x4a, 0xd1, 0x6d, 0x65, 0xd3, 0x52, 0xd1,
  0x5b, 0xe3, 0xf8, 0x68, 0xdd, 0x5a, 0xd8, 0x59, 0xde, 0x6d, 0x68, 0xd9,
  0x4e, 0xce, 0x4f, 0xe1, 0xeb, 0x4e, 0xc9, 0x45, 0xcd, 0x5d, 0x58, 0xc9,
  0x3f, 0xc2, 0x4b, 0xf6, 0xce, 0x3f, 0xbd, 0x40, 0xcf, 0xe0, 0x45, 0xbc,
  0x3d, 0xc3, 0x5e, 0x51, 0xbf, 0x3c, 0xbd, 0x4b, 0x7b, 0xc7, 0x3e, 0xbb,
  0x42, 0xd4, 0xd6, 0x45, 0xbd, 0x3f, 0xc9, 0x6f, 0x50, 0xc3, 0x40, 0xc5,
  0x53, 0x6c, 0xce, 0x46, 0xc7, 0x4c, 0xe0, 0xeb, 0x51, 0xce, 0x4d, 0xd7,
  0x5f, 0x6c, 0xe3, 0x57, 0xd9, 0x57, 0xde, 0x64, 0xfd, 0xe9, 0x5b, 0xd5,
  0x52, 0xd5, 0x61, 0x78, 0xd6, 0x4d, 0xc9, 0x4e, 0xd8, 0xe5, 0x4e, 0xc4,
  0x44, 0xc9, 0x5f, 0x5a, 0xc6, 0x3f, 0xc0, 0x4b, 0xf5, 0xcd, 0x3f, 0xbd,
  0x40, 0xd2, 0xdf, 0x43, 0xbd, 0x3c, 0xc6, 0x5e, 0x4e, 0xbf, 0x3b, 0xbf,
  0x4c, 0x6b, 0xc9, 0x3e, 0xbd, 0x44, 0xda, 0xd8, 0x45, 0xbf, 0x42, 0xcc,
  0x75, 0x52, 0xc6, 0x45, 0xc8, 0x58, 0x76, 0xd2, 0x4c, 0xca, 0x51, 0xdd,
  0xed, 0x5d, 0xd3, 0x55, 0xd7, 0x61, 0xec, 0xef, 0x65, 0xdc, 0x58, 0xd7,
  0x5a, 0xe4, 0xfd, 0x5c, 0xd2, 0x4c, 0xcf, 0x57, 0x77, 0xd8, 0x49, 0xc7,
  0x48, 0xd8, 0xeb, 0x4b, 0xc3, 0x40, 0xc8, 0x5d, 0x57, 0xc4, 0x3e, 0xbf,
  0x4b, 0xf8, 0xca, 0x3f, 0xbc, 0x42, 0xd1, 0xd9, 0x45, 0xbc, 0x3e, 0xc6,
  0x6a, 0x4f, 0xbf, 0x3d, 0xc0, 0x4f, 0x67, 0xc9, 0x3f, 0xbf, 0x47, 0xdf,
  0xdb, 0x47, 0xc4, 0x44, 0xd1, 0x6c, 0x53, 0xcc, 0x48, 0xce, 0x58, 0x74,
  0xdc, 0x50, 0xd1, 0x54, 0xdf, 0x74, 0x6a, 0xde, 0x5b, 0xd9, 0x5d, 0xdd,
  0x6e, 0xfc, 0xdd, 0x5a, 0xcf, 0x54, 0xd6, 0x7b, 0x60, 0xcd, 0x4b, 0xc9,
  0x55, 0xf2, 0xd2, 0x48, 0xc3, 0x47, 0xd5, 0xe6, 0x4a, 0xc1, 0x3f, 0xc8,
  0x5d, 0x52, 0xc4, 0x3d, 0xc0, 0x4b, 0x71, 0xcb, 0x3e, 0xbd, 0x41, 0xd7,
  0xdc, 0x43, 0xbe, 0x3e, 0xc9, 0x6a, 0x4e, 0xc1, 0x3e, 0xc3, 0x52, 0x6a,
  0xca, 0x43, 0xc1, 0x4b, 0xdd, 0xda, 0x4c, 0xc6, 0x4a, 0xd1, 0x77, 0x5d,
  0xce, 0x4e, 0xcf, 0x5c, 0xf3, 0xe5, 0x5a, 0xd8, 0x58, 0xdd, 0x62, 0xfb,
  0xf4, 0x5e, 0xdc, 0x54, 0xd9, 0x5a, 0xf6, 0xea, 0x52, 0xce, 0x4c, 0xd4,
  0x67, 0x5c, 0xcc, 0x46, 0xc8, 0x50, 0xf8, 0xd0, 0x45, 0xc0, 0x46, 0xd3,
  0xe1, 0x49, 0xbf, 0x3f, 0xc6, 0x63, 0x54, 0xc1, 0x3e, 0xbf, 0x4d, 0x76,
  0xc9, 0x3f, 0xbd, 0x44, 0xd8, 0xda, 0x44, 0xbe, 0x3f, 0xcb, 0x6b, 0x4e,
  0xc4, 0x3f, 0xc7, 0x53, 0x66, 0xcd, 0x45, 0xc6, 0x4d, 0xe3, 0xdf, 0x4e,
  0xcb, 0x4d, 0xd5, 0x6f, 0x65, 0xd6, 0x55, 0xd4, 0x5e, 0xe5, 0xf1, 0x6b,
  0xdc, 0x5d, 0xd8, 0x5e, 0xdf, 0x79, 0x6d, 0xd9, 0x53, 0xcf, 0x56, 0xe3,
  0xe8, 0x52, 0xcb, 0x49, 0xcf, 0x61, 0x5a, 0xcb, 0x43, 0xc6, 0x4d, 0x7c,
  0xd1, 0x42, 0xc0, 0x43, 0xd6, 0xe3, 0x47, 0xbf, 0x3e, 0xc8, 0x63, 0x51,
  0xc1, 0x3e, 0xc0, 0x4e, 0x6f, 0xc9, 0x3f, 0xbe, 0x47, 0xd9, 0xd7, 0x47,
  0xbf, 0x43, 0xcc, 0x79, 0x51, 0xc6, 0x44, 0xc9, 0x58, 0x6a, 0xd0, 0x49,
  0xca, 0x4f, 0xe6, 0xea, 0x54, 0xd1, 0x50, 0xdb, 0x65, 0x6e, 0xe4, 0x5a,
  0xdc, 0x5a, 0xe1, 0x67, 0xfe, 0xea, 0x5d, 0xd7, 0x55, 0xd8, 0x63, 0x74,
  0xd8, 0x4f, 0xcb, 0x4f, 0xdc, 0xe5, 0x50, 0xc7, 0x47, 0xcc, 0x65, 0x5b,
  0xc8, 0x43, 0xc4, 0x4e, 0xfa, 0xcd, 0x42, 0xbf, 0x44, 0xd6, 0xdf, 0x46,
  0xbf, 0x3f, 0xc9, 0x64, 0x4f, 0xc3, 0x3e, 0xc3, 0x4f, 0x68, 0xcb, 0x40,
  0xc0, 0x48, 0xde, 0xd9, 0x48, 0xc2, 0x45, 0xcf, 0x7b, 0x55, 0xc9, 0x48,
  0xcb, 0x5c, 0x75, 0xd3, 0x4f, 0xcd, 0x56, 0xe0, 0xed, 0x5e, 0xd7, 0x58,
  0xdb, 0x63, 0xef, 0xf5, 0x65, 0xdf, 0x5a, 0xdb, 0x5b, 0xea, 0x7d, 0x5d,
  0xd6, 0x4e, 0xd3, 0x59, 0x73, 0xd9, 0x4b, 0xca, 0x4b, 0xdc, 0xeb, 0x4d,
  0xc6, 0x44, 0xcb, 0x61, 0x59, 0xc7, 0x41, 0xc2, 0x4e, 0xfb, 0xcc, 0x42,
  0xbe, 0x46, 0xd5, 0xdb, 0x47, 0xbe, 0x40, 0xc9, 0x6e, 0x50, 0xc2, 0x3f,
  0xc4, 0x52, 0x69, 0xcb, 0x42, 0xc3, 0x4a, 0xe2, 0xdc, 0x49, 0xc6, 0x48,
  0xd4, 0x71, 0x56, 0xcd, 0x4a, 0xcf, 0x5b, 0x73, 0xdd, 0x53, 0xd3, 0x57,
  0xe2, 0x78, 0x6a, 0xdf, 0x5d, 0xdb, 0x5e, 0xe1, 0x6f, 0x7a, 0xe0, 0x5b,
  0xd4, 0x57, 0xdb, 0x79, 0x5f, 0xd0, 0x4d, 0xcd, 0x58, 0xfd, 0xd6, 0x4a,
  0xc7, 0x4a, 0xd9, 0xe8, 0x4c, 0xc5, 0x42, 0xcb, 0x5f, 0x55, 0xc7, 0x3f,
  0xc4, 0x4e, 0x71, 0xcd, 0x41, 0xbf, 0x46, 0xd9, 0xdb, 0x47, 0xbf, 0x41,
  0xcb, 0x70, 0x51, 0xc4, 0x42, 0xc5, 0x57, 0x6b, 0xcc, 0x46, 0xc4, 0x4d,
  0xe0, 0xdb, 0x4d, 0xc8, 0x4c, 0xd5, 0x78, 0x5d, 0xd1, 0x4f, 0xd3, 0x5d,
  0xfb, 0xe6, 0x5a, 0xda, 0x59, 0xe1, 0x67, 0x7c, 0xf1, 0x5f, 0xde, 0x58,
  0xdc, 0x5e, 0xf9, 0xe8, 0x56, 0xd1, 0x4f, 0xd7, 0x6d, 0x5e, 0xce, 0x4a,
  0xcb, 0x55, 0xf7, 0xd3, 0x49, 0xc4, 0x4a, 0xd7, 0xe3, 0x4c, 0xc2, 0x43,
  0xca, 0x66, 0x56, 0xc5, 0x40, 0xc3, 0x4f, 0x74, 0xcc, 0x42, 0xc0, 0x47,
  0xdb, 0xdc, 0x47, 0xc1, 0x42, 0xce, 0x6e, 0x50, 0xc7, 0x43, 0xc9, 0x57,
  0x67, 0xcf, 0x48, 0xc9, 0x4e, 0xe6, 0xe0, 0x50, 0xcd, 0x4e, 0xd8, 0x6f,
  0x65, 0xd7, 0x55, 0xd7, 0x5f, 0xeb, 0xf3, 0x68, 0xde, 0x5e, 0xdc, 0x60,
  0xe5, 0x7b, 0x6b, 0xdc, 0x56, 0xd4, 0x59, 0xe8, 0xe8, 0x55, 0xcd, 0x4c,
  0xd3, 0x68, 0x5c, 0xcd, 0x47, 0xc9, 0x52, 0xfe, 0xd2, 0x47, 0xc4, 0x48,
  0xd8, 0xe2, 0x4a, 0xc2, 0x42, 0xcb, 0x68, 0x54, 0xc5, 0x40, 0xc4, 0x51,
  0x6e, 0xcc, 0x42, 0xc1, 0x49, 0xdd, 0xda, 0x49, 0xc3, 0x46, 0xcf, 0x7a,
  0x53, 0xc8, 0x46, 0xcb, 0x5b, 0x6a, 0xd2, 0x4b, 0xcc, 0x52, 0xe7, 0xe7,
  0x56, 0xd2, 0x53, 0xdc, 0x6a, 0x6d, 0xe2, 0x5b, 0xdc, 0x5e, 0xe5, 0x6d,
  0x7a, 0xea, 0x5f, 0xda, 0x59, 0xdc, 0x68, 0x70, 0xdb, 0x52, 0xcf, 0x53,
  0xe0, 0xe9, 0x53, 0xcb, 0x4a, 0xcf, 0x66, 0x5c, 0xcb, 0x46, 0xc7, 0x51,
  0xfb, 0xcf, 0x46, 0xc2, 0x48, 0xd8, 0xdf, 0x4a, 0xc2, 0x42, 0xcb, 0x69,
  0x53, 0xc5, 0x41, 0xc5, 0x53, 0x6b, 0xcc, 0x44, 0xc3, 0x4a, 0xe0, 0xdb,
  0x4a, 0xc5, 0x48, 0xd2, 0x78, 0x55, 0xcb, 0x49, 0xce, 0x5c, 0x6e, 0xd7,
  0x4f, 0xcf, 0x56, 0xe6, 0xef, 0x5d, 0xd8, 0x59, 0xdc, 0x67, 0xf6, 0xee,
  0x65, 0xdf, 0x5d, 0xdd, 0x61, 0xec, 0xf4, 0x5f, 0xd8, 0x54, 0xd6, 0x5f,
  0x78, 0xda, 0x4f, 0xcc, 0x4f, 0xde, 0xea, 0x50, 0xc9, 0x48, 0xce, 0x64,
  0x5a, 0xca, 0x45, 0xc7, 0x50, 0x7b, 0xcf, 0x45, 0xc3, 0x48, 0xda, 0xde,
  0x4a, 0xc2, 0x43, 0xcc, 0x6d, 0x53, 0xc6, 0x43, 0xc7, 0x56, 0x6a, 0xcd,
  0x46, 0xc5, 0x4d, 0xe2, 0xdc, 0x4c, 0xc8, 0x4b, 0xd5, 0x7a, 0x59, 0xce,
  0x4d, 0xd0, 0x5e, 0x76, 0xdc, 0x55, 0xd4, 0x5a, 0xe5, 0x7d, 0x68, 0xdf,
  0x5d, 0xde, 0x60, 0xe9, 0x73, 0x70, 0xe4, 0x5c, 0xd9, 0x59, 0xe1, 0x7a,
  0x60, 0xd5, 0x4f, 0xd1, 0x5b, 0x7e, 0xd9, 0x4d, 0xca, 0x4d, 0xdb, 0xe8,
  0x4f, 0xc8, 0x47, 0xcd, 0x66, 0x5a, 0xc9, 0x44, 0xc6, 0x51, 0x78, 0xce,
  0x45, 0xc3, 0x49, 0xdb, 0xdd, 0x49, 0xc3, 0x44, 0xce, 0x6f, 0x53, 0xc7,
  0x44, 0xc9, 0x57, 0x69, 0xce, 0x48, 0xc8, 0x4e, 0xe6, 0xde, 0x4e, 0xcb,
  0x4d, 0xd8, 0x78, 0x5d, 0xd2, 0x50, 0xd5, 0x5f, 0xfc, 0xe4, 0x5c, 0xda,
  0x5c, 0xe2, 0x6e, 0x7d, 0xeb, 0x63, 0xde, 0x5d, 0xde, 0x65, 0xf9, 0xe7,
  0x5a, 0xd5, 0x54, 0xdb, 0x6f, 0x5f, 0xd2, 0x4d, 0xce, 0x58, 0x7d, 0xd7,
  0x4b, 0xc9, 0x4c, 0xdb, 0xe7, 0x4e, 0xc6, 0x46, 0xcd, 0x67, 0x58, 0xc8,
  0x44, 0xc7, 0x53, 0x72, 0xce, 0x45, 0xc3, 0x4a, 0xdd, 0xdc, 0x4a, 0xc4,
  0x46, 0xcf, 0x76, 0x54, 0xc9, 0x46, 0xcb, 0x5a, 0x69, 0xd0, 0x4a, 0xcb,
  0x51, 0xe8, 0xe1, 0x52, 0xce, 0x50, 0xdb, 0x72, 0x63, 0xda, 0x56, 0xda,
  0x5f, 0xf1, 0xf3, 0x65, 0xe0, 0x5e, 0xe0, 0x63, 0xec, 0x7c, 0x6a, 0xde,
  0x59, 0xd8, 0x5c, 0xec, 0xe9, 0x58, 0xd0, 0x4f, 0xd7, 0x6c, 0x5f, 0xcf,
  0x4b, 0xcc, 0x56, 0xfc, 0xd5, 0x4a, 0xc7, 0x4b, 0xdb, 0xe4, 0x4d, 0xc6,
  0x46, 0xcd, 0x69, 0x57, 0xc8, 0x44, 0xc7, 0x54, 0x6e, 0xce, 0x46, 0xc5,
  0x4b, 0xdf, 0xdc, 0x4b, 0xc6, 0x48, 0xd2, 0x79, 0x55, 0xcb, 0x49, 0xcd,
  0x5d, 0x6c, 0xd4, 0x4d, 0xcd, 0x55, 0xe8, 0xe6, 0x58, 0xd3, 0x55, 0xdd,
  0x6e, 0x6d, 0xe0, 0x5d, 0xdd, 0x5f, 0xe9, 0x73, 0x75, 0xe9, 0x60, 0xdd,
  0x5c, 0xe0, 0x6c, 0x6e, 0xde, 0x55, 0xd4, 0x57, 0xe6, 0xeb, 0x56, 0xce,
  0x4d, 0xd4, 0x6a, 0x5e, 0xce, 0x49, 0xcb, 0x55, 0xfe, 0xd3, 0x49, 0xc6,
  0x4b, 0xdb, 0xe2, 0x4c, 0xc5, 0x46, 0xce, 0x6c, 0x56, 0xc8, 0x45, 0xc8,
  0x56, 0x6c, 0xce, 0x47, 0xc6, 0x4d, 0xe3, 0xdd, 0x4c, 0xc8, 0x4a, 0xd5,
  0x7a, 0x57, 0xcd, 0x4b, 0xcf, 0x5e, 0x6d, 0xd8, 0x50, 0xd1, 0x58, 0xe9,
  0xee, 0x5d, 0xd9, 0x5a, 0xde, 0x6a, 0xfe, 0xec, 0x65, 0xe0, 0x5f, 0xe0,
  0x67, 0xf0, 0xf1, 0x63, 0xda, 0x58, 0xda, 0x65, 0x78, 0xdc, 0x53, 0xcf,
  0x54, 0xe1, 0xeb, 0x54, 0xcc, 0x4b, 0xd1, 0x68, 0x5d, 0xcd, 0x48, 0xca,
  0x54, 0x7b, 0xd2, 0x48, 0xc6, 0x4b, 0xdc, 0xe0, 0x4c, 0xc6, 0x47, 0xcf,
  0x6e, 0x55, 0xc9, 0x45, 0xca, 0x58, 0x6b, 0xcf, 0x48, 0xc8, 0x4e, 0xe5,
  0xdd, 0x4e, 0xca, 0x4c, 0xd8, 0x7b, 0x5a, 0xcf, 0x4e, 0xd3, 0x60, 0x73,
  0xdd, 0x56, 0xd6, 0x5b, 0xe8, 0xfc, 0x67, 0xdf, 0x5e, 0xdf, 0x65, 0xed,
  0x7b, 0x6e, 0xe5, 0x5e, 0xdc, 0x5d, 0xe6, 0xff, 0x63, 0xd8, 0x53, 0xd5,
  0x5e, 0x7c, 0xdb, 0x4f, 0xcd, 0x50, 0xde, 0xea, 0x52, 0xcb, 0x4a, 0xcf,
  0x68, 0x5c, 0xcc, 0x47, 0xc9, 0x54, 0x79, 0xd1, 0x48, 0xc6, 0x4b, 0xdd,
  0xdf, 0x4c, 0xc6, 0x47, 0xd0, 0x6f, 0x56, 0xca, 0x47, 0xcb, 0x5a, 0x6b,
  0xd1, 0x4a, 0xca, 0x50, 0xe7, 0xdf, 0x50, 0xcd, 0x4f, 0xda, 0x79, 0x5e,
  0xd5, 0x52, 0xd7, 0x62, 0xff, 0xe4, 0x5c, 0xdb, 0x5d, 0xe5, 0x73, 0x77,
  0xea, 0x64, 0xe0, 0x5f, 0xe2, 0x6b, 0xfe, 0xe8, 0x5c, 0xd8, 0x58, 0xde,
  0x76, 0x63, 0xd5, 0x50, 0xd1, 0x5b, 0xff, 0xda, 0x4e, 0xcb, 0x4f, 0xdd,
  0xe9, 0x50, 0xca, 0x49, 0xcf, 0x69, 0x5b, 0xcb, 0x47, 0xc9, 0x55, 0x75,
  0xd1, 0x48, 0xc7, 0x4c, 0xde, 0xde, 0x4c, 0xc7, 0x49, 0xd2, 0x76, 0x57,
  0xcb, 0x49, 0xcd, 0x5c, 0x6b, 0xd3, 0x4c, 0xcd, 0x54, 0xe9, 0xe3, 0x54,
  0xcf, 0x52, 0xdc, 0x75, 0x64, 0xda, 0x58, 0xdb, 0x63, 0xf4, 0xee, 0x65,
  0xe0, 0x5f, 0xe3, 0x68, 0xf1, 0xf9, 0x6a, 0xe0, 0x5d, 0xdc, 0x60, 0xef,
  0xeb, 0x5b, 0xd5, 0x54, 0xda, 0x6d, 0x62, 0xd3, 0x4e, 0xcf, 0x59, 0xfd,
  0xd9, 0x4d, 0xca, 0x4e, 0xdd, 0xe8, 0x4f, 0xc9, 0x49, 0xcf, 0x69, 0x5a,
  0xcb, 0x47, 0xca, 0x56, 0x73, 0xd1, 0x49, 0xc7, 0x4d, 0xdf, 0xdf, 0x4d,
  0xc8, 0x4a, 0xd4, 0x77, 0x58, 0xcd, 0x4b, 0xcf, 0x5d, 0x6d, 0xd6, 0x4e,
  0xcf, 0x56, 0xea, 0xe9, 0x59, 0xd5, 0x56, 0xde, 0x6f, 0x6d, 0xdf, 0x5d,
  0xdd, 0x62, 0xeb, 0x7c, 0x71, 0xe8, 0x62, 0xdf, 0x60, 0xe5, 0x73, 0x6f,
  0xdf, 0x5a, 0xd7, 0x5c, 0xe9, 0xec, 0x5a, 0xd1, 0x50, 0xd7, 0x6c, 0x61,
  0xd1, 0x4c, 0xcd, 0x58, 0xfd, 0xd7, 0x4c, 0xc9, 0x4d, 0xdd, 0xe7, 0x4f,
  0xc9, 0x49, 0xcf, 0x6b, 0x59, 0xcb, 0x47, 0xcb, 0x57, 0x6f, 0xd1, 0x49,
  0xc9, 0x4e, 0xe2, 0xdf, 0x4e, 0xca, 0x4c, 0xd6, 0x78, 0x5a, 0xcf, 0x4d,
  0xd1, 0x5f, 0x70, 0xda, 0x52, 0xd3, 0x59, 0xe9, 0xef, 0x5e, 0xda, 0x5a,
  0xdf, 0x6b, 0x7b, 0xeb, 0x63, 0xe1, 0x61, 0xe5, 0x6b, 0xfa, 0xf0, 0x64,
  0xdd, 0x5b, 0xde, 0x68, 0x75, 0xdf, 0x56, 0xd4, 0x58, 0xe4, 0xed, 0x58,
  0xcf, 0x4e, 0xd5, 0x6a, 0x60, 0xcf, 0x4b, 0xcc, 0x57, 0xfd, 0xd6, 0x4b,
  0xc9, 0x4d, 0xdd, 0xe5, 0x4f, 0xc9, 0x49, 0xd0, 0x6d, 0x5a, 0xcc, 0x48,
  0xcc, 0x59, 0x6f, 0xd3, 0x4b, 0xca, 0x4f, 0xe5, 0xe1, 0x50, 0xcc, 0x4e,
  0xd9, 0x77, 0x5d, 0xd2, 0x4f, 0xd5, 0x60, 0x77, 0xde, 0x57, 0xd7, 0x5c,
  0xe8, 0xfa, 0x67, 0xdf, 0x5e, 0xe0, 0x67, 0xf0, 0xfc, 0x6d, 0xe5, 0x5f,
  0xdf, 0x61, 0xeb, 0xfb, 0x65, 0xdb, 0x57, 0xd9, 0x61, 0x7c, 0xde, 0x54,
  0xd0, 0x54, 0xe1, 0xed, 0x56, 0xcd, 0x4d, 0xd3, 0x69, 0x5f, 0xce, 0x4b,
  0xcc, 0x57, 0x7d, 0xd5, 0x4b, 0xc9, 0x4e, 0xde, 0xe4, 0x4f, 0xc9, 0x4a,
  0xd2, 0x6f, 0x5a, 0xcc, 0x4a, 0xcd, 0x5b, 0x6f, 0xd4, 0x4c, 0xcc, 0x52,
  0xe7, 0xe4, 0x53, 0xce, 0x50, 0xdb, 0x76, 0x60, 0xd6, 0x54, 0xd8, 0x62,
  0xff, 0xe5, 0x5d, 0xdc, 0x5e, 0xe7, 0x75, 0x73, 0xe9, 0x64, 0xe2, 0x63,
  0xe7, 0x6f, 0x7b, 0xe9, 0x5f, 0xdb, 0x5c, 0xe2, 0x78, 0x65, 0xd9, 0x54,
  0xd6, 0x5e, 0xfe, 0xdd, 0x51, 0xce, 0x52, 0xdf, 0xec, 0x54, 0xcd, 0x4c,
  0xd2, 0x69, 0x5d, 0xce, 0x4a, 0xcc, 0x57, 0x7a, 0xd5, 0x4b, 0xc9, 0x4e,
  0xdf, 0xe3, 0x4f, 0xca, 0x4b, 0xd4, 0x70, 0x5a, 0xcd, 0x4b, 0xce, 0x5c,
  0x6f, 0xd6, 0x4e, 0xce, 0x55, 0xe8, 0xe7, 0x57, 0xd2, 0x54, 0xdd, 0x73,
  0x66, 0xdb, 0x59, 0xdb, 0x63, 0xf5, 0xee, 0x65, 0xe0, 0x60, 0xe5, 0x6b,
  0xf7, 0xf6, 0x69, 0xe2, 0x5f, 0xdf, 0x65, 0xf5, 0xeb, 0x5d, 0xd8, 0x58,
  0xdd, 0x71, 0x65, 0xd7, 0x51, 0xd2, 0x5c, 0xfd, 0xdb, 0x4f, 0xcd, 0x50,
  0xde, 0xea, 0x53, 0xcc, 0x4c, 0xd2, 0x6a, 0x5d, 0xce, 0x4a, 0xcc, 0x58,
  0x78, 0xd4, 0x4b, 0xca, 0x4f, 0xe1, 0xe3, 0x4f, 0xcb, 0x4c, 0xd6, 0x74,
  0x5b, 0xcf, 0x4d, 0xd0, 0x5e, 0x70, 0xd9, 0x50, 0xd0, 0x58, 0xea, 0xeb,
  0x5b, 0xd6, 0x58, 0xdf, 0x6f, 0x6d, 0xe1, 0x5d, 0xde, 0x64, 0xed, 0xff,
  0x6e, 0xe8, 0x63, 0xe2, 0x64, 0xe9, 0x77, 0x6e, 0xe2, 0x5c, 0xdb, 0x5e,
  0xec, 0xed, 0x5c, 0xd5, 0x54, 0xda, 0x6d, 0x64, 0xd5, 0x4f, 0xd0, 0x5a,
  0xfd, 0xda, 0x4e, 0xcc, 0x4f, 0xde, 0xe9, 0x52, 0xcb, 0x4b, 0xd3, 0x6c,
  0x5c, 0xce, 0x4a, 0xcd, 0x5a, 0x74, 0xd5, 0x4c, 0xcb, 0x50, 0xe4, 0xe3,
  0x51, 0xcc, 0x4e, 0xd8, 0x77, 0x5c, 0xd1, 0x4f, 0xd4, 0x60, 0x72, 0xdc,
  0x55, 0xd5, 0x5b, 0xeb, 0xef, 0x5f, 0xdb, 0x5c, 0xe1, 0x6d, 0x7a, 0xeb,
  0x65, 0xe3, 0x64, 0xe8, 0x6e, 0xfc, 0xef, 0x66, 0xdf, 0x5e, 0xe0, 0x6b,
  0x76, 0xe0, 0x59, 0xd7, 0x5a, 0xe8, 0xee, 0x5a, 0xd2, 0x51, 0xd8, 0x6c,
  0x62, 0xd3, 0x4e, 0xcf, 0x5a, 0xff, 0xd9, 0x4e, 0xcc, 0x4f, 0xdf, 0xe7,
  0x51, 0xcb, 0x4c, 0xd4, 0x6e, 0x5c, 0xce, 0x4b, 0xce, 0x5b, 0x71, 0xd5,
  0x4d, 0xcd, 0x53, 0xe7, 0xe3, 0x53, 0xce, 0x50, 0xdb, 0x78, 0x5e, 0xd5,
  0x52, 0xd7, 0x63, 0x78, 0xdf, 0x5a, 0xd9, 0x5e, 0xea, 0xf9, 0x69, 0xe1,
  0x60, 0xe3, 0x6a, 0xf2, 0xfa, 0x6e, 0xe7, 0x63, 0xe1, 0x65, 0xed, 0xfa,
  0x67, 0xdd, 0x5a, 0xdc, 0x65, 0x7b, 0xdf, 0x57, 0xd4, 0x57, 0xe4, 0xee,
  0x59, 0xd0, 0x4f, 0xd6, 0x6b, 0x60, 0xd2, 0x4d, 0xce, 0x59, 0x7d, 0xd8,
  0x4d, 0xcc, 0x4f, 0xe0, 0xe7, 0x51, 0xcc, 0x4c, 0xd5, 0x6f, 0x5b, 0xce,
  0x4c, 0xcf, 0x5c, 0x70, 0xd7, 0x4e, 0xce, 0x55, 0xe9, 0xe5, 0x56, 0xd1,
  0x53, 0xdd, 0x78, 0x62, 0xd9, 0x57, 0xda, 0x66, 0x7e, 0xe6, 0x5e, 0xde,
  0x60, 0xe9, 0x78, 0x73, 0xea, 0x66, 0xe4, 0x66, 0xea, 0x71, 0x7a, 0xea,
  0x61, 0xde, 0x5e, 0xe5, 0x7a, 0x67, 0xdb, 0x57, 0xd8, 0x60, 0x7e, 0xde,
  0x54, 0xd1, 0x55, 0xe2, 0xed, 0x57, 0xcf, 0x4e, 0xd6, 0x6b, 0x5f, 0xd0,
  0x4c, 0xce, 0x5a, 0x7a, 0xd8, 0x4d, 0xcc, 0x50, 0xe3, 0xe5, 0x51, 0xcc,
  0x4d, 0xd7, 0x74, 0x5c, 0xcf, 0x4d, 0xd1, 0x5e, 0x6f, 0xd9, 0x50, 0xd0,
  0x58, 0xea, 0xe7, 0x59, 0xd4, 0x57, 0xde, 0x77, 0x68, 0xdd, 0x5b, 0xdd,
  0x66, 0xf7, 0xee, 0x67, 0xe3, 0x64, 0xe7, 0x6d, 0xf9, 0xf5, 0x6b, 0xe5,
  0x62, 0xe2, 0x68, 0xf6, 0xed, 0x5f, 0xdb, 0x5a, 0xdf, 0x72, 0x67, 0xd9,
  0x54, 0xd5, 0x5e, 0xfd, 0xdd, 0x52, 0xcf, 0x53, 0xe1, 0xed, 0x56, 0xce,
  0x4e, 0xd5, 0x6b, 0x5e, 0xd0, 0x4c, 0xce, 0x5a, 0x77, 0xd7, 0x4d, 0xcc,
  0x52, 0xe4, 0xe5, 0x53, 0xcd, 0x4e, 0xd8, 0x76, 0x5d, 0xd1, 0x4f, 0xd3,
  0x5f, 0x71, 0xdb, 0x53, 0xd4, 0x5a, 0xec, 0xec, 0x5d, 0xd9, 0x5a, 0xe1,
  0x72, 0x6e, 0xe3, 0x5f, 0xe0, 0x66, 0xef, 0xfe, 0x6f, 0xe9, 0x66, 0xe5,
  0x67, 0xec, 0x79, 0x70, 0xe5, 0x5e, 0xdd, 0x60, 0xee, 0xee, 0x5e, 0xd8,
  0x57, 0xdc, 0x6f, 0x67, 0xd8, 0x52, 0xd3, 0x5d, 0xfd, 0xdc, 0x51, 0xce,
  0x53, 0xe0, 0xeb, 0x55, 0xce, 0x4e, 0xd6, 0x6d, 0x5e, 0xd0, 0x4c, 0xcf,
  0x5b, 0x75, 0xd8, 0x4e, 0xcd, 0x53, 0xe6, 0xe5, 0x54, 0xce, 0x50, 0xda,
  0x78, 0x5e, 0xd4, 0x51, 0xd6, 0x63, 0x74, 0xdd, 0x57, 0xd7, 0x5d, 0xec,
  0xf0, 0x61, 0xdd, 0x5e, 0xe4, 0x6f, 0x7a, 0xec, 0x67, 0xe5, 0x67, 0xea,
  0x70, 0xfe, 0xf0, 0x68, 0xe2, 0x61, 0xe3, 0x6d, 0x77, 0xe4, 0x5c, 0xda,
  0x5d, 0xea, 0xef, 0x5d, 0xd6, 0x54, 0xdb, 0x6c, 0x65, 0xd6, 0x50, 0xd2,
  0x5c, 0xfe, 0xdc, 0x50, 0xce, 0x52, 0xe1, 0xea, 0x55, 0xcd, 0x4e, 0xd6,
  0x6e, 0x5e, 0xd0, 0x4d, 0xcf, 0x5d, 0x74, 0xd8, 0x4f, 0xce, 0x55, 0xe8,
  0xe6, 0x56, 0xd0, 0x53, 0xdc, 0x78, 0x60, 0xd7, 0x55, 0xd9, 0x65, 0x78,
  0xe2, 0x5b, 0xdb, 0x5f, 0xec, 0xfa, 0x69, 0xe3, 0x62, 0xe6, 0x6b, 0xf6,
  0xfa, 0x6e, 0xe9, 0x66, 0xe5, 0x68, 0xee, 0xfb, 0x69, 0xdf, 0x5d, 0xde,
  0x68, 0x7c, 0xe3, 0x5a, 0xd7, 0x5a, 0xe6, 0xef, 0x5c, 0xd3, 0x52, 0xd9,
  0x6c, 0x64, 0xd5, 0x4f, 0xd1, 0x5b, 0xff, 0xdb, 0x4f, 0xce, 0x53, 0xe2,
  0xe9, 0x55, 0xce, 0x4e, 0xd7, 0x70, 0x5e, 0xd1, 0x4e, 0xd1, 0x5e, 0x73,
  0xd9, 0x50, 0xd0, 0x58, 0xea, 0xe7, 0x58, 0xd3, 0x56, 0xde, 0x78, 0x64,
  0xdb, 0x59, 0xdc, 0x67, 0x7d, 0xe8, 0x5f, 0xdf, 0x62, 0xeb, 0x79, 0x72,
  0xeb, 0x67, 0xe7, 0x68, 0xec, 0x74, 0x79, 0xec, 0x64, 0xe0, 0x60, 0xe8,
  0x7a, 0x6a, 0xde, 0x5a, 0xdb, 0x63, 0xfe, 0xe1, 0x58, 0xd4, 0x58, 0xe4,
  0xef, 0x5a, 0xd2, 0x51, 0xd8, 0x6c, 0x63, 0xd4, 0x4f, 0xd0, 0x5c, 0x7d,
  0xda, 0x4f, 0xce, 0x53, 0xe3, 0xe8, 0x55, 0xce, 0x4f, 0xd9, 0x73, 0x5e,
  0xd2, 0x4f, 0xd4, 0x5f, 0x72, 0xdb, 0x53, 0xd3, 0x5a, 0xeb, 0xea, 0x5b,
  0xd7, 0x59, 0xe0, 0x75, 0x6a, 0xde, 0x5d, 0xde, 0x68, 0xf9, 0xef, 0x67,
  0xe5, 0x65, 0xe9, 0x6f, 0xfb, 0xf5, 0x6c, 0xe7, 0x64, 0xe5, 0x6a, 0xf8,
  0xee, 0x62, 0xdd, 0x5d, 0xe2, 0x73, 0x6a, 0xdc, 0x57, 0xd8, 0x5f, 0xfb,
  0xe0, 0x56, 0xd2, 0x57, 0xe2, 0xee, 0x59, 0xd1, 0x50, 0xd8, 0x6d, 0x62,
  0xd3, 0x4e, 0xd0, 0x5c, 0x7a, 0xda, 0x4f, 0xce, 0x54, 0xe5, 0xe8, 0x56,
  0xcf, 0x50, 0xda, 0x75, 0x5f, 0xd4, 0x51, 0xd6, 0x62, 0x74, 0xdd, 0x56,
  0xd6, 0x5c, 0xec, 0xed, 0x5e, 0xdb, 0x5c, 0xe3, 0x73, 0x6e, 0xe5, 0x60,
  0xe3, 0x68, 0xf1, 0xfd, 0x6f, 0xeb, 0x67, 0xe7, 0x69, 0xee, 0x7a, 0x71,
  0xe7, 0x61, 0xdf, 0x64, 0xef, 0xef, 0x60, 0xda, 0x5a, 0xde, 0x70, 0x69,
  0xda, 0x55, 0xd6, 0x5e, 0xfb, 0xde, 0x55, 0xd1, 0x56, 0xe2, 0xed, 0x59,
  0xd0, 0x50, 0xd8, 0x6d, 0x60, 0xd3, 0x4f, 0xd1, 0x5d, 0x79, 0xda, 0x50,
  0xcf, 0x56, 0xe7, 0xe8, 0x57, 0xd1, 0x53, 0xdc, 0x77, 0x60, 0xd7, 0x54,
  0xd8, 0x64, 0x76, 0xdf, 0x59, 0xd9, 0x5e, 0xed, 0xf2, 0x64, 0xde, 0x5f,
  0xe5, 0x6f, 0x79, 0xec, 0x68, 0xe7, 0x68, 0xec, 0x73, 0x7e, 0xf1, 0x6a,
  0xe5, 0x63, 0xe7, 0x6f, 0x77, 0xe7, 0x5e, 0xdc, 0x5e, 0xeb, 0xf2, 0x5f,
  0xd9, 0x57, 0xdc, 0x6d, 0x68, 0xd9, 0x53, 0xd5, 0x5d, 0xfc, 0xde, 0x53,
  0xd0, 0x55, 0xe3, 0xed, 0x58, 0xd0, 0x50, 0xd8, 0x6e, 0x60, 0xd3, 0x4f,
  0xd2, 0x5e, 0x77, 0xdb, 0x52, 0xd1, 0x57, 0xe8, 0xe9, 0x59, 0xd3, 0x55,
  0xdd, 0x78, 0x64, 0xd9, 0x57, 0xdb, 0x66, 0x7b, 0xe4, 0x5d, 0xdc, 0x61,
  0xec, 0xfa, 0x6b, 0xe4, 0x64, 0xe7, 0x6d, 0xf7, 0xf8, 0x6f, 0xea, 0x68,
  0xe8, 0x6a, 0xf2, 0xfa, 0x6b, 0xe3, 0x5f, 0xe1, 0x69, 0x7c, 0xe6, 0x5c,
  0xda, 0x5c, 0xe9, 0xf3, 0x5e, 0xd7, 0x55, 0xdb, 0x6c, 0x67, 0xd8, 0x52,
  0xd4, 0x5d, 0xfd, 0xdd, 0x53, 0xd0, 0x55, 0xe3, 0xec, 0x58, 0xd0, 0x50,
  0xd9, 0x6f, 0x61, 0xd4, 0x50, 0xd4, 0x5f, 0x77, 0xdc, 0x54, 0xd3, 0x59,
  0xea, 0xea, 0x5b, 0xd6, 0x58, 0xdf, 0x77, 0x67, 0xdc, 0x5a, 0xdd, 0x68,
  0xfe, 0xea, 0x62, 0xdf, 0x64, 0xeb, 0x7b, 0x73, 0xeb, 0x68, 0xe8, 0x6a,
  0xee, 0x77, 0x79, 0xed, 0x67, 0xe3, 0x64, 0xeb, 0x7c, 0x6b, 0xe0, 0x5c,
  0xdd, 0x65, 0xfe, 0xe5, 0x5a, 0xd8, 0x5a, 0xe6, 0xf3, 0x5d, 0xd5, 0x54,
  0xda, 0x6d, 0x67, 0xd7, 0x51, 0xd3, 0x5d, 0xfe, 0xdd, 0x53, 0xd0, 0x56,
  0xe5, 0xeb, 0x58, 0xd1, 0x52, 0xda, 0x71, 0x61, 0xd6, 0x52, 0xd6, 0x61,
  0x77, 0xdd, 0x56, 0xd5, 0x5b, 0xeb, 0xec, 0x5d, 0xd9, 0x5a, 0xe2, 0x75,
  0x6b, 0xe0, 0x5e, 0xe0, 0x68, 0xf9, 0xf0, 0x68, 0xe5, 0x66, 0xeb, 0x70,
  0xfe, 0xf4, 0x6c, 0xe9, 0x67, 0xe8, 0x6d, 0xfa, 0xef, 0x65, 0xdf, 0x5f,
  0xe6, 0x75, 0x6b, 0xde, 0x5a, 0xdb, 0x62, 0xfc, 0xe3, 0x59, 0xd6, 0x59,
  0xe5, 0xf2, 0x5c, 0xd4, 0x53, 0xda, 0x6d, 0x65, 0xd7, 0x51, 0xd4, 0x5e,
  0x7e, 0xdd, 0x53, 0xd1, 0x57, 0xe6, 0xeb, 0x59, 0xd2, 0x53, 0xdc, 0x75,
  0x62, 0xd7, 0x54, 0xd8, 0x64, 0x78, 0xdf, 0x59, 0xd8, 0x5d, 0xec, 0xee,
  0x60, 0xdc, 0x5d, 0xe4, 0x74, 0x70, 0xe6, 0x63, 0xe3, 0x6a, 0xf2, 0xfc,
  0x70, 0xeb, 0x69, 0xe9, 0x6b, 0xf0, 0x7d, 0x72, 0xe9, 0x64, 0xe3, 0x67,
  0xf2, 0xf2, 0x63, 0xdd, 0x5c, 0xe1, 0x70, 0x6b, 0xdd, 0x58, 0xd9, 0x5f,
  0xfb, 0xe2, 0x58, 0xd4, 0x58, 0xe5, 0xf1, 0x5b, 0xd4, 0x53, 0xda, 0x6d,
  0x64, 0xd6, 0x51, 0xd4, 0x5e, 0x7b, 0xdd, 0x54, 0xd2, 0x58, 0xe8, 0xeb,
  0x5a, 0xd4, 0x55, 0xdd, 0x76, 0x64, 0xd9, 0x57, 0xda, 0x65, 0x79, 0xe2,
  0x5b, 0xdb, 0x5f, 0xed, 0xf3, 0x66, 0xdf, 0x61, 0xe7, 0x71, 0x7a, 0xed,
  0x69, 0xe8, 0x6a, 0xed, 0x76, 0x7e, 0xf1, 0x6b, 0xe7, 0x66, 0xea, 0x71,
  0x77, 0xe9, 0x60, 0xde, 0x61, 0xed, 0xf5, 0x61, 0xdb, 0x5a, 0xde, 0x6e,
  0x6b, 0xdc, 0x57, 0xd8, 0x5f, 0xfb, 0xe1, 0x57, 0xd4, 0x57, 0xe5, 0xef,
  0x5b, 0xd3, 0x53, 0xda, 0x6e, 0x64, 0xd7, 0x52, 0xd5, 0x5f, 0x7b, 0xdd,
  0x55, 0xd3, 0x59, 0xe9, 0xeb, 0x5b, 0xd6, 0x58, 0xde, 0x77, 0x67, 0xdb,
  0x59, 0xdc, 0x68, 0x7d, 0xe6, 0x5f, 0xde, 0x63, 0xed, 0xfb, 0x6b, 0xe6,
  0x65, 0xe8, 0x6e, 0xfa, 0xf8, 0x6e, 0xeb, 0x69, 0xea, 0x6c, 0xf5, 0xfa,
  0x6c, 0xe5, 0x61, 0xe4, 0x6c, 0x7c, 0xe8, 0x5e, 0xdc, 0x5e, 0xea, 0xf4,
  0x60, 0xd9, 0x58, 0xdd, 0x6e, 0x6a, 0xdb, 0x55, 0xd7, 0x5e, 0xfc, 0xdf,
  0x56, 0xd3, 0x58, 0xe5, 0xee, 0x5b, 0xd3, 0x54, 0xdb, 0x6f, 0x64, 0xd7,
  0x53, 0xd7, 0x60, 0x79, 0xde, 0x56, 0xd5, 0x5b, 0xeb, 0xed, 0x5d, 0xd8,
  0x5a, 0xe1, 0x76, 0x69, 0xde, 0x5c, 0xde, 0x69, 0xfd, 0xeb, 0x64, 0xe2,
  0x66, 0xed, 0x7c, 0x74, 0xec, 0x6a, 0xe9, 0x6c, 0xef, 0x7a, 0x78, 0xee,
  0x68, 0xe6, 0x67, 0xed, 0x7c, 0x6d, 0xe3, 0x5e, 0xdf, 0x68, 0xfe, 0xe7,
  0x5d, 0xda, 0x5d, 0xe8, 0xf4, 0x5f, 0xd8, 0x57, 0xdc, 0x6e, 0x69, 0xda,
  0x55, 0xd6, 0x5e, 0xfd, 0xdf, 0x56, 0xd3, 0x58, 0xe6, 0xed, 0x5a, 0xd4,
  0x54, 0xdc, 0x72, 0x64, 0xd8, 0x55, 0xd8, 0x63, 0x78, 0xdf, 0x58, 0xd8,
  0x5d, 0xed, 0xee, 0x5f, 0xdb, 0x5c, 0xe4, 0x76, 0x6d, 0xe2, 0x5f, 0xe2,
  0x6a, 0xfa, 0xf1, 0x6a, 0xe7, 0x68, 0xec, 0x72, 0x7e, 0xf5, 0x6e, 0xea,
  0x69, 0xea, 0x6e, 0xfc, 0xf0, 0x68, 0xe2, 0x62, 0xe7, 0x77, 0x6d, 0xe0,
  0x5d, 0xdd, 0x65, 0xfb, 0xe6, 0x5b, 0xd9, 0x5b, 0xe7, 0xf4, 0x5e, 0xd7,
  0x56, 0xdc, 0x6e, 0x68, 0xd9, 0x54, 0xd6, 0x5f, 0xfe, 0xdf, 0x56, 0xd4,
  0x59, 0xe7, 0xed, 0x5b, 0xd5, 0x56, 0xdd, 0x73, 0x65, 0xda, 0x57, 0xda,
  0x65, 0x79, 0xe2, 0x5b, 0xda, 0x5f, 0xed, 0xf1, 0x63, 0xde, 0x5f, 0xe6,
  0x75, 0x72, 0xe8, 0x64, 0xe6, 0x6b, 0xf4, 0xfb, 0x70, 0xec, 0x6a, 0xeb,
  0x6d, 0xf3, 0x7e, 0x72, 0xeb, 0x66, 0xe5, 0x69, 0xf5, 0xf3, 0x66, 0xdf,
  0x5f, 0xe4, 0x73, 0x6d, 0xdf, 0x5b, 0xdc, 0x63, 0xfb, 0xe5, 0x5a, 0xd7,
  0x5a, 0xe6, 0xf3, 0x5d, 0xd7, 0x56, 0xdc, 0x6e, 0x67, 0xd9, 0x55, 0xd7,
  0x5f, 0x7e, 0xdf, 0x57, 0xd5, 0x5a, 0xe9, 0xed, 0x5c, 0xd6, 0x58, 0xde,
  0x76, 0x67, 0xdb, 0x59, 0xdc, 0x66, 0x7b, 0xe5, 0x5d, 0xdc, 0x61, 0xee,
  0xf6, 0x67, 0xe2, 0x62, 0xe8, 0x71, 0x7a, 0xee, 0x69, 0xe9, 0x6b, 0xef,
  0x78, 0x7c, 0xf0, 0x6c, 0xe9, 0x69, 0xec, 0x76, 0x77, 0xea, 0x63, 0xe1,
  0x65, 0xee, 0xf4, 0x65, 0xdd, 0x5d, 0xe1, 0x70, 0x6d, 0xde, 0x59, 0xda,
  0x61, 0xfb, 0xe4, 0x59, 0xd7, 0x5a, 0xe6, 0xf2, 0x5d, 0xd6, 0x56, 0xdc,
  0x6e, 0x67, 0xd9, 0x55, 0xd8, 0x61, 0x7c, 0xdf, 0x58, 0xd6, 0x5b, 0xea,
  0xee, 0x5d, 0xd8, 0x59, 0xe0, 0x76, 0x69, 0xdd, 0x5b, 0xde, 0x68, 0x7d,
  0xe9, 0x5f, 0xdf, 0x63, 0xee, 0xfc, 0x6c, 0xe7, 0x66, 0xe9, 0x6f, 0xfb,
  0xf7, 0x6e, 0xec, 0x6a, 0xec, 0x6e, 0xf8, 0xf9, 0x6d, 0xe7, 0x65, 0xe7,
  0x6e, 0x7c, 0xea, 0x61, 0xde, 0x61, 0xec, 0xf6, 0x64, 0xdc, 0x5b, 0xdf,
  0x6f, 0x6c, 0xdd, 0x58, 0xd9, 0x61, 0xfb, 0xe3, 0x59, 0xd6, 0x5a, 0xe7,
  0xf1, 0x5d, 0xd6, 0x56, 0xdd, 0x6f, 0x67, 0xda, 0x56, 0xd9, 0x62, 0x7c,
  0xe0, 0x59, 0xd8, 0x5d, 0xeb, 0xee, 0x5f, 0xda, 0x5b, 0xe2, 0x76, 0x6b,
  0xe0, 0x5d, 0xe0, 0x6a, 0xfe, 0xed, 0x65, 0xe4, 0x67, 0xee, 0x7b, 0x73,
  0xed, 0x6a, 0xeb, 0x6d, 0xf2, 0x7b, 0x77, 0xee, 0x6a, 0xe9, 0x6a, 0xef,
  0x7e, 0x6e, 0xe6, 0x61, 0xe2, 0x6a, 0xfe, 0xe9, 0x5f, 0xdc, 0x5f, 0xea,
  0xf7, 0x62, 0xdb, 0x5a, 0xde, 0x6e, 0x6c, 0xdc, 0x58, 0xd9, 0x60, 0xfc,
  0xe2, 0x59, 0xd6, 0x5a, 0xe7, 0xef, 0x5d, 0xd7, 0x57, 0xde, 0x72, 0x67,
  0xdb, 0x57, 0xda, 0x64, 0x7b, 0xe2, 0x5b, 0xda, 0x5e, 0xed, 0xf0, 0x61,
  0xdd, 0x5e, 0xe5, 0x77, 0x6e, 0xe4, 0x61, 0xe3, 0x6c, 0xf9, 0xf1, 0x6b,
  0xe8, 0x6a, 0xed, 0x75, 0x7e, 0xf5, 0x6e, 0xec, 0x6b, 0xec, 0x71, 0xfe,
  0xf1, 0x69, 0xe5, 0x65, 0xea, 0x78, 0x6e, 0xe4, 0x5e, 0xdf, 0x67, 0xfc,
  0xe9, 0x5e, 0xdb, 0x5d, 0xe9, 0xf6, 0x61, 0xda, 0x59, 0xde, 0x6e, 0x6b,
  0xdc, 0x57, 0xd9, 0x61, 0xfd, 0xe2, 0x59, 0xd7, 0x5b, 0xe9, 0xef, 0x5d,
  0xd8, 0x58, 0xdf, 0x73, 0x68, 0xdc, 0x59, 0xdc, 0x66, 0x7b, 0xe4, 0x5c,
  0xdc, 0x60, 0xee, 0xf4, 0x65, 0xdf, 0x60, 0xe7, 0x75, 0x73, 0xe9, 0x66,
  0xe7, 0x6c, 0xf5, 0xfa, 0x71, 0xed, 0x6b, 0xec, 0x6e, 0xf6, 0xfe, 0x73,
  0xec, 0x68, 0xe9, 0x6b, 0xf7, 0xf5, 0x68, 0xe2, 0x61, 0xe7, 0x73, 0x6e,
  0xe2, 0x5d, 0xde, 0x65, 0xfa, 0xe8, 0x5d, 0xda, 0x5d, 0xe8, 0xf6, 0x5f,
  0xd9, 0x59, 0xdd, 0x6f, 0x6a, 0xdc, 0x58, 0xd9, 0x62, 0xfe, 0xe2, 0x59,
  0xd7, 0x5c, 0xe9, 0xef, 0x5e, 0xd9, 0x5a, 0xdf, 0x75, 0x69, 0xdd, 0x5b,
  0xdd, 0x68, 0x7d, 0xe7, 0x5f, 0xde, 0x63, 0xee, 0xf7, 0x69, 0xe4, 0x64,
  0xe9, 0x72, 0x7b, 0xee, 0x6b, 0xea, 0x6c, 0xf0, 0x79, 0x7b, 0xf2, 0x6d,
  0xeb, 0x6b, 0xee, 0x76, 0x78, 0xec, 0x66, 0xe4, 0x67, 0xf0, 0xf7, 0x67,
  0xdf, 0x5e, 0xe4, 0x70, 0x6e, 0xe0, 0x5c, 0xdc, 0x63, 0xfa, 0xe7, 0x5c,
  0xd9, 0x5c, 0xe8, 0xf5, 0x5f, 0xd9, 0x58, 0xde, 0x6f, 0x6a, 0xdc, 0x58,
  0xda, 0x62, 0x7e, 0xe3, 0x5a, 0xd9, 0x5d, 0xeb, 0xf0, 0x5f, 0xdb, 0x5b,
  0xe2, 0x74, 0x6b, 0xdf, 0x5d, 0xdf, 0x69, 0x7e, 0xea, 0x63, 0xe1, 0x65,
  0xee, 0xfd, 0x6e, 0xe8, 0x68, 0xea, 0x6f, 0xfc, 0xf8, 0x6f, 0xed, 0x6c,
  0xed, 0x70, 0xf9, 0xf9, 0x6e, 0xe9, 0x68, 0xe9, 0x6f, 0x7c, 0xec, 0x64,
  0xe1, 0x64, 0xed, 0xf8, 0x66, 0xde, 0x5d, 0xe1, 0x6f, 0x6e, 0xdf, 0x5b,
  0xdc, 0x63, 0xfb, 0xe6, 0x5b, 0xd9, 0x5c, 0xe8, 0xf4, 0x5f, 0xd9, 0x59,
  0xde, 0x70, 0x6a, 0xdc, 0x59, 0xdb, 0x64, 0x7e, 0xe3, 0x5b, 0xda, 0x5e,
  0xec, 0xf0, 0x61, 0xdc, 0x5d, 0xe4, 0x75, 0x6d, 0xe2, 0x5f, 0xe1, 0x6b,
  0xfb, 0xee, 0x67, 0xe5, 0x68, 0xee, 0x7c, 0x75, 0xed, 0x6b, 0xec, 0x6e,
  0xf4, 0x7d, 0x77, 0xef, 0x6c, 0xea, 0x6b, 0xf1, 0xff, 0x6f, 0xe8, 0x64,
  0xe6, 0x6c, 0xff, 0xeb, 0x62, 0xdf, 0x61, 0xec, 0xf8, 0x65, 0xdd, 0x5c,
  0xe0, 0x6f, 0x6d, 0xdf, 0x5a, 0xdb, 0x63, 0xfa, 0xe6, 0x5b, 0xd9, 0x5c,
  0xe8, 0xf3, 0x5f, 0xda, 0x59, 0xdf, 0x71, 0x6a, 0xdd, 0x59, 0xdc, 0x65,
  0x7d, 0xe5, 0x5d, 0xdc, 0x5f, 0xed, 0xf3, 0x64, 0xde, 0x5f, 0xe6, 0x75,
  0x70, 0xe6, 0x63, 0xe5, 0x6c, 0xf8, 0xf3, 0x6c, 0xe9, 0x6a, 0xed, 0x76,
  0x7e, 0xf5, 0x6e, 0xec, 0x6c, 0xee, 0x74, 0xfe, 0xf2, 0x6b, 0xe8, 0x68,
  0xec, 0x7a, 0x6f, 0xe6, 0x61, 0xe2, 0x6a, 0xfc, 0xea, 0x60, 0xdd, 0x5f,
  0xea, 0xf8, 0x64, 0xdc, 0x5b, 0xdf, 0x6e, 0x6d, 0xde, 0x5a, 0xdb, 0x63,
  0xfb, 0xe5, 0x5b, 0xd9, 0x5d, 0xea, 0xf3, 0x5f, 0xda, 0x5a, 0xe0, 0x72,
  0x6b, 0xde, 0x5b, 0xdd, 0x67, 0x7e, 0xe7, 0x5e, 0xdd, 0x62, 0xee, 0xf6,
  0x68, 0xe1, 0x62, 0xe8, 0x74, 0x75, 0xeb, 0x68, 0xe8, 0x6c, 0xf6, 0xfb,
  0x72, 0xed, 0x6d, 0xed, 0x70, 0xf7, 0xfe, 0x74, 0xed, 0x6a, 0xea, 0x6d,
  0xf7, 0xf6, 0x6a, 0xe5, 0x64, 0xe9, 0x75, 0x70, 0xe5, 0x5f, 0xdf, 0x67,
  0xfa, 0xea, 0x5f, 0xdc, 0x5e, 0xe9, 0xf8, 0x63, 0xdc, 0x5b, 0xdf, 0x6f,
  0x6c, 0xde, 0x5a, 0xdb, 0x63, 0xfc, 0xe6, 0x5c, 0xda, 0x5e, 0xea, 0xf3,
  0x61, 0xdb, 0x5c, 0xe2, 0x74, 0x6c, 0xdf, 0x5d, 0xdf, 0x69, 0x7e, 0xe9,
  0x61, 0xdf, 0x64, 0xef, 0xfa, 0x6b, 0xe6, 0x65, 0xea, 0x72, 0x7b, 0xef,
  0x6c, 0xeb, 0x6d, 0xf1, 0x7a, 0x7a, 0xf3, 0x6e, 0xec, 0x6c, 0xef, 0x78,
  0x78, 0xed, 0x68, 0xe7, 0x6a, 0xf2, 0xf7, 0x6a, 0xe2, 0x61, 0xe6, 0x72,
  0x70, 0xe3, 0x5e, 0xde, 0x66, 0xfa, 0xe9, 0x5e, 0xdc, 0x5e, 0xe9, 0xf8,
  0x62, 0xdb, 0x5b, 0xdf, 0x6f, 0x6c, 0xde, 0x5a, 0xdc, 0x64, 0xfd, 0xe6,
  0x5c, 0xdb, 0x5e, 0xeb, 0xf4, 0x62, 0xdd, 0x5d, 0xe3, 0x74, 0x6d, 0xe2,
  0x5e, 0xe1, 0x69, 0xfd, 0xed, 0x65, 0xe3, 0x67, 0xee, 0xfe, 0x6f, 0xea,
  0x69, 0xeb, 0x70, 0xfb, 0xf7, 0x70, 0xed, 0x6d, 0xee, 0x72, 0xfa, 0xf9,
  0x6f, 0xeb, 0x6a, 0xeb, 0x71, 0x7c, 0xed, 0x67, 0xe3, 0x66, 0xee, 0xf9,
  0x69, 0xe0, 0x5f, 0xe4, 0x71, 0x71, 0xe2, 0x5d, 0xdd, 0x65, 0xf8, 0xe9,
  0x5e, 0xdb, 0x5e, 0xe8, 0xf7, 0x63, 0xdb, 0x5b, 0xdf, 0x70, 0x6d, 0xde,
  0x5b, 0xdc, 0x65, 0xfc, 0xe7, 0x5d, 0xdc, 0x5f, 0xec, 0xf5, 0x64, 0xde,
  0x5e, 0xe5, 0x73, 0x6f, 0xe5, 0x60, 0xe3, 0x6a, 0xfc, 0xf0, 0x68, 0xe7,
  0x69, 0xef, 0x7b, 0x75, 0xee, 0x6c, 0xec, 0x6f, 0xf5, 0x7d, 0x77, 0xef,
  0x6d, 0xec, 0x6d, 0xf3, 0xff, 0x70, 0xea, 0x66, 0xe8, 0x6e, 0xfe, 0xed,
  0x65, 0xe1, 0x64, 0xed, 0xfa, 0x68, 0xdf, 0x5e, 0xe2, 0x6f, 0x6f, 0xe1,
  0x5d, 0xdd, 0x65, 0xf9, 0xe9, 0x5e, 0xdb, 0x5e, 0xe9, 0xf6, 0x63, 0xdc,
  0x5b, 0xe0, 0x71, 0x6d, 0xdf, 0x5c, 0xdd, 0x66, 0xfe, 0xe9, 0x5f, 0xdd,
  0x61, 0xed, 0xf7, 0x67, 0xe0, 0x60, 0xe7, 0x74, 0x73, 0xe8, 0x64, 0xe6,
  0x6c, 0xf8, 0xf5, 0x6c, 0xeb, 0x6b, 0xee, 0x76, 0x7d, 0xf4, 0x6f, 0xed,
  0x6d, 0xef, 0x75, 0x7e, 0xf4, 0x6c, 0xe9, 0x6a, 0xee, 0x7a, 0x71, 0xe9,
  0x64, 0xe5, 0x6b, 0xfc, 0xed, 0x63, 0xdf, 0x62, 0xeb, 0xfa, 0x67, 0xde,
  0x5d, 0xe1, 0x6f, 0x6f, 0xe0, 0x5c, 0xdd, 0x64, 0xf9, 0xe8, 0x5e, 0xdb,
  0x5e, 0xea, 0xf6, 0x64, 0xdc, 0x5c, 0xe1, 0x72, 0x6d, 0xe0, 0x5d, 0xde,
  0x68, 0xfd, 0xea, 0x61, 0xdf, 0x63, 0xed, 0xf9, 0x6a, 0xe4, 0x63, 0xe9,
  0x74, 0x77, 0xec, 0x69, 0xe9, 0x6d, 0xf6, 0xfd, 0x73, 0xee, 0x6d, 0xee,
  0x72, 0xf9, 0xfd, 0x74, 0xee, 0x6c, 0xec, 0x6f, 0xf9, 0xf6, 0x6c, 0xe8,
  0x66, 0xeb, 0x76, 0x72, 0xe8, 0x62, 0xe2, 0x69, 0xfa, 0xec, 0x62, 0xde,
  0x60, 0xea, 0xfb, 0x66, 0xde, 0x5d, 0xe1, 0x6f, 0x6f, 0xe0, 0x5c, 0xdd,
  0x65, 0xfa, 0xe9, 0x5e, 0xdc, 0x5f, 0xeb, 0xf7, 0x64, 0xdd, 0x5d, 0xe3,
  0x72, 0x6e, 0xe2, 0x5e, 0xe0, 0x69, 0xfc, 0xec, 0x64, 0xe1, 0x65, 0xef,
  0xfc, 0x6c, 0xe7, 0x66, 0xeb, 0x72, 0x7c, 0xf1, 0x6c, 0xec, 0x6d, 0xf2,
  0x7b, 0x7a, 0xf2, 0x6e, 0xed, 0x6e, 0xf1, 0x7a, 0x79, 0xee, 0x6a, 0xe9,
  0x6c, 0xf4, 0xf9, 0x6b, 0xe5, 0x64, 0xe8, 0x73, 0x73, 0xe6, 0x60, 0xe0,
  0x68, 0xf9, 0xec, 0x61, 0xde, 0x5f, 0xea, 0xfa, 0x66, 0xde, 0x5d, 0xe1,
  0x6f, 0x6f, 0xe1, 0x5c, 0xdd, 0x66, 0xfb, 0xe9, 0x5e, 0xdd, 0x5f, 0xec,
  0xf7, 0x65, 0xde, 0x5e, 0xe5, 0x74, 0x6f, 0xe5, 0x60, 0xe2, 0x6a, 0xfc,
  0xee, 0x67, 0xe5, 0x68, 0xef, 0xfe, 0x71, 0xeb, 0x6a, 0xec, 0x72, 0xfc,
  0xf8, 0x71, 0xee, 0x6e, 0xef, 0x74, 0xfb, 0xf9, 0x70, 0xed, 0x6c, 0xed,
  0x73, 0x7d, 0xef, 0x69, 0xe6, 0x68, 0xef, 0xfa, 0x6b, 0xe3, 0x62, 0xe6,
  0x72, 0x73, 0xe5, 0x5f, 0xdf, 0x67, 0xf8, 0xeb, 0x60, 0xdd, 0x5f, 0xea,
  0xfb, 0x65, 0xde, 0x5d, 0xe2, 0x6f, 0x6e, 0xe1, 0x5d, 0xde, 0x66, 0xfd,
  0xea, 0x5f, 0xde, 0x61, 0xed, 0xf8, 0x67, 0xe0, 0x60, 0xe7, 0x74, 0x71,
  0xe8, 0x63, 0xe5, 0x6c, 0xfa, 0xf1, 0x6b, 0xe8, 0x6a, 0xef, 0x7c, 0x77,
  0xef, 0x6d, 0xed, 0x71, 0xf5, 0x7e, 0x79, 0xf0, 0x6e, 0xed, 0x6f, 0xf4,
  0xfe, 0x73, 0xeb, 0x69, 0xe9, 0x6f, 0xfd, 0xee, 0x67, 0xe4, 0x66, 0xed,
  0xfb, 0x6a, 0xe2, 0x60, 0xe5, 0x70, 0x72, 0xe5, 0x5e, 0xdf, 0x66, 0xf8,
  0xeb, 0x5f, 0xdd, 0x5f, 0xea, 0xfa, 0x65, 0xde, 0x5d, 0xe3, 0x6f, 0x6e,
  0xe2, 0x5d, 0xdf, 0x67, 0xfc, 0xeb, 0x60, 0xdf, 0x63, 0xed, 0xf9, 0x69,
  0xe3, 0x63, 0xe9, 0x74, 0x75, 0xea, 0x67, 0xe8, 0x6d, 0xf9, 0xf7, 0x6e,
  0xec, 0x6c, 0xef, 0x78, 0x7e, 0xf5, 0x71, 0xee, 0x6e, 0xf0, 0x77, 0xfe,
  0xf4, 0x6e, 0xeb, 0x6c, 0xef, 0x7b, 0x74, 0xea, 0x67, 0xe7, 0x6d, 0xfb,
  0xee, 0x66, 0xe1, 0x64, 0xec, 0xfc, 0x69, 0xe1, 0x5f, 0xe4, 0x6f, 0x72,
  0xe4, 0x5e, 0xdf, 0x66, 0xf9, 0xeb, 0x5f, 0xdd, 0x5f, 0xeb, 0xf9, 0x66,
  0xde, 0x5e, 0xe3, 0x71, 0x6f, 0xe4, 0x5f, 0xe0, 0x69, 0xfc, 0xec, 0x63,
  0xe1, 0x65, 0xef, 0xfb, 0x6b, 0xe6, 0x65, 0xea, 0x74, 0x79, 0xed, 0x6a,
  0xea, 0x6e, 0xf6, 0xfc, 0x73, 0xef, 0x6e, 0xef, 0x73, 0xf9, 0xfd, 0x75,
  0xef, 0x6d, 0xed, 0x70, 0xfa, 0xf7, 0x6e, 0xe9, 0x69, 0xec, 0x77, 0x74,
  0xe9, 0x65, 0xe5, 0x6b, 0xfa, 0xee, 0x64, 0xe0, 0x63, 0xec, 0xfc, 0x69,
  0xe0, 0x5f, 0xe3, 0x6f, 0x72, 0xe4, 0x5e, 0xdf, 0x66, 0xfa, 0xeb, 0x60,
  0xde, 0x60, 0xeb, 0xf9, 0x67, 0xdf, 0x5f, 0xe5, 0x72, 0x70, 0xe5, 0x60,
  0xe2, 0x6a, 0xfc, 0xee, 0x66, 0xe4, 0x67, 0xef, 0xfd, 0x6e, 0xe9, 0x68,
  0xec, 0x73, 0x7d, 0xf3, 0x6e, 0xed, 0x6e, 0xf3, 0x7b, 0x7b, 0xf5, 0x70,
  0xee, 0x6f, 0xf3, 0x7a, 0x7a, 0xef, 0x6c, 0xeb, 0x6d, 0xf5, 0xf9, 0x6d,
  0xe7, 0x67, 0xea, 0x75, 0x75, 0xe8, 0x63, 0xe3, 0x69, 0xf8, 0xed, 0x64,
  0xdf, 0x62, 0xeb, 0xfc, 0x69, 0xdf, 0x5f, 0xe3, 0x70, 0x71, 0xe3, 0x5e,
  0xdf, 0x67, 0xfa, 0xeb, 0x61, 0xdf, 0x61, 0xed, 0xfa, 0x68, 0xe1, 0x60,
  0xe7, 0x73, 0x71, 0xe7, 0x62, 0xe5, 0x6b, 0xfb, 0xf0, 0x69, 0xe7, 0x69,
  0xef, 0x7e, 0x72, 0xed, 0x6b, 0xed, 0x72, 0xfc, 0xf9, 0x72, 0xef, 0x6e,
  0xf1, 0x74, 0xfc, 0xf9, 0x71, 0xee, 0x6d, 0xee, 0x75, 0x7d, 0xf0, 0x6b,
  0xe8, 0x6b, 0xf0, 0xfa, 0x6d, 0xe6, 0x64, 0xe8, 0x72, 0x75, 0xe8, 0x62,
  0xe2, 0x69, 0xf8, 0xed, 0x63, 0xdf, 0x61, 0xeb, 0xfc, 0x68, 0xdf, 0x5f,
  0xe4, 0x70, 0x71, 0xe4, 0x5f, 0xe0, 0x68, 0xfb, 0xec, 0x62, 0xdf, 0x63,
  0xed, 0xfa, 0x69, 0xe3, 0x62, 0xe8, 0x74, 0x74, 0xea, 0x65, 0xe7, 0x6c,
  0xfa, 0xf4, 0x6c, 0xea, 0x6b, 0xef, 0x7a, 0x78, 0xf0, 0x6e, 0xee, 0x71,
  0xf6, 0xff, 0x79, 0xf2, 0x6f, 0xee, 0x70, 0xf5, 0xfd, 0x74, 0xed, 0x6b,
  0xec, 0x70, 0xfe, 0xf0, 0x69, 0xe7, 0x68, 0xef, 0xfd, 0x6c, 0xe5, 0x62,
  0xe7, 0x70, 0x74, 0xe7, 0x60, 0xe1, 0x67, 0xf9, 0xee, 0x62, 0xdf, 0x61,
  0xeb, 0xfb, 0x68, 0xe0, 0x5f, 0xe4, 0x70, 0x71, 0xe5, 0x5f, 0xe1, 0x69,
  0xfb, 0xed, 0x64, 0xe1, 0x65, 0xee, 0xfb, 0x6b, 0xe5, 0x65, 0xe9, 0x74,
  0x78, 0xec, 0x69, 0xe9, 0x6e, 0xf8, 0xf8, 0x6f, 0xec, 0x6d, 0xef, 0x77,
  0x7e, 0xf6, 0x72, 0xef, 0x70, 0xf2, 0x78, 0x7e, 0xf6, 0x6f, 0xed, 0x6d,
  0xf0, 0x7b, 0x75, 0xed, 0x69, 0xe9, 0x6e, 0xfb, 0xf0, 0x68, 0xe5, 0x66,
  0xee, 0xfd, 0x6b, 0xe4, 0x61, 0xe6, 0x70, 0x74, 0xe7, 0x60, 0xe1, 0x67,
  0xf8, 0xed, 0x63, 0xdf, 0x62, 0xeb, 0xfb, 0x69, 0xe0, 0x5f, 0xe5, 0x71,
  0x72, 0xe6, 0x61, 0xe2, 0x6a, 0xfa, 0xee, 0x66, 0xe3, 0x67, 0xee, 0xfc,
  0x6e, 0xe8, 0x67, 0xeb, 0x74, 0x7c, 0xef, 0x6c, 0xeb, 0x6e, 0xf6, 0xfd,
  0x75, 0xf0, 0x6f, 0xef, 0x74, 0xfa, 0xfd, 0x75, 0xf0, 0x6e, 0xef, 0x73,
  0xfb, 0xf8, 0x6e, 0xeb, 0x6a, 0xee, 0x78, 0x76, 0xeb, 0x67, 0xe7, 0x6c,
  0xfa, 0xf0, 0x67, 0xe3, 0x65, 0xed, 0xfe, 0x6b, 0xe3, 0x61, 0xe5, 0x6f,
  0x74, 0xe7, 0x60, 0xe1, 0x67, 0xf9, 0xee, 0x63, 0xdf, 0x62, 0xec, 0xfc,
  0x69, 0xe2, 0x60, 0xe6, 0x72, 0x73, 0xe8, 0x63, 0xe4, 0x6b, 0xfa, 0xef,
  0x68, 0xe5, 0x69, 0xef, 0xfe, 0x70, 0xea, 0x6a, 0xec, 0x74, 0x7e, 0xf3,
  0x6f, 0xed, 0x6f, 0xf3, 0x7c, 0x7b, 0xf4, 0x71, 0xef, 0x71, 0xf4, 0x7c,
  0x7a, 0xf0, 0x6e, 0xec, 0x6f, 0xf6, 0xfa, 0x6f, 0xea, 0x69, 0xeb, 0x76,
  0x77, 0xeb, 0x66, 0xe5, 0x6b, 0xf8, 0xef, 0x67, 0xe2, 0x64, 0xed, 0xfe,
  0x6b, 0xe3, 0x60, 0xe5, 0x6f, 0x74, 0xe7, 0x60, 0xe1, 0x68, 0xf9, 0xee,
  0x63, 0xe1, 0x63, 0xed, 0xfd, 0x6a, 0xe4, 0x62, 0xe8, 0x72, 0x75, 0xe9,
  0x65, 0xe6, 0x6c, 0xfa, 0xf2, 0x6b, 0xe8, 0x6a, 0xef, 0x7d, 0x74, 0xed,
  0x6d, 0xed, 0x73, 0xfb, 0xf9, 0x74, 0xef, 0x70, 0xf1, 0x77, 0xfd, 0xfa,
  0x73, 0xef, 0x6e, 0xef, 0x76, 0x7d, 0xf2, 0x6c, 0xeb, 0x6c, 0xf2, 0xfc,
  0x6e, 0xe9, 0x67, 0xea, 0x72, 0x77, 0xea, 0x65, 0xe4, 0x6a, 0xf8, 0xef,
  0x66, 0xe2, 0x63, 0xec, 0xff, 0x6b, 0xe3, 0x60, 0xe5, 0x70, 0x75, 0xe7,
  0x61, 0xe2, 0x69, 0xf9, 0xee, 0x65, 0xe2, 0x64, 0xed, 0xfd, 0x6c, 0xe5,
  0x64, 0xe9, 0x73, 0x77, 0xeb, 0x67, 0xe8, 0x6d, 0xf9, 0xf6, 0x6d, 0xeb,
  0x6c, 0xef, 0x7a, 0x7a, 0xf1, 0x6f, 0xee, 0x72, 0xf7, 0xff, 0x78, 0xf3,
  0x70, 0xef, 0x72, 0xf7, 0xfe, 0x75, 0xee, 0x6c, 0xed, 0x72, 0xfd, 0xf2,
  0x6b, 0xe8, 0x6a, 0xef, 0xfd, 0x6e, 0xe7, 0x65, 0xe9, 0x71, 0x78, 0xea,
  0x63, 0xe4, 0x69, 0xf7, 0xef, 0x66, 0xe1, 0x64, 0xec, 0xff, 0x6b, 0xe3,
  0x61, 0xe6, 0x70, 0x75, 0xe8, 0x62, 0xe3, 0x6a, 0xf9, 0xef, 0x67, 0xe3,
  0x66, 0xee, 0xfe, 0x6d, 0xe7, 0x66, 0xea, 0x74, 0x7a, 0xee, 0x6a, 0xea,
  0x6e, 0xf7, 0xfa, 0x70, 0xee, 0x6e, 0xf1, 0x77, 0x7e, 0xf7, 0x72, 0xf0,
  0x71, 0xf4, 0x79, 0x7d, 0xf6, 0x71, 0xee, 0x6f, 0xf2, 0x7c, 0x77, 0xee,
  0x6b, 0xeb, 0x6f, 0xfb, 0xf2, 0x6b, 0xe7, 0x68, 0xee, 0xff, 0x6e, 0xe6,
  0x64, 0xe7, 0x70, 0x78, 0xea, 0x63, 0xe3, 0x69, 0xf7, 0xef, 0x66, 0xe2,
  0x64, 0xec, 0xfe, 0x6b, 0xe4, 0x62, 0xe6, 0x71, 0x76, 0xe9, 0x63, 0xe4,
  0x6a, 0xf9, 0xf1, 0x68, 0xe5, 0x67, 0xef, 0x7e, 0x6f, 0xea, 0x68, 0xec,
  0x74, 0x7c, 0xf1, 0x6c, 0xec, 0x6f, 0xf6, 0xfe, 0x76, 0xf1, 0x6f, 0xf0,
  0x75, 0xfb, 0xfd, 0x76, 0xf1, 0x6f, 0xef, 0x74, 0xfb, 0xf9, 0x70, 0xec,
  0x6d, 0xee, 0x79, 0x78, 0xed, 0x6a, 0xe9, 0x6d, 0xf9, 0xf2, 0x6a, 0xe6,
  0x67, 0xed, 0x7e, 0x6d, 0xe6, 0x63, 0xe7, 0x70, 0x78, 0xe9, 0x63, 0xe3,
  0x69, 0xf7, 0xf0, 0x66, 0xe2, 0x64, 0xec, 0xfe, 0x6c, 0xe5, 0x63, 0xe7,
  0x71, 0x77, 0xea, 0x65, 0xe6, 0x6b, 0xf8, 0xf3, 0x6a, 0xe8, 0x69, 0xef,
  0x7e, 0x72, 0xec, 0x6b, 0xed, 0x74, 0xfe, 0xf5, 0x6f, 0xee, 0x6f, 0xf4,
  0x7c, 0x7b, 0xf5, 0x71, 0xf0, 0x72, 0xf6, 0x7b, 0x79, 0xf3, 0x6e, 0xee,
  0x6f, 0xf7, 0xfb, 0x6f, 0xec, 0x6b, 0xed, 0x76, 0x79, 0xed, 0x68, 0xe7,
  0x6c, 0xf7, 0xf2, 0x69, 0xe5, 0x66, 0xec, 0x7e, 0x6e, 0xe5, 0x63, 0xe7,
  0x6f, 0x78, 0xe9, 0x63, 0xe4, 0x69, 0xf7, 0xf0, 0x67, 0xe3, 0x65, 0xed,
  0xff, 0x6d, 0xe6, 0x65, 0xe9, 0x73, 0x78, 0xeb, 0x67, 0xe7, 0x6c, 0xf8,
  0xf5, 0x6d, 0xea, 0x6b, 0xf0, 0x7c, 0x76, 0xef, 0x6d, 0xee, 0x72, 0xfc,
  0xfb, 0x74, 0xf2, 0x70, 0xf3, 0x76, 0xfe, 0xfb, 0x75, 0xf0, 0x6f, 0xf1,
  0x77, 0x7d, 0xf4, 0x6e, 0xec, 0x6d, 0xf3, 0xfe, 0x70, 0xeb, 0x69, 0xeb,
  0x73, 0x7a, 0xed, 0x67, 0xe7, 0x6b, 0xf7, 0xf4, 0x69, 0xe5, 0x66, 0xec,
  0x7d, 0x6d, 0xe5, 0x63, 0xe6, 0x6f, 0x79, 0xea, 0x64, 0xe3, 0x6a, 0xf6,
  0xf0, 0x68, 0xe4, 0x66, 0xed, 0xff, 0x6e, 0xe7, 0x66, 0xea, 0x73, 0x7a,
  0xed, 0x69, 0xe9, 0x6d, 0xf8, 0xf8, 0x6f, 0xec, 0x6d, 0xf1, 0x7a, 0x7a,
  0xf3, 0x6f, 0xf0, 0x72, 0xf8, 0x7e, 0x78, 0xf5, 0x70, 0xf1, 0x72, 0xf9,
  0xff, 0x75, 0xf0, 0x6d, 0xef, 0x72, 0xfd, 0xf4, 0x6d, 0xeb, 0x6b, 0xf1,
  0xff, 0x70, 0xea, 0x67, 0xea, 0x72, 0x7a, 0xec, 0x66, 0xe5, 0x6a, 0xf6,
  0xf3, 0x68, 0xe4, 0x66, 0xec, 0x7d, 0x6e, 0xe6, 0x64, 0xe7, 0x70, 0x79,
  0xea, 0x65, 0xe4, 0x6b, 0xf6, 0xf2, 0x69, 0xe5, 0x68, 0xed, 0xff, 0x6f,
  0xe9, 0x68, 0xeb, 0x73, 0x7c, 0xef, 0x6c, 0xeb, 0x6e, 0xf6, 0xfc, 0x72,
  0xee, 0x6e, 0xf1, 0x77, 0xfe, 0xf8, 0x73, 0xf2, 0x71, 0xf5, 0x79, 0x7d,
  0xf7, 0x72, 0xef, 0x6f, 0xf4, 0x7b, 0x77, 0xf0, 0x6c, 0xec, 0x6f, 0xfb,
  0xf5, 0x6c, 0xe9, 0x6a, 0xef, 0x7d, 0x6f, 0xe9, 0x66, 0xe9, 0x70, 0x7a,
  0xec, 0x66, 0xe5, 0x6a, 0xf6, 0xf3, 0x69, 0xe4, 0x65, 0xec, 0x7d, 0x6e,
  0xe7, 0x64, 0xe8, 0x70, 0x79, 0xeb, 0x66, 0xe6, 0x6b, 0xf7, 0xf4, 0x6b,
  0xe7, 0x69, 0xee, 0x7d, 0x72, 0xeb, 0x6a, 0xec, 0x73, 0xff, 0xf2, 0x6e,
  0xed, 0x6f, 0xf5, 0xfe, 0x78, 0xf2, 0x70, 0xf1, 0x75, 0xfb, 0xfd, 0x77,
  0xf3, 0x70, 0xf1, 0x75, 0xfb, 0xfa, 0x73, 0xee, 0x6e, 0xf0, 0x78, 0x79,
  0xef, 0x6b, 0xeb, 0x6e, 0xf8, 0xf5, 0x6c, 0xe8, 0x69, 0xee, 0x7c, 0x6f,
  0xe9, 0x66, 0xe8, 0x6f, 0x7a, 0xec, 0x66, 0xe5, 0x6a, 0xf6, 0xf4, 0x69,
  0xe5, 0x66, 0xed, 0x7c, 0x6e, 0xe7, 0x65, 0xe9, 0x71, 0x7a, 0xec, 0x68,
  0xe7, 0x6c, 0xf7, 0xf6, 0x6c, 0xe9, 0x6b, 0xef, 0x7c, 0x75, 0xed, 0x6c,
  0xed, 0x74, 0xfd, 0xf7, 0x71, 0xef, 0x70, 0xf4, 0x7c, 0x7c, 0xf6, 0x74,
  0xf1, 0x73, 0xf6, 0x7d, 0x7b, 0xf3, 0x70, 0xef, 0x71, 0xf7, 0xfd, 0x72,
  0xee, 0x6c, 0xee, 0x75, 0x7a, 0xef, 0x6a, 0xea, 0x6d, 0xf7, 0xf6, 0x6b,
  0xe7, 0x68, 0xed, 0x7b, 0x6f, 0xe8, 0x66, 0xe9, 0x6f, 0x7b, 0xec, 0x66,
  0xe5, 0x6a, 0xf6, 0xf4, 0x6a, 0xe6, 0x67, 0xed, 0x7c, 0x6f, 0xe9, 0x66,
  0xe9, 0x72, 0x7a, 0xee, 0x69, 0xe9, 0x6d, 0xf8, 0xf8, 0x6e, 0xeb, 0x6c,
  0xf0, 0x7b, 0x78, 0xf0, 0x6e, 0xef, 0x74, 0xfa, 0xfb, 0x76, 0xf1, 0x71,
  0xf3, 0x78, 0xfd, 0xfa, 0x76, 0xf1, 0x71, 0xf3, 0x78, 0x7e, 0xf5, 0x6f,
  0xed, 0x6f, 0xf4, 0xfe, 0x72, 0xec, 0x6b, 0xec, 0x74, 0x7c, 0xee, 0x6a,
  0xe8, 0x6c, 0xf6, 0xf5, 0x6b, 0xe7, 0x67, 0xed, 0x7c, 0x6f, 0xe9, 0x65,
  0xe9, 0x6f, 0x7a, 0xed, 0x66, 0xe6, 0x6a, 0xf6, 0xf5, 0x6a, 0xe7, 0x68,
  0xee, 0x7c, 0x70, 0xea, 0x68, 0xeb, 0x72, 0x7c, 0xef, 0x6b, 0xeb, 0x6e,
  0xf7, 0xfa, 0x70, 0xee, 0x6d, 0xf1, 0x79, 0x7b, 0xf5, 0x70, 0xf0, 0x74,
  0xf7, 0x7e, 0x7a, 0xf4, 0x73, 0xf1, 0x75, 0xf9, 0xfe, 0x77, 0xf1, 0x6f,
  0xef, 0x74, 0xfc, 0xf6, 0x6f, 0xec, 0x6d, 0xf1, 0x7e, 0x73, 0xeb, 0x6a,
  0xeb, 0x73, 0x7d, 0xee, 0x69, 0xe7, 0x6b, 0xf5, 0xf6, 0x6b, 0xe7, 0x67,
  0xed, 0x7b, 0x6f, 0xe9, 0x66, 0xe9, 0x6f, 0x7b, 0xed, 0x67, 0xe7, 0x6b,
  0xf7, 0xf6, 0x6b, 0xe8, 0x68, 0xee, 0x7c, 0x72, 0xeb, 0x69, 0xec, 0x73,
  0x7d, 0xf2, 0x6d, 0xec, 0x6f, 0xf7, 0xfc, 0x75, 0xef, 0x6f, 0xf1, 0x78,
  0xfe, 0xf9, 0x75, 0xf2, 0x73, 0xf5, 0x7a, 0x7e, 0xf8, 0x74, 0xf1, 0x71,
  0xf4, 0x7c, 0x79, 0xf1, 0x6e, 0xee, 0x71, 0xfb, 0xf7, 0x6e, 0xeb, 0x6b,
  0xf0, 0x7c, 0x72, 0xeb, 0x69, 0xea, 0x71, 0x7d, 0xee, 0x68, 0xe7, 0x6b,
  0xf5, 0xf6, 0x6b, 0xe7, 0x68, 0xed, 0x7c, 0x70, 0xe9, 0x67, 0xe9, 0x70,
  0x7b, 0xed, 0x68, 0xe8, 0x6c, 0xf7, 0xf6, 0x6c, 0xe9, 0x6a, 0xef, 0x7b,
  0x74, 0xed, 0x6b, 0xed, 0x73, 0xff, 0xf5, 0x6f, 0xee, 0x6f, 0xf6, 0x7e,
  0x79, 0xf3, 0x71, 0xf2, 0x76, 0xfb, 0xfd, 0x78, 0xf5, 0x72, 0xf3, 0x76,
  0xfc, 0xfa, 0x74, 0xef, 0x6f, 0xf2, 0x79, 0x7a, 0xf1, 0x6d, 0xec, 0x6f,
  0xf9, 0xf7, 0x6d, 0xea, 0x6b, 0xee, 0x7c, 0x72, 0xeb, 0x68, 0xea, 0x70,
  0x7d, 0xee, 0x69, 0xe7, 0x6b, 0xf4, 0xf6, 0x6c, 0xe7, 0x68, 0xed, 0x7b,
  0x71, 0xea, 0x67, 0xea, 0x71, 0x7c, 0xee, 0x69, 0xe9, 0x6c, 0xf6, 0xf8,
  0x6e, 0xeb, 0x6b, 0xf0, 0x7a, 0x76, 0xef, 0x6d, 0xee, 0x73, 0xfd, 0xf9,
  0x72, 0xf0, 0x70, 0xf5, 0x7b, 0x7c, 0xf7, 0x73, 0xf3, 0x74, 0xf8, 0x7c,
  0x7b, 0xf5, 0x71, 0xf1, 0x72, 0xf9, 0xfd, 0x74, 0xee, 0x6d, 0xef, 0x77,
  0x7c, 0xf1, 0x6c, 0xeb, 0x6e, 0xf7, 0xf7, 0x6d, 0xe9, 0x6a, 0xee, 0x7c,
  0x72, 0xea, 0x68, 0xea, 0x70, 0x7d, 0xee, 0x69, 0xe7, 0x6b, 0xf5, 0xf6,
  0x6c, 0xe7, 0x69, 0xed, 0x7c, 0x72, 0xea, 0x68, 0xeb, 0x71, 0x7d, 0xef,
  0x6b, 0xea, 0x6d, 0xf7, 0xfa, 0x6f, 0xec, 0x6d, 0xf1, 0x7a, 0x7a, 0xf2,
  0x6f, 0xef, 0x74, 0xfa, 0xfc, 0x76, 0xf3, 0x72, 0xf4, 0x78, 0xfe, 0xfb,
  0x75, 0xf3, 0x72, 0xf4, 0x79, 0x7e, 0xf7, 0x70, 0xef, 0x70, 0xf5, 0xfe,
  0x75, 0xee, 0x6c, 0xee, 0x75, 0x7d, 0xf0, 0x6c, 0xea, 0x6d, 0xf7, 0xf8,
  0x6d, 0xe9, 0x69, 0xee, 0x7b, 0x73, 0xea, 0x68, 0xea, 0x70, 0x7d, 0xee,
  0x69, 0xe8, 0x6b, 0xf6, 0xf7, 0x6c, 0xe8, 0x69, 0xee, 0x7b, 0x73, 0xec,
  0x6a, 0xec, 0x71, 0x7d, 0xf2, 0x6c, 0xec, 0x6e, 0xf7, 0xfc, 0x73, 0xee,
  0x6e, 0xf1, 0x79, 0x7c, 0xf6, 0x72, 0xf1, 0x74, 0xf9, 0x7e, 0x7a, 0xf6,
  0x73, 0xf3, 0x75, 0xfa, 0xfe, 0x78, 0xf3, 0x70, 0xf1, 0x76, 0xfd, 0xf7,
  0x70, 0xed, 0x6e, 0xf3, 0x7e, 0x75, 0xed, 0x6c, 0xed, 0x73, 0x7e, 0xf0,
  0x6b, 0xea, 0x6c, 0xf6, 0xf8, 0x6d, 0xe9, 0x69, 0xee, 0x7b, 0x72, 0xeb,
  0x68, 0xea, 0x70, 0x7d, 0xee, 0x69, 0xe9, 0x6c, 0xf5, 0xf8, 0x6d, 0xea,
  0x6a, 0xef, 0x7b, 0x75, 0xed, 0x6b, 0xed, 0x72, 0xff, 0xf4, 0x6e, 0xed,
  0x6f, 0xf6, 0xfe, 0x75, 0xf1, 0x70, 0xf3, 0x78, 0xfe, 0xf9, 0x75, 0xf3,
  0x73, 0xf6, 0x7b, 0x7d, 0xf9, 0x74, 0xf2, 0x72, 0xf7, 0x7c, 0x7a, 0xf3,
  0x6f, 0xef, 0x73, 0xfb, 0xf8, 0x6f, 0xed, 0x6d, 0xf1, 0x7c, 0x75, 0xed,
  0x6b, 0xec, 0x73, 0x7d, 0xef, 0x6b, 0xe9, 0x6c, 0xf6, 0xf8, 0x6d, 0xe9,
  0x69, 0xee, 0x7a, 0x73, 0xeb, 0x69, 0xeb, 0x71, 0x7e, 0xef, 0x6b, 0xe9,
  0x6d, 0xf6, 0xf8, 0x6e, 0xea, 0x6c, 0xef, 0x7c, 0x77, 0xee, 0x6d, 0xee,
  0x74, 0xfe, 0xf7, 0x70, 0xef, 0x70, 0xf6, 0x7d, 0x78, 0xf5, 0x71, 0xf4,
  0x76, 0xfb, 0xfe, 0x78, 0xf6, 0x73, 0xf5, 0x76, 0xfd, 0xfb, 0x75, 0xf2,
  0x70, 0xf3, 0x7a, 0x7b, 0xf3, 0x6e, 0xed, 0x71, 0xf9, 0xf8, 0x6f, 0xec,
  0x6c, 0xef, 0x7c, 0x75, 0xec, 0x6a, 0xec, 0x71, 0x7e, 0xf0, 0x6a, 0xe9,
  0x6c, 0xf6, 0xf9, 0x6d, 0xe9, 0x69, 0xee, 0x7a, 0x73, 0xec, 0x69, 0xeb,
  0x71, 0x7e, 0xf0, 0x6b, 0xea, 0x6d, 0xf6, 0xfa, 0x6f, 0xec, 0x6d, 0xf0,
  0x7b, 0x79, 0xf0, 0x6e, 0xef, 0x75, 0xfc, 0xf9, 0x74, 0xf1, 0x72, 0xf6,
  0x7b, 0x7c, 0xf8, 0x75, 0xf4, 0x74, 0xf8, 0x7d, 0x7c, 0xf7, 0x73, 0xf2,
  0x74, 0xf9, 0xfd, 0x76, 0xf0, 0x6f, 0xf0, 0x77, 0x7d, 0xf3, 0x6d, 0xed,
  0x6f, 0xf8, 0xfa, 0x6f, 0xeb, 0x6b, 0xef, 0x7b, 0x75, 0xec, 0x6a, 0xeb,
  0x71, 0x7e, 0xf0, 0x6a, 0xe9, 0x6c, 0xf5, 0xf9, 0x6d, 0xea, 0x6a, 0xee,
  0x7a, 0x74, 0xed, 0x6a, 0xec, 0x71, 0x7e, 0xf2, 0x6c, 0xec, 0x6e, 0xf5,
  0xfc, 0x72, 0xed, 0x6e, 0xf1, 0x79, 0x7b, 0xf3, 0x70, 0xef, 0x74, 0xfa,
  0xfc, 0x78, 0xf3, 0x73, 0xf4, 0x79, 0xfc, 0xfa, 0x77, 0xf3, 0x74, 0xf4,
  0x7a, 0xfe, 0xf7, 0x73, 0xef, 0x71, 0xf7, 0x7e, 0x76, 0xef, 0x6e, 0xef,
  0x75, 0x7d, 0xf3, 0x6d, 0xec, 0x6e, 0xf7, 0xfa, 0x6e, 0xeb, 0x6b, 0xef,
  0x79, 0x74, 0xed, 0x69, 0xeb, 0x6f, 0x7e, 0xf1, 0x6a, 0xea, 0x6c, 0xf6,
  0xfa, 0x6e, 0xeb, 0x6a, 0xef, 0x7a, 0x76, 0xee, 0x6b, 0xed, 0x72, 0xfe,
  0xf4, 0x6e, 0xed, 0x6f, 0xf6, 0xfd, 0x75, 0xef, 0x6f, 0xf1, 0x79, 0x7e,
  0xf6, 0x75, 0xf1, 0x76, 0xf8, 0xfd, 0x7a, 0xf5, 0x74, 0xf2, 0x76, 0xf8,
  0x7e, 0x7a, 0xf6, 0x71, 0xec, 0x76, 0xfa, 0x7e, 0x7b, 0xf9, 0x72, 0xf5,
  0x7d, 0xfb, 0xfb, 0x76, 0xf9, 0x75, 0x7b, 0xf1, 0x77, 0xfe, 0x7a, 0xfb,
  0x7e, 0x73, 0xfa, 0x7e, 0xfb, 0x7d, 0x77, 0xf7, 0x7e, 0x7c, 0xfe, 0x78,
  0xfa, 0x7e, 0xff, 0x7e, 0x76, 0xf9, 0xfd, 0xf9, 0xfe, 0x75, 0xf1, 0x76,
  0x7c, 0xfc, 0x7a, 0xf3, 0x70, 0xfd, 0x7e, 0x7d, 0xf3, 0x70, 0xf7, 0x78,
  0x7e, 0xf9, 0x72, 0xef, 0x77, 0xfc, 0xfd, 0x75, 0xee, 0x72, 0xf7, 0xfb
#endif
};

static const short MuLawDecompressTable[256] =
{
     -32124,-31100,-30076,-29052,-28028,-27004,-25980,-24956,
     -23932,-22908,-21884,-20860,-19836,-18812,-17788,-16764,
     -15996,-15484,-14972,-14460,-13948,-13436,-12924,-12412,
     -11900,-11388,-10876,-10364, -9852, -9340, -8828, -8316,
      -7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
      -5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
      -3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
      -2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
      -1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
      -1372, -1308, -1244, -1180, -1116, -1052,  -988,  -924,
       -876,  -844,  -812,  -780,  -748,  -716,  -684,  -652,
       -620,  -588,  -556,  -524,  -492,  -460,  -428,  -396,
       -372,  -356,  -340,  -324,  -308,  -292,  -276,  -260,
       -244,  -228,  -212,  -196,  -180,  -164,  -148,  -132,
       -120,  -112,  -104,   -96,   -88,   -80,   -72,   -64,
        -56,   -48,   -40,   -32,   -24,   -16,    -8,     -1,
      32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956,
      23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764,
      15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412,
      11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316,
       7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140,
       5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092,
       3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004,
       2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980,
       1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436,
       1372,  1308,  1244,  1180,  1116,  1052,   988,   924,
        876,   844,   812,   780,   748,   716,   684,   652,
        620,   588,   556,   524,   492,   460,   428,   396,
        372,   356,   340,   324,   308,   292,   276,   260,
        244,   228,   212,   196,   180,   164,   148,   132,
        120,   112,   104,    96,    88,    80,    72,    64,
         56,    48,    40,    32,    24,    16,     8,     0
};


void vt_bell (VT *vt)
{
  if (vt->bell < 2)
    return;
  for (int i = 0; i < (int)sizeof (vt_bell_audio); i++)
  {
    int16_t val = MuLawDecompressTable[vt_bell_audio[i]] * vt->bell / 8;
    terminal_queue_pcm (val, val);
  }
}


void terminal_queue_pcm (int16_t sample_left, int16_t sample_right);

void vt_audio (VT *vt, const char *command)
{
  AudioState *audio = &vt->audio;
  // the simplest form of audio is raw audio
  // _As=8000,c=2,b=8,e=u
  //
  // multiple voices:
  //   ids to queue - store samples as images...
  //
  // reusing samples
  //   .. pitch bend and be able to do a mod player?
  const char *payload = NULL;
  char key = 0;
  int  value;
  int  pos = 1;

  audio->frames=0;
  audio->action='t';

  int configure = 0;
  while (command[pos] != ';')
  {
    pos ++; // G or ,
    if (command[pos] == ';') break;
    key = command[pos]; pos++;
    if (command[pos] == ';') break;
    pos ++; // =
    if (command[pos] == ';') break;

    if (command[pos] >= '0' && command[pos] <= '9')
      value = atoi(&command[pos]);
    else
      value = command[pos];
    while (command[pos] &&
           command[pos] != ',' &&
           command[pos] != ';') pos++;
    
    if (value=='?')
    {
      char buf[256];
      const char *range="";
      switch (key)
      {
        case 's':range="8000,16000,24000,48000";break;
        case 'b':range="8,16";break;
        case 'B':range="512-65536";break;
        case 'c':range="1";break;
        case 'T':range="u,s,f";break;
        case 'e':range="b,a";break;
        case 'o':range="z,0";break;
        case 'a':range="t,q";break;
        default:range="unknown";break;
      }
      sprintf (buf, "\033_A%c=?;%s\033\\", key, range);
      vt_write (vt, buf, strlen(buf));
      return;
    }

    switch (key)
    {
      case 's': audio->samplerate = value; configure = 1; break;
      case 'b': audio->bits = value; configure = 1; break;
      case 'B': audio->buffer_size = value; configure = 1; break;
      case 'c': audio->channels = value; configure = 1; break;
      case 'a': audio->action = value; configure = 1; break;
      case 'T': audio->type = value; configure = 1; break;
      case 'f': audio->frames = value; configure = 1; break;
      case 'e': audio->encoding = value; configure = 1; break;
      case 'o': audio->compression = value; configure = 1; break;
      case 'm': 
        audio->mic = value?1:0;
        break;
    }

    if (configure)
    {
      /* these are the specific sample rates supported by opus,
       * instead of enabling anything SDL supports, the initial
       * implementation limits itself to the opus sample rates
       */
      if (audio->samplerate <= 8000)
      {
        audio->samplerate = 8000;
      }
      else if (audio->samplerate <= 16000)
      {
        audio->samplerate = 16000;
      }
      else if (audio->samplerate <= 24000)
      {
        audio->samplerate = 24000;
      }
      else
      {
        audio->samplerate = 48000;
      }

      if (audio->bits != 8 && audio->bits != 16)
        audio->bits = 8;

      if (audio->buffer_size > 2048)
        audio->buffer_size = 2048;
      else if (audio->buffer_size < 512)
        audio->buffer_size = 512;

      switch (audio->type)
      {
        case 'u':
        case 's':
        case 'f':
          break;
        default:
          audio->type = 's';
      }

      /* only 1 and 2 channels supported */
      if (audio->channels <= 0 || audio->channels > 2)
      {
        audio->channels = 1;
      }
    }
  }
  
  if (audio->frames ||  audio->action != 'd')
  {
  payload = &command[pos+1];

  // accumulate incoming data
  {
     int chunk_size = strlen (payload);
     int old_size = audio->data_size;
     if (audio->data == NULL)
     {
       audio->data_size = chunk_size;
       audio->data = ctx_malloc (audio->data_size + 1);
     }
     else
     {
       audio->data_size += chunk_size;
       audio->data = ctx_realloc (audio->data, audio->data_size+1 - chunk_size, audio->data_size + 1);
     }
     memcpy (audio->data + old_size, payload, chunk_size);
     audio->data[audio->data_size]=0;
  }

    if (audio->frames)
    switch (audio->encoding)
    {
      case 'y':
        audio->data_size = ydec (audio->data, audio->data, audio->data_size);
      break;
      case 'a':
      {
        int bin_length = audio->data_size;
        if (bin_length)
        {
        uint8_t *data2 = ctx_malloc ((unsigned int)ctx_a85len ((char*)audio->data, audio->data_size) + 1);
        // a85len is inaccurate but gives an upper bound,
        // should be fixed.
        bin_length = ctx_a85dec ((char*)audio->data,
                                 (void*)data2,
                                 bin_length);
        free (audio->data);
        audio->data = data2;
        audio->data_size = bin_length;
        }
      }
      break;

      case 'b':
      {
        int bin_length = audio->data_size;
        uint8_t *data2 = ctx_malloc (audio->data_size);
        bin_length = ctx_base642bin ((char*)audio->data,
                                     &bin_length,
                                     data2);
        memcpy (audio->data, data2, bin_length + 1);
        audio->data_size = bin_length;
        ctx_free (data2);
      }
      break;
    }

    if (audio->frames)
    switch (audio->compression)
    {
      case 'z':
    {
      unsigned long int
              actual_uncompressed_size = audio->frames * audio->bits/8 * audio->channels + 512;
      unsigned char *data2 = ctx_malloc (actual_uncompressed_size);
      /* if a buf size is set (rather compression, but
       * this works first..) then */
      int z_result = uncompress (data2, &actual_uncompressed_size,
                                 audio->data,
                                 audio->data_size);
      if (z_result != Z_OK)
      {
       // fprintf (stderr, "[z error %i %i]", __LINE__, z_result);
      }

#if 0
      // XXX : we seem to get buf-error (-5) here, which indicates not enough
      //       space in output buffer, which is odd
      //
      //       it is non fatal though so we ignore it and use the validly
      //       decompressed bits.
      {
        char buf[256];
        sprintf (buf, "\e_Ao=z;zlib error1 %i\e\\", z_result);
        vt_write (vt, buf, strlen(buf));
        //goto cleanup;
      }
#endif
      ctx_free (audio->data);
      audio->data = data2;
      audio->data_size = actual_uncompressed_size;
    }

        break;
      case 'o':
        break;
      default:
        break;
    }

    if (audio->frames == 0)
    {
      /* implicit frame count */
      audio->frames = audio->data_size /
                                (audio->bits/8) /
                                   audio->channels;
    }


#if 0
    if (audio->format == 100/* opus */)
    {
      int channels;
      uint8_t *new_data = NULL;//stbi_load_from_memory (audio->data, audio->data_size, &audio->buf_width, &audio->buf_height, &channels, 4);

      if (!new_data)
      {
        const char *buf= "\e_Gf=100;audio decode error\e\\";
        vt_write (vt, buf, strlen(buf));
        goto cleanup;
      }
      audio->format = 32;
      ctx_free (audio->data);
      audio->data = new_data;
      audio->data_size = audio->buf_width * audio->buf_height * 4;
    }
#endif

  switch (audio->action)
  {
    case 't': // transfer
       if (audio->type == 'u') // implied 8bit
       {
         if (audio->channels == 2)
         {
           for (int i = 0; i < audio->frames; i++)
           {
             int val_left = MuLawDecompressTable[audio->data[i*2]];
             int val_right = MuLawDecompressTable[audio->data[i*2+1]];
             terminal_queue_pcm (val_left, val_right);
           }
         }
         else
         {
           for (int i = 0; i < audio->frames; i++)
           {
             int val = MuLawDecompressTable[audio->data[i]];
             terminal_queue_pcm (val, val);
           }
         }
       }
       else if (audio->type == 's')
       {
         if (audio->bits == 8)
         {
           if (audio->channels == 2)
           {
             for (int i = 0; i < audio->frames; i++)
             {
               int val_left = 256*((int8_t*)(audio->data))[i*2];
               int val_right = 256*((int8_t*)(audio->data))[i*2+1];
               terminal_queue_pcm (val_left, val_right);
             }
           }
           else
           {
             for (int i = 0; i < audio->frames; i++)
             {
               int val = 256*((int8_t*)(audio->data))[i];
               terminal_queue_pcm (val, val);
             }
           }
         }
         else
         {
           if (audio->channels == 2)
           {
             for (int i = 0; i < audio->frames; i++)
             {
               int val_left = ((int16_t*)(audio->data))[i*2];
               int val_right = ((int16_t*)(audio->data))[i*2+1];
               terminal_queue_pcm (val_left, val_right);
             }
           }
           else
           {
             for (int i = 0; i < audio->frames; i++)
             {
               int val = ((int16_t*)(audio->data))[i];
               terminal_queue_pcm (val, val);
             }
           }
         }
       }
       ctx_free (audio->data);
       audio->data = NULL;
       audio->data_size=0;
       break;
    case 'q': // query
       {
         char buf[512];
         sprintf (buf, "\033_As=%i,b=%i,c=%i,T=%c,B=%i,e=%c,o=%c;OK\033\\",
      audio->samplerate, audio->bits, audio->channels, audio->type,
      audio->buffer_size,
      audio->encoding?audio->encoding:'0',
      audio->compression?audio->compression:'0'
      /*audio->transmission*/);

         vt_write (vt, buf, strlen(buf));
       }
      break;
  }
  }

//cleanup:
    if (audio->data)
      ctx_free (audio->data);
    audio->data = NULL;
    audio->data_size=0;
}
#endif
#endif

#if CTX_VT

static void draw_braille_bit (Ctx *ctx, float x, float y, float cw, float ch, int u, int v)
{
  ctx_rectangle (ctx, 0.167 * cw + x + u * cw * 0.5,
                 y - ch + 0.080 * ch + v * ch * 0.25,
                 0.33 *cw, 0.33 * cw);
}

static void draw_sextant_bit (Ctx *ctx, float x, float y, float cw, float ch, int u, int v)
{
  ctx_rectangle (ctx,  x + u * cw * 0.5,
                       y - ch + v * ch * 0.3333,
                       0.5 *cw, 0.34 * ch);
}

int vt_special_glyph (Ctx *ctx, VT *vt, float x, float y, float cw, float ch, int unichar, uint8_t red, uint8_t green, uint8_t blue)
{
#define SETUP \
        ctx_reset_path (ctx); \
        ctx_rgba8 (ctx, red, green, blue, 255);
  cw += 1.0f;
  ch += 1.0f;

  switch (unichar>>8)
  {
    case 0x25:
    {
      float lw = ch * 0.1f;
      SETUP;

  switch (unichar)
    {
      case 0x25a0: // BLACK SQUARE
        {
          float side = cw * 0.8;
          ctx_rectangle (ctx, x + cw * 0.5 - side/2, y - ch * 0.5 - side/2, side, side);
          ctx_fill (ctx);
        }
        return 0;
      case 0x25a1: // WHITE SQUARE
        {
          float side = cw * 0.8;

          ctx_rectangle (ctx, x + cw * 0.5 - side/2, y - ch * 0.5 - side/2, side, side);
          ctx_line_width (ctx, 0.05f * ch);
          ctx_stroke (ctx);
        }
        return 0;
      case 0x25a2: // WHITE SQUARE WITH ROUNDED CORNERS
        {
          float side = cw * 0.8;
          ctx_round_rectangle (ctx, x + cw * 0.5 - side/2, y - ch * 0.5 - side/2, side, side, 0.2 * side);
          ctx_line_width (ctx, 0.05f * ch);
          ctx_stroke (ctx);
        }
        return 0;

      case 0x2594: // UPPER_ONE_EIGHT_BLOCK
        {
          float factor = 1.0f/8.0f;
          ctx_rectangle (ctx, x, y - ch, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2581: // LOWER_ONE_EIGHT_BLOCK:
        {
          float factor = 1.0f/8.0f;
          ctx_rectangle (ctx, x, y - ch * factor, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2582: // LOWER_ONE_QUARTER_BLOCK:
        {
          float factor = 1.0f/4.0f;
          ctx_rectangle (ctx, x, y - ch * factor, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2583: // LOWER_THREE_EIGHTS_BLOCK:
        {
          float factor = 3.0f/8.0f;
          ctx_rectangle (ctx, x, y - ch * factor, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2585: // LOWER_FIVE_EIGHTS_BLOCK:
        {
          float factor = 5.0f/8.0f;
          ctx_rectangle (ctx, x, y - ch * factor, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2586: // LOWER_THREE_QUARTERS_BLOCK:
        {
          float factor = 3.0f/4.0f;
          ctx_rectangle (ctx, x, y - ch * factor, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2587: // LOWER_SEVEN_EIGHTS_BLOCK:
        {
          float factor = 7.0f/8.0f;
          ctx_rectangle (ctx, x, y - ch * factor, cw, ch * factor);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2589: // LEFT_SEVEN_EIGHTS_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw*7/8, ch);
        ctx_fill (ctx);
        return 0;
      case 0x258A: // LEFT_THREE_QUARTERS_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw*3/4, ch);
        ctx_fill (ctx);
        return 0;
      case 0x258B: // LEFT_FIVE_EIGHTS_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw*5/8, ch);
        ctx_fill (ctx);
        return 0;
      case 0x258D: // LEFT_THREE_EIGHTS_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw*3/8, ch);
        ctx_fill (ctx);
        return 0;
      case 0x258E: // LEFT_ONE_QUARTER_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw/4, ch);
        ctx_fill (ctx);
        return 0;
      case 0x258F: // LEFT_ONE_EIGHT_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw/8, ch);
        ctx_fill (ctx);
        return 0;
      case 0x258C: // HALF_LEFT_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw/2, ch);
        ctx_fill (ctx);
        return 0;
      case 0x2590: // HALF_RIGHT_BLOCK:
        ctx_rectangle (ctx, x + cw/2, y - ch, cw/2, ch);
        ctx_fill (ctx);
        return 0;
      case 0x2595: // VT_RIGHT_ONE_EIGHT_BLOCK:
        ctx_rectangle (ctx, x + cw*7/8, y - ch, cw/8, ch);
        ctx_fill (ctx);
        return 0;

      case 0x2580: // HALF_UP_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x2584: // _HALF_DOWN_BLOCK:
        ctx_rectangle (ctx, x, y - ch/2, cw, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x2596: // _QUADRANT LOWER LEFT
        ctx_rectangle (ctx, x, y - ch/2, cw/2, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x2597: // _QUADRANT LOWER RIGHT
        ctx_rectangle (ctx, x+cw/2, y - ch/2, cw/2, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x2598: // _QUADRANT UPPER LEFT
        ctx_rectangle (ctx, x, y - ch, cw/2, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x259D: // _QUADRANT UPPER RIGHT
        ctx_rectangle (ctx, x + cw/2, y - ch, cw/2, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x2599: // _QUADRANT UPPER LEFT AND LOWER LEFT AND LOWER RIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2598, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2596, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2597, red, green, blue);
        return 0;
      case 0x259A: // _QUADRANT UPPER LEFT AND LOWER RIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2598, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2597, red, green, blue);
        return 0;
      case 0x259B: // _QUADRANT UPPER LEFT AND UPPER RIGHT AND LOWER LEFT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2598, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x259D, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2596, red, green, blue);
        return 0;
      case 0x259C: // _QUADRANT UPPER LEFT AND UPPER RIGHT AND LOWER RIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2598, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x259D, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2597, red, green, blue);
        return 0;
      case 0x259E: // _QUADRANT UPPER RIGHT AND LOWER LEFT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x259D, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2596, red, green, blue);
        return 0;
      case 0x259F: // _QUADRANT UPPER RIGHT AND LOWER LEFT AND LOWER RIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x259D, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2596, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2597, red, green, blue);
        return 0;
      case 0x2588: // FULL_BLOCK:
        ctx_rectangle (ctx, x, y - ch, cw, ch);
        ctx_fill (ctx);
        return 0;
      case 0x2591: // LIGHT_SHADE:
        ctx_rectangle (ctx, x, y - ch, cw, ch);
        ctx_save (ctx);
        ctx_global_alpha (ctx, 0.25);
        ctx_fill (ctx);
        ctx_restore (ctx);
        return 0;
      case 0x2592: // MEDIUM_SHADE:
        ctx_rectangle (ctx, x, y - ch, cw, ch);
        ctx_save (ctx);
        ctx_global_alpha (ctx, 0.5);
        ctx_fill (ctx);
        ctx_restore (ctx);
        return 0;
      case 0x2593: // DARK SHADE:
        ctx_rectangle (ctx, x, y - ch, cw, ch);
        ctx_save (ctx);
        ctx_global_alpha (ctx, 0.75);
        ctx_fill (ctx);
        ctx_restore (ctx);
        return 0;
      case 0x2500: //VT_BOX_DRAWINGS_LIGHT_HORIZONTAL // and scanline 5
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2501: //VT_BOX_DRAWINGS_HEAVY_HORIZONTAL // and scanline 5
        lw *= 2;
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2502: // VT_BOX_DRAWINGS_LIGHT_VERTICAL:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch + 1);
        ctx_fill (ctx);
        return 0;
      case 0x2503: // VT_BOX_DRAWINGS_HEAVY_VERTICAL:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch + 1);
        ctx_fill (ctx);
        return 0;

      case 0x2504: // VT_BOX_DRAWINGS_LIGHT_TRIPLE_DASH_HORIZONTAL
        {
          float gap = cw * (1.0/6);
          for (int i = 0; i< 3; i++)
            ctx_rectangle (ctx, x + gap * i*2, y - ch/2 - lw / 2, gap, lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2505: // VT_BOX_DRAWINGS_HEAVY_TRIPLE_DASH_HORIZONTAL
        {
          float gap = cw * (1.0/6);
          lw *= 2;
          for (int i = 0; i< 3; i++)
            ctx_rectangle (ctx, x + gap * i*2, y - ch/2 - lw / 2, gap, lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2506: // VT_BOX_DRAWINGS_LIGHT_TRIPLE_DASH_VERTICAL
        {
          float gap = ch * (1.0/6);
          for (int i = 0; i< 3; i++)
            ctx_rectangle (ctx, x + cw/2 - lw /2, y - ch + gap * i*2, lw, gap);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2507: // VT_BOX_DRAWINGS_HEAVY_TRIPLE_DASH_VERTICAL
        {
          lw *=2;
          float gap = ch * (1.0/6);
          for (int i = 0; i< 3; i++)
            ctx_rectangle (ctx, x + cw/2 - lw /2, y - ch + gap * i*2, lw, gap);
          ctx_fill (ctx);
        }
        return 0;


      case 0x2508: // VT_BOX_DRAWINGS_LIGHT_QUADRUPLE_DASH_HORIZONTAL
        {
          float gap = cw * (1.0/8);
          for (int i = 0; i< 4; i++)
            ctx_rectangle (ctx, x + gap * i*2, y - ch/2 - lw / 2, gap, lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2509: // VT_BOX_DRAWINGS_HEAVY_QUADRUPLE_DASH_HORIZONTAL
        {
          float gap = cw * (1.0/8);
          lw *= 2;
          for (int i = 0; i< 4; i++)
            ctx_rectangle (ctx, x + gap * i*2, y - ch/2 - lw / 2, gap, lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x250A: // VT_BOX_DRAWINGS_LIGHT_QUADRUPLE_DASH_VERTICAL
        {
          float gap = ch * (1.0/8);
          for (int i = 0; i< 4; i++)
            ctx_rectangle (ctx, x + cw/2 - lw /2, y - ch + gap * i*2, lw, gap);
          ctx_fill (ctx);
        }
        return 0;
      case 0x250B: // VT_BOX_DRAWINGS_HEAVY_QUADRUPLE_DASH_VERTICAL
        {
          lw *=2;
          float gap = ch * (1.0/8);
          for (int i = 0; i< 4; i++)
            ctx_rectangle (ctx, x + cw/2 - lw /2, y - ch + gap * i*2, lw, gap);
          ctx_fill (ctx);
        }
        return 0;

      case 0x250c: //VT_BOX_DRAWINGS_LIGHT_DOWN_AND_RIGHT:
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, lw, ch/2 + lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, cw/2+ lw, lw);
        ctx_fill (ctx);
        return 0;

      case 0x250d: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_RIGHT_HEAVY:
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, lw, ch/2 + lw);
        ctx_fill (ctx);
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/4, y - ch/2 - lw/2, cw/2+ lw/2, lw);
        ctx_fill (ctx);
        return 0;

      case 0x250e: //VT_BOX_DRAWINGS_DOWN_HEAVY_AND_RIGHT_LIGHT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/4, lw, ch/2 + lw/2);
        ctx_fill (ctx);
        lw /= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/4, y - ch/2 - lw/2, cw/2+ lw/2, lw);
        ctx_fill (ctx);
        return 0;

      case 0x250f: //VT_BOX_DRAWINGS_HEAVY_DOWN_AND_RIGHT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, lw, ch/2 + lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, cw/2+ lw, lw);
        ctx_fill (ctx);
        return 0;

      case 0x2510: //VT_BOX_DRAWINGS_LIGHT_DOWN_AND_LEFT:
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, lw, ch/2 + lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2 - lw/2, cw/2+  lw/2, lw);
        ctx_fill (ctx);
        return 0;

      case 0x2511: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_LEFT_HEAVY:
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, lw, ch/2 + lw);
        ctx_fill (ctx);
        lw *= 2;
        ctx_rectangle (ctx, x, y - ch/2 - lw/2, cw/2+  lw/4, lw);
        ctx_fill (ctx);
        return 0;

      case 0x2512: //VT_BOX_DRAWINGS_DOWN_HEAVY_AND_LEFT_LIGHT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/4, lw, ch/2 + lw);
        ctx_fill (ctx);
        lw /= 2;
        ctx_rectangle (ctx, x, y - ch/2 - lw/2, cw/2+  lw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2513: //VT_BOX_DRAWINGS_HEAVY_DOWN_AND_LEFT:
        lw *=2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, lw, ch/2 + lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2 - lw/2, cw/2+  lw/2, lw);
        ctx_fill (ctx);
        return 0;

      case 0x2514: //VT_BOX_DRAWINGS_LIGHT_UP_AND_RIGHT:
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch, lw, ch/2+ lw/2);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, cw/2 + lw, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2515: //VT_BOX_DRAWINGS_UP_LIGHT_AND_RIGHT_HEAVY:
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch, lw, ch/2+ lw/2);
        ctx_fill (ctx);
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/4, y - ch/2 - lw/2, cw/2 + lw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2516: //VT_BOX_DRAWINGS_UP_HEAVY_AND_RIGHT_LIGHT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch, lw, ch/2+ lw/4);
        ctx_fill (ctx);
        lw /= 2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, cw/2 + lw, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2517: //VT_BOX_DRAWINGS_HEAVY_UP_AND_RIGHT:
        lw *=2;
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch, lw, ch/2+ lw/2);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 - lw/2, cw/2 + lw, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2518: //VT_BOX_DRAWINGS_LIGHT_UP_AND_LEFT:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch/2+ lw/2);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2- lw/2, cw/2+ lw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2519: //VT_BOX_DRAWINGS_UP_LIGHT_AND_LEFT_HEAVY:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch/2+ lw/2);
        ctx_fill (ctx);
        lw *=2;
        ctx_rectangle (ctx, x, y - ch/2- lw/2, cw/2+ lw/4, lw);
        ctx_fill (ctx);
        return 0;
      case 0x251A: //VT_BOX_DRAWINGS_UP_HEAVY_AND_LEFT_LIGHT:
        lw *=2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch/2+ lw/4);
        ctx_fill (ctx);
        lw /=2;
        ctx_rectangle (ctx, x, y - ch/2- lw/2, cw/2+ lw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x251B: //VT_BOX_DRAWINGS_HEAVY_UP_AND_LEFT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch/2+ lw/2);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2- lw/2, cw/2+ lw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x251C: //VT_BOX_DRAWINGS_LIGHT_VERTICAL_AND_RIGHT:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch/2- lw/2, cw/2+lw, lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch);
        ctx_fill (ctx);
        return 0;

      case 0x251D: //VT_BOX_DRAWINGS_VERTICAL_LIGHT_AND_RIGHT_HEAVY:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2502, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257A, red, green, blue);
        return 0;
      case 0x251E: //VT_BOX_DRAWINGS_VERTICAL_UP_HEAVY_AND RIGHT DOWN LIGHT:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250C, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2579, red, green, blue);
        return 0;
      case 0x251F: //VT_BOX_DRAWINGS_DOWN_HEAVY_AND_RIGHT_UP_LIGHT:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2514, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257B, red, green, blue);
        return 0;
      case 0x2520: //VT_BOX_DRAWINGS_VRTICAL_HEAVY_AND_RIGHT_LIGHT:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2503, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2576, red, green, blue);
        return 0;
      case 0x2521: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_RIGHT_UP_HEAVY:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2517, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2577, red, green, blue);
        return 0;
      case 0x2522: //VT_BOX_DRAWINGS_UP_LIGHT_AND_RIGHT_DOWN_HEAVY:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250F, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2575, red, green, blue);
        return 0;
      case 0x2523: //VT_BOX_DRAWINGS_HEAVY_VERTICAL_AND_RIGHT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch/2- lw/2, cw/2+lw, lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch);
        ctx_fill (ctx);
        return 0;
      case 0x2524: //VT_BOX_DRAWINGS_LIGHT_VERTICAL_AND_LEFT:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2-lw/2, cw/2+lw/2, lw);
        ctx_fill (ctx);
        return 0;

      case 0x2525: //VT_BOX_DRAWINGS_VERTICAL_LIGHT_AND_LEFT_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250F, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2574, red, green, blue);
        return 0;

      case 0x2526: //VT_BOX_DRAWINGS_UP_HEAVY_AND_LEFT_DOWN_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2510, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2579, red, green, blue);
        return 0;

      case 0x2527: //VT_BOX_DRAWINGS_DOWN_HEAVY_AND_LEFT_UP_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2518, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257b, red, green, blue);
        return 0;

      case 0x2528: //VT_BOX_DRAWINGS_VERTICAL_HEAVY_AND_LEFT_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2503, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2574, red, green, blue);
        return 0;

      case 0x2529: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_LEFT_UP_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x251B, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2577, red, green, blue);
        return 0;

      case 0x252A: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_LEFT_UP_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2513, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2575, red, green, blue);
        return 0;

      case 0x252B: //VT_BOX_DRAWINGS_HEAVY_VERTICAL_AND_LEFT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2-lw/2, cw/2+lw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x252C: // VT_BOX_DRAWINGS_LIGHT_DOWN_AND_HORIZONTAL:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch/2-lw/2, lw, ch/2+lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        return 0;

      case 0x252D: //VT_BOX_DRAWINGS_LEFT_HEAVY_AND_RIGHT_DOWN_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250C, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2578, red, green, blue);
        return 0;
      case 0x252E: //VT_BOX_DRAWINGS_RIGHT_HEAVY_AND_LEFT_DOWN_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2510, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257A, red, green, blue);
        return 0;
      case 0x252F: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_HORIZONTAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2501, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2577, red, green, blue);
        return 0;
      case 0x2530: //VT_BOX_DRAWINGS_DOWN_HEAVY_AND_HORIZONTAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2500, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257B, red, green, blue);
        return 0;
      case 0x2531: //VT_BOX_DRAWINGS_RIGHT_LIGHT_AND_LEFT_DOWN_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2513, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2576, red, green, blue);
        return 0;
      case 0x2532: //VT_BOX_DRAWINGS_LEFT_LIGHT_AND_RIGHT_DOWN_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250f, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2574, red, green, blue);
        return 0;


      case 0x2533: // VT_BOX_DRAWINGS_HEAVY_DOWN_AND_HORIZONTAL:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch/2-lw/2, lw, ch/2+lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2534: // VT_BOX_DRAWINGS_LIGHT_UP_AND_HORIZONTAL:
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch /2+lw/2);
        ctx_fill (ctx);
        return 0;

      case 0x2535: //VT_BOX_DRAWINGS_LEFT_HEAVY_AND_RIGHT_UP_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2514, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2578, red, green, blue);
        return 0;
      case 0x2536: //VT_BOX_DRAWINGS_RIGHT_HEAVY_AND_LEFT_UP_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2518, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257A, red, green, blue);
        return 0;
      case 0x2537: //VT_BOX_DRAWINGS_UP_LIGHT_AND_HORIZONYAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2501, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2575, red, green, blue);
        return 0;
      case 0x2538: //VT_BOX_DRAWINGS_UP_HEAVY_AND_HORIZONYAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2500, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2579, red, green, blue);
        return 0;
      case 0x2539: //VT_BOX_DRAWINGS_RIGHT_LIGHT_AND_LEFT_UP_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x251B, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2576, red, green, blue);
        return 0;
      case 0x253A: //VT_BOX_DRAWINGS_LEFT_LIGHT_AND_RIGHT_UP_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2517, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2574, red, green, blue);
        return 0;
      case 0x253B: // VT_BOX_DRAWINGS_HEAVY_UP_AND_HORIZONTAL:
        lw *= 2;
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch /2+lw/2);
        ctx_fill (ctx);
        return 0;
      case 0x253C: // VT_BOX_DRAWINGS_LIGHT_VERTICAL_AND_HORIZONTAL:
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch);
        ctx_fill (ctx);
        return 0;
      case 0x253D: //VT_BOX_DRAWINGS_LEFT_HEAVY_AND_RIGHT_VERTICAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x251c, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2578, red, green, blue);
        return 0;
      case 0x253E: //VT_BOX_DRAWINGS_RIGHT_HEAVY_AND_LEFT_VERTICAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2524, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257A, red, green, blue);
        return 0;
      case 0x253F: //VT_BOX_DRAWINGS_VERTICAL_LIGHT_AND_HORIZONTAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2502, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2501, red, green, blue);
        return 0;
      case 0x2540: //VT_BOX_DRAWINGS_UP_HEAVT_AND_DOWN_HORIZONTAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x252c, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2579, red, green, blue);
        return 0;
      case 0x2541: //VT_BOX_DRAWINGS_DOWN_HEAVY_AND_UP_HORIZONTAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2534, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257B, red, green, blue);
        return 0;
      case 0x2542: //VT_BOX_DRAWINGS_VERTICAL_HEAVY_AND_HORIZONTAL_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2503, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2500, red, green, blue);
        return 0;
      case 0x2543: //VT_BOX_DRAWINGS_LEFT_UP_HEAVY_AND_RIGHT_DOWN_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x251B, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250c, red, green, blue);
        return 0;
      case 0x2544: //VT_BOX_DRAWINGS_RIGHT_UP_HEAVY_AND_LEFT_DOWN_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2517, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2510, red, green, blue);
        return 0;
      case 0x2545: //VT_BOX_DRAWINGS_LEFT_DOWN_HEAVY_AND_RIGHT_UP_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2513, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2514, red, green, blue);
        return 0;
      case 0x2546: //VT_BOX_DRAWINGS_RIGHT_DOWN_HEAVY_AND_LEFT_UP_LIGHT
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x250f, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2518, red, green, blue);
        return 0;
      case 0x2547: //VT_BOX_DRAWINGS_DOWN_LIGHT_AND_UP_HORIZONTAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x253B, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2577, red, green, blue);
        return 0;
      case 0x2548: //VT_BOX_DRAWINGS_UP_LIGHT_AND_DOWN_HORIZONTAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2533, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2575, red, green, blue);
        return 0;
      case 0x2549: //VT_BOX_DRAWINGS_RIGHT_LIGHT_AND_LEFT_VERTICAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x252B, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2576, red, green, blue);
        return 0;
      case 0x254A: //VT_BOX_DRAWINGS_LEFT_LIGHT_AND_RIGHT_VERTICAL_HEAVY
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2523, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2574, red, green, blue);
        return 0;
      case 0x254B: // VT_BOX_DRAWINGS_HEAVY_VERTICAL_AND_HORIZONTAL:
        lw *=2;
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw, lw);
        ctx_fill (ctx);
        ctx_fill (ctx);
        return 0;

      case 0x254c: // VT_BOX_DRAWINGS_LIGHT_DOUBLE_DASH_HORIZONTAL
        {
          float gap = cw * (1.0/4);
          for (int i = 0; i< 2; i++)
            ctx_rectangle (ctx, x + gap * i*2, y - ch/2 - lw / 2, gap, lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x254d: // VT_BOX_DRAWINGS_HEAVY_DOUBLE_DASH_HORIZONTAL
        {
          float gap = cw * (1.0/4);
          lw *= 2;
          for (int i = 0; i< 2; i++)
            ctx_rectangle (ctx, x + gap * i*2, y - ch/2 - lw / 2, gap, lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x254e: // VT_BOX_DRAWINGS_LIGHT_DOUBLE_DASH_VERTICAL
        {
          float gap = ch * (1.0/4);
          for (int i = 0; i< 2; i++)
            ctx_rectangle (ctx, x + cw/2 - lw /2, y - ch + gap * i*2, lw, gap);
          ctx_fill (ctx);
        }
        return 0;
      case 0x254f: // VT_BOX_DRAWINGS_HEAVY_DOUBLE_DASH_VERTICAL
        {
          lw *=2;
          float gap = ch * (1.0/4);
          for (int i = 0; i< 2; i++)
            ctx_rectangle (ctx, x + cw/2 - lw /2, y - ch + gap * i*2, lw, gap);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2550: //VT_BOX_DRAWING_DOUBLE_HORIZONTAL
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw, lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2551: //VT_BOX_DRAWING_DOUBLE_VERTICAL
        {
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2552: //VT_BOX_DRAWING_DOWN_SINGLE_AND_RIGHT_DOUBLE
        {
          ctx_rectangle (ctx, x+cw/2, y - ch/2 - lw * 1.5, cw/2, lw);
          ctx_rectangle (ctx, x+cw/2, y - ch/2 + lw/2, cw/2, lw);
          ctx_rectangle (ctx, x+cw/2-lw/2, y - ch/2 - lw * 1.5, lw, ch/2 + lw * 1.5);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2553: //VT_BOX_DRAWING_DOWN_DOUBLE_AND_RIGHT_SINGLE
        {
          ctx_rectangle (ctx, x+cw/2 - lw * 1.5, y - ch/2 - lw/2, cw/2 + lw * 1.5, lw);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch/2, lw, ch/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch/2, lw, ch/2);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2554: //VT_BOX_DRAWING_DOUBLE_DOWN_AND_RIGHT
        {
          ctx_rectangle (ctx, x+cw/2 - lw * 1.5, y - ch/2 - lw * 1.5, cw/2 + lw * 1.55, lw);
          ctx_rectangle (ctx, x+cw/2 + lw/2, y - ch/2 + lw /2, cw/2 - lw/2, lw);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch/2 - lw * 1.5, lw, ch/2 + lw * 1.5);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch/2 + lw, lw, ch/2-lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2555: //VT_BOX_DRAWING_DOWN_SINGLE_AND_LEFT_DOUBLE
        {
          ctx_rectangle (ctx, x+cw/2-lw/2, y - ch/2 - lw * 1.5, lw, ch/2 + lw * 1.5);
          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw/2, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw/2, lw);

          ctx_fill (ctx);
        }
        return 0;

      case 0x2556: //VT_BOX_DRAWING_DOWN_DOUBLE_AND_LEFT_SINGLE
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw/2, cw/2 + lw * 1.5, lw);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch/2, lw, ch/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch/2, lw, ch/2);

          ctx_fill (ctx);
        }
        return 0;
      case 0x2557: //VT_BOX_DRAWING_DOUBLE_DOWN_AND_LEFT
        {

          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw/2 + lw * 1.55, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw /2, cw/2 - lw/2, lw);

          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch/2 + lw/2, lw, ch/2-lw/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch/2 - lw * 1.5, lw, ch/2 + lw * 1.5);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2558: //VT_BOX_DRAWING_UP_SINGLE_AND_RIGHT_DOUBLE
        {
          ctx_rectangle (ctx, x+cw/2, y - ch/2 - lw * 1.5, cw/2, lw);
          ctx_rectangle (ctx, x+cw/2, y - ch/2 + lw/2, cw/2, lw);

          ctx_rectangle (ctx, x+cw/2-lw/2, y-ch, lw, ch/2 + lw * 1.5);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2559: //VT_BOX_DRAWING_UP_DOUBLE_AND_RIGHT_SINGLE
        {
          ctx_rectangle (ctx, x+cw/2 - lw * 1.5, y - ch/2 - lw/2, cw/2 + lw * 1.5, lw);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch/2);
          ctx_fill (ctx);
        }
        return 0;
      case 0x255A: //VT_BOX_DRAWING_DOUBLE_UP_AND_RIGHT
        {
          ctx_rectangle (ctx, x+cw/2 - lw * 1.5, y - ch/2+lw/2, 
                                            cw/2 + lw * 1.55, lw);
          ctx_rectangle (ctx, x+cw/2 + lw/2,    y - ch/2-1.5*lw,  
                                         cw/2 - lw/2, lw);

          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2 + lw * 1.5);
          ctx_rectangle (ctx, x + cw/2 + lw / 2,   y-ch, lw, ch/2-lw);
          ctx_fill (ctx);
        }
        return 0;
      case 0x255B: //VT_BOX_DRAWING_UP_SINGLE_AND_LEFT_DOUBLE
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw/2, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw/2, lw);

          ctx_rectangle (ctx, x+cw/2-lw/2, y-ch, lw, ch/2 + lw * 1.5);
          ctx_fill (ctx);
        }
        return 0;
      case 0x255C: //VT_BOX_DRAWING_UP_DOUBLE_AND_LEFT_SINGLE
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw/2, cw/2 + lw * 1.5, lw);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch/2);
          ctx_fill (ctx);
        }
        return 0;

      case 0x255D: //VT_BOX_DRAWING_DOUBLE_UP_AND_LEFT
        {
          ctx_rectangle (ctx, x, y - ch/2+lw/2, cw/2 + lw * 1.55, lw);
          ctx_rectangle (ctx, x, y - ch/2-1.5*lw, cw/2 - lw/2, lw);

          ctx_rectangle (ctx, x + cw/2 + lw /2, y-ch, lw, ch/2 + lw * 1.5);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2-lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x255E: //VT_BOX_DRAWING_VERTICAL_SINGLE_AND_RIGHT_DOUBLE
        {

          ctx_rectangle (ctx, x+cw/2, y - ch/2 - lw * 1.5, cw/2, lw);
          ctx_rectangle (ctx, x+cw/2, y - ch/2 + lw/2, cw/2, lw);

          ctx_rectangle (ctx, x+cw/2-lw/2, y-ch,   lw, ch);

          ctx_fill (ctx);
        }
        return 0;

      case 0x255f: //VT_BOX_DRAWING_VERTICAL_DOUBLE_AND_RIGHT_SINGLE
        {

          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch/2-lw/2, cw/2-lw/2, lw);

          ctx_fill (ctx);
        }
        return 0;

      case 0x2560: //VT_BOX_DRAWING_DOUBLE_VERTICAL_AND_RIGHT
        {
          ctx_rectangle (ctx, x+cw/2 + lw/2, y - ch/2-1.5*lw,  
                                         cw/2 - lw/2, lw);
          ctx_rectangle (ctx, x+cw/2 + lw/2, y - ch/2+lw/2, 
                                         cw/2 - lw/2, lw);


          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 + lw / 2,   y-ch, lw, ch/2-lw);
          ctx_rectangle (ctx, x + cw/2 + lw / 2,   y-ch/2+lw/2, lw, ch/2-lw/2);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2561: //VT_BOX_DRAWING_VERTICAL_SINGLE_AND_LEFT_DOUBLE
        {

          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw/2, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw/2, lw);

          ctx_rectangle (ctx, x+cw/2-lw/2, y-ch,   lw, ch);

          ctx_fill (ctx);
        }
        return 0;

      case 0x2562: //VT_BOX_DRAWING_VERTICAL_DOUBLE_AND_LEFT_SINGLE
        {

          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch);
          ctx_rectangle (ctx, x, y-ch/2-lw/2, cw/2-lw/2, lw);

          ctx_fill (ctx);
        }
        return 0;

      case 0x2563: //VT_BOX_DRAWING_DOUBLE_VERTICAL_AND_LEFT
        {
          ctx_rectangle (ctx, x, y - ch/2-1.5*lw,  
                                         cw/2 - lw/2, lw);
          ctx_rectangle (ctx, x, y - ch/2+lw/2, 
                                         cw/2 - lw/2, lw);


          ctx_rectangle (ctx, x + cw/2 + lw / 2, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5,   y-ch, lw, ch/2-lw);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5,   y-ch/2+lw/2, lw, ch/2-lw/2);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2564: //VT_BOX_DRAWING_DOWN_SINGLE_AND_HORIZONTAL_DOUBLE
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw, lw);
          ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch/2 + lw, lw, ch/2 - lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2565: //VT_BOX_DRAWING_DOWN_DOUBLE_AND_HORIZONTAL_SINGLE
        {
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch/2, lw, ch/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch/2, lw, ch/2);
          ctx_rectangle (ctx, x, y-ch/2-lw/2, cw, lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2566: //VT_BOX_DRAWING_DOUBLE_DOWN_AND_HORIZONTAL
        {
          ctx_rectangle (ctx, x, y - ch/2-1.5*lw,  cw, lw);
          ctx_rectangle (ctx, x, y - ch/2+lw/2,   cw/2 - lw/2, lw);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y - ch/2+lw/2,   cw/2 - lw/2, lw);


          ctx_rectangle (ctx, x + cw/2 + lw / 2, y-ch/2+lw/2, lw, ch/2-lw/2);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5,   y-ch/2+lw/2, lw, ch/2-lw/2);
          ctx_fill (ctx);
        }
        return 0;
      case 0x2567: //VT_BOX_DRAWING_UP_SINGLE_AND_HORIZONTAL_DOUBLE
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw, lw);
          ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch, lw, ch/2 - lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2568: //VT_BOX_DRAWING_UP_DOUBLE_AND_HORIZONTAL_SINGLE
        {
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch/2);
          ctx_rectangle (ctx, x, y-ch/2-lw/2, cw, lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x2569: //VT_BOX_DRAWING_DOUBLE_UP_AND_HORIZONTAL
        {
          ctx_rectangle (ctx, x, y - ch/2+lw/2,  cw, lw);
          ctx_rectangle (ctx, x,               y - ch/2-lw*1.5,   cw/2 - lw/2, lw);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y - ch/2-lw*1.5,   cw/2 - lw/2, lw);

          ctx_rectangle (ctx, x + cw/2 + lw / 2, y-ch, lw, ch/2-lw/2);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2-lw/2);
          ctx_fill (ctx);
        }
        return 0;

      case 0x256A: //VT_BOX_DRAWING_VERTICAL_SINGLE_AND_HORIZONTAL_DOUBLE
        {
          ctx_rectangle (ctx, x, y - ch/2 - lw * 1.5, cw, lw);
          ctx_rectangle (ctx, x, y - ch/2 + lw/2, cw, lw);
          ctx_rectangle (ctx, x + cw/2 - lw/2, y - ch, lw, ch);
          ctx_fill (ctx);
        }
        return 0;

      case 0x256B: //VT_BOX_DRAWING_VERTICAL_DOUBLE_AND_HORIZONTAL_SINGLE
        {
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y-ch, lw, ch);
          ctx_rectangle (ctx, x, y-ch/2-lw/2, cw, lw);
          ctx_fill (ctx);
        }
        return 0;

      case 0x256C: //VT_BOX_DRAWING_DOUBLE_VERTICAL_AND_HORIZONTAL
        {
          ctx_rectangle (ctx, x, y - ch/2+lw/2, cw/2-lw/2, lw);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y - ch/2+lw/2, cw/2-lw/2, lw);

          ctx_rectangle (ctx, x,               y - ch/2-lw*1.5,   cw/2 - lw/2, lw);
          ctx_rectangle (ctx, x + cw/2 + lw/2, y - ch/2-lw*1.5,   cw/2 - lw/2, lw);

          ctx_rectangle (ctx, x + cw/2 + lw / 2, y-ch, lw, ch/2-lw/2);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch, lw, ch/2-lw/2);

          ctx_rectangle (ctx, x + cw/2 + lw / 2, y-ch/2+lw/2, lw, ch/2-lw/2);
          ctx_rectangle (ctx, x + cw/2 - lw * 1.5, y-ch/2+lw/2, lw, ch/2-lw/2);

          ctx_fill (ctx);
        }
        return 0;

      case 0x256d: //VT_BOX_DRAWINGS_LIGHT_ARC_DOWN_AND_RIGHT:
      {
        float rad = 0.25f * ch;
        ctx_move_to (ctx, x + cw * 0.5f, y);

        ctx_arc (ctx, x + cw * 0.5f + rad,
                      y - ch * 0.5f + rad, rad, 0.0 + M_PI, M_PI+M_PI/2, 0);

        ctx_line_to (ctx, x + cw * 1.0f, y - ch * 0.5f);
        ctx_line_width (ctx, lw);
        ctx_stroke (ctx);
      }
        return 0;

      case 0x256e: //VT_BOX_DRAWINGS_LIGHT_ARC_DOWN_AND_LEFT:
      {
        float rad = 0.25f * ch;
        ctx_move_to (ctx, x + cw * 0.0f, y - ch * 0.5f);

        ctx_arc (ctx, x + cw * 0.5f - rad,
                      y - ch * 0.5f + rad, rad, 0.0 + M_PI + M_PI/2, M_PI+M_PI, 0);
        ctx_line_to (ctx, x + cw * 0.5f, y);

        ctx_line_width (ctx, lw);
        ctx_stroke (ctx);
      }
        return 0;



      case 0x256f: //VT_BOX_DRAWINGS_LIGHT_ARC_UP_AND_LEFT:
      {
        float rad = 0.25f * ch;
        ctx_move_to (ctx, x + cw * 0.5f, y - ch * 1.0f);

        ctx_arc (ctx, x + cw * 0.5f - rad,
                      y - ch * 0.5f - rad, rad, 0.0, M_PI/2, 0);
        ctx_line_to (ctx, x + cw * 0.0f, y - ch * 0.5f);

        ctx_line_width (ctx, lw);
        ctx_stroke (ctx);
      }
        return 0;

      case 0x2570: //VT_BOX_DRAWINGS_LIGHT_ARC_UP_AND_RIGHT:
      {
        float rad = 0.25f * ch;

        ctx_move_to (ctx, x + cw * 1.0f, y - ch * 0.5f);
        ctx_arc (ctx, x + cw * 0.5f + rad,
                      y - ch * 0.5f - rad, rad, M_PI/2, M_PI, 0);

        ctx_line_to (ctx, x + cw * 0.5f, y - ch * 1.0f);

        ctx_line_width (ctx, lw);
        ctx_stroke (ctx);
      }
        return 0;

      case 0x2571:
        ctx_line_width (ctx, lw);
        ctx_move_to (ctx, x, y);
        ctx_line_to (ctx, x + cw, y-ch);
        ctx_stroke (ctx);
        return 0;
      case 0x2572:
        ctx_line_width (ctx, lw);
        ctx_move_to (ctx, x, y - ch);
        ctx_line_to (ctx, x + cw, y);
        ctx_stroke (ctx);
        return 0;
      case 0x2573:
        ctx_line_width (ctx, lw);
        ctx_move_to (ctx, x, y - ch);
        ctx_line_to (ctx, x + cw, y);
        ctx_move_to (ctx, x, y);
        ctx_line_to (ctx, x + cw, y-ch);
        ctx_stroke (ctx);
        return 0;

      case 0x2574: // VT_BOX_DRAWINGS_LIGHT_LEFT:
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2575: // VT_BOX_DRAWINGS_LIGHT_UP:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x2576: // VT_BOX_DRAWINGS_LIGHT_RIGHT:
        ctx_rectangle (ctx, x + cw/2, y - ch/2 - lw / 2, cw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2577: // VT_BOX_DRAWINGS_LIGHT_DOWN:
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch/2, lw, ch/2);
        ctx_fill (ctx);
        return 0;

      case 0x2578: // VT_BOX_DRAWINGS_HEAVY_LEFT:
        lw *= 2;
        ctx_rectangle (ctx, x, y - ch/2 - lw / 2, cw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x2579: // VT_BOX_DRAWINGS_HEAVY_UP:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch, lw, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x257A: // VT_BOX_DRAWINGS_HEAVY_RIGHT:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2, y - ch/2 - lw / 2, cw/2, lw);
        ctx_fill (ctx);
        return 0;
      case 0x257B: // VT_BOX_DRAWINGS_HEAVY_DOWN:
        lw *= 2;
        ctx_rectangle (ctx, x + cw/2 - lw / 2, y - ch/2, lw, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x257C: // VT_BOX_DRAWINGS_LIGHT_LEFT_AND_HEAVY_RIGHT:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2574, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257A, red, green, blue);
        return 0;
      case 0x257D: // VT_BOX_DRAWINGS_LIGHT_UP_AND_HEAVY_DOWN:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2575, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x257B, red, green, blue);
        return 0;
      case 0x257E: // VT_BOX_DRAWINGS_HEAVY_LEFT_AND_LIGHT_RIGHT:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2578, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2576, red, green, blue);
        return 0;
      case 0x257F: // VT_BOX_DRAWINGS_HEAVY_UP_AND_LIGHT_DOWN:
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2579, red, green, blue);
        vt_special_glyph (ctx, vt, x, y, cw, ch, 0x2577, red, green, blue);
        return 0;


      case 0x25E2: // VT_BLACK_LOWER_RIGHT_TRIANGLE:
        ctx_move_to (ctx, x, y);
        ctx_rel_line_to (ctx, cw, -ch);
        ctx_rel_line_to (ctx, 0, ch);
        ctx_fill (ctx);
        return 0;
      case 0x25E3: //  VT_BLACK_LOWER_LEFT_TRIANGLE:
        ctx_move_to (ctx, x, y);
        ctx_rel_line_to (ctx, 0, -ch);
        ctx_rel_line_to (ctx, cw, ch);
        ctx_fill (ctx);
        return 0;
      case 0x25E4: // tri
        ctx_move_to (ctx, x, y);
        ctx_rel_line_to (ctx, 0, -ch);
        ctx_rel_line_to (ctx, cw, 0);
        ctx_fill (ctx);
        return 0;
      case 0x25E5: // tri
        ctx_move_to (ctx, x, y - ch);
        ctx_rel_line_to (ctx, cw, 0);
        ctx_rel_line_to (ctx, 0, ch);
        ctx_fill (ctx);
        return 0;
        }
        }
        break;
      default:
      switch (unichar)
      {
      case 0x1fb8f: // VT_RIGHT_SEVEN_EIGHTS_BLOCK:
        SETUP;
        ctx_rectangle (ctx, x + cw*1/8, y - ch, cw*7/8, ch);
        ctx_fill (ctx);
        return 0;
      case 0x1fb8d: // VT_RIGHT_FIVE_EIGHTS_BLOCK:
        SETUP;
        ctx_rectangle (ctx, x + cw*3/8, y - ch, cw*5/8, ch);
        ctx_fill (ctx);
        return 0;
      case 0x1fb8b: // VT_RIGHT_ONE_QUARTER_BLOCK:
        SETUP;
        ctx_rectangle (ctx, x + cw*3/4, y - ch, cw/4, ch);
        ctx_fill (ctx);
        return 0;
      case 0x1fb8e: // VT_RIGHT_THREE_QUARTER_BLOCK:
        SETUP;
        ctx_rectangle (ctx, x + cw*1/4, y - ch, cw*3/4, ch);
        ctx_fill (ctx);
        return 0;
      case 0x23BA: //HORIZONTAL_SCANLINE-1
        SETUP;
        ctx_rectangle (ctx, x,      y - ch + ch*0.1 - ch * 0.1,
                       cw, ch * 0.1);
        ctx_fill (ctx);
        return 0;
      case 0x23BB: //HORIZONTAL_SCANLINE-3
        SETUP;
        ctx_rectangle (ctx, x,      y - ch + ch*0.3 - ch * 0.075,
                       cw, ch * 0.1);
        ctx_fill (ctx);
        return 0;
      case 0x23BC: //HORIZONTAL_SCANLINE-7
        SETUP;
        ctx_rectangle (ctx, x,      y - ch + ch*0.7 - ch * 0.025,
                       cw, ch * 0.1);
        ctx_fill (ctx);
        return 0;
      case 0x23BD: //HORIZONTAL_SCANLINE-9
        SETUP;
        ctx_rectangle (ctx, x,      y - ch + ch*0.9 + ch * 0.0,
                       cw, ch * 0.1);
        ctx_fill (ctx);
        return 0;


      case 0x2212: // minus -sign
        SETUP;
        ctx_rectangle (ctx, x + cw * 0.1, y - ch/2 - ch * 0.1 / 2, cw * 0.8, ch * 0.1);
        ctx_fill (ctx);
        return 0;

      case 0xe0a0: // PowerLine branch
        ctx_save (ctx);
        SETUP;
        ctx_move_to (ctx, x+cw/2, y - 0.15 * ch);
        ctx_rel_line_to (ctx, -cw/3, -ch * 0.7);
        ctx_rel_line_to (ctx, cw/2, 0);
        ctx_rel_line_to (ctx, -cw/3, ch * 0.7);
        ctx_line_width (ctx, cw * 0.25);
        ctx_stroke (ctx);
        ctx_restore (ctx);
        break;
      // case 0xe0a1: // PowerLine LN
      // case 0xe0a2: // PowerLine Lock
      case 0xe0b0: // PowerLine left solid
        SETUP;
        ctx_move_to (ctx, x, y);
        ctx_rel_line_to (ctx, 0, -ch);
        ctx_rel_line_to (ctx, cw, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0xe0b1: // PowerLine left line
        ctx_save (ctx);
        SETUP;
        ctx_move_to (ctx, x, y - ch * 0.1);
        ctx_rel_line_to (ctx, cw * 0.9, -ch/2 * 0.8);
        ctx_rel_line_to (ctx, -cw * 0.9, -ch/2 * 0.8);
        ctx_line_width (ctx, cw * 0.2);
        ctx_stroke (ctx);
        ctx_restore (ctx);
        return 0;
      case 0xe0b2: // PowerLine Right solid
        SETUP;
        ctx_move_to (ctx, x, y);
        ctx_rel_move_to (ctx, cw, 0);
        ctx_rel_line_to (ctx, -cw, -ch/2);
        ctx_rel_line_to (ctx, cw, -ch/2);
        ctx_fill (ctx);
        return 0;
      case 0xe0b3: // PowerLine right line
        ctx_save (ctx);
        SETUP;
        ctx_move_to (ctx, x, y - ch * 0.1);
        ctx_rel_move_to (ctx, cw, 0);
        ctx_rel_line_to (ctx, -cw * 0.9, -ch/2 * 0.8);
        ctx_rel_line_to (ctx,  cw * 0.9, ch/2 * 0.8);
        ctx_line_width (ctx, cw * 0.2);
        ctx_stroke (ctx);
        ctx_restore (ctx);
        return 0;
        /*
      case 0x1fb70: // left triangular one quarter block
        SETUP;
        ctx_move_to (ctx, x, y);
        ctx_rel_line_to (ctx, 0, -ch);
        ctx_rel_line_to (ctx, cw/2, -ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x1fb72: // right triangular one quarter block
        SETUP;
        ctx_move_to (ctx, x, y);
        ctx_rel_move_to (ctx, cw/2, -ch/2);
        ctx_rel_line_to (ctx, cw/2, -ch/2);
        ctx_rel_line_to (ctx, 0, ch);
        ctx_fill (ctx);
        return 0;
      case 0x1fb73: // lower triangular one quarter block
        SETUP;
        ctx_move_to (ctx, x, y);
        ctx_rel_line_to (ctx, cw/2, -ch/2);
        ctx_rel_line_to (ctx, cw/2, ch/2);
        ctx_fill (ctx);
        return 0;
      case 0x1fb71: // upper triangular one quarter block
        SETUP;
        ctx_move_to (ctx, x, y);
        ctx_rel_move_to (ctx, cw/2, -ch/2);
        ctx_rel_line_to (ctx, -cw/2, -ch/2);
        ctx_rel_line_to (ctx, cw, 0);
        ctx_fill (ctx);
        return 0;
        */
      case 0x2800:
      case 0x2801:
      case 0x2802:
      case 0x2803:
      case 0x2804:
      case 0x2805:
      case 0x2806:
      case 0x2807:
      case 0x2808:
      case 0x2809:
      case 0x280A:
      case 0x280B:
      case 0x280C:
      case 0x280D:
      case 0x280E:
      case 0x280F:
      case 0x2810:
      case 0x2811:
      case 0x2812:
      case 0x2813:
      case 0x2814:
      case 0x2815:
      case 0x2816:
      case 0x2817:
      case 0x2818:
      case 0x2819:
      case 0x281A:
      case 0x281B:
      case 0x281C:
      case 0x281D:
      case 0x281E:
      case 0x281F:
      case 0x2820:
      case 0x2821:
      case 0x2822:
      case 0x2823:
      case 0x2824:
      case 0x2825:
      case 0x2826:
      case 0x2827:
      case 0x2828:
      case 0x2829:
      case 0x282A:
      case 0x282B:
      case 0x282C:
      case 0x282D:
      case 0x282E:
      case 0x282F:
      case 0x2830:
      case 0x2831:
      case 0x2832:
      case 0x2833:
      case 0x2834:
      case 0x2835:
      case 0x2836:
      case 0x2837:
      case 0x2838:
      case 0x2839:
      case 0x283A:
      case 0x283B:
      case 0x283C:
      case 0x283D:
      case 0x283E:
      case 0x283F:
        SETUP;
        {
          int bit_pattern = unichar - 0x2800;
          int bit = 0;
          int u = 0;
          int v = 0;
          for (bit = 0; bit < 6; bit++)
            {
              if (bit_pattern & (1<<bit) )
                {
                  draw_braille_bit (ctx, x, y, cw, ch, u, v);
                }
              v++;
              if (v > 2)
                {
                  v = 0;
                  u++;
                }
            }
        }
        ctx_fill (ctx);
        return 0;
      case 0x2840:
      case 0x2841:
      case 0x2842:
      case 0x2843:
      case 0x2844:
      case 0x2845:
      case 0x2846:
      case 0x2847:
      case 0x2848:
      case 0x2849:
      case 0x284A:
      case 0x284B:
      case 0x284C:
      case 0x284D:
      case 0x284E:
      case 0x284F:
      case 0x2850:
      case 0x2851:
      case 0x2852:
      case 0x2853:
      case 0x2854:
      case 0x2855:
      case 0x2856:
      case 0x2857:
      case 0x2858:
      case 0x2859:
      case 0x285A:
      case 0x285B:
      case 0x285C:
      case 0x285D:
      case 0x285E:
      case 0x285F:
      case 0x2860:
      case 0x2861:
      case 0x2862:
      case 0x2863:
      case 0x2864:
      case 0x2865:
      case 0x2866:
      case 0x2867:
      case 0x2868:
      case 0x2869:
      case 0x286A:
      case 0x286B:
      case 0x286C:
      case 0x286D:
      case 0x286E:
      case 0x286F:
      case 0x2870:
      case 0x2871:
      case 0x2872:
      case 0x2873:
      case 0x2874:
      case 0x2875:
      case 0x2876:
      case 0x2877:
      case 0x2878:
      case 0x2879:
      case 0x287A:
      case 0x287B:
      case 0x287C:
      case 0x287D:
      case 0x287E:
      case 0x287F:
        SETUP;
        draw_braille_bit (ctx, x, y, cw, ch, 0, 3);
        {
          int bit_pattern = unichar - 0x2840;
          int bit = 0;
          int u = 0;
          int v = 0;
          for (bit = 0; bit < 6; bit++)
            {
              if (bit_pattern & (1<<bit) )
                {
                  draw_braille_bit (ctx, x, y, cw, ch, u, v);
                }
              v++;
              if (v > 2)
                {
                  v = 0;
                  u++;
                }
            }
        }
        ctx_fill (ctx);
        return 0;
      case 0x2880:
      case 0x2881:
      case 0x2882:
      case 0x2883:
      case 0x2884:
      case 0x2885:
      case 0x2886:
      case 0x2887:
      case 0x2888:
      case 0x2889:
      case 0x288A:
      case 0x288B:
      case 0x288C:
      case 0x288D:
      case 0x288E:
      case 0x288F:
      case 0x2890:
      case 0x2891:
      case 0x2892:
      case 0x2893:
      case 0x2894:
      case 0x2895:
      case 0x2896:
      case 0x2897:
      case 0x2898:
      case 0x2899:
      case 0x289A:
      case 0x289B:
      case 0x289C:
      case 0x289D:
      case 0x289E:
      case 0x289F:
      case 0x28A0:
      case 0x28A1:
      case 0x28A2:
      case 0x28A3:
      case 0x28A4:
      case 0x28A5:
      case 0x28A6:
      case 0x28A7:
      case 0x28A8:
      case 0x28A9:
      case 0x28AA:
      case 0x28AB:
      case 0x28AC:
      case 0x28AD:
      case 0x28AE:
      case 0x28AF:
      case 0x28B0:
      case 0x28B1:
      case 0x28B2:
      case 0x28B3:
      case 0x28B4:
      case 0x28B5:
      case 0x28B6:
      case 0x28B7:
      case 0x28B8:
      case 0x28B9:
      case 0x28BA:
      case 0x28BB:
      case 0x28BC:
      case 0x28BD:
      case 0x28BE:
      case 0x28BF:
        SETUP;
        draw_braille_bit (ctx, x, y, cw, ch, 1, 3);
        {
          int bit_pattern = unichar - 0x2880;
          int bit = 0;
          int u = 0;
          int v = 0;
          for (bit = 0; bit < 6; bit++)
            {
              if (bit_pattern & (1<<bit) )
                {
                  draw_braille_bit (ctx, x, y, cw, ch, u, v);
                }
              v++;
              if (v > 2)
                {
                  v = 0;
                  u++;
                }
            }
        }
        ctx_fill (ctx);
        return 0;
      case 0x28C0:
      case 0x28C1:
      case 0x28C2:
      case 0x28C3:
      case 0x28C4:
      case 0x28C5:
      case 0x28C6:
      case 0x28C7:
      case 0x28C8:
      case 0x28C9:
      case 0x28CA:
      case 0x28CB:
      case 0x28CC:
      case 0x28CD:
      case 0x28CE:
      case 0x28CF:
      case 0x28D0:
      case 0x28D1:
      case 0x28D2:
      case 0x28D3:
      case 0x28D4:
      case 0x28D5:
      case 0x28D6:
      case 0x28D7:
      case 0x28D8:
      case 0x28D9:
      case 0x28DA:
      case 0x28DB:
      case 0x28DC:
      case 0x28DD:
      case 0x28DE:
      case 0x28DF:
      case 0x28E0:
      case 0x28E1:
      case 0x28E2:
      case 0x28E3:
      case 0x28E4:
      case 0x28E5:
      case 0x28E6:
      case 0x28E7:
      case 0x28E8:
      case 0x28E9:
      case 0x28EA:
      case 0x28EB:
      case 0x28EC:
      case 0x28ED:
      case 0x28EE:
      case 0x28EF:
      case 0x28F0:
      case 0x28F1:
      case 0x28F2:
      case 0x28F3:
      case 0x28F4:
      case 0x28F5:
      case 0x28F6:
      case 0x28F7:
      case 0x28F8:
      case 0x28F9:
      case 0x28FA:
      case 0x28FB:
      case 0x28FC:
      case 0x28FD:
      case 0x28FE:
      case 0x28FF:
        SETUP;
        draw_braille_bit (ctx, x, y, cw, ch, 0, 3);
        draw_braille_bit (ctx, x, y, cw, ch, 1, 3);
        {
          int bit_pattern = unichar - 0x28C0;
          int bit = 0;
          int u = 0;
          int v = 0;
          for (bit = 0; bit < 6; bit++)
            {
              if (bit_pattern & (1<<bit) )
                {
                  draw_braille_bit (ctx, x, y, cw, ch, u, v);
                }
              v++;
              if (v > 2)
                {
                  v = 0;
                  u++;
                }
            }
        }
        ctx_fill (ctx);
        return 0;
      case 0x1fb00:
      case 0x1fb01:
      case 0x1fb02:
      case 0x1fb03:
      case 0x1fb04:
      case 0x1fb05:
      case 0x1fb06:
      case 0x1fb07:
      case 0x1fb08:
      case 0x1fb09:
      case 0x1fb0a:
      case 0x1fb0b:
      case 0x1fb0c:
      case 0x1fb0d:
      case 0x1fb0e:
      case 0x1fb0f:
      case 0x1fb10:
      case 0x1fb11:
      case 0x1fb12:
      case 0x1fb13:
      case 0x1fb14:
      case 0x1fb15:
      case 0x1fb16:
      case 0x1fb17:
      case 0x1fb18:
      case 0x1fb19:
      case 0x1fb1a:
      case 0x1fb1b:
      case 0x1fb1c:
      case 0x1fb1d:
      case 0x1fb1e:
      case 0x1fb1f:
      case 0x1fb20:
      case 0x1fb21:
      case 0x1fb22:
      case 0x1fb23:
      case 0x1fb24:
      case 0x1fb25:
      case 0x1fb26:
      case 0x1fb27:
      case 0x1fb28:
      case 0x1fb29:
      case 0x1fb2a:
      case 0x1fb2b:
      case 0x1fb2c:
      case 0x1fb2d:
      case 0x1fb2e:
      case 0x1fb2f:
      case 0x1fb30:
      case 0x1fb31:
      case 0x1fb32:
      case 0x1fb33:
      case 0x1fb34:
      case 0x1fb35:
      case 0x1fb36:
      case 0x1fb37:
      case 0x1fb38:
      case 0x1fb39:
      case 0x1fb3a:
      case 0x1fb3b:

        {
          SETUP;
          uint32_t bitmask = (unichar - 0x1fb00) + 1;
          if (bitmask > 20) bitmask ++;
          if (bitmask > 41) bitmask ++;
          int bit = 0;
          for (int v = 0; v < 3; v ++)
          for (int u = 0; u < 2; u ++, bit ++)
          {
            if (bitmask & (1<<bit))
            {
              draw_sextant_bit (ctx, x, y, cw, ch, u, v);
            }
          }
          ctx_fill (ctx);
          return 0;
        }
        break;
      case 0x1fb3c:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch / 3.0f);
          ctx_rel_line_to (ctx, cw/2, ch/3.0f);
          ctx_fill (ctx);
          return 0;
        }
        break;
      case 0x1fb3d:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0f);
          ctx_rel_line_to (ctx, cw, ch/3.0f);
          ctx_fill (ctx);
          return 0;
        }
        break;
      case 0x1fb3e:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0,   -ch/3.0f * 2);
          ctx_rel_line_to (ctx, cw/2, ch/3.0f * 2);
          ctx_fill (ctx);
          return 0;
        }
        break;
      case 0x1fb3f:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0,  -ch/3.0f * 2);
          ctx_rel_line_to (ctx, cw, ch/3.0f * 2);
          ctx_fill (ctx);
          return 0;
        }
        break;
      case 0x1fb40:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, ch);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb41:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw/2, -ch/3.0);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, 0.0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb42:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw, -ch/3.0);
          ctx_rel_line_to (ctx, 0.0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb43:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0f);
          ctx_rel_line_to (ctx, cw/2, -ch/3.0f*2.0f);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, 0.0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb44:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, cw, -ch/3.0 * 2);
          ctx_rel_line_to (ctx, 0.0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb45:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, cw/2, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, 0.0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb46:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, cw, -ch/3.0);
          ctx_rel_line_to (ctx, 0.0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb47:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, cw/2, -ch/3.0);
          ctx_rel_line_to (ctx, 0.0, ch/3.0);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb48:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, cw, -ch/3.0);
          ctx_rel_line_to (ctx, 0.0, ch/3.0);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb49:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, cw/2, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0.0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb4a:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, cw, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0.0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb4b:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, cw/2, ch/3);
          ctx_rel_line_to (ctx, 0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb4c:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, ch/3);
          ctx_rel_line_to (ctx, 0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb4d:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, ch/3);
          ctx_rel_line_to (ctx, 0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb4e:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, cw/2, ch/3 *  2);
          ctx_rel_line_to (ctx, 0, ch/3.0);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb4f:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, ch/3 *  2);
          ctx_rel_line_to (ctx, 0, ch/3.0);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb50:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, cw/2, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb51:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw, ch/3.0);
          ctx_rel_line_to (ctx, 0, ch/3.0);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb52:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb53:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw, -ch/3.0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb54:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb55:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw, -ch/3.0*2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb56:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_rel_line_to (ctx, -cw/2, -ch);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb57:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0, -ch/3);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, -cw/2, ch/3);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb58:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0, -ch/3);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, -cw, ch/3);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb59:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, -cw/2, ch/3 * 2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb5a:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0);
          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, -cw, ch/3 * 2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb5b:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, -cw/2, ch);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb5c:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3);

          ctx_rel_line_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3);
          ctx_rel_line_to (ctx, -cw, ch/3);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb5d:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3 * 2);
          ctx_rel_line_to (ctx, -cw/2, ch/3);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb5e:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3 * 2);
          ctx_rel_line_to (ctx, -cw, ch/3);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb5f:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3);
          ctx_rel_line_to (ctx, -cw/2, ch/3*2);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb60:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3);
          ctx_rel_line_to (ctx, -cw, ch/3*2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb61:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, -cw/2, ch);
          ctx_rel_line_to (ctx, -cw/2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb62:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/2, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, 0, ch/3);
          ctx_rel_line_to (ctx, -cw/2, -ch/3);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb63:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3);
          ctx_rel_line_to (ctx, -cw, -ch/3);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb64:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/2, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, 0, ch/3*2);
          ctx_rel_line_to (ctx, -cw/2, -ch/3*2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb65:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3*2);
          ctx_rel_line_to (ctx, -cw, -ch/3*2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb66:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/2, -ch);
          ctx_rel_line_to (ctx, cw/2, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, -ch);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb67:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/3.0*2);
          ctx_rel_line_to (ctx, 0, -ch/3);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/3.0*2);
          ctx_rel_line_to (ctx, -cw, -ch/3.0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb68:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, cw/2, -ch/2);
          ctx_rel_line_to (ctx, -cw/2, -ch/2);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb69:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, ch/2);
          ctx_rel_line_to (ctx, cw/2, -ch/2);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb6a:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, -cw/2, ch/2);
          ctx_rel_line_to (ctx, cw/2, ch/2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb6b:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, -ch/2);
          ctx_rel_line_to (ctx, -cw/2, ch/2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb6c:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, ch/2);
          ctx_rel_line_to (ctx, -cw/2, ch/2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb6d:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, -cw/2, ch/2);
          ctx_rel_line_to (ctx, -cw/2, -ch/2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb6e:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw, -ch);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, -ch/2);
          ctx_rel_line_to (ctx, cw/2, -ch/2);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb6f:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, cw/2, -ch/2);
          ctx_rel_line_to (ctx, cw/2, ch/2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb82:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/8 * 2);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_move_to (ctx, 0, ch/8 * 2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb83:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/8 * 3);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_move_to (ctx, 0, ch/8 * 3);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb84:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/8 * 5);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_move_to (ctx, 0, ch/8 * 5);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb85:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/8 * 6);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_move_to (ctx, 0, ch/8 * 6);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb86:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, 0, -ch/8 * 7);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_rel_move_to (ctx, 0, ch/8 * 7);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb87:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/8*6, 0);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_move_to (ctx, cw/8*2, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_move_to (ctx, -cw/8*2, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb88:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/8*5, 0);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_move_to (ctx, cw/8*3, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_move_to (ctx, -cw/8*3, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb89:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/8*3, 0);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_move_to (ctx, cw/8*5, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_move_to (ctx, -cw/8*5, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb8a:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_move_to (ctx, cw/8*2, 0);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_move_to (ctx, cw/8*6, 0);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_move_to (ctx, -cw/8*6, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb97:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch/4);
          ctx_rel_move_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/4);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_close_path (ctx);
          ctx_move_to (ctx, 0, -ch/2);
          ctx_rel_line_to (ctx, 0, -ch/4);
          ctx_rel_move_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, 0, ch/4);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb9a:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, cw/2, -ch/2);
          ctx_rel_line_to (ctx, -cw/2, -ch/2);
          ctx_rel_move_to (ctx, cw, 0);
          ctx_rel_line_to (ctx, -cw/2, ch/2);
          ctx_rel_line_to (ctx, cw/2, ch/2);
          ctx_rel_line_to (ctx, -cw, 0);
          ctx_fill (ctx);
          return 0;
        }
      case 0x1fb9b:
        {
          SETUP;
          ctx_move_to (ctx, x, y);
          ctx_rel_line_to (ctx, 0, -ch);
          ctx_rel_line_to (ctx, cw/2, ch/2);
          ctx_rel_line_to (ctx, cw/2, -ch/2);
          ctx_rel_line_to (ctx, 0, ch);
          ctx_rel_line_to (ctx, -cw/2, -ch/2);
          ctx_rel_line_to (ctx, -cw/2, ch/2);
          ctx_fill (ctx);
          return 0;
        }
    }
  }
  #undef SETUP
  return -1;
}

#endif

#if CTX_VT

#if CTX_STB_IMAGE
#ifndef STBI_INCLUDE_STB_IMAGE_H 
#include "stb_image.h"
#endif
#endif

/* DEC terminals/xterm family terminal with ANSI, utf8, vector graphics and
 * audio.
 *
 * Copyright (c) 2014, 2016, 2018, 2020 Øyvind Kolås <pippin@gimp.org>
 *
 * Adhering to the standards with modern extensions.
 *
 * Features:
 *     ligatures
 *     dim, bold, strikethrough, underline, italic, reverse
 *     ANSI colors, 256 colors (non-redefineable), 24bit color
 *     UTF8, cp437
 *     vt100 - 101 points on scoresheet
 *     vt320 - horizontal margins
 *     BBS/ANSI-art mode
 *
 *     realtime audio transmission
 *     raster sprites (sixels, iterm2 and kitty specs)
 *     vector graphics
 *     proportional fonts
 *
 * 8bit clean
 *
 * Todo:
 *     DECCIR - cursor state report https://vt100.net/docs/vt510-rm/DECCIR.html
 *
 */

int ctx_dummy_in_len = 0;

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/time.h>
#if CTX_PTY
#include <sys/ioctl.h>
#include <termios.h>
#endif

#include "ctx.h"


#define CTX_VT_132COL 1  // disabled - can cause hangs at least in fuzzer rig

//#define STB_IMAGE_IMPLEMENTATION
//#include "stb_image.h"

//#include "vt-line.h"
//#include "vt.h"
//#include "ctx-clients.h"

#define VT_LOG_INFO     (1<<0)
#define VT_LOG_CURSOR   (1<<1)
#define VT_LOG_COMMAND  (1<<2)
#define VT_LOG_WARNING  (1<<3)
#define VT_LOG_ERROR    (1<<4)
#define VT_LOG_INPUT    (1<<5)
#define VT_LOG_ALL       0xff

static int vt_log_mask = VT_LOG_INPUT;
//static int vt_log_mask = VT_LOG_WARNING | VT_LOG_ERROR;// | VT_LOG_COMMAND;// | VT_LOG_INFO | VT_LOG_COMMAND;
//static int vt_log_mask = VT_LOG_WARNING | VT_LOG_ERROR | VT_LOG_INFO | VT_LOG_COMMAND | VT_LOG_INPUT;
//static int vt_log_mask = VT_LOG_ALL;

#if 0
#define vt_log(domain, fmt, ...)

#define VT_input(str, ...)
#define VT_info(str, ...)
#define VT_command(str, ...)
#define VT_cursor(str, ...)
#define VT_warning(str, ...)
#define VT_error(str, ...)
#else
#define vt_log(domain, line, a...) \
        do {fprintf (stderr, "%i %s ", line, domain);fprintf(stderr, ##a);fprintf(stderr, "\n");}while(0)
#define VT_info(a...) if (vt_log_mask & VT_LOG_INFO) vt_log ("INFO  ", __LINE__, ##a)
#define VT_input(a...) if (vt_log_mask & VT_LOG_INPUT) vt_log ("INPUT ", __LINE__, ##a)
#define VT_command(a...) if (vt_log_mask & VT_LOG_COMMAND) vt_log ("CMD   ", __LINE__, ##a)
#define VT_cursor(a...) if (vt_log_mask & VT_LOG_CURSOR) vt_log ("CURSOR",__LINE__, ##a)
#define VT_warning(a...) if (vt_log_mask & VT_LOG_WARNING) vt_log ("WARN  ",__LINE__, ##a)
#define VT_error(a...) if (vt_log_mask & VT_LOG_ERROR) vt_log ("ERROR",__LINE__, ##a)

#endif

#ifndef MIN
#define MIN(a,b)  ((a)<(b)?(a):(b))
#endif

static void vt_state_neutral      (VT *vt, int byte);
static void vt_state_esc          (VT *vt, int byte);
static void vt_state_osc          (VT *vt, int byte);
static void vt_state_apc          (VT *vt, int byte);
static void vt_state_apc_generic  (VT *vt, int byte);
#if CTX_VT_SIXELS
static void vt_state_sixel        (VT *vt, int byte);
#endif
static void vt_state_esc_sequence (VT *vt, int byte);
static void vt_state_esc_foo      (VT *vt, int byte);
static void vt_state_swallow      (VT *vt, int byte);
#if CTX_PARSER
static void vt_state_ctx          (VT *vt, int byte);
#endif
static void vt_state_vt52         (VT *vt, int byte);

static inline void vt_line_free2 (VT *vt, VtLine *line)
{
  if (line->string.allocated_length > vt->cols * 1.6f)
    vt_line_free (line, 1);
  else
    ctx_list_prepend (&vt->limbo, line);
}

static VtLine *vt_line_new2 (VT *vt)
{
  if (vt->limbo)
  {
    VtLine *ret = vt->limbo->data;
    ctx_list_remove (&vt->limbo, ret);
    vt_line_set (ret, "");
    vt_line_clear (ret);
    return ret;
  }
  return vt_line_new_with_size ("", vt->cols/4);
}

typedef enum
{
  STYLE_REVERSE         = 1 << 0,
  STYLE_BOLD            = 1 << 1,
  STYLE_BLINK           = 1 << 2,
  STYLE_UNDERLINE       = 1 << 3,
  STYLE_DIM             = 1 << 4,
  STYLE_HIDDEN          = 1 << 5,
  STYLE_ITALIC          = 1 << 6,
  STYLE_UNDERLINE_VAR   = 1 << 7,
  STYLE_STRIKETHROUGH   = 1 << 8,
  STYLE_OVERLINE        = 1 << 9,
  STYLE_BLINK_FAST      = 1 << 10,
  STYLE_PROPORTIONAL    = 1 << 11,
  STYLE_FG_COLOR_SET    = 1 << 12,
  STYLE_BG_COLOR_SET    = 1 << 13,
  STYLE_FG24_COLOR_SET  = 1 << 14,
  STYLE_BG24_COLOR_SET  = 1 << 15,
  //STYLE_NONERASABLE     = 1 << 16  // needed for selective erase
} TerminalStyle;

typedef struct Image
{
  int kitty_format;
  int width;
  int height;
  int id;
  int eid_no;
  int size;
  uint8_t *data;
} Image;

#define MAX_IMAGES 128

static Image image_db[MAX_IMAGES]= {{0,},};

static Image *image_query (int id)
{
  for (int i = 0; i < MAX_IMAGES; i++)
    {
      Image *image = &image_db[i];
      if (image->id == id)
        { return image; }
    }
  return NULL;
}

static int image_eid_no = 0;

static CtxList *ctx_vts;
static Image *image_add (int width,
                         int height,
                         int id,
                         int format,
                         int size,
                         uint8_t *data)
{
  // look for id if id is not 0
  Image *image;
  for (int i = 0; i < MAX_IMAGES; i++)
    {
      image = &image_db[i];
      if (image->data == NULL)
        { break; }
    }
  if (image->data)
    {
      // not a good eviction strategy
      image = &image_db[random() %MAX_IMAGES];
    }
  if (image->data)
    { ctx_free (image->data); }
  image->kitty_format = format;
  image->width  = width;
  image->height = height;
  image->id     = id;
  image->size   = size;
  image->data   = data;
  image->eid_no = image_eid_no++;
  return image;
}

void vtpty_resize (void *data, int cols, int rows, int px_width, int px_height)
{
#if CTX_PTY
  VtPty *vtpty = data;
  VT    *vt    = data;
  struct winsize ws;
  ws.ws_row = rows;
  ws.ws_col = cols;
  ws.ws_xpixel = px_width;
  ws.ws_ypixel = px_height;
  ioctl (vtpty->pty, TIOCSWINSZ, &ws);
  char buf[64];
  sprintf (buf, "resize-event %i %i %i %i", px_width, px_height, rows, cols);
  vt_feed_keystring (vt, NULL, buf);
#endif
}

ssize_t vtpty_write (void *data, const void *buf, size_t count)
{
  VtPty *vtpty = data;
  return write (vtpty->pty, buf, count);
}

ssize_t vtpty_read (void  *data, void *buf, size_t count)
{
  VtPty *vtpty = data;
  return read (vtpty->pty, buf, count);
}

int vtpty_waitdata (void  *data, int timeout)
{
  VtPty *vtpty = data;
  struct timeval tv;
  fd_set fdset;
  FD_ZERO (&fdset);
  FD_SET (vtpty->pty, &fdset);
  tv.tv_sec = 0;
  tv.tv_usec = timeout;
  tv.tv_sec  = timeout / 1000000;
  tv.tv_usec = timeout % 1000000;
  if (select (vtpty->pty+1, &fdset, NULL, NULL, &tv) == -1)
    {
      perror ("select");
      return 0;
    }
  if (FD_ISSET (vtpty->pty, &fdset) )
    {
      return 1;
    }
  return 0;
}


/* on current line */
static int vt_col_to_pos (VT *vt, int col)
{
  int pos = col;
  if (vt->current_line->contains_proportional)
    {
      Ctx *ctx = ctx_new_drawlist (vt->width, vt->height);
      ctx_font (ctx, "Regular");
      ctx_font_size (ctx, vt->font_size);
      float x = 0;
      pos = 0;
      int prev_prop = 0;
      while (x <= col * vt->cw)
        {
          if (vt_line_get_style (vt->current_line, pos) & STYLE_PROPORTIONAL)
            {
              x += ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, vt_line_get_unichar (vt->current_line, pos)));
              prev_prop = 1;
            }
          else
            {
              if (prev_prop)
                {
                  int new_cw = vt->cw - ( ((int)(x) % (int)(vt->cw)) );
                  if (new_cw < vt->cw*3/2)
                    { new_cw += vt->cw; }
                  x += new_cw;
                }
              else
                {
                  x += vt->cw;
                }
              prev_prop = 0;
            }
          pos ++;
        }
      pos --;
      ctx_destroy (ctx);
    }
  return pos;
}

static int vt_margin_left (VT *vt)
{
  int left = vt->left_right_margin_mode?vt->margin_left:1;
  return vt_col_to_pos (vt, left);
}

#define VT_MARGIN_LEFT vt_margin_left(vt)

static int vt_margin_right (VT *vt)
{
  int right = vt->left_right_margin_mode?vt->margin_right:vt->cols;
  return vt_col_to_pos (vt, right);
}

#define VT_MARGIN_RIGHT vt_margin_right(vt)

static void vtcmd_reset_to_initial_state (VT *vt, const char *sequence);
int vt_set_prop (Ctx *ctx, VT *vt, uint32_t key_hash, const char *val);

void vt_set_title (VT *vt, const char *new_title)
{
  if (vt->inert) return;
  if (vt->title)
    { ctx_free (vt->title); }
  vt->title = ctx_strdup (new_title);
  vt_set_prop (vt->current_line->ctx, vt, ctx_strhash ("title"), (char*)new_title);
}

const char *vt_get_title (VT *vt)
{
  return vt->title;
}

#if CTX_PTY
static void vt_run_command (VT *vt, const char *command, const char *term);
#endif
static void vtcmd_set_top_and_bottom_margins (VT *vt, const char *sequence);
static void vtcmd_set_left_and_right_margins (VT *vt, const char *sequence);
static void _vt_move_to (VT *vt, int y, int x);

static void vtcmd_clear (VT *vt, const char *sequence)
{

  while (vt->lines)
    {
      vt_line_free2 (vt, vt->lines->data);
      ctx_list_remove (&vt->lines, vt->lines->data);
    }
  vt->lines = NULL;
  vt->line_count = 0;

  { /* HACK adding lines to scrollback if previous screenful
       in scrollback contained images
     */
    int images = 0;
    for (int i = 0; i < vt->rows; i++)
    {
      VtLine *line = ctx_list_nth_data (vt->scrollback, i);
      if (line && line->images[0])
        images++;
    }

    if (images)
      for (int i=0; i<vt->rows; i++)
      {
        vt->current_line = vt_line_new2 (vt);
        ctx_list_prepend (&vt->scrollback, vt->current_line);
        vt->scrollback_count++;
      }
  }

  /* populate lines */
  for (int i=0; i<vt->rows; i++)
    {
      vt->current_line = vt_line_new2 (vt);
      ctx_list_prepend (&vt->lines, vt->current_line);
      vt->line_count++;
    }
}

#define set_fg_rgb(r, g, b) \
    vt->cstyle ^= (vt->cstyle & (((uint64_t)((1l<<24)-1))<<16));\
    vt->cstyle |=  ((uint64_t)(r)<<16);\
    vt->cstyle |=  ((uint64_t)(g)<<(16+8));\
    vt->cstyle |=  ((uint64_t)(b)<<(16+8+8));\
    vt->cstyle |= STYLE_FG_COLOR_SET;\
    vt->cstyle |= STYLE_FG24_COLOR_SET;\

#define set_bg_rgb(r, g, b) \
    vt->cstyle ^= (vt->cstyle & (((uint64_t)((1l<<24)-1))<<40));\
    vt->cstyle |=  ((uint64_t)(r)<<40);\
    vt->cstyle |=  ((uint64_t)(g)<<(40+8));\
    vt->cstyle |=  ((uint64_t)(b)<<(40+8+8));\
    vt->cstyle |= STYLE_BG_COLOR_SET;\
    vt->cstyle |= STYLE_BG24_COLOR_SET;\

#define set_fg_idx(idx) \
    vt->cstyle ^= (vt->cstyle & (((uint64_t)((1l<<24)-1))<<16));\
    vt->cstyle ^= (vt->cstyle & STYLE_FG24_COLOR_SET);\
    vt->cstyle |=  ((idx)<<16);\
    vt->cstyle |= STYLE_FG_COLOR_SET;

#define set_bg_idx(idx) \
    vt->cstyle ^= (vt->cstyle & (((uint64_t)((1l<<24)-1))<<40));\
    vt->cstyle ^= (vt->cstyle & STYLE_BG24_COLOR_SET);\
    vt->cstyle |= ((int64_t)(idx)<<40) ;\
    vt->cstyle |= STYLE_BG_COLOR_SET;


static void _vt_compute_cw_ch (VT *vt)
{
  vt->ch = vt->font_size * vt->line_spacing;
  Ctx *ctx = ctx_new_drawlist (-1, -1);
  ctx_font (ctx, "Mono");
  ctx_font_size (ctx, vt->font_size);
  vt->cw = ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, ' '));
  ctx_destroy (ctx);
}

static void vtcmd_set_132_col (VT  *vt, int set)
{
  // this should probably force the window as well
  if (set == 0 && vt->scale_x == 1.0f) return;
  if (set == 1 && vt->scale_x != 1.0f) return;
  if (set) // 132 col
    {
      vt->scale_x = 74.0/132.0; // show all - po
      //vt->scale_x = 80.0/132.0;
      vt->scale_y = 1.0;
      _vt_compute_cw_ch (vt);
      vt_set_term_size (vt, vt->cols * 132/80.0, vt->rows);
    }
  else // 80 col
    {
      vt->scale_x = 1.0;
      vt->scale_y = 1.0;
      _vt_compute_cw_ch (vt);
      vt_set_term_size (vt, vt->cols * 80/132.0, vt->rows);
    }
}

static void vt_line_feed (VT *vt);
static void vt_carriage_return (VT *vt);

static int vt_trimlines (VT *vt, int max);
static void vtcmd_reset_to_initial_state (VT *vt, const char *sequence)
{
  VT_info ("reset %s", sequence);
  if (getenv ("VT_DEBUG") )
    { vt->debug = 1; }
  vtcmd_clear (vt, sequence);
  vt->encoding = 0;
  vt->bracket_paste = 0;
  vt->ctx_events = 0;
  vt->cr_on_lf = 0;
  vtcmd_set_top_and_bottom_margins (vt, "[r");
  vtcmd_set_left_and_right_margins (vt, "[s");
  vt->autowrap               = 1;
  vt->justify                = 0;
  vt->cursor_visible         = 1;
  vt->scrollbar_visible      = 1;
  vt->charset[0]             = 0;
  vt->charset[1]             = 0;
  vt->charset[2]             = 0;
  vt->charset[3]             = 0;
  vt->bell                   = 3;
  vt->scale_x                = 1.0f;
  vt->scale_y                = 1.0f;
  vt->saved_x                = 1;
  vt->saved_y                = 1;
  vt->saved_style            = 1;
  vt->reverse_video          = 0;
  vt->cstyle                 = 0;
  vt->keyrepeat              = 1;
  vt->cursor_key_application = 0;
  vt->argument_buf_len       = 0;
  vt->argument_buf[0]        = 0;
  vt->vtpty.done             = 0;
  vt->result                 = -1;
  vt->state                  = vt_state_neutral;
  vt->scroll_on_output       = 0;
  vt->scroll_on_input        = 1;
  vt->unit_pixels            = 0;
  vt->mouse                  = 0;
  vt->mouse_drag             = 0;
  vt->mouse_all              = 0;
  vt->mouse_decimal          = 0;
  _vt_compute_cw_ch (vt);
  for (int i = 0; i < MAX_COLS; i++)
    { vt->tabs[i] = i % 8 == 0? 1 : 0; }
  _vt_move_to (vt, vt->margin_top, vt->cursor_x);
  vt_carriage_return (vt);
  //if (vt->ctx)
  //  { ctx_reset (vt->ctx); }
  vt->audio.bits = 8;
  vt->audio.channels = 1;
  vt->audio.type = 'u';
  vt->audio.samplerate = 8000;
  vt->audio.buffer_size = 1024;
  vt->audio.encoding = 'a';
  vt->audio.compression = '0';
  vt->audio.mic = 0;
  while (vt->scrollback)
    {
      vt_line_free (vt->scrollback->data, 1);
      ctx_list_remove (&vt->scrollback, vt->scrollback->data);
    }
  while (vt->limbo)
    {
      vt_line_free (vt->limbo->data, 1);
      ctx_list_remove (&vt->limbo, vt->limbo->data);
    }
  vt->scrollback_count = 0;
}

void vt_set_font_size (VT *vt, float font_size)
{
  vt->font_size = font_size;
  _vt_compute_cw_ch (vt);
}

float       vt_get_font_size      (VT *vt)
{
  return vt->font_size;
}

void vt_set_baseline (VT *vt, float baseline)
{
  vt->baseline = baseline;
}

void vt_set_line_spacing (VT *vt, float line_spacing)
{
  if (vt->line_spacing != line_spacing)
  {
    vt->line_spacing = line_spacing;
    _vt_compute_cw_ch (vt);
  }
}


#if CTX_PTY
static void ctx_clients_signal_child (int signum)
{
  pid_t pid;
  int   status;
  if ( (pid = waitpid (-1, &status, WNOHANG) ) != -1)
    {
      if (pid)
        {
          for (CtxList *l = ctx_vts; l; l=l->next)
            {
              VtPty *vt = l->data;
              if (vt->pid == pid)
                {
                  vt->done = 1;
                  //vt->result = status;
                }
            }
        }
    }
}
#endif

static void vt_init (VT *vt, int width, int height, float font_size, float line_spacing, int id, int can_launch)
{
  static int signal_installed = 0;
  if (!signal_installed)
  {
#if CTX_PTY
    signal (SIGCHLD,ctx_clients_signal_child);
#endif
    signal_installed = 1;
  }
  vt->id                 = id;
  vt->lastx              = -1;
  vt->lasty              = -1;
  vt->state              = vt_state_neutral;
  vt->smooth_scroll      = 0;
  vt->can_launch         = can_launch;
  vt->scroll_offset      = 0.0;
  vt->waitdata           = vtpty_waitdata;
  vt->read               = vtpty_read;
  vt->write              = vtpty_write;
  vt->resize             = vtpty_resize;
  vt->font_to_cell_scale = 0.98;
  vt->cursor_visible     = 1;
  vt->lines              = NULL;
  vt->line_count         = 0;
  vt->current_line       = NULL;
  vt->cols               = 0;
  vt->rows               = 0;

  vt->scrollback_limit   = DEFAULT_SCROLLBACK;
  vt->argument_buf_len   = 0;
  vt->argument_buf_cap   = 64;
  vt->argument_buf       = ctx_malloc (vt->argument_buf_cap);
  vt->argument_buf[0]    = 0;
  vt->vtpty.done         = 0;
  vt->result             = -1;
  vt->line_spacing       = 1.0f;
  vt->baseline           = 0.78f;
  vt->scale_x            = 1.0f;
  vt->scale_y            = 1.0f;
  vt->fg_color[0]        = 216;
  vt->fg_color[1]        = 216;
  vt->fg_color[2]        = 216;
  vt->bg_color[0]        = 0;
  vt->bg_color[1]        = 0;
  vt->bg_color[2]        = 0;
}

#if CTX_PTY
static pid_t
vt_forkpty (int  *amaster,
            char *aname,
            const struct termios *termp,
            const struct winsize *winsize)
{
  pid_t pid;
  int master = posix_openpt (O_RDWR|O_NOCTTY);
  int slave;

  if (master < 0)
    return -1;
  if (grantpt (master) != 0)
    return -1;
  if (unlockpt (master) != 0)
    return -1;
#if 0
  char name[1024];
  if (ptsname_r (master, name, sizeof(name)-1))
    return -1;
#else
  char *name = NULL;
  if ((name = ptsname (master)) == NULL)
    return -1;
#endif

  slave = open(name, O_RDWR|O_NOCTTY);

  if (termp)   tcsetattr(slave, TCSAFLUSH, termp);
  if (winsize) ioctl(slave, TIOCSWINSZ, winsize);

  pid = fork();
  if (pid < 0)
  {
    return pid;
  } else if (pid == 0)
  {
    close (master);
    setsid ();
    dup2 (slave, STDIN_FILENO);
    dup2 (slave, STDOUT_FILENO);
    dup2 (slave, STDERR_FILENO);

    close (slave);
    return 0;
  }
  ioctl (slave, TIOCSCTTY, NULL);
  close (slave);
  *amaster = master;
  return pid;
}
#endif

static void
ctx_child_prepare_env (int was_pidone, const char *term)
{
  if (was_pidone)
  {
    if (setuid(1000)) fprintf (stderr, "setuid failed\n");
  }
  else
  {
    for (int i = 3; i<768; i++) { close (i); } /*hack, trying to close xcb */
  }
  unsetenv ("TERM");
  unsetenv ("TERM_PROGRAM");
  unsetenv ("TERM_VERSION");
  unsetenv ("COLUMNS");
  unsetenv ("LINES");
  unsetenv ("TERMCAP");
  unsetenv ("COLOR_TERM");
  unsetenv ("COLORTERM");
  unsetenv ("VTE_VERSION");
  unsetenv ("CTX_BACKEND");
  //setenv ("TERM", "ansi", 1);
  //setenv ("TERM", "vt102", 1);
  //setenv ("TERM", "vt100", 1);
  // setenv ("TERM", term?term:"xterm", 1);
  setenv ("TERM", term?term:"xterm-256color", 1);
  setenv ("TERM_PROGRAM", "ctx", 1);
  setenv ("TERM_VERSION", CTX_VERSION_STRING, 1);
  setenv ("COLORTERM", "truecolor", 1);
}

void _ctx_add_listen_fd (int fd);
void _ctx_remove_listen_fd (int fd);

#ifdef EMSCRIPTEN

#define EM_BUFSIZE 81920

char em_inbuf[EM_BUFSIZE]="";
char em_outbuf[EM_BUFSIZE]="";
int em_in_len = 0;
int em_in_pos = 0;
int em_in_read_pos = 0;
EMSCRIPTEN_KEEPALIVE int em_out_len = 0;
int em_out_pos = 0;

ssize_t em_write (void *s, const void *buf, size_t count)
{
  const char *src = (const char*)buf;
  int i;
  for (i = 0; i < count && em_out_len < EM_BUFSIZE; i ++)
  {
    em_outbuf[em_out_pos++] = src[i];
    em_out_len++;
    if (em_out_pos >= EM_BUFSIZE)em_out_pos = 0;
  }
  if (em_out_len >= EM_BUFSIZE)
    printf ("em_outbuf overflow\n");
  else
  EM_ASM({
    console.log('a a ' + UTF8ToString($1));
    ws.send(new Blob([UTF8ToString($0)]));
    }, src
       );

  return i;
}

EMSCRIPTEN_KEEPALIVE
ssize_t em_buffer (void *s, const void *buf, size_t count)
{
  const char *src = (const char*)buf;
  int i;
  for (i = 0; i < count && em_in_len < EM_BUFSIZE; i ++)
  {
    em_inbuf[em_in_pos++] = src[i];
    em_in_len++;
    if (em_in_pos >= EM_BUFSIZE)em_in_pos = 0;
    if (src[i]=='\n')
    {
      em_inbuf[em_in_pos++] = '\r';
      em_in_len++;
      if (em_in_pos >= EM_BUFSIZE)em_in_pos = 0;
    }
  }
  if (em_in_len >= EM_BUFSIZE)
    printf ("em_inbuf overflow\n");
  return i;
}

ssize_t em_read    (void *serial_obj, void *buf, size_t count)
{
  char *dst = (char*)buf;
  if (em_in_len)
  {
    *dst = em_inbuf[em_in_read_pos++];
    --em_in_len;
    if (em_in_read_pos>=EM_BUFSIZE)em_in_read_pos = 0;
    return 1;
  }
  return 0;
}

int     em_waitdata (void *serial_obj, int timeout)
{
  return em_in_len;
}

#endif

#define CTX_VT_INBUFSIZE  400
#define CTX_VT_OUTBUFSIZE 32

static char ctx_dummy_inbuf[CTX_VT_INBUFSIZE]="";
static char ctx_dummy_outbuf[CTX_VT_OUTBUFSIZE]="";
static int ctx_dummy_in_pos = 0;
static int ctx_dummy_in_read_pos = 0;
static int ctx_dummy_out_len = 0;
static int ctx_dummy_out_pos = 0;
static int ctx_dummy_out_read_pos = 0;

int ctx_vt_available (Ctx *ctx)
{
  return CTX_VT_INBUFSIZE - ctx_dummy_in_len - 1;
}

void ctx_vt_write (Ctx *ctx, uint8_t byte)
{
#if 0
  while (ctx_dummy_in_len > CTX_VT_INBUFSIZE/2)
  {
  }
#endif
  if (ctx_dummy_in_len < CTX_VT_INBUFSIZE)
  {
    ctx_dummy_inbuf[ctx_dummy_in_pos++] = byte;
    ctx_dummy_in_len++;
    if (ctx_dummy_in_pos >= CTX_VT_INBUFSIZE)ctx_dummy_in_pos = 0;
  }
  else
  {
    //fprintf (stderr, "ctx uart overflow\n");
  }
}

int ctx_vt_has_data (Ctx *ctx)
{
  return ctx_dummy_out_len;
}

int ctx_vt_read (Ctx *ctx)
{
  int ret = -1;
  if (ctx_dummy_out_len)
  {
    ret = ctx_dummy_outbuf[ctx_dummy_out_read_pos++];
    --ctx_dummy_out_len;
    if (ctx_dummy_out_read_pos>=CTX_VT_OUTBUFSIZE)ctx_dummy_out_read_pos = 0;
  }
  return ret;
}

int ctx_vt_cursor_y (CtxClient *client)
{
  if (!client) return 0;
  VT *vt = ctx_client_vt (client);
  if (!vt) return 0;
  return vt_get_cursor_y (vt);
}

int ctx_vt_cursor_x (CtxClient *client)
{
  if (!client) return 0;
  VT *vt = ctx_client_vt (client);
  if (!vt) return 0;
  return vt_get_cursor_x (vt);
}

static ssize_t ctx_dummy_write (void *s, const void *buf, size_t count)
{
  const char *src = (const char*)buf;
  unsigned int i;
  for (i = 0; i < count && ctx_dummy_out_len < CTX_VT_OUTBUFSIZE; i ++)
  {
    ctx_dummy_outbuf[ctx_dummy_out_pos++] = src[i];
    ctx_dummy_out_len++;
    if (ctx_dummy_out_pos >= CTX_VT_OUTBUFSIZE)ctx_dummy_out_pos = 0;
  }
  if (ctx_dummy_out_len >= CTX_VT_OUTBUFSIZE)
    printf ("ctx_dummy_outbuf overflow\n");

  return i;
}

static ssize_t ctx_dummy_read    (void *serial_obj, void *buf, size_t count)
{
  char *dst = (char*)buf;
  if (ctx_dummy_in_len)
  {
    *dst = ctx_dummy_inbuf[ctx_dummy_in_read_pos++];
    --ctx_dummy_in_len;
    if (ctx_dummy_in_read_pos>=CTX_VT_INBUFSIZE)ctx_dummy_in_read_pos = 0;
    return 1;
  }
  return 0;
}

static int ctx_dummy_waitdata (void *serial_obj, int timeout)
{
  return ctx_dummy_in_len;
}

void ctx_dummy_resize  (void *serial_obj, int cols, int rows, int px_width, int px_height)
{
}

static void vt_run_argv (VT *vt, char **argv, const char *term)
{

#if 0
  int was_pidone = (getpid () == 1);
#else
  int was_pidone = 0; // do no special treatment, all child processes belong
                      // to root
#endif

#if CTX_PTY==1
  if (!argv)
#endif
  {
    vt->read = ctx_dummy_read;
    vt->write = ctx_dummy_write;
    vt->waitdata = ctx_dummy_waitdata;
    vt->resize = ctx_dummy_resize;
    return;
  }


#if CTX_PTY

  struct winsize ws;
  //signal (SIGCHLD,signal_child);
  signal (SIGINT,SIG_DFL);
  ws.ws_row = vt->rows;
  ws.ws_col = vt->cols;
  ws.ws_xpixel = ws.ws_col * vt->cw;
  ws.ws_ypixel = ws.ws_row * vt->ch;
  vt->vtpty.pid = vt_forkpty (&vt->vtpty.pty, NULL, NULL, &ws);
#endif
  if (vt->vtpty.pid == 0)
    {
      ctx_child_prepare_env (was_pidone, term);

      execvp (argv[0], (char**)argv);
      exit (0);
    }
  else if (vt->vtpty.pid < 0)
    {
      VT_error ("forkpty failed (%s)", argv[0]);
      return;
    }
  fcntl(vt->vtpty.pty, F_SETFL, O_NONBLOCK|O_NOCTTY);
  _ctx_add_listen_fd (vt->vtpty.pty);
}


VT *vt_new_argv (char **argv, int width, int height, float font_size, float line_spacing, int id, int can_launch)
{
  VT *vt                 = ctx_calloc (sizeof (VT), 1);
  vt_init (vt, width, height, font_size, line_spacing, id, can_launch);
  vt_set_font_size (vt, font_size);
  vt_set_line_spacing (vt, line_spacing);
  //if (argv)
    {
      vt_run_argv (vt, argv, NULL);
    }
  if (width <= 0) width = 640;
  if (height <= 0) width = 480;
  vt_set_px_size (vt, width, height);

  vtcmd_reset_to_initial_state (vt, NULL);
  //vt->ctx = ctx_new ();
  ctx_list_prepend (&ctx_vts, vt);
  return vt;
}

static char *string_chop_head (char *orig) /* return pointer to reset after arg */
{
  int j=0;
  int eat=0; /* number of chars to eat at start */

  if(orig)
    {
      int got_more;
      char *o = orig;
      while(o[j] == ' ')
        {j++;eat++;}

      if (o[j]=='"')
        {
          eat++;j++;
          while(o[j] != '"' &&
                o[j] != 0)
            j++;
          o[j]='\0';
          j++;
        }
      else if (o[j]=='\'')
        {
          eat++;j++;
          while(o[j] != '\'' &&
                o[j] != 0)
            j++;
          o[j]='\0';
          j++;
        }
      else
        {
          while(o[j] != ' ' &&
                o[j] != 0 &&
                o[j] != ';')
            j++;
        }
      if (o[j] == 0 ||
          o[j] == ';')
        got_more = 0;
      else
        got_more = 1;
      o[j]=0; /* XXX: this is where foo;bar won't work but foo ;bar works*/

      if(eat)
       {
         int k;
         for (k=0; k<j-eat; k++)
           orig[k] = orig[k+eat];
       }
      if (got_more)
        return &orig[j+1];
    }
  return NULL;
}


VT *vt_new (const char *command, int width, int height, float font_size, float line_spacing, int id, int can_launch)
{
  if (!command)
    return vt_new_argv (NULL, width, height, font_size, line_spacing, id, can_launch);
  char *cargv[32];
  int   cargc;
  char *rest, *copy;
  copy = ctx_calloc (strlen (command)+2, 1); // XXX leaked!
  strcpy (copy, command);
  rest = copy;
  cargc = 0;
  while (rest && cargc < 30 && rest[0] != ';')
  {
    cargv[cargc++] = rest;
    rest = string_chop_head (rest);
  }
  cargv[cargc] = NULL;
  VT *ret = vt_new_argv ((char**)cargv, width, height, font_size, line_spacing, id, can_launch);
  ret->arg_copy = copy;
  return ret;
}

float vt_cw (VT *vt)
{
  return vt->cw;
}

float vt_ch (VT *vt)
{
  return vt->ch;
}


static int vt_trimlines (VT *vt, int max)
{
  CtxList *chop_point = NULL;
  CtxList *l;
  int i;
  if (vt->line_count < max)
    { 
      return 0;
    }
  for (l = vt->lines, i = 0; l && i < max-1; l = l->next, i++);
  if (l)
    {
      chop_point = l->next;
      l->next = NULL;
    }
  while (chop_point)
    {
      if (vt->in_alt_screen)
        {
          vt_line_free2 (vt, chop_point->data);
        }
      else
        {
          ctx_list_prepend (&vt->scrollback, chop_point->data);
          vt->scrollback_count ++;
        }
      ctx_list_remove (&chop_point, chop_point->data);
      vt->line_count--;
    }

  if (vt->scrollback_count > vt->scrollback_limit + 256)
    {
      CtxList *l = vt->scrollback;
      int no = 0;
      while (l && no < vt->scrollback_limit)
        {
          l = l->next;
          no++;
        }
      chop_point = NULL;
      if (l)
        {
          chop_point = l->next;
          l->next = NULL;
        }
      while (chop_point)
        {
          vt_line_free2 (vt, chop_point->data);
          ctx_list_remove (&chop_point, chop_point->data);
          vt->scrollback_count --;
        }
    }
  return 0;
}

static void vt_rewrap_pair (VT *vt, VtLine *topline, VtLine *bottomline, int max_col)
{
  int toplen = 0;

  while ((toplen = vt_line_get_utf8length (topline)) > max_col)
  {
     uint32_t unichar = vt_line_get_unichar (topline, toplen-1);
     uint32_t style =  vt_line_get_style (topline, toplen-1);
     vt_line_insert_unichar (bottomline, 0, unichar);
     vt_line_remove (topline, toplen-1);
     vt_line_set_style (bottomline, 0, style);
  }

  while (vt_line_get_length (bottomline) &&
         (toplen = vt_line_get_utf8length (topline)) < max_col)
  {
     uint32_t unichar = vt_line_get_unichar (bottomline, 0);
     uint32_t style =  vt_line_get_style (bottomline, 0);
     vt_line_append_unichar (topline, unichar);
     vt_line_set_style (topline, toplen, style);
     vt_line_remove (bottomline, 0);
  }
}

static void vt_rewrap (VT *vt, int max_col)
{
  if (max_col < 8) max_col = 8;
  CtxList *list = NULL;

  for (CtxList *l = vt->lines; l;)
  {
    CtxList *next = l->next;
    ctx_list_prepend (&list, l->data);
    ctx_list_remove (&vt->lines, l->data);
    l = next;
  }
  for (CtxList *l = vt->scrollback; l;)
  {
    CtxList *next = l->next;
    ctx_list_prepend (&list, l->data);
    ctx_list_remove (&vt->scrollback, l->data);
    l = next;
  }

  for (CtxList *l = list; l; l = l->next)
    {
      VtLine *line = l->data;
      VtLine *next = l->next ?l->next->data:NULL;

      if (vt_line_get_utf8length (line) >= max_col || (next && next->wrapped))
      {
        if (!next)
        {
          ctx_list_append (&list, vt_line_new2 (vt));
          next = l->next->data;
          next->wrapped = 1;
        }
        else if (!next->wrapped)
        {
          ctx_list_insert_before (&list, l->next, vt_line_new2 (vt));
          next = l->next->data;
          next->wrapped = 1;
        } 
        vt_rewrap_pair (vt, line, next, max_col);
        if (vt_line_get_utf8length (next) == 0)
          ctx_list_remove (&list, l->next->data);
      }
    }

  int rows = vt->rows;
  int total_rows = ctx_list_length (list);

  int scrollback_rows = total_rows - rows;

  int c = 0;
  CtxList *l;
  for (l = list; l && c < scrollback_rows;)
  {
    CtxList *next = l->next;
    ctx_list_prepend (&vt->scrollback, l->data);
    ctx_list_remove (&list, l->data);
    l = next;
    c++;
  }
  for (; l ;)
  {
    CtxList *next = l->next;
    ctx_list_prepend (&vt->lines, l->data);
    ctx_list_remove (&list, l->data);
    l = next;
    c++;
  }
}

void vt_set_term_size (VT *vt, int icols, int irows)
{
  if (vt->rows == irows && vt->cols == icols)
    return;

#if CTX_PARSER
  if (vt->state == vt_state_ctx)
  {
    // we should queue a pending resize instead,
    // .. or set a flag indicating that the last
    // rendered frame is discarded?
    return;
  }
#endif

  if(1)vt_rewrap (vt, icols);

  while (irows > vt->rows)
    {
      if (vt->scrollback_count && vt->scrollback)
        {
          vt->scrollback_count--;
          ctx_list_append (&vt->lines, vt->scrollback->data);
          ctx_list_remove (&vt->scrollback, vt->scrollback->data);
          vt->cursor_y++;
        }
      else
        {
          ctx_list_prepend (&vt->lines, vt_line_new2 (vt));
        }
      vt->line_count++;
      vt->rows++;
    }
  while (irows < vt->rows)
    {
      vt->cursor_y--;
      vt->rows--;
    }
  vt->rows = irows;
  vt->cols = icols;
  vt_resize (vt, vt->cols, vt->rows, vt->width, vt->height);
  vt_trimlines (vt, vt->rows);
  vt->margin_top     = 1;
  vt->margin_left    = 1;
  vt->margin_bottom  = vt->rows;
  vt->margin_right   = vt->cols;
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
  ctx_client_rev_inc (vt->client);
  vt->size_age = ctx_ticks ();
  VT_info ("resize %i %i", irows, icols);
#if CTX_PARSER
  if (vt->ctxp)
    ctx_parser_destroy (vt->ctxp);
#endif
  vt->ctxp = NULL;
}

void vt_set_px_size (VT *vt, int width, int height)
{
  _vt_compute_cw_ch (vt);
  int cols = width / vt->cw;
  int rows = height / vt->ch;
  vt->width = width;
  vt->height = height;
  vt_set_term_size (vt, cols, rows);
}

void vt_recompute_cols (VT *vt)
{
  int width = vt->width;
  int height = vt->height;
  vt_set_px_size (vt, width, height);
}

static void vt_argument_buf_reset (VT *vt, const char *start)
{
  if (start)
    {
      ctx_strcpy (vt->argument_buf, start);
      vt->argument_buf_len = ctx_strlen (start);
    }
  else
    { vt->argument_buf[vt->argument_buf_len=0]=0; }
}

static inline void vt_argument_buf_add (VT *vt, int ch)
{
  if (vt->argument_buf_len + 1 >= 1024 * 1024 * 16)
    return; 
  //
  if (vt->argument_buf_len + 1 >=
      vt->argument_buf_cap)
    {
      vt->argument_buf_cap = vt->argument_buf_cap * 2;
      vt->argument_buf = ctx_realloc (vt->argument_buf, vt->argument_buf_cap/2, vt->argument_buf_cap);
    }
  vt->argument_buf[vt->argument_buf_len] = ch;
  vt->argument_buf[++vt->argument_buf_len] = 0;
}

static void
_vt_move_to (VT *vt, int y, int x)
{
  int i;
  x = x < 1 ? 1 : (x > vt->cols ? vt->cols : x);
  y = y < 1 ? 1 : (y > vt->rows ? vt->rows : y);
  vt->at_line_home = 0;
  vt->cursor_x = x;
  vt->cursor_y = y;
  i = vt->rows - y;
  CtxList *l;
  vt->current_line = vt->lines->data;
  for (l = vt->lines; l && i >= 1; l = l->next, i--);
  if (l)
    {
      vt->current_line = l->data;
    }
  else
    {
      for (; i > 0; i--)
        {
          vt->current_line = vt_line_new2 (vt);
          ctx_list_append (&vt->lines, vt->current_line);
          vt->line_count++;
        }
    }
  VT_cursor ("%i,%i (_vt_move_to)", y, x);
  ctx_client_rev_inc (vt->client);
}

static void vt_scroll (VT *vt, int amount);

static void _vt_add_str (VT *vt, const char *str)
{
  int logical_margin_right = VT_MARGIN_RIGHT;
  vt->current_line->contains_proportional |= ((vt->cstyle & STYLE_PROPORTIONAL)==STYLE_PROPORTIONAL);
  if (vt->cursor_x > logical_margin_right)
    {
      if (vt->autowrap) // XXX : needs revisiting old_line is messed up after fuzz fixes
        {
          int chars = 0;
          int old_x = vt->cursor_x;
          VtLine *old_line = vt->current_line;
          if (vt->justify && str[0] != ' ')
            {
              while (old_x-1-chars >1 && vt_line_get_unichar (vt->current_line,
                     old_x-1-chars) !=' ')
                {
                  chars++;
                }
              chars--;
              if (chars > (vt->margin_right - vt->margin_left) * 3 / 2)
                { chars = 0; }
            }
          if (vt->cursor_y == vt->margin_bottom)
            {
              vt_scroll (vt, -1);
              old_line = vt->current_line;
            }
          else
            {
              _vt_move_to (vt, vt->cursor_y+1, 1);
            }
          vt->current_line->wrapped=1;
          vt_carriage_return (vt);
          for (int i = 0; i < chars; i++)
            {
              vt_line_set_style (vt->current_line, vt->cursor_x-1, vt->cstyle);
              vt_line_replace_unichar (vt->current_line, vt->cursor_x - 1,
                                         vt_line_get_unichar (old_line, old_x-1-chars+i) );
              vt->cursor_x++;
            }
          for (int i = 0; i < chars; i++)
            {
              vt_line_replace_unichar (old_line, old_x-1-chars+i, ' ');
            }
          if (str[0] == ' ')
            return;
        }
      else
        {
          vt->cursor_x = logical_margin_right;
        }
    }
  if (vt->insert_mode)
    {
      vt_line_insert_utf8 (vt->current_line, vt->cursor_x - 1, str);
      vt_line_set_style (vt->current_line, vt->cursor_x-1, vt->cstyle);
      while (vt->current_line->string.utf8_length > logical_margin_right)
        { vt_line_remove (vt->current_line, logical_margin_right); }
    }
  else
    {
      vt_line_set_style (vt->current_line, vt->cursor_x-1, vt->cstyle);
      vt_line_replace_utf8 (vt->current_line, vt->cursor_x - 1, str);
    }
  vt->cursor_x += 1;
  vt->at_line_home = 0;
  ctx_client_rev_inc (vt->client);
}

static void _vt_backspace (VT *vt)
{
  if (vt->current_line)
    {
      vt->cursor_x --;
      if (vt->cursor_x == VT_MARGIN_RIGHT) { vt->cursor_x--; }
      if (vt->cursor_x < VT_MARGIN_LEFT)
        {
          vt->cursor_x = VT_MARGIN_LEFT;
          vt->at_line_home = 1;
        }
      VT_cursor ("backspace");
    }
  ctx_client_rev_inc (vt->client);
}

static void vtcmd_set_top_and_bottom_margins (VT *vt, const char *sequence)
{
  int top = 1, bottom = vt->rows;
  /* w3m issues this; causing reset of cursor position, why it is issued
   * is unknown 
   */
  if (!strcmp (sequence, "[?1001r"))
    return;
  if (strlen (sequence) > 2)
    {
      sscanf (sequence, "[%i;%ir", &top, &bottom);
    }
  VT_info ("margins: %i %i", top, bottom);
  if (top <1) { top = 1; }
  if (top > vt->rows) { top = vt->rows; }
  if (bottom > vt->rows) { bottom = vt->rows; }
  if (bottom < top) { bottom = top; }
  vt->margin_top = top;
  vt->margin_bottom = bottom;
#if 0
  _vt_move_to (vt, top, 1);
#endif
  vt_carriage_return (vt);
  VT_cursor ("%i, %i (home)", top, 1);
}
static void vtcmd_save_cursor_position (VT *vt, const char *sequence);

static void vtcmd_set_left_and_right_margins (VT *vt, const char *sequence)
{
  int left = 1, right = vt->cols;
  if (!vt->left_right_margin_mode)
    {
      vtcmd_save_cursor_position (vt, sequence);
      return;
    }
  if (strlen (sequence) > 2)
    {
      sscanf (sequence, "[%i;%is", &left, &right);
    }
  VT_info ("hor margins: %i %i", left, right);
  if (left <1) { left = 1; }
  if (left > vt->cols) { left = vt->cols; }
  if (right > vt->cols) { right = vt->cols; }
  if (right < left) { right = left; }
  vt->margin_left = left;
  vt->margin_right = right;
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
  vt_carriage_return (vt);
  //VT_cursor ("%i, %i (home)", left, 1);
}

static inline int parse_int (const char *arg, int def_val)
{
  if (!((arg[1]>='0' && arg[1]<='9')) || ctx_strlen (arg) == 2)
    { return def_val; }
  return ctx_atoi (arg+1);
}

static void vtcmd_set_line_home (VT *vt, const char *sequence)
{
  int val = parse_int (sequence, 1);
  if (val < 0) val = 0;
  char buf[256];
  vt->left_right_margin_mode = 1;
  sprintf (buf, "[%i;%it", val, vt->margin_right);
  vtcmd_set_left_and_right_margins (vt, buf);
}

static void vtcmd_set_line_limit (VT *vt, const char *sequence)
{
  int val = parse_int (sequence, 0);
  char buf[256];
  vt->left_right_margin_mode = 1;
  if (val < vt->margin_left) { val = vt->margin_left; }
  sprintf (buf, "[%i;%it", vt->margin_left, val);
  vtcmd_set_left_and_right_margins (vt, buf);
}

static void vt_scroll (VT *vt, int amount)
{
  int remove_no, insert_before;
  VtLine *string = NULL;
  if (amount == 0) { amount = 1; }
  if (amount < 0)
    {
      remove_no = vt->margin_top;
      insert_before = vt->margin_bottom;
    }
  else
    {
      remove_no = vt->margin_bottom;
      insert_before = vt->margin_top;
    }
  CtxList *l;
  int i;
  for (i=vt->rows, l = vt->lines; i > 0 && l; l=l->next, i--)
    {
      if (i == remove_no)
        {
          string = l->data;
          ctx_list_remove (&vt->lines, string);
          break;
        }
    }
  if (string)
    {
      if (!vt->in_alt_screen &&
          (vt->margin_top == 1 && vt->margin_bottom == vt->rows) )
        {
          ctx_list_prepend (&vt->scrollback, string);
          vt->scrollback_count ++;
        }
      else
        {
          vt_line_free2 (vt, string);
        }
    }
  string = vt_line_new2 (vt);
  if (amount > 0 && vt->margin_top == 1)
    {
      ctx_list_append (&vt->lines, string);
    }
  else
    {
      for (i=vt->rows, l = vt->lines; l; l=l->next, i--)
        {
          if (i == insert_before)
            {
              ctx_list_insert_before (&vt->lines, l, string);
              break;
            }
        }
      if (i != insert_before)
        {
          ctx_list_append (&vt->lines, string);
        }
    }
  vt->current_line = string;
  /* not updating line count since we should always remove one and add one */
  if (vt->smooth_scroll)
    {
      if (amount < 0)
        {
          vt->scroll_offset = -1.0;
          vt->in_smooth_scroll = -1;
        }
      else
        {
          vt->scroll_offset = 1.0;
          vt->in_smooth_scroll = 1;
        }
    }

  {
    vt->select_begin_row += amount;
    vt->select_end_row += amount;
    vt->select_start_row += amount;
  }
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
}

typedef struct Sequence
{
  const char *prefix;
  char        suffix;
  void (*vtcmd) (VT *vt, const char *sequence);
  uint32_t    compat;
} Sequence;

static void vtcmd_cursor_position (VT *vt, const char *sequence)
{
  int y = 1, x = 1;
  const char *semi;
  if (sequence[0] != 'H' && sequence[0] != 'f')
    {
      y = parse_int (sequence, 1);
      if ( (semi = ctx_strchr (sequence, ';') ) )
        {
          x = parse_int (semi, 1);
        }
    }
  if (x == 0) { x = 1; }
  if (y == 0) { y = 1; }
  if (vt->origin)
    {
      y += vt->margin_top - 1;
      _vt_move_to (vt, y, vt->cursor_x);
      x += VT_MARGIN_LEFT - 1;
    }
  VT_cursor ("%i %i CUP", y, x);
  _vt_move_to (vt, y, x);
}


static void vtcmd_horizontal_position_absolute (VT *vt, const char *sequence)
{
  int x = parse_int (sequence, 1);
  if (x<=0) { x = 1; }
  _vt_move_to (vt, vt->cursor_y, x);
}

static void vtcmd_goto_row (VT *vt, const char *sequence)
{
  int y = parse_int (sequence, 1);
  _vt_move_to (vt, y, vt->cursor_x);
}

static void vtcmd_cursor_forward (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n>vt->cols)n=vt->cols;
  if (n==0) { n = 1; }
  for (int i = 0; i < n; i++)
    {
      vt->cursor_x++;
    }
  if (vt->cursor_x > VT_MARGIN_RIGHT)
    { vt->cursor_x = VT_MARGIN_RIGHT; }
}

static void vtcmd_cursor_backward (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n>vt->cols)n=vt->cols;
  if (n==0) { n = 1; }
  for (int i = 0; i < n; i++)
    {
      vt->cursor_x--;
    }
  if (vt->cursor_x < VT_MARGIN_LEFT)
    {
      vt->cursor_x = VT_MARGIN_LEFT; // should this wrap??
      vt->at_line_home = 1;
    }
}

static void vtcmd_reverse_index (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n>vt->rows)n=vt->rows;
  if (n==0) { n = 1; }
  for (int i = 0; i < n; i++)
    {
      if (vt->cursor_y == vt->margin_top)
        {
          vt_scroll (vt, 1);
          _vt_move_to (vt, vt->margin_top, vt->cursor_x);
        }
      else
        {
          _vt_move_to (vt, vt->cursor_y-1, vt->cursor_x);
        }
    }
}

static void vtcmd_cursor_up (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n>vt->rows)n=vt->rows;
  if (n==0) { n = 1; }
  for (int i = 0; i < n; i++)
    {
      if (vt->cursor_y == vt->margin_top)
        {
          //_vt_move_to (vt, 1, vt->cursor_x);
        }
      else
        {
          _vt_move_to (vt, vt->cursor_y-1, vt->cursor_x);
        }
    }
}

static void vtcmd_back_index (VT *vt, const char *sequence)
{
  // XXX implement
}

static void vtcmd_forward_index (VT *vt, const char *sequence)
{
  // XXX implement
}

static void vtcmd_index (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n>vt->rows)n=vt->rows;
  if (n==0) { n = 1; }
  for (int i = 0; i < n; i++)
    {
      if (vt->cursor_y == vt->margin_bottom)
        {
          vt_scroll (vt, -1);
          _vt_move_to (vt, vt->margin_bottom, vt->cursor_x);
        }
      else
        {
          _vt_move_to (vt, vt->cursor_y + 1, vt->cursor_x);
        }
    }
}

static void vtcmd_cursor_down (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n>vt->rows)n=vt->rows;
  if (n==0) { n = 1; }
  for (int i = 0; i < n; i++)
    {
      if (vt->cursor_y >= vt->margin_bottom)
        {
          _vt_move_to (vt, vt->margin_bottom, vt->cursor_x);
        }
      else
        {
          _vt_move_to (vt, vt->cursor_y + 1, vt->cursor_x);
        }
    }
}

static void vtcmd_next_line (VT *vt, const char *sequence)
{
  vtcmd_index (vt, sequence);
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
  vt_carriage_return (vt);
  vt->cursor_x = VT_MARGIN_LEFT;
}

static void vtcmd_cursor_preceding_line (VT *vt, const char *sequence)
{
  vtcmd_cursor_up (vt, sequence);
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
  vt->cursor_x = VT_MARGIN_LEFT;
}

static void vtcmd_erase_in_line (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 0);
  if (n>vt->cols)n=vt->cols;
  switch (n)
    {
      case 0: // clear to end of line
        {
          char *p = (char *) ctx_utf8_skip (vt->current_line->string.str, vt->cursor_x-1);
          if (p) { *p = 0; }
          // XXX : this is chopping lines
          for (int col = vt->cursor_x; col <= VT_MARGIN_RIGHT; col++)
            { vt_line_set_style (vt->current_line, col - 1, vt->cstyle); }
          vt->current_line->string.length = strlen (vt->current_line->string.str);
          vt->current_line->string.utf8_length = ctx_utf8_strlen (vt->current_line->string.str);
        }
        break;
      case 1: // clear from beginning to cursor
        {
          for (int col = VT_MARGIN_LEFT; col <= vt->cursor_x; col++)
            {
              vt_line_replace_utf8 (vt->current_line, col-1, " ");
            }
          for (int col = VT_MARGIN_LEFT; col <= vt->cursor_x; col++)
            { vt_line_set_style (vt->current_line, col-1, vt->cstyle); }
          vt->current_line->string.length = strlen (vt->current_line->string.str);
          vt->current_line->string.utf8_length = ctx_utf8_strlen (vt->current_line->string.str); // should be a nop
        }
        break;
      case 2: // clear entire line
        for (int col = VT_MARGIN_LEFT; col <= VT_MARGIN_RIGHT; col++)
          { vt_line_set_style (vt->current_line, col-1, vt->cstyle); }
        vt_line_set (vt->current_line, ""); // XXX not all
        break;
    }
}

static void vtcmd_erase_in_display (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 0);
  switch (n)
    {
      case 0: // clear to end of screen
        {
          char *p = (char *) ctx_utf8_skip (vt->current_line->string.str, vt->cursor_x-1);
          if (p) { *p = 0; }
          vt->current_line->string.length = strlen (vt->current_line->string.str);
          vt->current_line->string.utf8_length = ctx_utf8_strlen (vt->current_line->string.str);
        }
        for (int col = vt->cursor_x; col <= VT_MARGIN_RIGHT; col++)
          { vt_line_set_style (vt->current_line, col-1, vt->cstyle); }
        {
          CtxList *l;
          int no = vt->rows;
          for (l = vt->lines; l && l->data != vt->current_line; l = l->next, no--)
            {
              VtLine *buf = l->data;
              buf->string.str[0] = 0;
              buf->string.length = 0;
              buf->string.utf8_length = 0;
              for (int col = 1; col <= vt->cols; col++)
                { vt_line_set_style (buf, col-1, vt->cstyle); }
            }
        }
        break;
      case 1: // clear from beginning to cursor
        {
          for (int col = 1; col <= vt->cursor_x; col++)
            {
              vt_line_replace_utf8 (vt->current_line, col-1, " ");
              vt_line_set_style (vt->current_line, col-1, vt->cstyle);
            }
        }
        {
          CtxList *l;
          int there_yet = 0;
          int no = vt->rows;
          for (l = vt->lines; l; l = l->next, no--)
            {
              VtLine *buf = l->data;
              if (there_yet)
                {
                  buf->string.str[0] = 0;
                  buf->string.length = 0;
                  buf->string.utf8_length = 0;
                  for (int col = 1; col <= vt->cols; col++)
                    { vt_line_set_style (buf, col-1, vt->cstyle); }
                }
              if (buf == vt->current_line)
                {
                  there_yet = 1;
                }
            }
        }
        break;
      case 3: // also clear scrollback
        while (vt->scrollback)
        {
           vt_line_free2 (vt, vt->scrollback->data);
           ctx_list_remove (&vt->scrollback, vt->scrollback->data);
         }
        vt->scrollback_count = 0;
        /* FALLTHROUGH */
      case 2: // clear entire screen but keep cursor;
        {
          int tx = vt->cursor_x;
          int ty = vt->cursor_y;
          vtcmd_clear (vt, "");
          _vt_move_to (vt, ty, tx);
          for (CtxList *l = vt->lines; l; l = l->next)
            {
              VtLine *line = l->data;
              for (int col = 1; col <= vt->cols; col++)
                { vt_line_set_style (line, col-1, vt->cstyle); }
            }
        }
        break;
    }
}

static void vtcmd_screen_alignment_display (VT *vt, const char *sequence)
{
  for (int y = 1; y <= vt->rows; y++)
    {
      _vt_move_to (vt, y, 1);
      for (int x = 1; x <= vt->cols; x++)
        {
          _vt_add_str (vt, "E");
        }
    }
}

#if 0
static int find_idx (int r, int g, int b)
{
  r = r / 255.0f * 5;
  g = g / 255.0f * 5;
  b = b / 255.0f * 5;
  return 16 + r * 6 * 6 + g * 6 + b;
}
#endif

static void vtcmd_set_graphics_rendition (VT *vt, const char *sequence)
{
  const char *s = sequence;
  if (s[0]) { s++; }
  while (s && *s)
    {
      int n = parse_int (s - 1, 0); // works until color
      // both fg and bg could be set in 256 color mode FIXME
      //
      /* S_GR@38@Set forground color@foo bar baz@ */
      if (n == 38) // set foreground
        {
          s = ctx_strchr (s, ';');
          if (!s)
            {
              VT_warning ("incomplete [38m expected ;  %s", sequence);
              return;
            }
          n = parse_int (s, 0);
          if (n == 5)
            {
              s++;
              if (ctx_strchr (s, ';') )
                { s = ctx_strchr (s, ';'); }
              else
                { s = ctx_strchr (s, ':'); }
              if (s)
                {
                  n = parse_int (s, 0);
                  set_fg_idx (n);
                  s++;
                  while (*s && *s >= '0' && *s <='9') { s++; }
                }
            }
          else if (n == 2)
            {
              int r = 0, g = 0, b = 0;
              s++;
              if (strchr (s, ';') )
                {
                  s = ctx_strchr (s, ';');
                  if (s)
                    { 
                      r = ctx_atoi (s+1);
                      s = ctx_strchr (s+1, ';');
                      if (s)
                      {
                        g = ctx_atoi (s+1);
                        s = ctx_strchr (s+1, ';');
                        if (s)
                        {
                          b = ctx_atoi (s+1);
                        }
                      }
                    }
                }
              else
                {
                  s = ctx_strchr (s, ':');
                  if (s)
                    { 
                      r = ctx_atoi (s+1);
                      s = ctx_strchr (s+1, ':');
                      if (s)
                      {
                        g = ctx_atoi (s+1);
                        s = ctx_strchr (s+1, ':');
                        if (s)
                        {
                          b = ctx_atoi (s+1);
                        }
                      }
                    }
                }
              if (s)
              for (int i = 0; i < 3; i++)
                {
                  if (*s)
                    {
                      s++;
                      while (*s && *s >= '0' && *s <='9') { s++; }
                    }
                }
              set_fg_rgb (r,g,b);
            }
          else
            {
              VT_warning ("unhandled %s %i", sequence, n);
              return;
            }
          //return; // XXX we should continue, and allow further style set after complex color
        }
      else if (n == 48) // set background
        {
          s = ctx_strchr (s, ';');
          if (!s)
            {
              VT_warning ("incomplete [38m expected ;  %s", sequence);
              return;
            }
          n = parse_int (s, 0);
          if (n == 5)
            {
              s++;
              if (ctx_strchr (s, ';') )
                { s = ctx_strchr (s, ';'); }
              else
                { s = ctx_strchr (s, ':'); }
              if (s)
                { n = parse_int (s, 0); }
              set_bg_idx (n);
              if (s)
                {
                  s++;
                  while (*s && *s >= '0' && *s <='9') { s++; }
                }
            }
          else if (n == 2)
            {
              int r = 0, g = 0, b = 0;
              s++;
              if (ctx_strchr (s, ';') )
                {
                  s = ctx_strchr (s, ';');
                  if (s)
                    { 
                      r = ctx_atoi (s+1);
                      s = ctx_strchr (s+1, ';');
                      if (s)
                      {
                        g = ctx_atoi (s+1);
                        s = ctx_strchr (s+1, ';');
                        if (s)
                        {
                          b = ctx_atoi (s+1);
                        }
                      }
                    }
                }
              else
                {
                  s = ctx_strchr (s, ':');
                  if (s)
                    { 
                      r = ctx_atoi (s+1);
                      s = ctx_strchr (s+1, ';');
                      if (s)
                      {
                        g = ctx_atoi (s+1);
                        s = ctx_strchr (s+1, ';');
                        if (s)
                        {
                          b = ctx_atoi (s+1);
                        }
                      }
                    }
                }
              if (s)
              for (int i = 0; i < 3; i++)
                {
                  s++;
                  while (*s >= '0' && *s <='9') { s++; }
                }
              set_bg_rgb (r,g,b);
            }
          else
            {
              VT_warning ("unhandled %s %i", sequence, n);
              return;
            }
          //return; // we XXX should continue, and allow further style set after complex color
        }
      else
        switch (n)
          {
            case 0: /* SGR@0@Style reset@@ */
              if (vt->cstyle & STYLE_PROPORTIONAL)
                { vt->cstyle = STYLE_PROPORTIONAL; }
              else
                { vt->cstyle = 0; }
              break;
            case 1: /* SGR@@Bold@@ */
              vt->cstyle |= STYLE_BOLD;
              break;
            case 2: /* SGR@@Dim@@ */
              vt->cstyle |= STYLE_DIM;
              break;
            case 3: /* SGR@@Italic@@ */
              vt->cstyle |= STYLE_ITALIC;
              break;
            case 4: /* SGR@@Underscore@@ */
                    /* SGR@4:2@Double underscore@@ */
                    /* SGR@4:3@Curvy underscore@@ */
              if (s[1] == ':')
                {
                  switch (s[2])
                    {
                      case '0':
                        break;
                      case '1':
                        vt->cstyle |= STYLE_UNDERLINE;
                        break;
                      case '2':
                        vt->cstyle |= STYLE_UNDERLINE|
                                      STYLE_UNDERLINE_VAR;
                        break;
                      default:
                      case '3':
                        vt->cstyle |= STYLE_UNDERLINE_VAR;
                        break;
                    }
                }
              else
                {
                  vt->cstyle |= STYLE_UNDERLINE;
                }
              break;
            case 5: /* SGR@@Blink@@ */
              vt->cstyle |= STYLE_BLINK;
              break;
            case 6: /* SGR@@Blink Fast@@ */
              vt->cstyle |= STYLE_BLINK_FAST;
              break;
            case 7: /* SGR@@Reverse@@ */
              vt->cstyle |= STYLE_REVERSE;
              break;
            case 8: /* SGR@@Hidden@@ */
              vt->cstyle |= STYLE_HIDDEN;
              break;
            case 9: /* SGR@@Strikethrough@@ */
              vt->cstyle |= STYLE_STRIKETHROUGH;
              break;
            case 10: /* SGR@@Font 0@@ */
              break;
            case 11: /* SGR@@Font 1@@ */
              break;
            case 12: /* SGR@@Font 2(ignored)@@ */
            case 13: /* SGR@@Font 3(ignored)@@ */
            case 14: /* SGR@@Font 4(ignored)@@ */
              break;
            case 22: /* SGR@@Bold off@@ */
              vt->cstyle ^= (vt->cstyle & STYLE_BOLD);
              vt->cstyle ^= (vt->cstyle & STYLE_DIM);
              break;
            case 23: /* SGR@@Italic off@@ */
              vt->cstyle ^= (vt->cstyle & STYLE_ITALIC);
              break;
            case 24: /* SGR@@Underscore off@@ */
              vt->cstyle ^= (vt->cstyle & (STYLE_UNDERLINE|STYLE_UNDERLINE_VAR) );
              break;
            case 25: /* SGR@@Blink off@@ */
              vt->cstyle ^= (vt->cstyle & STYLE_BLINK);
              vt->cstyle ^= (vt->cstyle & STYLE_BLINK_FAST);
              break;
            case 26: /* SGR@@Proportional spacing @@ */
              vt->cstyle |= STYLE_PROPORTIONAL;
              break;
            case 27: /* SGR@@Reverse off@@ */
              vt->cstyle ^= (vt->cstyle & STYLE_REVERSE);
              break;
            case 28: /* SGR@@Hidden off@@ */
              vt->cstyle ^= (vt->cstyle & STYLE_HIDDEN);
              break;
            case 29: /* SGR@@Strikethrough off@@ */
              vt->cstyle ^= (vt->cstyle & STYLE_STRIKETHROUGH);
              break;
            case 30: /* SGR@@black text color@@ */
              set_fg_idx (0);
              break;
            case 31: /* SGR@@red text color@@ */
              set_fg_idx (1);
              break;
            case 32: /* SGR@@green text color@@ */
              set_fg_idx (2);
              break;
            case 33: /* SGR@@yellow text color@@ */
              set_fg_idx (3);
              break;
            case 34: /* SGR@@blue text color@@ */
              set_fg_idx (4);
              break;
            case 35: /* SGR@@magenta text color@@ */
              set_fg_idx (5);
              break;
            case 36: /* SGR@@cyan text color@@ */
              set_fg_idx (6);
              break;
            case 37: /* SGR@@light gray text color@@ */
              set_fg_idx (7);
              break;
          /* SGR@38;5;Pn@256 color index foreground color@where Pn is 0-15 is system colors 16-(16+6*6*6) is a 6x6x6  RGB cube and in the end a grayscale without white and black.@ */
              /* SGR@38;2;Pr;Pg;Pb@24 bit RGB foreground color each of Pr Pg and Pb have 0-255 range@@ */
            case 39: /* SGR@@default text color@@ */
              set_fg_idx (vt->reverse_video?0:15);
              vt->cstyle ^= (vt->cstyle & STYLE_FG_COLOR_SET);
              break;
            case 40: /* SGR@@black background color@@ */
              set_bg_idx (0);  // XXX XXX why|where does 0,0,1 work, when idx 0 and 0,0,0 does not?
              //set_bg_rgb(0, 0, 1); //
              break;
            case 41: /* SGR@@red background color@@ */
              set_bg_idx (1);
              break;
            case 42: /* SGR@@green background color@@ */
              set_bg_idx (2);
              break;
            case 43: /* SGR@@yellow background color@@ */
              set_bg_idx (3);
              break;
            case 44: /* SGR@@blue background color@@ */
              set_bg_idx (4);
              break;
            case 45: /* SGR@@magenta background color@@ */
              set_bg_idx (5);
              break;
            case 46: /* SGR@@cyan background color@@ */
              set_bg_idx (6);
              break;
            case 47: /* SGR@@light gray background color@@ */
              set_bg_idx (7);
              break;

          /* SGR@48;5;Pn@256 color index background color@where Pn is 0-15 is system colors 16-(16+6*6*6) is a 6x6x6  RGB cube and in the end a grayscale without white and black.@ */
          /* SGR@48;2;Pr;Pg;Pb@24 bit RGB background color@Where Pr Pg and Pb have 0-255 range@ */

            case 49: /* SGR@@default background color@@ */
              set_bg_idx (vt->reverse_video?15:0);
              vt->cstyle ^= (vt->cstyle & STYLE_BG_COLOR_SET);
              break;
            case 50: /* SGR@@Proportional spacing off @@ */
              vt->cstyle ^= (vt->cstyle & STYLE_PROPORTIONAL);
              break;
            // 51 : framed
            // 52 : encircled
            case 53: /* SGR@@Overlined@@ */
              vt->cstyle |= STYLE_OVERLINE;
              break;
            case 55: /* SGR@@Not Overlined@@ */
              vt->cstyle ^= (vt->cstyle&STYLE_OVERLINE);
              break;
            case 90: /* SGR@@dark gray text color@@ */
              set_fg_idx (8);
              break;
            case 91: /* SGR@@light red text color@@ */
              set_fg_idx (9);
              break;
            case 92: /* SGR@@light green text color@@ */
              set_fg_idx (10);
              break;
            case 93: /* SGR@@light yellow text color@@ */
              set_fg_idx (11);
              break;
            case 94: /* SGR@@light blue text color@@ */
              set_fg_idx (12);
              break;
            case 95: /* SGR@@light magenta text color@@ */
              set_fg_idx (13);
              break;
            case 96: /* SGR@@light cyan text color@@ */
              set_fg_idx (14);
              break;
            case 97: /* SGR@@white text color@@ */
              set_fg_idx (15);
              break;
            case 100: /* SGR@@dark gray background color@@ */
              set_bg_idx (8);
              break;
            case 101: /* SGR@@light red background color@@ */
              set_bg_idx (9);
              break;
            case 102: /* SGR@@light green background color@@ */
              set_bg_idx (10);
              break;
            case 103: /* SGR@@light yellow background color@@ */
              set_bg_idx (11);
              break;
            case 104: /* SGR@@light blue background color@@ */
              set_bg_idx (12);
              break;
            case 105: /* SGR@@light magenta background color@@ */
              set_bg_idx (13);
              break;
            case 106: /* SGR@@light cyan background color@@ */
              set_bg_idx (14);
              break;
            case 107: /* SGR@@white background color@@ */
              set_bg_idx (15);
              break;
            default:
              VT_warning ("unhandled style code %i in sequence \\033%s\n", n, sequence);
              return;
          }
      while (s && *s && *s != ';') { s++; }
      if (s && *s == ';') { s++; }
    }
}

static void vtcmd_ignore (VT *vt, const char *sequence)
{
  VT_info ("ignoring sequence %s", sequence);
}

static void vtcmd_clear_all_tabs (VT *vt, const char *sequence)
{
  memset (vt->tabs, 0, sizeof (vt->tabs) );
}

static void vtcmd_clear_current_tab (VT *vt, const char *sequence)
{
  vt->tabs[ vt->cursor_x-1] = 0;
}

static void vtcmd_horizontal_tab_set (VT *vt, const char *sequence)
{
  vt->tabs[ vt->cursor_x-1] = 1;
}

static void vtcmd_save_cursor_position (VT *vt, const char *sequence)
{
  vt->saved_x = vt->cursor_x;
  vt->saved_y = vt->cursor_y;
}

static void vtcmd_restore_cursor_position (VT *vt, const char *sequence)
{
  _vt_move_to (vt, vt->saved_y, vt->saved_x);
}


static void vtcmd_save_cursor (VT *vt, const char *sequence)
{
  vt->saved_style   = vt->cstyle;
  vt->saved_origin  = vt->origin;
  vtcmd_save_cursor_position (vt, sequence);
  for (int i = 0; i < 4; i++)
    { vt->saved_charset[i] = vt->charset[i]; }
}

static void vtcmd_restore_cursor (VT *vt, const char *sequence)
{
  vtcmd_restore_cursor_position (vt, sequence);
  vt->cstyle  = vt->saved_style;
  vt->origin  = vt->saved_origin;
  for (int i = 0; i < 4; i++)
    { vt->charset[i] = vt->saved_charset[i]; }
}

static void vtcmd_erase_n_chars (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n < 0) n = 0;
  if (n > vt->cols) n = vt->cols;
  while (n--) 
    {
      vt_line_replace_utf8 (vt->current_line, vt->cursor_x - 1 + n, " ");
      vt_line_set_style (vt->current_line, vt->cursor_x + n - 1, vt->cstyle);
    }
}

static void vtcmd_delete_n_chars (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n < 0) n = 0;
  if (n > vt->cols) n = vt->cols;
  int count = n;
  while (count--)
    {
      if (vt->cursor_x>0)
        vt_line_remove (vt->current_line, vt->cursor_x - 1);
    }
}

static void vtcmd_delete_n_lines (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n > vt->rows) n = vt->rows;
  for (int a = 0; a < n; a++)
    {
      int i;
      CtxList *l;
      VtLine *string = vt->current_line;
      vt_line_clear (string);
      ctx_list_remove (&vt->lines, string);
      int inserted = 0;
      for (i=vt->rows, l = vt->lines; l; l=l->next, i--)
        {
          if (i == vt->margin_bottom)
            {
              vt->current_line = string;
              ctx_list_insert_before (&vt->lines, l, string);
              inserted = 1;
              break;
            }
        }
      if (!inserted) // XXX : probably not happening in normal use - but
                     //       this keeps expectations of valid current_line
        ctx_list_insert_before (&vt->lines, vt->lines, string);
        
      _vt_move_to (vt, vt->cursor_y, vt->cursor_x); // updates current_line
    }
}

static void vtcmd_insert_character (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n > vt->cols * vt->rows) n = vt->rows * vt->cols;
  if (n <= 0) n = 1;
  while (n--)
    {
      vt_line_insert_utf8 (vt->current_line, vt->cursor_x-1, " ");
      vt_line_set_style (vt->current_line, vt->cursor_x-1, vt->cstyle);
    }
  while (vt->current_line->string.utf8_length > vt->cols)
    { vt_line_remove (vt->current_line, vt->cols); }
}

static void vtcmd_scroll_up (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n > vt->rows) n = vt->rows;
  if (n <= 0) { n = 1; }
  while (n--)
    { vt_scroll (vt, -1); }
}

static void vtcmd_scroll_down (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n > vt->rows) n = vt->rows;
  if (n <= 0) { n = 1; }
  while (n--)
    { vt_scroll (vt, 1); }
}

static void vtcmd_insert_blank_lines (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n > vt->rows) n = vt->rows;
  if (n <= 0)
  { n = 1;
  }
  {
    int st = vt->margin_top;
    int sb = vt->margin_bottom;
    vt->margin_top = vt->cursor_y;
    while (n--)
      {
        vt_scroll (vt, 1);
      }
    vt->margin_top = st;
    vt->margin_bottom = sb;
  }
}

static void vtcmd_set_default_font (VT *vt, const char *sequence)
{
  vt->charset[0] = 0;
}

static void vtcmd_set_alternate_font (VT *vt, const char *sequence)
{
  vt->charset[0] = 1;
}

static void vt_ctx_start_frame (Ctx *ctx, void *data)
{
  ctx_start_frame (ctx);
}

static void vt_ctx_end_frame (Ctx *ctx, void *data)
{
  VT *vt = data;
  vt->state = vt_state_neutral;
  ctx_client_rev_inc (vt->client);
  if (!vt->current_line)
    return;
#if 0
  fprintf (stderr, "\n");
  if (vt->current_line->prev)
  fprintf (stderr, "---prev(%i)----\n%s", (int)strlen(vt->current_line->prev),vt->current_line->prev);
  fprintf (stderr, "---new(%i)----\n%s", (int)strlen(vt->current_line->frame->str),vt->current_line->frame->str);
  fprintf (stderr, "--------\n");
#endif

  void *tmp = vt->current_line->ctx;
  vt->current_line->ctx = vt->current_line->ctx_copy;
  vt->current_line->ctx_copy = tmp;

  if (vt->current_line->ctx && vt->current_line->ctx_copy)
  {
    ctx_set_textureclock (vt->current_line->ctx, ctx_textureclock (vt->current_line->ctx) + 1);
    ctx_set_textureclock (vt->current_line->ctx_copy, ctx_textureclock (vt->current_line->ctx));
  }
#if 1
  if (vt->ctxp) // XXX: ugly hack to aid double buffering
    ((void**)vt->ctxp)[0]= vt->current_line->ctx;
#endif

  //ctx_parser_destroy (vt->ctxp);
  //vt->ctxp = NULL;
}

static int vt_get_prop (Ctx *ctx, VT *vt, const char *key, const char **val, int *len)
{
#if 0
  uint32_t key_hash = ctx_strhash (key);
  char str[4096]="";
  fprintf (stderr, "%s: %s %i\n", __FUNCTION__, key, key_hash);
  CtxClient *client = ctx_client_by_id (ct->id);
  if (!client)
    return 0;
  switch (key_hash)
  {
    case SQZ_title:
      sprintf (str, "setkey %s %s\n", key, client->title);
      break;
    case SQZ_x:      
      sprintf (str, "setkey %s %i\n", key, client->x);
      break;
    case SQZ_y:    
      sprintf (str, "setkey %s %i\n", key, client->y);
      break;
    case SQZ_width:
      sprintf (str, "setkey %s %i\n", key, client->width);
      break;
    case SQZ_height:
      sprintf (str, "setkey %s %i\n", key, client->width);
      break;
    default:
      sprintf (str, "setkey %s undefined\n", key);
      break;
  }
  if (str[0])
  {
    vtpty_write ((void*)ct, str, strlen (str));
    fprintf (stderr, "%s", str);
  }
#endif
  return 0;
}

static void vtcmd_set_mode (VT *vt, const char *sequence)
{
  int set = 1;
  if (sequence[strlen (sequence)-1]=='l')
    { set = 0; }
  if (sequence[1]=='?')
    {
      int qval;
      sequence++;
qagain:
      qval = parse_int (sequence, 1);
      switch (qval)
        {
          case 1: /*MODE;DECCKM;Cursor key mode;Application;Cursor;*/
            vt->cursor_key_application = set;
            break;
          case 2: /*MODE;DECANM;VT52 emulation;on;off; */
            if (set==0)
              { vt->state = vt_state_vt52; }
            break;
#if CTX_VT_132COL
          case 3: /*MODE;DECCOLM;Column mode;132 columns;80 columns;*/
            vtcmd_set_132_col (vt, set);
            break; // set 132 col
#endif
          case 4: /*MODE;DECSCLM;Scrolling mode;smooth;jump;*/
            vt->smooth_scroll = set;
            break;
          case 5: /*MODE;DECSCNM;Screen mode;Reverse;Normal;*/
            vt->reverse_video = set;
            break;
          case 6: /*MODE;DECOM;Origin mode;Relative;Absolute;*/
            vt->origin = set;
            if (set)
              {
                _vt_move_to (vt, vt->margin_top, 1);
                vt_carriage_return (vt);
              }
            else
              { _vt_move_to (vt, 1, 1); }
            break;
          case 7: /*MODE;DECAWM;Autowrap;on;off;*/
            vt->autowrap = set;
            break;
          case 8: /*MODE;DECARM;Auto repeat;on;off;*/
            vt->keyrepeat = set;
            break;
          // case 9: // send mouse x & y on button press 

          // 10 - Block DECEDM
          // 18 - Print form feed  DECPFF  default off
          // 19 - Print extent fullscreen DECPEX  default on
          case 12:
            vtcmd_ignore (vt, sequence);
            break; // blinking_cursor
          case 25:/*MODE;DECTCEM;Cursor visible;on;off; */
            vt->cursor_visible = set;
            break;
          case 30: // from rxvt - show/hide scrollbar
            vt->scrollbar_visible = set;
            break;
          case 34: // DECRLM - right to left mode
            break;
          case 38: // DECTEK - enter tektronix mode
            break;
          case 60: // horizontal cursor coupling
          case 61: // vertical cursor coupling
            break;
          case 69:/*MODE;DECVSSM;Left right margin mode;on;off; */
            vt->left_right_margin_mode = set;
            break;
          case 80:/* DECSDM Sixel scrolling */
            break;
          case 437:/*MODE;;Encoding/cp437mode;cp437;utf8; */
            vt->encoding = set ? 1 : 0;
            break;
          case 1000:/*MODE;;Mouse reporting;on;off;*/
            vt->mouse = set;
            break;
          case 1001:
          case 1002:/*MODE;;Mouse drag;on;off;*/
            vt->mouse_drag = set;
            break;
          case 1003:/*MODE;;Mouse all;on;off;*/
            vt->mouse_all = set;
            break;
          case 1006:/*MODE;;Mouse decimal;on;off;*/
            vt->mouse_decimal = set;
            break;
          case 47:
          case 1047:
          //case 1048:
          case 1049:/*MODE;;Alt screen;on;off;*/
            if (set)
              {
                if (vt->in_alt_screen)
                  {
                  }
                else
                  {
                    vtcmd_save_cursor (vt, "");
                    vt->saved_lines = vt->lines;
                    vt->saved_line_count = vt->line_count;
                    vt->line_count = 0;
                    vt->lines = NULL;
                    for (int i = 0; i <  vt->rows; i++)
                      {
                        vt->current_line = vt_line_new2 (vt);
                        ctx_list_append (&vt->lines, vt->current_line);
                        vt->line_count++;
                      }
                    vt->in_alt_screen = 1;
                    vt->had_alt_screen = 1;
                    vt_line_feed (vt);
                    _vt_move_to (vt, 1, 1);
                    vt_carriage_return (vt);
                  }
              }
            else
              {
                if (vt->in_alt_screen)
                  {
                    while (vt->lines)
                      {
                        vt_line_free2 (vt, vt->lines->data);
                        ctx_list_remove (&vt->lines, vt->lines->data);
                      }
                    vt->line_count = vt->saved_line_count;
                    vt->lines = vt->saved_lines;
                    vtcmd_restore_cursor (vt, "");
                    vt->saved_lines = NULL;
                    vt->in_alt_screen = 0;
                  }
                else
                  {
                  }
              }
            break; // alt screen
          case 1010: /*MODE;;scroll on output;on;off; */ //rxvt
            vt->scroll_on_output = set;
            break;
          case 1011:/*MODE:;scroll on input;on;off; */ //rxvt)
            vt->scroll_on_input = set;
            break;
          case 2004:/*MODE;;bracketed paste;on;off; */
            vt->bracket_paste = set;
            break;
          case 201:/*MODE;;ctx-events;on;off;*/
            vt->ctx_events = set;
            break;
         
#if CTX_PARSER 
          case 200:/*MODE;;ctx vector graphics mode;on;;*/
            if (set)
              {
                if (!vt->current_line->ctx)
                  {
                    vt->current_line->ctx = ctx_new (vt->width, vt->height, "drawlist");
                    vt->current_line->ctx_copy = ctx_new (vt->width, vt->height, "drawlist");
                    ctx_set_texture_cache (vt->current_line->ctx_copy, vt->current_line->ctx);
                    _ctx_set_transformation (vt->current_line->ctx, 0);
                    _ctx_set_transformation (vt->current_line->ctx_copy, 0);

                  }

                {
                  // there is only one parser
                  // but also only one proper global state

                if (vt->ctxp)
                  ctx_parser_destroy (vt->ctxp);

                CtxParserConfig config = {
                   .width = vt->width,
                   .height = vt->height,
                   .cell_width = vt->cw,
                   .cell_height = vt->ch,
                   .cursor_x = vt->cursor_x,
                   .cursor_y = vt->cursor_y,
                   .set_prop = (void*)vt_set_prop,
                   .get_prop = (void*)vt_get_prop,
                   .user_data = vt,
                   .end_frame = vt_ctx_end_frame,
                   .start_frame = vt_ctx_start_frame,
                };
                vt->ctxp = ctx_parser_new (vt->current_line->ctx, &config);
                }
                vt->utf8_holding[vt->utf8_pos=0]=0; // XXX : needed?
                vt->state = vt_state_ctx;

#if CTX_DECOMPRESSOR
                if (vt->current_line->ctx_prev_frame)
                {
                  free (vt->current_line->ctx_prev_frame);
                  vt->current_line->ctx_prev_frame = NULL;
                  vt->current_line->ctx_prev_frame_length = 0;
                }
                if (vt->current_line->ctx_frame)
                {
                  vt->current_line->ctx_prev_frame = vt->current_line->ctx_frame->str;
                  vt->current_line->ctx_prev_frame_length = vt->current_line->ctx_frame->length;
                  ctx_string_free (vt->current_line->ctx_frame, 0);
                }
                vt->current_line->ctx_frame = ctx_string_new ("");
#endif
              }
            break;
#endif
          default:
            VT_warning ("unhandled CSI ? %i%s", qval, set?"h":"l");
            return;
        }
      if (strchr (sequence + 1, ';') )
        {
          sequence = strchr (sequence + 1, ';');
          goto qagain;
        }
    }
  else
    {
      int val;
again:
      val = parse_int (sequence, 1);
      switch (val)
        {
          case 1:/*GATM - transfer enhanced data */
          case 2:/*KAM - keyboard action mode */
            break;
          case 3:/*CRM - control representation mode */
            /* show control chars? */
            break;
          case 4:/*MODE2;IRM;Insert Mode;Insert;Replace; */
            vt->insert_mode = set;
            break;
          case 9: /* interlace mode */
            break;
          case 12:/*MODE2;SRM;Local echo;on;off; */
            vt->echo = set;
            break;
          case 20:/*MODE2;LNM;Carriage Return on LF/Newline;on;off;*/
            ;
            vt->cr_on_lf = set;
            break;
          case 21: // GRCM - whether SGR accumulates or a reset on each command
            break;
          case 32: // WYCRTSAVM - screen saver
            break;
          case 33: // WYSTCURM  - steady cursor
            break;
          case 34: // WYULCURM  - underline cursor
            break;
          default:
            VT_warning ("unhandled CSI %ih", val);
            return;
        }
      if (strchr (sequence, ';') && sequence[0] != ';')
        {
          sequence = strchr (sequence, ';');
          goto again;
        }
    }
}

static void vtcmd_request_mode (VT *vt, const char *sequence)
{
  char buf[64]="";
  if (sequence[1]=='?')
    {
      int qval;
      sequence++;
      qval = parse_int (sequence, 1);
      int is_set = -1; // -1 undefiend   0 reset 1 set  1000 perm_reset  1001 perm_set
      switch (qval)
        {
          case 1:
            is_set = vt->cursor_key_application;
            break;
          case 2: /*VT52 emulation;;enable; */
          //if (set==0) vt->in_vt52 = 1;
            is_set = 1001;
            break;
          case 3:
            is_set = 0;
            break;
          case 4:
            is_set = vt->smooth_scroll;
            break;
          case 5:
            is_set = vt->reverse_video;
            break;
          case 6:
            is_set = vt->origin;
            break;
          case 7:
            is_set = vt->autowrap;
            break;
          case 8:
            is_set = vt->keyrepeat;
            break;
          case 9: // should be dynamic
            is_set = 1000;
            break;
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 16:
          case 18:
          case 19:
            is_set = 1000;
            break;
          case 25:
            is_set = vt->cursor_visible;
            break;
          case 45:
            is_set = 1000;
            break;
          case 47:
            is_set = vt->in_alt_screen;
            break;
          case 69:
            is_set = vt->left_right_margin_mode;
            break;
          case 437:
            is_set = vt->encoding;
            break;
          case 1000:
            is_set = vt->mouse;
            break;
            // 1001 hilite tracking
          case 1002:
            is_set = vt->mouse_drag;
            break;
          case 1003:
            is_set = vt->mouse_all;
            break;
          case 1006:
            is_set = vt->mouse_decimal;
            break;
          case 201:
            is_set = vt->ctx_events;
            break;
          case 2004:
            is_set = vt->bracket_paste;
            break;
          case 1010: // scroll to bottom on tty output (rxvt)
            is_set = vt->scroll_on_output;
            break;
          case 1011: // scroll to bottom on key press (rxvt)
            is_set = vt->scroll_on_input;
            break;
          case 1049:
            is_set = vt->in_alt_screen;
            break;
            break;
#if CTX_PARSER
          case 200:/*ctx protocol;On;;*/
            is_set = (vt->state == vt_state_ctx);
            break;
#endif
          case 30: // from rxvt - show/hide scrollbar
            is_set = vt->scrollbar_visible;
            break;
          case 80:/* DECSDM Sixel scrolling */
          case 34: // DECRLM - right to left mode
          case 60: // horizontal cursor coupling
          case 61: // vertical cursor coupling
          default:
            break;
        }
      switch (is_set)
      {
        case 0:
          sprintf (buf, "\033[?%i;%i$y", qval, 2);
          break;
        case 1:
          { sprintf (buf, "\033[?%i;%i$y", qval, 1); }
          break;
        case 1000:
          sprintf (buf, "\033[?%i;%i$y", qval, 4);
          break;
        case 1001:
          sprintf (buf, "\033[?%i;%i$y", qval, 3);
          break;
        case -1:
          { sprintf (buf, "\033[?%i;%i$y", qval, 0); }
      }
    }
  else
    {
      int val;
      val = parse_int (sequence, 1);
      switch (val)
        {
          case 1:
            sprintf (buf, "\033[%i;%i$y", val, 0);
            break;
          case 2:/* AM - keyboard action mode */
            sprintf (buf, "\033[%i;%i$y", val, 0);
            break;
          case 3:/*CRM - control representation mode */
            sprintf (buf, "\033[%i;%i$y", val, 0);
            break;
          case 4:/*Insert Mode;Insert;Replace; */
            sprintf (buf, "\033[%i;%i$y", val, vt->insert_mode?1:2);
            break;
          case 9: /* interlace mode */
            sprintf (buf, "\033[%i;%i$y", val, 1);
            break;
          case 12:
            sprintf (buf, "\033[%i;%i$y", val, vt->echo?1:2);
            break;
          case 20:/*Carriage Return on LF/Newline;on;off;*/
            ;
            sprintf (buf, "\033[%i;%i$y", val, vt->cr_on_lf?1:2);
            break;
          case 21: // GRCM - whether SGR accumulates or a reset on each command
          default:
            sprintf (buf, "\033[%i;%i$y", val, 0);
        }
    }
  if (buf[0])
    { vt_write (vt, buf, strlen (buf) ); }
}

static void vtcmd_set_t (VT *vt, const char *sequence)
{
  /* \033[21y is request title - allows inserting keychars */
  if      (!strcmp (sequence,  "[1t")) { ctx_client_unshade (vt->root_ctx, vt->id); }
  else if (!strcmp (sequence,  "[2t")) { ctx_client_shade (vt->root_ctx, vt->id); } 
  else if (!strncmp (sequence, "[3;", 3)) {
    int x=0,y=0;
    sscanf (sequence, "[3;%i;%ir", &y, &x);
    ctx_client_move (vt->root_ctx, vt->id, x, y);
  }
  else if (!strncmp (sequence, "[4;", 3))
  {
    int width = 0, height = 0;
    sscanf (sequence, "[4;%i;%ir", &height , &width);
    if (width < 0) width = vt->cols * vt->cw;
    if (height < 0) height = vt->rows * vt->ch;
    if (width == 0) width = ctx_width (vt->root_ctx);
    if (height == 0) height = ctx_height (vt->root_ctx);
    ctx_client_resize (vt->root_ctx, vt->id, width, height);
  }
  else if (!strcmp (sequence, "[5t") ) { ctx_client_raise_top (vt->root_ctx, vt->id); } 
  else if (!strcmp (sequence, "[6t") ) { ctx_client_lower_bottom (vt->root_ctx, vt->id); } 
  else if (!strcmp (sequence, "[7t") ) { 
          ctx_client_rev_inc (vt->client);
          /* refresh */ }
  else if (!strncmp (sequence, "[8;", 3) )
  {
    int cols = 0, rows = 0;
    sscanf (sequence, "[8;%i;%ir", &rows, &cols);
    if (cols < 0) cols = vt->cols;
    if (rows < 0) rows = vt->rows;
    if (cols == 0) cols = ctx_width (vt->root_ctx) / vt->cw;
    if (rows == 0) rows = ctx_height (vt->root_ctx) / vt->ch;
    ctx_client_resize (vt->root_ctx, vt->id, cols * vt->cw, rows * vt->ch);
  }
  else if (!strcmp (sequence, "[9;0t") ) { ctx_client_unmaximize (vt->root_ctx, vt->id); } 
  else if (!strcmp (sequence, "[9;1t") ) { ctx_client_maximize (vt->root_ctx, vt->id);} 

  /* should actually be full-screen */
  else if (!strcmp (sequence, "[10;0t") ) { ctx_client_unmaximize (vt->root_ctx, vt->id); } 
  else if (!strcmp (sequence, "[10;1t") ) { ctx_client_maximize (vt->root_ctx, vt->id);} 
  else if (!strcmp (sequence, "[10;2t") ) { ctx_client_toggle_maximized (vt->root_ctx, vt->id);} 

  else if (!strcmp (sequence, "[11t") )  /* report window state  */
    {
      char buf[128];
      if (ctx_client_is_iconified (vt->root_ctx, vt->id))
        sprintf (buf, "\033[2t");
      else
        sprintf (buf, "\033[1t");
      vt_write (vt, buf, strlen (buf) );
    }
  else if (!strcmp (sequence, "[13t") ) /* request terminal position */
    {
      char buf[128];
      sprintf (buf, "\033[3;%i;%it", ctx_client_y (vt->root_ctx, vt->id), ctx_client_x (vt->root_ctx, vt->id));
      vt_write (vt, buf, strlen (buf) );
    }
  else if (!strcmp (sequence, "[14t") ) /* request terminal dimensions in px */
    {
      char buf[128];
      sprintf (buf, "\033[4;%i;%it", (int)(vt->rows * vt->ch), (int)(vt->cols * vt->cw));
      vt_write (vt, buf, strlen (buf) );
    }
  else if (!strcmp (sequence, "[15t") ) /* request root dimensions in px */
    {
      char buf[128];
      sprintf (buf, "\033[5;%i;%it", ctx_height (vt->root_ctx), ctx_width(vt->root_ctx));
      vt_write (vt, buf, strlen (buf) );
    }
  else if (!strcmp (sequence, "[16t") ) /* request char dimensions in px */
    {
      char buf[128];
      sprintf (buf, "\033[6;%i;%it", (int)roundf(vt->ch), (int)roundf(vt->cw));
      vt_write (vt, buf, strlen (buf) );
    }
  else if (!strcmp (sequence, "[18t") ) /* request terminal dimensions */
    {
      char buf[128];
      sprintf (buf, "\033[8;%i;%it", vt->rows, vt->cols);
      vt_write (vt, buf, strlen (buf) );
    }
  else if (!strcmp (sequence, "[19t") ) /* request root window size in char */
    {
      char buf[128];
      sprintf (buf, "\033[9;%i;%it", (int)(ctx_height(vt->root_ctx)/vt->ch), (int)(ctx_width (vt->root_ctx)/vt->cw));
      vt_write (vt, buf, strlen (buf) );
    }

#if 0
  {"[", 's',  foo, VT100}, /*args:PnSP id:DECSWBV Set warning bell volume */
#endif
  else if (sequence[strlen (sequence)-2]==' ') /* DECSWBV */
    {
      int val = parse_int (sequence, 0);
      if (val <= 1) { vt->bell = 0; }
      if (val <= 8) { vt->bell = val; }
    }
  else
    {
      // XXX: X for ints >=24 resize to that number of lines
      VT_info ("unhandled subsequence %s", sequence);
    }
}

static void _vt_htab (VT *vt)
{
  do
    {
      vt->cursor_x ++;
    }
  while (vt->cursor_x < VT_MARGIN_RIGHT &&  ! vt->tabs[ (int) vt->cursor_x-1]);
  if (vt->cursor_x > VT_MARGIN_RIGHT)
    { vt->cursor_x = VT_MARGIN_RIGHT; }
}

static void _vt_rev_htab (VT *vt)
{
  do
    {
      vt->cursor_x--;
    }
  while ( vt->cursor_x > 1 && ! vt->tabs[ (int) vt->cursor_x-1]);
  if (vt->cursor_x < VT_MARGIN_LEFT)
    { vt_carriage_return (vt); }
}

static void vtcmd_insert_n_tabs (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n < 0) n = 0;
  if (n > vt->cols) n = vt->cols;
  while (n--)
    {
      _vt_htab (vt);
    }
}

static void vtcmd_rev_n_tabs (VT *vt, const char *sequence)
{
  int n = parse_int (sequence, 1);
  if (n < 0) n = 0;
  if (n > vt->cols) n = vt->cols;
  while (n--)
    {
      _vt_rev_htab (vt);
    }
}

static void vtcmd_set_double_width_double_height_top_line
(VT *vt, const char *sequence)
{
  vt->current_line->double_width         = 1;
  vt->current_line->double_height_top    = 1;
  vt->current_line->double_height_bottom = 0;
}
static void vtcmd_set_double_width_double_height_bottom_line
(VT *vt, const char *sequence)
{
  vt->current_line->double_width         = 1;
  vt->current_line->double_height_top    = 0;
  vt->current_line->double_height_bottom = 1;
}
static void vtcmd_set_single_width_single_height_line
(VT *vt, const char *sequence)
{
  vt->current_line->double_width         = 0;
  vt->current_line->double_height_top    = 0;
  vt->current_line->double_height_bottom = 0;
}
static void
vtcmd_set_double_width_single_height_line
(VT *vt, const char *sequence)
{
  vt->current_line->double_width         = 1;
  vt->current_line->double_height_top    = 0;
  vt->current_line->double_height_bottom = 0;
}

static void vtcmd_set_led (VT *vt, const char *sequence)
{
  int val = 0;
  //fprintf (stderr, "%s\n", sequence);
  for (const char *s = sequence; *s; s++)
    {
      switch (*s)
        {
          case '0': val = 0; break;
          case '1': val = 1; break;
          case '2': val = 2; break;
          case '3': val = 3; break;
          case '4': val = 4; break;
          case ';':
          case 'q':
            if (val == 0)
              { vt->leds[0] = vt->leds[1] = vt->leds[2] = vt->leds[3] = 0; }
            else
              { vt->leds[val-1] = 1; }
            val = 0;
            break;
        }
    }
}

static void vtcmd_char_at_cursor (VT *vt, const char *sequence)
{
  char *buf="";
  vt_write (vt, buf, strlen (buf) );
}

static void vtcmd_DECELR (VT *vt, const char *sequence)
{
  int ps1 = parse_int (sequence, 0);
  int ps2 = 0;
  const char *s = strchr (sequence, ';');
  if (ps1) {/* unused */};
  if (s)
    { ps2 = parse_int (s, 0); }
  if (ps2 == 1)
    { vt->unit_pixels = 1; }
  else
    { vt->unit_pixels = 0; }
}

static void vtcmd_graphics (VT *vt, const char *sequence)
{
  fprintf (stderr, "gfx intro [%s]\n",sequence); // maybe implement such as well?
}
void vt_audio_task (VT *vt, int click);

static void vtcmd_report (VT *vt, const char *sequence)
{
  char buf[64]="";
  if (!strcmp (sequence, "[5n") ) // DSR device status report
    {
      ctx_wait_frame (vt->root_ctx, vt);
      //if (vt->ctx_events)
      //  sprintf (buf, "\033[0n\n"); // we're always OK :)
      //else
      sprintf (buf, "\033[0n"); // we're always OK :)
    }
  else if (!strcmp (sequence, "[?15n") ) // printer status
    {
      sprintf (buf, "\033[?13n"); // no printer
    }
  else if (!strcmp (sequence, "[?26n") ) // keyboard dialect
    {
      sprintf (buf, "\033[?27;1n"); // north american/ascii
    }
  else if (!strcmp (sequence, "[?25n") ) // User Defined Key status
    {
      sprintf (buf, "\033[?21n"); // locked
    }
#if 0
  {"[6n", 0, },  /* id:DSR  cursor position report, yields a reply <tt>\033[Pl;PcR</tt> */
#endif
  else if (!strcmp (sequence, "[6n") ) // DSR cursor position report
    {
      sprintf (buf, "\033[%i;%iR", vt->cursor_y - (vt->origin? (vt->margin_top - 1) :0), (int) vt->cursor_x - (vt->origin? (VT_MARGIN_LEFT-1) :0) );
    }
  else if (!strcmp (sequence, "[?6n") ) // DECXPR extended cursor position report
    {
#if 0
  {"[?6n", 0, },  /* id:DEXCPR  extended cursor position report, yields a reply <tt>\033[Pl;PcR</tt> */
#endif
      sprintf (buf, "\033[?%i;%i;1R", vt->cursor_y - (vt->origin? (vt->margin_top - 1) :0), (int) vt->cursor_x - (vt->origin? (VT_MARGIN_LEFT-1) :0) );
    }
  else if (!strcmp (sequence, "[>c") )
    {
      sprintf (buf, "\033[>23;01;1c");
    }
  else if (sequence[strlen (sequence)-1]=='c') // device attributes
    {
      //buf = "\033[?1;2c"; // what rxvt reports
      //buf = "\033[?1;6c"; // VT100 with AVO ang GPO
      //buf = "\033[?2c";     // VT102
      sprintf (buf, "\033[?63;14;4;22c");
    }
  else if (sequence[strlen (sequence)-1]=='x') // terminal parameters
    {
      if (!strcmp (sequence, "[1x") )
        { sprintf (buf, "\033[3;1;1;120;120;1;0x"); }
      else
        { sprintf (buf, "\033[2;1;1;120;120;1;0x"); }
    }
  if (buf[0])
    { vt_write (vt, buf, strlen (buf) );
    }
}

static void vtcmd_report_version (VT *vt, const char *sequence)
{
  char buf[64];
  sprintf(buf, "\033P>|ctx(%s)\033\\", CTX_VERSION_STRING);
  vt_write (vt, buf, strlen (buf));
}


static const char *charmap_cp437[]=
{
  " ","☺","☻","♥","♦","♣","♠","•","◘","○","◙","♂","♀","♪","♫","☼",
  "►","◄","↕","‼","¶","§","▬","↨","↑","↓","→","←","∟","↔","▲","▼",
  " ","!","\"","#","$","%","&","'","(",")","*","+",",","-",".","/",
  "0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?",
  "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O",
  "P","Q","R","S","T","U","V","W","X","Y","Z","[","\\","]","^","_",
  "`","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o",
  "p","q","r","s","t","u","v","w","x","y","z","{","|","}","~","⌂",
  "Ç","ü","é","â","ä","à","å","ç","ê","ë","è","ï","î","ì","Ä","Å",
  "É","æ","Æ","ô","ö","ò","û","ù","ÿ","Ö","Ü","¢","£","¥","₧","ƒ",
  "á","í","ó","ú","ñ","Ñ","ª","º","¿","⌐","¬","½","¼","¡","«","»",
  "░","▒","▓","│","┤","╡","╢","╖","╕","╣","║","╗","╝","╜","╛","┐",
  "└","┴","┬","├","─","┼","╞","╟","╚","╔","╩","╦","╠","═","╬","╧",
  "╨","╤","╥","╙","╘","╒","╓","╫","╪","┘","┌","█","▄","▌","▐","▀",
  "α","ß","Γ","π","Σ","σ","µ","τ","Φ","Θ","Ω","δ","∞","φ","ε","∩",
  "≡","±","≥","≤","⌠","⌡","÷","≈","°","∙","·","√","ⁿ","²","■"," "
};


static const char *charmap_graphics[]=
{
  " ","!","\"","#","$","%","&","'","(",")","*","+",",","-",".","/","0",
  "1","2","3","4","5","6","7","8","9",":",";","<","=",">","?",
  "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P",
  "Q","R","S","T","U","V","W","X","Y","Z","[","\\","]","^","_",
  "◆","▒","␉","␌","␍","␊","°","±","␤","␋","┘","┐","┌","└","┼","⎺","⎻",
  "─","⎼","⎽","├","┤","┴","┬","│","≤","≥","π","≠","£","·"," "
};

static const char *charmap_uk[]=
{
  " ","!","\"","£","$","%","&","'","(",")","*","+",",","-",".","/","0",
  "1","2","3","4","5","6","7","8","9",":",";","<","=",">","?",
  "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P",
  "Q","R","S","T","U","V","W","X","Y","Z","[","\\","]","^","_",
  "`","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p",
  "q","r","s","t","u","v","w","x","y","z","{","|","}","~"," "
};

static const char *charmap_ascii[]=
{
  " ","!","\"","#","$","%","&","'","(",")","*","+",",","-",".","/","0",
  "1","2","3","4","5","6","7","8","9",":",";","<","=",">","?",
  "@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P",
  "Q","R","S","T","U","V","W","X","Y","Z","[","\\","]","^","_",
  "`","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p",
  "q","r","s","t","u","v","w","x","y","z","{","|","}","~"," "
};

static void vtcmd_justify (VT *vt, const char *sequence)
{
  int n = parse_int (vt->argument_buf, 0);
  switch (n)
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
        vt->justify = n;
        break;
      default:
        vt->justify = 0;
    }
}

static void vtcmd_sixel_related_req (VT *vt, const char *sequence)
{
  //fprintf (stderr, "it happens!\n");
}

static void vtcmd_set_charmap (VT *vt, const char *sequence)
{
  int slot = 0;
  int set = sequence[1];
  if (sequence[0] == ')') { slot = 1; }
  if (set == 'G') { set = 'B'; }
  vt->charset[slot] = set;
}
#if 0

CSI Pm ' }    '
Insert Ps Column (s) (default = 1) (DECIC), VT420 and up.

CSI Pm ' ~    '
Delete Ps Column (s) (default = 1) (DECDC), VT420 and up.


in text.  When bracketed paste mode is set, the program will receive:
ESC [ 2 0 0 ~,
      followed by the pasted text, followed by
      ESC [ 2 0 1 ~ .


            CSI I
            when the terminal gains focus, and CSI O  when it loses focus.
#endif

#define COMPAT_FLAG_LEVEL_0   (1<<1)
#define COMPAT_FLAG_LEVEL_1   (1<<2)
#define COMPAT_FLAG_LEVEL_2   (1<<3)
#define COMPAT_FLAG_LEVEL_3   (1<<4)
#define COMPAT_FLAG_LEVEL_4   (1<<5)
#define COMPAT_FLAG_LEVEL_5   (1<<6)

#define COMPAT_FLAG_LEVEL_102 (1<<7)

#define COMPAT_FLAG_ANSI      (1<<8)
#define COMPAT_FLAG_OBSOLETE  (1<<9)

#define COMPAT_FLAG_ANSI_COLOR (1<<10)
#define COMPAT_FLAG_256_COLOR  (1<<11)
#define COMPAT_FLAG_24_COLOR   (1<<12)

#define COMPAT_FLAG_MOUSE_REPORT (1<<13)

#define COMPAT_FLAG_AUDIO      (1<<14)
#define COMPAT_FLAG_GRAPHICS   (1<<15)

#define ANSI    COMPAT_FLAG_ANSI
#define OBS     COMPAT_FLAG_OBSOLETE

#define VT100   (COMPAT_FLAG_LEVEL_0|COMPAT_FLAG_LEVEL_1)
#define VT102   (VT100|COMPAT_FLAG_LEVEL_102)
#define VT200   (VT102|COMPAT_FLAG_LEVEL_2)
#define VT300   (VT200|COMPAT_FLAG_LEVEL_3)
#define VT400   (VT300|COMPAT_FLAG_LEVEL_4)
#define VT220   VT200
#define VT320   VT300

#define XTERM   (VT400|COMPAT_FLAG_24_COLOR|COMPAT_FLAG_256_COLOR|COMPAT_FLAG_ANSI_COLOR)

#define VT2020  (XTERM|COMPAT_FLAG_GRAPHICS|COMPAT_FLAG_AUDIO)


static const Sequence sequences[]=
  {
    /*
      prefix suffix  command */
    //{"B",  0,  vtcmd_break_permitted},
    //{"C",  0,  vtcmd_nobreak_here},
    {"D", 0,    vtcmd_index, VT100}, /* args: id:IND Index  */
    {"E",  0,   vtcmd_next_line, 0}, /* ref:none id:  Next line */
    {"_", 'G',  vtcmd_graphics, 0},
    {"H",   0,  vtcmd_horizontal_tab_set, VT100}, /* id:HTS Horizontal Tab Set */

    //{"I",  0,  vtcmd_char_tabulation_with_justification},
    //{"K",  0,  PLD partial line down
    //{"L",  0,  PLU partial line up
    {"M",  0,   vtcmd_reverse_index, VT100}, /* ref:none id:RI Reverse Index */
    //{"N",  0,  vtcmd_ignore}, /* Set Single Shift 2 - SS2*/
    //{"O",  0,  vtcmd_ignore}, /* Set Single Shift 3 - SS3*/

#if 0
    {"[0F", 0, vtcmd_justify, ANSI}, /* ref:none id:JFY disable justification and wordwrap  */ // needs special link to ANSI standard
    {"[1F", 0, vtcmd_justify, ANSI}, /* ref:none id:JFY enable wordwrap  */
#endif

    /* these need to occur before vtcmd_preceding_line to have precedence */
    {"[0 F", 0, vtcmd_justify, ANSI},
    {"[1 F", 0, vtcmd_justify, ANSI},
    {"[2 F", 0, vtcmd_justify, 0},
    {"[3 F", 0, vtcmd_justify, 0},
    {"[4 F", 0, vtcmd_justify, 0},
    {"[5 F", 0, vtcmd_justify, 0},
    {"[6 F", 0, vtcmd_justify, 0},
    {"[7 F", 0, vtcmd_justify, 0},
    {"[8 F", 0, vtcmd_justify, 0},
// XXX missing DECIC DECDC  insert and delete column
    {"[", 'A', vtcmd_cursor_up, VT100},   /* args:Pn    id:CUU Cursor Up */
    {"[",  'B', vtcmd_cursor_down, VT100}, /* args:Pn    id:CUD Cursor Down */
    {"[",  'C', vtcmd_cursor_forward, VT100}, /* args:Pn id:CUF Cursor Forward */
    {"[",  'D', vtcmd_cursor_backward, VT100}, /* args:Pn id:CUB Cursor Backward */
    {"[",  'j', vtcmd_cursor_backward, ANSI}, /* args:Pn ref:none id:HPB Horizontal Position Backward */
    {"[",  'k', vtcmd_cursor_up, ANSI}, /* args:Pn ref:none id:VPB Vertical Position Backward */
    {"[",  'E', vtcmd_next_line, VT100}, /* args:Pn id:CNL Cursor Next Line */
    {"[",  'F', vtcmd_cursor_preceding_line, VT100}, /* args:Pn id:CPL Cursor Preceding Line */
    {"[",  'G', vtcmd_horizontal_position_absolute, 0}, /* args:Pn id:CHA Cursor Horizontal Absolute */
    {"[",  'H', vtcmd_cursor_position, VT100}, /* args:Pl;Pc id:CUP Cursor Position */
    {"[",  'I', vtcmd_insert_n_tabs, 0}, /* args:Pn id:CHT Cursor Horizontal Forward Tabulation */
    {"[",  'J', vtcmd_erase_in_display, VT100}, /* args:Ps id:ED Erase in Display */
    {"[",  'K', vtcmd_erase_in_line, VT100}, /* args:Ps id:EL Erase in Line */
    {"[",  'L', vtcmd_insert_blank_lines, VT102}, /* args:Pn id:IL Insert Line */
    {"[",  'M', vtcmd_delete_n_lines, VT102}, /* args:Pn id:DL Delete Line   */
    // [ N is EA - Erase in field
    // [ O is EA - Erase in area
    {"[",  'P', vtcmd_delete_n_chars, VT102}, /* args:Pn id:DCH Delete Character */
    // [ Q is SEE - Set editing extent
    // [ R is CPR - active cursor position report
    {"[?", 'S', vtcmd_sixel_related_req, 0},
    {"[",  'S', vtcmd_scroll_up, VT100},   /* args:Pn id:SU Scroll Up */
    {"[",  'T', vtcmd_scroll_down, VT100}, /* args:Pn id:SD Scroll Down */
    {"[",/*SP*/'U', vtcmd_set_line_home, ANSI}, /* args:PnSP id=SLH Set Line Home */
    {"[",/*SP*/'V', vtcmd_set_line_limit, ANSI},/* args:PnSP id=SLL Set Line Limit */
    // [ W is cursor tabulation control
    // [ Pn Y  - cursor line tabulation
    //
    {"[",  'X', vtcmd_erase_n_chars, 0}, /* args:Pn id:ECH Erase Character */
    {"[",  'Z', vtcmd_rev_n_tabs, 0},    /* args:Pn id:CBT Cursor Backward Tabulation */
    {"[",  '^', vtcmd_scroll_down, 0}  , /* muphry alternate from ECMA */
    {"[",  '@', vtcmd_insert_character, VT102}, /* args:Pn id:ICH Insert Character */

    {"[",  'a', vtcmd_cursor_forward, ANSI}, /* args:Pn id:HPR Horizontal Position Relative */
    {"[",  'b', vtcmd_cursor_forward, ANSI}, /* REP previous char XXX incomplete */
    {"[",  'c', vtcmd_report, 0}, /* ref:none id:DA args:... Device Attributes */
    {"[",  'd', vtcmd_goto_row, 0},       /* args:Pn id:VPA Vertical Position Absolute  */
    {"[",  'e', vtcmd_cursor_down, 0},    /* args:Pn id:VPR Vertical Position Relative */
    {"[",  'f', vtcmd_cursor_position, VT100}, /* args:Pl;Pc id:HVP Cursor Position */
    {"[g", 0,   vtcmd_clear_current_tab, VT100}, /* id:TBC clear current tab */
    {"[0g", 0,  vtcmd_clear_current_tab, VT100}, /* id:TBC clear current tab */
    {"[3g", 0,  vtcmd_clear_all_tabs, VT100},    /* id:TBC clear all tabs */
    {"[",  'm', vtcmd_set_graphics_rendition, VT100}, /* args:Ps;Ps;.. id:SGR Select Graphics Rendition */
    {"[",  'n', vtcmd_report, VT200}, /* id:DSR args:... CPR Cursor Position Report  */
    {"[",  'r', vtcmd_set_top_and_bottom_margins, VT100}, /* args:Pt;Pb id:DECSTBM Set Top and Bottom Margins */
#if 0
    // handled by set_left_and_right_margins - in if 0 to be documented
    {"[s",  0,  vtcmd_save_cursor_position, VT100}, /*ref:none id:SCP Save Cursor Position */
#endif
    {"[u",  0,  vtcmd_restore_cursor_position, VT100}, /*ref:none id:RCP Restore Cursor Position */
    {"[",  's', vtcmd_set_left_and_right_margins, VT400}, /* args:Pl;Pr id:DECSLRM Set Left and Right Margins */
    {"[",  '`', vtcmd_horizontal_position_absolute, ANSI},  /* args:Pn id:HPA Horizontal Position Absolute */

    {"[",  'h', vtcmd_set_mode, VT100},   /* args:Pn[;...] id:SM Set Mode */
    {"[",  'l', vtcmd_set_mode, VT100}, /* args:Pn[;...]  id:RM Reset Mode */
    {"[",  't', vtcmd_set_t, 0},
    {"[>", 'q', vtcmd_report_version, 0}, // 
    {"[",  'q', vtcmd_set_led, VT100}, /* args:Ps id:DECLL Load LEDs */
    {"[",  'x', vtcmd_report, 0}, /* ref:none id:DECREQTPARM */
    {"[",  'z', vtcmd_DECELR, 0}, /* ref:none id:DECELR set locator res  */

    {"5",   0,  vtcmd_char_at_cursor, VT300}, /* ref:none id:DECXMIT */
    {"6",   0,  vtcmd_back_index, VT400}, /* id:DECBI Back index (hor. scroll) */
    {"7",   0,  vtcmd_save_cursor, VT100}, /* id:DECSC Save Cursor */
    {"8",   0,  vtcmd_restore_cursor, VT100}, /* id:DECRC Restore Cursor */
    {"9",   0,  vtcmd_forward_index, VT400}, /* id:DECFI Forward index (hor. scroll)*/

    //{"Z", 0,  vtcmd_device_attributes},
    //{"%G",0,  vtcmd_set_default_font}, // set_alternate_font


    {"(0",  0,   vtcmd_set_charmap, 0},
    {"(1",  0,   vtcmd_set_charmap, 0},
    {"(2",  0,   vtcmd_set_charmap,0},
    {"(A",  0,   vtcmd_set_charmap,0},
    {"(B",  0,   vtcmd_set_charmap,0},
    {")0",  0,   vtcmd_set_charmap,0},
    {")1",  0,   vtcmd_set_charmap,0},
    {")2",  0,   vtcmd_set_charmap,0},
    {")A",  0,   vtcmd_set_charmap,0},
    {")B",  0,   vtcmd_set_charmap,0},
    {"%G",  0,   vtcmd_set_charmap,0},

    {"#3",  0,   vtcmd_set_double_width_double_height_top_line, VT100}, /*id:DECDHL Top half of double-width, double-height line */
    {"#4",  0,   vtcmd_set_double_width_double_height_bottom_line, VT100}, /*id:DECDHL Bottom half of double-width, double-height line */
    {"#5",  0,   vtcmd_set_single_width_single_height_line, VT100}, /* id:DECSWL Single-width line */
    {"#6",  0,   vtcmd_set_double_width_single_height_line, VT100}, /* id:DECDWL Double-width line */

    {"#8",  0,   vtcmd_screen_alignment_display, VT100}, /* id:DECALN Screen Alignment Pattern */
    {"=",   0,   vtcmd_ignore,0},  // keypad mode change
    {">",   0,   vtcmd_ignore,0},  // keypad mode change
    {"c",   0,   vtcmd_reset_to_initial_state, VT100}, /* id:RIS Reset to Initial State */
    {"[!", 'p',  vtcmd_ignore,0},       // soft reset?
    {"[",  'p',  vtcmd_request_mode,0}, /* args:Pa$ id:DECRQM Request ANSI Mode */
#if 0
    {"[?",  'p',  vtcmd_request_mode,0}, /* args:Pd$ id:DECRQM Request DEC Mode */
#endif

    {NULL, 0, NULL, 0}
  };

  static void handle_sequence (VT *vt, const char *sequence)
{
  int i0 = ctx_strlen (sequence)-1;
  int i;
  ctx_client_rev_inc (vt->client);
  for (i = 0; sequences[i].prefix; i++)
    {
      if (!strncmp (sequence, sequences[i].prefix, ctx_strlen (sequences[i].prefix) ) )
        {
          if (! (sequences[i].suffix && (sequence[i0] != sequences[i].suffix) ) )
            {
              VT_command ("%s", sequence);
              sequences[i].vtcmd (vt, sequence);
              return;
            }
        }
    }
#ifndef ASANBUILD
  VT_warning ("unhandled: %c%c%c%c%c%c%c%c%c\n", sequence[0], sequence[1], sequence[2], sequence[3], sequence[4], sequence[5], sequence[6], sequence[7], sequence[8]);
#endif
}

static void vt_line_feed (VT *vt)
{
  int was_home = vt->at_line_home;
  if (vt->margin_top == 1 && vt->margin_bottom == vt->rows)
    {
      if (vt->lines == NULL ||
          (vt->lines->data == vt->current_line && vt->cursor_y != vt->rows) )
        {
          vt->current_line = vt_line_new2 (vt);
          ctx_list_prepend (&vt->lines, vt->current_line);
          vt->line_count++;
        }
      if (vt->cursor_y >= vt->margin_bottom)
        {
          vt->cursor_y = vt->margin_bottom;
          vt_scroll (vt, -1);
        }
      else
        {
          vt->cursor_y++;
        }
    }
  else
    {
      if (vt->lines->data == vt->current_line &&
          (vt->cursor_y != vt->margin_bottom) && 0)
        {
          vt->current_line = vt_line_new2 (vt);
          ctx_list_prepend (&vt->lines, vt->current_line);
          vt->line_count++;
        }
      vt->cursor_y++;
      if (vt->cursor_y > vt->margin_bottom)
        {
          vt->cursor_y = vt->margin_bottom;
          vt_scroll (vt, -1);
        }
    }
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
  if (vt->cr_on_lf)
    { vt_carriage_return (vt); }
  vt_trimlines (vt, vt->rows);
  if (was_home)
    { vt_carriage_return (vt); }
}

//#include "vt-encodings.h"

#if CTX_SDL
static void vt_state_apc_audio (VT *vt, int byte)
{
  if ( (byte < 32) && ( (byte < 8) || (byte > 13) ) )
    {
#if CTX_AUDIO
      vt_audio (vt, vt->argument_buf);
#endif
      vt->state = ( (byte == 27) ?  vt_state_swallow : vt_state_neutral);
    }
  else
    {
      vt_argument_buf_add (vt, byte);
    }
}

#else

void vt_audio_task (VT *vt, int click)
{
}

void vt_bell (VT *vt)
{
}
static void vt_state_apc_audio (VT *vt, int byte)
{
  vt->state = vt_state_apc_generic;
}

#endif

static void
vt_carriage_return (VT *vt)
{
  _vt_move_to (vt, vt->cursor_y, vt->cursor_x);
  vt->cursor_x = VT_MARGIN_LEFT;
  vt->at_line_home = 1;
}

/* if the byte is a non-print control character, handle it and return 1
 * oterhwise return 0*/
static int _vt_handle_control (VT *vt, int byte)
{
  /* the big difference between ANSI-BBS mode and VT100+ mode is that
   * most C0 characters are printable
   */
  if (CTX_UNLIKELY(vt->encoding == 1)) // this codepage is for ansi-bbs use
    switch (byte)
      {
        case '\0':
          return 1;
        case 1:    /* SOH start of heading */
        case 2:    /* STX start of text */
        case 3:    /* ETX end of text */
        case 4:    /* EOT end of transmission */
        case 5:    /* ENQuiry */
        case 6:    /* ACKnolwedge */
        case '\v': /* VT vertical tab */
        case '\f': /* VF form feed */
        case 14: /* SO shift in - alternate charset */
        case 15: /* SI shift out - (back to normal) */
        case 16: /* DLE data link escape */
        case 17: /* DC1 device control 1 - XON */
        case 18: /* DC2 device control 2 */
        case 19: /* DC3 device control 3 - XOFF */
        case 20: /* DC4 device control 4 */
        case 21: /* NAK negative ack */
        case 22: /* SYNchronous idle */
        case 23: /* ETB end of trans. blk */
        case 24: /* CANcel (vt100 aborts sequence) */
        case 25: /* EM  end of medium */
        case 26: /* SUB stitute */
        case 28: /* FS file separator */
        case 29: /* GS group separator */
        case 30: /* RS record separator */
        case 31: /* US unit separator */
          _vt_add_str (vt, charmap_cp437[byte]);
          return 1;
      }
  switch (byte)
    {
      case '\0':
      case 1:    /* SOH start of heading */
      case 2:    /* STX start of text */
      case 3:    /* ETX end of text */
      case 4:    /* EOT end of transmission */
      case 6:    /* ACKnolwedge */
        return 1;
      case 5:    /* ENQuiry */
        {
          const char *reply = getenv ("TERM_ENQ_REPLY");
          if (reply)
            {
              char *copy = ctx_strdup (reply);
              for (uint8_t *c = (uint8_t *) copy; *c; c++)
                {
                  if (*c < ' ' || * c > 127) { *c = 0; }
                }
              vt_write (vt, reply, strlen (reply) );
              free (copy);
            }
        }
        return 1;
      case '\a': /* BELl */
#if CTX_AUDIO
        vt_bell (vt);
#endif
        return 1;
      case '\b': /* BS */
        _vt_backspace (vt);
        return 1;
      case '\t': /* HT tab */
        _vt_htab (vt);
        return 1;
      case '\v': /* VT vertical tab */
      case '\f': /* VF form feed */
      case '\n': /* LF line ffed */
        vt_line_feed (vt);
        return 1;
      case '\r': /* CR carriage return */
        vt_carriage_return (vt);
        return 1;
      case 14: /* SO shift in - alternate charset */
        vt->shifted_in = 1;  // XXX not in vt52
        return 1;
      case 15: /* SI shift out - (back to normal) */
        vt->shifted_in = 0;
        return 1;
      case 16: /* DLE data link escape */
      case 17: /* DC1 device control 1 - XON */
      case 18: /* DC2 device control 2 */
      case 19: /* DC3 device control 3 - XOFF */
      case 20: /* DC4 device control 4 */
      case 21: /* NAK negative ack */
      case 22: /* SYNchronous idle */
      case 23: /* ETB end of trans. blk */
      case 24: /* CANcel (vt100 aborts sequence) */
      case 25: /* EM  end of medium */
      case 26: /* SUB stitute */
        _vt_add_str (vt, "¿");  // in vt52? XXX
        return 1;
      case 27: /* ESCape */
        return 0;
        break;
      case 28: /* FS file separator */
      case 29: /* GS group separator */
      case 30: /* RS record separator */
      case 31: /* US unit separator */
      case 127: /* DEL */
        return 1;
      default:
        return 0;
    }
}

#if CTX_VT_LOG
void vt_open_log (VT *vt, const char *path)
{
  unlink (path);
  vt->log = fopen (path, "w");
}
#endif

/* the function shared by sixels, kitty mode and iterm2 mode for
 * doing inline images. it attaches an image to the current line
 */
static void display_image (VT *vt, Image *image,
                           int col,
                           float xoffset,
                           float yoffset,
                           int rows,
                           int cols,
                           int subx,
                           int suby,
                           int subw,
                           int subh
                          )
{
  int i = 0;
  for (i = 0; vt->current_line->images[i] && i < 4; i++)
  {
     if (vt->current_line->image_col[i] == vt->cursor_x)
       break;
  }
  //for (i = 0; vt->current_line->images[i] && i < 4; i++);
  if (i >= 4) { i = 3; }
  /* this needs a struct and dynamic allocation */
  vt->current_line->images[i] = image;
  vt->current_line->image_col[i] = vt->cursor_x;
  vt->current_line->image_X[i] = xoffset;
  vt->current_line->image_Y[i] = yoffset;
  vt->current_line->image_subx[i] = subx;
  vt->current_line->image_suby[i] = suby;
  vt->current_line->image_subw[i] = subw;
  vt->current_line->image_subh[i] = subh;
  vt->current_line->image_rows[i] = rows;
  vt->current_line->image_cols[i] = cols;
}

static int vt_gfx_pending=0;


#if CTX_VT_GFX
void vt_gfx (VT *vt, const char *command)
{
  const char *payload = NULL;
  char key = 0;
  int  value;
  int  len = vt->argument_buf_len;
  int  pos = 1;
  if (vt->gfx.multichunk == 0)
    {
      memset (&vt->gfx, 0, sizeof (GfxState) );
      vt->gfx.action='t';
      vt->gfx.transmission='d';
    }
  while (pos < len && command[pos] != ';')
    {
      pos ++; // G or ,
      if (command[pos] == ';') { break; }
      key = command[pos];
      if (pos < len)
      pos++;
      if (command[pos] == ';') { break; }
      if (pos < len)
      pos ++; // =
      if (command[pos] == ';') { break; }
      if (command[pos] >= '0' && command[pos] <= '9')
        { value = ctx_atoi (&command[pos]); }
      else
        { value = command[pos]; }
      while (pos < len && 
             command[pos] &&
             command[pos] != ',' &&
             command[pos] != ';') { pos++; }
      switch (key)
        {
          case 'a':
            vt->gfx.action = value;
            break;
          case 'd':
            vt->gfx._delete = value;
            break;
          case 'i':
            vt->gfx.id = value;
            break;
          case 'S':
            vt->gfx.buf_size = value;
            break;
          case 's':
            vt->gfx.buf_width = value;
            break;
          case 'v':
            vt->gfx.buf_height = value;
            break;
          case 'f':
            vt->gfx.format = value;
            break;
          case 'm':
            vt->gfx.multichunk = value;
            break;
          case 'o':
            vt->gfx.compression = value;
            break;
          case 't':
            vt->gfx.transmission = value;
            break;
          case 'x':
            vt->gfx.x = value;
            break;
          case 'y':
            vt->gfx.y = value;
            break;
          case 'w':
            vt->gfx.w = value;
            break;
          case 'h':
            vt->gfx.h = value;
            break;
          case 'X':
            vt->gfx.x_cell_offset = value;
            break;
          case 'Y':
            vt->gfx.y_cell_offset = value;
            break;
          case 'c':
            vt->gfx.columns = value;
            break;
          case 'r':
            vt->gfx.rows = value;
            break;
          case 'z':
            vt->gfx.z_index = value;
            break;
        }
    }
  if (pos + 1 >= len)
    goto cleanup;
  payload = &command[pos+1];
  {
    int chunk_size = strlen (payload);
    int old_size = vt->gfx.data_size;
    // accumulate incoming data
    if (vt->gfx.data == NULL)
      {
        vt->gfx.data_size = chunk_size;
        vt->gfx.data = ctx_malloc (vt->gfx.data_size + 1);
      }
    else
      {
        vt->gfx.data_size += chunk_size;
        vt->gfx.data = ctx_realloc (vt->gfx.data, vt->gfx.data_size-chunk_size,vt->gfx.data_size + 1);
      }
    memcpy (vt->gfx.data + old_size, payload, chunk_size);
    vt->gfx.data[vt->gfx.data_size]=0;
  }
  if (vt->gfx.multichunk == 0)
    {
      if (vt->gfx.transmission != 'd') /* */
        {
          char buf[256];
          sprintf (buf, "\033_Gi=%i;only direct transmission supported\033\\",
                   vt->gfx.id);
          vt_write (vt, buf, strlen (buf) );
          goto cleanup;
        }
      {
        int bin_length = vt->gfx.data_size;
        uint8_t *data2 = ctx_malloc (vt->gfx.data_size);
        bin_length = ctx_base642bin ( (char *) vt->gfx.data,
                                     &bin_length,
                                     data2);
        memcpy (vt->gfx.data, data2, bin_length + 1);
        vt->gfx.data_size = bin_length;
        free (data2);
      }
      if (vt->gfx.buf_width)
        {
          // implicit buf_size
          vt->gfx.buf_size = vt->gfx.buf_width * vt->gfx.buf_height *
                             (vt->gfx.format == 24 ? 3 : 4);
        }
#if 0
      if (vt->gfx.compression == 'z')
        {
          //vt->gfx.buf_size)
          unsigned char *data2 = ctx_malloc (vt->gfx.buf_size + 1);
          /* if a buf size is set (rather compression, but
           * this works first..) then */
      unsigned long int
          actual_uncompressed_size = vt->gfx.buf_size;
          int z_result = uncompress (data2, &actual_uncompressed_size,
                                     vt->gfx.data,
                                     vt->gfx.data_size);
          if (z_result != Z_OK)
            {
              const char *buf = "\033_Go=z;zlib error\033\\";
              vt_write (vt, buf, strlen (buf) );
              goto cleanup;
            }
          free (vt->gfx.data);
          vt->gfx.data = data2;
          vt->gfx.data_size = actual_uncompressed_size;
          vt->gfx.compression = 0;
        }
#endif
#if CTX_STB_IMAGE
      if (vt->gfx.format == 100)
        {
          int channels;
          uint8_t *new_data = stbi_load_from_memory (vt->gfx.data, vt->gfx.data_size, &vt->gfx.buf_width, &vt->gfx.buf_height, &channels, 4);
          if (!new_data)
            {
              const char *buf= "\033_Gf=100;image decode error\033\\";
              vt_write (vt, buf, strlen (buf) );
              goto cleanup;
            }
          vt->gfx.format = 32;
          free (vt->gfx.data);
          vt->gfx.data = new_data;
          vt->gfx.data_size= vt->gfx.buf_width * vt->gfx.buf_height * 4;
        }
#endif
      Image *image = NULL;
      switch (vt->gfx.action)
        {
          case 't': // transfer
          case 'T': // transfer and present
            switch (vt->gfx.format)
              {
                case 24:
                case 32:
                  image = image_add (vt->gfx.buf_width, vt->gfx.buf_height, vt->gfx.id,
                                     vt->gfx.format, vt->gfx.data_size, vt->gfx.data);
                  vt->gfx.data = NULL;
                  vt->gfx.data_size=0;
                  break;
              }
            if (vt->gfx.action == 't')
              { break; }
          // fallthrough
          case 'p': // present
            if (!image && vt->gfx.id)
              { image = image_query (vt->gfx.id); }
            if (image)
              {
                display_image (vt, image, vt->cursor_x, vt->gfx.rows, vt->gfx.columns,
                               vt->gfx.x_cell_offset * 1.0 / vt->cw,
                               vt->gfx.y_cell_offset * 1.0 / vt->ch,
                               vt->gfx.x,
                               vt->gfx.y,
                               vt->gfx.w,
                               vt->gfx.h);
                int right = (image->width + (vt->cw-1) ) /vt->cw;
                int down = (image->height + (vt->ch-1) ) /vt->ch;
                for (int i = 0; i<down - 1; i++)
                  { vtcmd_index (vt, " "); }
                for (int i = 0; i<right; i++)
                  { vtcmd_cursor_forward (vt, " "); }
              }
            break;
          case 'q': // query
            if (image_query (vt->gfx.id) )
              {
                char buf[256];
                sprintf (buf, "\033_Gi=%i;OK\033\\", vt->gfx.id);
                vt_write (vt, buf, strlen (buf) );
              }
            break;
          case 'd': // delete
            {
              int row = vt->rows; // probably not right at start of session XXX
              for (CtxList *l = vt->lines; l; l = l->next, row --)
                {
                  VtLine *line = l->data;
                  for (int i = 0; i < 4; i ++)
                    {
                      int free_resource = 0;
                      int match = 0;
                      if (line->images[i])
                        switch (vt->gfx._delete)
                          {
                            case 'A':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'a': /* all images visible on screen */
                              match = 1;
                              break;
                            case 'I':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'i': /* all images with specified id */
                              if ( ( (Image *) (line->images[i]) )->id == vt->gfx.id)
                                { match = 1; }
                              break;
                            case 'P':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'p': /* all images intersecting cell
          specified with x and y */
                              if (line->image_col[i] == vt->gfx.x &&
                                  row == vt->gfx.y)
                                { match = 1; }
                              break;
                            case 'Q':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'q': /* all images with specified cell (x), row(y) and z */
                              if (line->image_col[i] == vt->gfx.x &&
                                  row == vt->gfx.y)
                                { match = 1; }
                              break;
                            case 'Y':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'y': /* all images with specified row (y) */
                              if (row == vt->gfx.y)
                                { match = 1; }
                              break;
                            case 'X':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'x': /* all images with specified column (x) */
                              if (line->image_col[i] == vt->gfx.x)
                                { match = 1; }
                              break;
                            case 'Z':
                              free_resource = 1;
                              /* FALLTHROUGH */
                            case 'z': /* all images with specified z-index (z) */
                              break;
                          }
                      if (match)
                        {
                          line->images[i] = NULL;
                          if (free_resource)
                            {
                              // XXX : NYI
                            }
                        }
                    }
                }
            }
            break;
        }
cleanup:
      if (vt->gfx.data)
        { free (vt->gfx.data); }
      vt->gfx.data = NULL;
      vt->gfx.data_size=0;
      vt->gfx.multichunk=0;
      vt_gfx_pending = 0;
    }
  else
     vt_gfx_pending = 1;
}
#endif

static void vt_state_vt52 (VT *vt, int byte)
{
  /* in vt52 mode, utf8_pos being non 0 means we got ESC prior */
  switch (vt->utf8_pos)
    {
      case 0:
        if (_vt_handle_control (vt, byte) == 0)
          switch (byte)
            {
              case 27: /* ESC */
                vt->utf8_pos = 1;
                break;
              default:
                {
                  char str[2] = {byte & 127, 0};
                  /* we're not validating utf8, and our utf8 manipulation
                   * functions are not robust against malformed utf8,
                   * hence we strip to ascii
                   */
                  _vt_add_str (vt, str);
                }
                break;
            }
        break;
      case 1:
        vt->utf8_pos = 0;
        switch (byte)
          {
            case 'A':
              vtcmd_cursor_up (vt, " ");
              break;
            case 'B':
              vtcmd_cursor_down (vt, " ");
              break;
            case 'C':
              vtcmd_cursor_forward (vt, " ");
              break;
            case 'D':
              vtcmd_cursor_backward (vt, " ");
              break;
            case 'F':
              vtcmd_set_alternate_font (vt, " ");
              break;
            case 'G':
              vtcmd_set_default_font (vt, " ");
              break;
            case 'H':
              _vt_move_to (vt, 1, 1);
              break;
            case 'I':
              vtcmd_reverse_index (vt, " ");
              break;
            case 'J':
              vtcmd_erase_in_display (vt, "[0J");
              break;
            case 'K':
              vtcmd_erase_in_line (vt, "[0K");
              break;
            case 'Y':
              vt->utf8_pos = 2;
              break;
            case 'Z':
              vt_write (vt, "\033/Z", 3);
              break;
            case '<':
              vt->state = vt_state_neutral;
              break;
            default:
              break;
          }
        break;
      case 2:
        _vt_move_to (vt, byte - 31, vt->cursor_x);
        vt->utf8_pos = 3;
        break;
      case 3:
        _vt_move_to (vt, vt->cursor_y, byte - 31);
        vt->utf8_pos = 0;
        break;
    }
}


#if CTX_VT_SIXELS
static void vt_sixels (VT *vt, const char *sixels)
{
  uint8_t colors[256][3];
  int width = 0;
  int height = 0;
  int x = 0;
  int y = 0;
  Image *image;
  uint8_t *pixels = NULL;
  int repeat = 1;
  const char *p = sixels;
  int pal_no = 0;
#if 0
  for (; *p && *p != ';'; p++);
  if (*p == ';') { p ++; }
  printf ("%i:[%c]%i\n", __LINE__, *p, atoi (p) );
  // should be 0
  for (; *p && *p != ';'; p++);
  if (*p == ';') { p ++; }
  printf ("%i:[%c]%i\n", __LINE__, *p, atoi (p) );
  // if 1 then transparency is enabled - otherwise use bg color
  for (; *p && *p != 'q'; p++);
#endif
  //for (; *p && *p != '"'; p++);
  while (*p && *p != 'q') { p++; }
  if (*p == 'q') { p++; }
  if (*p == '"') { p++; }
  //printf ("%i:[%c]%i\n", __LINE__, *p, atoi (p));
  for (; *p && *p != ';'; p++);
  if (*p == ';') { p ++; }
  //printf ("%i:[%c]%i\n", __LINE__, *p, atoi (p));
  for (; *p && *p != ';'; p++);
  if (*p == ';') { p ++; }
  width = ctx_atoi (p);
  for (; *p && *p != ';'; p++);
  if (*p == ';') { p ++; }
  height = ctx_atoi (p);
  if (width * height > 2048 * 2048)
    return;
  if (width <= 0 || height <=0)
    {
      width = 0;
      height = 0;
      // XXX  : a copy paste dry-run
      for (const char *t=p; *t; t++)
        {
          if (*t == '#')
            {
              t++;
              while (*t && *t >= '0' && *t <= '9') { t++; }
              if (*t == ';')
                {
                  for (; *t && *t != ';'; t++);
                  if (*t == ';') { t ++; }
                  for (; *t && *t != ';'; t++);
                  if (*t == ';') { t ++; }
                  for (; *t && *t != ';'; t++);
                  if (*t == ';') { t ++; }
                  for (; *t && *t != ';'; t++);
                  if (*t == ';') { t ++; }
                  while (*t && *t >= '0' && *t <= '9') { t++; }
                  t--;
                }
              else
                {
                  t--;
                }
            }
          else if (*t == '$') // carriage return
            {
              if (x > width) { width = x; }
              x = 0;
            }
          else if (*t == '-') // line feed
            {
              y += 6;
              x = 0;
            }
          else if (*t == '!') // repeat
            {
              t++;
              repeat = ctx_atoi (t);
              while (*t && *t >= '0' && *t <= '9') { t++; }
              t--;
            }
          else if (*t >= '?' && *t <= '~') /* sixel data */
            {
              x += repeat;
              repeat = 1;
            }
        }
      height = y;
    }
  x = 0;
  y = 0;
  pixels = ctx_calloc (width * (height + 6), 4);
  image = image_add (width, height, 0,
                     32, width*height*4, pixels);
  uint8_t *dst = pixels;
  for (; *p; p++)
    {
      if (*p == '#')
        {
          p++;
          pal_no = atoi (p);
          if (pal_no < 0 || pal_no > 255) { pal_no = 255; }
          while (*p && *p >= '0' && *p <= '9') { p++; }
          if (*p == ';')
            {
              /* define a palette */
              for (; *p && *p != ';'; p++);
              if (*p == ';') { p ++; }
              // color_model , 2 is rgb
              for (; *p && *p != ';'; p++);
              if (*p == ';') { p ++; }
              colors[pal_no][0] = atoi (p) * 255 / 100;
              for (; *p && *p != ';'; p++);
              if (*p == ';') { p ++; }
              colors[pal_no][1] = atoi (p) * 255 / 100;
              for (; *p && *p != ';'; p++);
              if (*p == ';') { p ++; }
              colors[pal_no][2] = atoi (p) * 255 / 100;
              while (*p && *p >= '0' && *p <= '9') { p++; }
              p--;
            }
          else
            {
              p--;
            }
        }
      else if (*p == '$') // carriage return
        {
          x = 0;
          dst = &pixels[ (4 * width * y)];
        }
      else if (*p == '-') // line feed
        {
          y += 6;
          x = 0;
          dst = &pixels[ (4 * width * y)];
        }
      else if (*p == '!') // repeat
        {
          p++;
          repeat = ctx_atoi (p);
          while (*p && *p >= '0' && *p <= '9') { p++; }
          p--;
        }
      else if (*p >= '?' && *p <= '~') /* sixel data */
        {
          int sixel = (*p) - '?';
          if (x + repeat <= width && y < height)
            {
              for (int bit = 0; bit < 6; bit ++)
                {
                  if (sixel & (1 << bit) )
                    {
                      for (int u = 0; u < repeat; u++)
                        {
                          for (int c = 0; c < 3; c++)
                            {
                              dst[ (bit * width * 4) + u * 4 + c] = colors[pal_no][c];
                              dst[ (bit * width * 4) + u * 4 + 3] = 255;
                            }
                        }
                    }
                }
             x   += repeat;
             dst += (repeat * 4);
            }
          repeat = 1;
        }
    }
  if (image)
    {
      display_image (vt, image, vt->cursor_x, 0,0, 0.0, 0.0, 0,0,0,0);
      int right = (image->width + (vt->cw-1) ) /vt->cw;
      int down = (image->height + (vt->ch-1) ) /vt->ch;
      for (int i = 0; i<down - 1; i++)
        { vtcmd_index (vt, " "); }
      for (int i = 0; i<right; i++)
        { vtcmd_cursor_forward (vt, " "); }
      vt_line_feed (vt);
      vt_carriage_return (vt);
    }
  ctx_client_rev_inc (vt->client);
}
#endif

#if CTX_PARSER

#if CTX_DECOMPRESSOR
static void vt_state_ctx (VT *vt, int byte);
static void vt_state_ctx_from_prev (VT *vt, int byte)
{
  if (vt->clen < 8)
  {
    vt->cbuf[vt->clen++] = byte;
    vt->cbuf[vt->clen] = 0;
  }
  else
  {
    vt->state = vt_state_ctx;
    vt->clen=0;
  }
  
  int l1 = _ctx_utf8_len(*vt->cbuf);
  int l2 = 0;
  if (l1) l2 = _ctx_utf8_len(vt->cbuf[l1]);
  if (l1 && l2 && vt->clen == l1 + l2)
  {
    int matchpos = _ctx_utf8_to_unichar (vt->cbuf) - 1;
    int matchlen = _ctx_utf8_to_unichar (vt->cbuf + _ctx_utf8_len(*vt->cbuf));

    matchpos += 2; ///  tweak : skipping ":\n"

    // bounds checking
    if (matchpos < 0) matchpos = 0;
    if (matchpos >= vt->current_line->ctx_prev_frame_length - 1)
      matchpos = vt->current_line->ctx_prev_frame_length - 1;

    if (matchlen < 0) matchlen = 0;
    if (matchpos + matchlen >= vt->current_line->ctx_prev_frame_length - 1)
      matchlen  = vt->current_line->ctx_prev_frame_length - 1 - matchpos;

    for (int i = matchpos; i < matchpos + matchlen; i++)
    {
      byte = vt->current_line->ctx_prev_frame[i];
      ctx_string_append_byte (vt->current_line->ctx_frame, byte);
      ctx_parser_feed_byte (vt->ctxp, byte);
    }

    vt->state = vt_state_ctx;
    vt->clen=0;
  }
}
#endif

static void vt_state_ctx (VT *vt, int byte)
{
  #if CTX_DECOMPRESSOR
  if (byte == CTX_FROM_PREV)
  {
    vt->state = vt_state_ctx_from_prev;
  }
  else
  {
    ctx_string_append_byte (vt->current_line->ctx_frame, byte);
    ctx_parser_feed_byte (vt->ctxp, byte);
  }
  #else
  ctx_parser_feed_byte (vt->ctxp, byte);
  #endif
}
#endif

static inline int vt_decoder_feed (VT *vt, int byte)
{
  int encoding = vt->encoding;
  switch (encoding)
    {
      case 0: /* utf8 */
        if (!vt->utf8_expected_bytes)
          {
            vt->utf8_expected_bytes = ctx_utf8_len (byte) - 1;
            vt->utf8_pos = 0;
          }
        if (vt->utf8_expected_bytes)
          {
            vt->utf8_holding[vt->utf8_pos++] = byte;
            vt->utf8_holding[vt->utf8_pos] = 0;
            if (vt->utf8_pos == vt->utf8_expected_bytes + 1)
              {
                vt->utf8_expected_bytes = 0;
                vt->utf8_pos = 0;
              }
            else
              {
                return 1;
              }
          }
        else
          {
            vt->utf8_holding[0] = byte;
            vt->utf8_holding[0] &= 127;
            vt->utf8_holding[1] = 0;
            if (vt->utf8_holding[0] == 0)
              { vt->utf8_holding[0] = 32; }
          }
        break;
      case 1:
        if ( ! (byte>=0 && byte < 256) )
          { byte = 255; }
        strcpy ( (char *) &vt->utf8_holding[0], &charmap_cp437[byte][0]);
        vt->utf8_expected_bytes = ctx_utf8_len (byte) - 1; // ?
        break;
      default:
        vt->utf8_holding[0] = byte & 127;
        vt->utf8_holding[1] = 0;
        break;
    }
  return 0;
}

static void vt_state_swallow (VT *vt, int byte)
{
  vt->state = vt_state_neutral;
}

static int vt_decode_hex_digit (char digit)
{
  if (digit >= '0' && digit <='9')
    return digit - '0';
  if (digit >= 'a' && digit <='f')
    return digit - 'a' + 10;
  if (digit >= 'A' && digit <='F')
    return digit - 'A' + 10;
  return 0;
}

static int vt_decode_hex (const char *two_digits)
{
  return vt_decode_hex_digit (two_digits[0]) * 16 +
         vt_decode_hex_digit (two_digits[1]);
}

static uint8_t palettes[][16][3]=
{
  {
{0, 0, 0},
{160, 41, 41},
{74, 160, 139},
{135, 132, 83},
{36, 36, 237},
{171, 74, 223},
{59, 107, 177},
{195, 195, 195},
{111, 111, 111},
{237, 172, 130},
{153, 237, 186},
{233, 216, 8},
{130, 180, 237},
{214, 111, 237},
{29, 225, 237},
{255, 255, 255},

  },

  {
    {0, 0, 0},
    {127, 0, 0},
    {90, 209, 88},
    {136, 109, 0},
    {3, 9, 235},
    {90, 4, 150},
    {43, 111, 150},
    {178, 178, 178},
    {87, 87, 87},
    {193, 122, 99},
    {110, 254, 174},
    {255, 200, 0},
    {10, 126, 254},
    {146, 155, 249},
    {184, 208, 254},
    {255, 255, 255},

  },{
    {0, 0, 0},
    {147, 53, 38},
    {30, 171, 82},
    {188, 153, 0},
    {32, 71, 193},
    {236, 49, 188},
    {42, 182, 253},
    {149, 149, 149},
    {73, 73, 73},
    {210, 36, 0},
    {96, 239, 97},
    {247, 240, 2},
    {93, 11, 249},
    {222, 42, 255},
    {11, 227, 255},
    {233, 235, 235},
  },


  { {0, 0, 0},{97, 27, 0},{129, 180, 0},{127, 100, 0},{44, 15, 255},{135, 10, 167},{20, 133, 164},{174, 174, 174},{71, 71, 71},{167, 114, 90},{162, 214, 127},{255, 251, 83},{118, 77, 253},{192, 121, 255},{14, 217, 255},{255, 255, 255},
  },{


#if 0
    {
      {0, 0, 0},
      {144, 0, 0},
      {9, 154, 9},
      {255, 137, 113},
      {3, 0, 255},
      {56, 0, 132},
      {0, 131, 131},
      {204, 204, 204},
      {127, 127, 127},
      {255, 33, 0},
      {113, 255, 88},
      {255, 236, 8},
      {1, 122, 255},
      {235, 0, 222},
      {0, 217, 255},
      {255, 255, 255},
    },{
#endif


    {0, 0, 0},
    {139, 0, 0},
    {9, 154, 9},
    {255, 137, 113},
    {3, 0, 255},
    {56, 0, 132},
    {0, 111, 111},
    {204, 204, 204},
    {127, 127, 127},
    {255, 33, 0},
    {118, 255, 92},
    {255, 230, 15},
    {1, 122, 255},
    {232, 0, 220},
    {1, 217, 255},
    {255, 255, 255},
  },
  {

    {0, 0, 0},
    {191, 0, 0},
    {3, 187, 0},
    {254, 212, 0},
    {0, 0, 255},
    {80, 0, 128},
    {0, 156, 255},
    {166, 166, 166},
    {84, 84, 84},
    {255, 62, 0},
    {85, 255, 143},
    {255, 255, 0},
    {67, 80, 255},
    {243, 70, 255},
    {30, 255, 222},
    {255, 255, 255},
  },
  {
    /* */
    { 32, 32, 32}, // 0 - background (black)
    {165, 15, 21}, // 1               red
    { 95,130, 10}, // 2               green
    {205,145, 60}, // 3               yellow
    { 49,130,189}, // 4               blue
    {120, 40,160}, // 5               magenta
    {120,230,230}, // 6               cyan
    {196,196,196},// 7                light-gray
    { 85, 85, 85},// 8                dark gray

    {251,106, 74},// 9                light red
    {130,215,140},// 10               light green
    {255,255,  0},// 11               light yellow
    {107,174,214},// 12               light blue
    {215,130,160},// 13               light magenta
    {225,255,245},// 14               light cyan
    {255,255,255},// 15 - foreground (white)
  },{
    /* */
    { 32, 32, 32}, // 0 - background (black)
    {160,  0,  0}, // 1               red
    {  9,233,  0}, // 2               green
    {220,110, 44}, // 3               yellow
    {  0,  0,200}, // 4               blue
    { 90,  0,130}, // 5               magenta
    {  0,156,180}, // 6               cyan
    {196,196,196}, // 7                light-gray
    { 85, 85, 85}, // 8                dark gray

    {240, 60, 40}, // 9                light red
    {170,240, 80}, // 10               light green
    {248,248,  0}, // 11               light yellow
    {  0, 40,255}, // 12               light blue
    {204, 62,214}, // 13               light magenta
    { 10,234,254}, // 14               light cyan
    {255,255,255}, // 15 - foreground (white)
  },
  /* inspired by DEC */
  { {  0,  0,  0}, // 0 - background  black
    {150, 10, 10}, // 1               red
    { 21,133,  0}, // 2               green

    {103,103, 24}, // 3               yellow
    { 44, 44,153}, // 4               blue
    {123, 94,183}, // 5               magenta

    { 20,183,193}, // 6               cyan

    {177,177,177},// 7                light-gray
    {100,100,100},// 8                dark gray

    {244, 39, 39},// 9                light red
    { 61,224, 81},// 10               light green
    {255,255,  0},// 11               light yellow
    { 61, 61,244},// 12               light blue
    {240, 11,240},// 13               light magenta
    { 61,234,234},// 14               light cyan

    {255,255,255},// 15 - foreground  white
  },
};

void vt_set_palette(int color_no, uint8_t red, uint8_t green, uint8_t blue)
{
  palettes[0][color_no][0]=red;
  palettes[0][color_no][1]=green;
  palettes[0][color_no][2]=blue;
}

static void vt_state_osc (VT *vt, int byte)
{
  // https://ttssh2.osdn.jp/manual/4/en/about/ctrlseq.html
  // and in "\033\" rather than just "\033", this would cause
  // a stray char
  //if (byte == '\a' || byte == 27 || byte == 0 || byte < 32)
  if ( (byte < 32) && ( (byte < 8) || (byte > 13) ) )
    {
      int n = parse_int (vt->argument_buf, 0);
      switch (n)
        {
          case 0:
          case 1:
          case 2:
#if 0
    {"]0;New_title\033\",  0, , }, /* id: set window title */ "
#endif
            if (strlen (vt->argument_buf)>3)
            vt_set_title (vt, vt->argument_buf + 3);
            break;
          case 4: // set palette entry
            {
            int color_no = parse_int (vt->argument_buf + 2, 0);
            char *rest = vt->argument_buf + 3;
            rest = strchr (rest, ';');

            if (rest++)
            if (strlen(rest)>10 &&
                rest[0] == 'r' &&
                rest[1] == 'g' &&
                rest[2] == 'b' &&
                rest[3] == ':' &&
                rest[6] == '/' &&
                rest[9] == '/')
            {
              int red = vt_decode_hex (&rest[4]);
              int green = vt_decode_hex (&rest[7]);
              int blue = vt_decode_hex (&rest[10]);
          //  fprintf (stderr, "set color:%i  %i %i %i\n", color_no, red, green, blue);
              if (color_no >= 0 && color_no <= 15)
              {
                vt_set_palette(color_no, red, green, blue);
              }
            }
            }
            break;
          case 12: // text cursor color
            break;
          case 17: // highlight color
            break;
          case 19: // ??
            break;

          case 10: // text fg
#if 0
#if 0
    {"]11;",  0, , }, /* id: set foreground color */
#endif
            {
              /* request current foreground color, xterm does this to
                 determine if it can use 256 colors, when this test fails,
                 it still mixes in color 130 together with stock colors
               */
              char buf[128];
              sprintf (buf, "\033]10;rgb:%2x/%2x/%2x\033\\",
                       vt->fg_color[0], vt->fg_color[1], vt->fg_color[2]);
              vt_write (vt, buf, strlen (buf) );
            }
#endif
            break;
          case 11: // text bg
#if 0
    {"]11;",  0, , }, /* id: get background color */
            {
              /* get background color */
              char buf[128];
              sprintf (buf, "\033]11;rgb:%2x/%2x/%2x\033\\",
                       vt->bg_color[0], vt->bg_color[1], vt->bg_color[2]);
              vt_write (vt, buf, strlen (buf) );
            }
#endif
            break;
#if 0
    {"]1337;key=value:base64data\b\",  0, vtcmd_erase_in_line, VT100}, /* args:keyvalue id: iterm2 graphics */ "
#endif
#if CTX_STB_IMAGE
          case 1337:
            if (!strncmp (&vt->argument_buf[6], "File=", 5) )
              {
                {
                  /* iTerm2 image protocol */
                  int width = 0;
                  int height = 0;
                  int file_size = 0;
                  int show_inline = 0;
                  int preserve_aspect = 1;
                  char *name = NULL;
                  char *p = &vt->argument_buf[11];
                  char key[128]="";
                  char value[128]="";
                  int in_key=1;
                  if (preserve_aspect) {}; /* XXX : NYI */
                  for (; *p && *p!=':'; p++)
                    {
                      if (in_key)
                        {
                          if (*p == '=')
                            { in_key = 0; }
                          else
                            {
                              if (strlen (key) < 124)
                                {
                                  key[strlen (key)+1] = 0;
                                  key[strlen (key)] = *p;
                                }
                            }
                        }
                      else
                        {
                          if (*p == ';')
                            {
                              if (!strcmp (key, "name") )
                                {
                                  name = ctx_strdup (value);
                                }
                              else if (!strcmp (key, "width") )
                                {
                                  width = atoi (value);
                                  if (strchr (value, 'x') )
                                    { /* pixels */ }
                                  else if (strchr (value, '%') )
                                    {
                                      /* percent */
                                      width = width / 100.0 * (vt->cw * vt->cols);
                                    }
                                  else
                                    { /* chars */ width = width * vt->cw; }
                                }
                              else if (!strcmp (key, "height") )
                                {
                                  height = atoi (value);
                                  if (strchr (value, 'x') )
                                    { /* pixels */ }
                                  else if (strchr (value, '%') )
                                    {
                                      /* percent */
                                      height = height / 100.0 * (vt->ch * vt->rows);
                                    }
                                  else
                                    { /* chars */ height = height * vt->ch; }
                                }
                              else if (!strcmp (key, "preserveAspectRatio") )
                                {
                                  preserve_aspect = atoi (value);
                                }
                              else if (!strcmp (key, "inline") )
                                {
                                  show_inline = atoi (value);
                                }
                              key[0]=0;
                              value[0]=0;
                              in_key = 1;
                            }
                          else
                            {
                              if (strlen (value) < 124)
                                {
                                  value[strlen (value)+1] = 0;
                                  value[strlen (value)] = *p;
                                }
                            }
                        }
                    }
                  if (key[0])
                    {
                      // code-dup
                      if (!strcmp (key, "name") )
                        {
                          name = ctx_strdup (value);
                        }
                      else if (!strcmp (key, "width") )
                        {
                          width = atoi (value);
                          if (strchr (value, 'x') )
                            { /* pixels */ }
                          else if (strchr (value, '%') )
                            {
                              /* percent */
                              width = width / 100.0 * (vt->cw * vt->cols);
                            }
                          else
                            { /* chars */ width = width * vt->cw; }
                        }
                      else if (!strcmp (key, "height") )
                        {
                          height = atoi (value);
                          if (strchr (value, 'x') )
                            { /* pixels */ }
                          else if (strchr (value, '%') )
                            {
                              /* percent */
                              height = height / 100.0 * (vt->ch * vt->rows);
                            }
                          else
                            { /* chars */ height = height * vt->ch; }
                        }
                      else if (!strcmp (key, "preserveAspectRatio") )
                        {
                          preserve_aspect = atoi (value);
                        }
                      else if (!strcmp (key, "inline") )
                        {
                          show_inline = atoi (value);
                        }
                    }
                  if (*p == ':')
                    {
                      p++;
                    }
                  if (0)
                    fprintf (stderr, "%s %i %i %i %i{%s\n", name?name:"",
                             width, height, file_size, show_inline,
                             p);
                  Image *image = NULL;
                  {
                    int bin_length = vt->argument_buf_len;
                    uint8_t *data2 = ctx_malloc (bin_length);
                    bin_length = ctx_base642bin ( (char *) p,
                                                 &bin_length,
                                                 data2);
                    int channels = 4;
                    int buf_width = 0;
                    int buf_height = 0;
                    uint8_t *new_data = stbi_load_from_memory (data2, bin_length, &buf_width, &buf_height, &channels, 4);
                    free (data2);
                    if (new_data)
                      {
                        image = image_add (buf_width, buf_height, 0,
                                           32, buf_width*buf_height*4, new_data);
                      }
                    else
                      {
                        fprintf (stderr, "image decoding problem %s\n", stbi_failure_reason());
                        fprintf (stderr, "len: %i\n", bin_length);
                      }
                  }
                  if (image)
                    {
                      display_image (vt, image, vt->cursor_x, 0,0, 0.0, 0.0, 0,0,0,0);
                      int right = (image->width + (vt->cw-1) ) /vt->cw;
                      int down = (image->height + (vt->ch-1) ) /vt->ch;
                      for (int i = 0; i<down - 1; i++)
                        { vtcmd_index (vt, " "); }
                      for (int i = 0; i<right; i++)
                        { vtcmd_cursor_forward (vt, " "); }
                    }
                }
              }
            break;
#endif
          case 104:
            break;
          case 8:
            fprintf (stderr, "unhandled OSC 8, hyperlink\n");
            break;
          default:
            fprintf (stderr, "unhandled OSC %i\n", n);
            break;
        }
      if (byte == 27)
        {
          vt->state = vt_state_swallow;
        }
      else
        {
          vt->state = vt_state_neutral;
        }
    }
  else
    {
      vt_argument_buf_add (vt, byte);
    }
}

#if CTX_VT_SIXELS
static void vt_state_sixel (VT *vt, int byte)
{
  // https://ttssh2.osdn.jp/manual/4/en/about/ctrlseq.html
  // and in "\033\" rather than just "\033", this would cause
  // a stray char
  if ( (byte < 32) && ( (byte < 8) || (byte > 13) ) )
    {
      vt_sixels (vt, vt->argument_buf);
      if (byte == 27)
        {
          vt->state = vt_state_swallow;
        }
      else
        {
          vt->state = vt_state_neutral;
        }
    }
  else
    {
      vt_argument_buf_add (vt, byte);
      //fprintf (stderr, "\r%i ", vt->argument_buf_len);
    }
}
#endif

//void add_tab (Ctx *ctx, const char *commandline, int can_launch);
//void vt_screenshot (const char *output_path);

static void vt_state_apc_generic (VT *vt, int byte)
{
  if ( (byte < 32) && ( (byte < 8) || (byte > 13) ) )
    {
#if CTX_VT_GFX
      if (vt->argument_buf[1] == 'G') /* graphics - from kitty */
        {
          vt_gfx (vt, vt->argument_buf);
        }
      else
#endif
      if (vt->argument_buf[1] == 'C') /* launch command */
      {
        if (vt->can_launch)
        {
          int   can_launch = 0;
          int   no_title = 0;
          int   no_move = 0;
          int   no_resize = 0;
          int   layer = 0;
  // escape subsequent arguments so that we dont have to pass a string?
          float x = -1.0;
          float y = -1.0;
          int   z = 0;
          float width = -1.0;
          float height = -1.0;

          for (int i=2; vt->argument_buf[i]; i++)
          {
            if (!strncmp (&vt->argument_buf[i], "can_launch=1", strlen ("can_launch=1")))
              can_launch = 1;
            if (!strncmp (&vt->argument_buf[i], "no_title=1", strlen("no_title=1")))
              no_title = 1;
            if (!strncmp (&vt->argument_buf[i], "no_move=1", strlen("no_move=1")))
              no_move = 1;
            else if (!strncmp (&vt->argument_buf[i], "z=", 2))
              z=atoi(&vt->argument_buf[i]+strlen("z="));
            else if (!strncmp (&vt->argument_buf[i], "x=", 2))
              x=atof(&vt->argument_buf[i]+strlen("x="));
            else if (!strncmp (&vt->argument_buf[i], "y=", 2))
              y=atof(&vt->argument_buf[i]+strlen("y="));
            else if (!strncmp (&vt->argument_buf[i], "width=", 6))
              width=atof(&vt->argument_buf[i]+strlen("width="));
            else if (!strncmp (&vt->argument_buf[i], "height=", 7))
              height=atof(&vt->argument_buf[i]+strlen("height="));
          }

          if (width + no_resize + layer + height + x + y + no_title + no_move + z + can_launch) {};

          char *sep = strchr(vt->argument_buf, ';');
          if (sep)
          {
            //fprintf (stderr, "[%s]", sep +  1);
            if (!strncmp (sep + 1, "fbsave", 6))
            {
              // vt_screenshot (sep + 8);
            }
            else
            {
#if 0
#if CTX_VT_LAUNCH
              add_tab (ctx, sep + 1, can_launch);
#endif
#endif
            }
          }
        }

      }
      vt->state = ( (byte == 27) ?  vt_state_swallow : vt_state_neutral);
    }
  else
    {
      vt_argument_buf_add (vt, byte);
    }
}

#if 0
    {"_G..\033\", 0, vtcmd_delete_n_chars, VT102}, /* ref:none id: <a href='https://sw.kovidgoyal.net/kitty/graphics-protocol.html'>kitty graphics</a> */ "
    {"_A..\033\", 0, vtcmd_delete_n_chars, VT102}, /* id:  <a href='https://github.com/hodefoting/atty/'>atty</a> audio input/output */ "
    {"_C..\033\", 0, vtcmd_delete_n_chars, VT102}, /* id:  run command */ "
#endif
static void vt_state_apc (VT *vt, int byte)
{
  if (byte == 'A')
    {
      vt_argument_buf_add (vt, byte);
      vt->state = vt_state_apc_audio;
    }
  else if ( (byte < 32) && ( (byte < 8) || (byte > 13) ) )
    {
      vt->state = ( (byte == 27) ?  vt_state_swallow : vt_state_neutral);
    }
  else
    {
      vt_argument_buf_add (vt, byte);
      vt->state = vt_state_apc_generic;
    }
}

static void vt_state_esc_foo (VT *vt, int byte)
{
  vt_argument_buf_add (vt, byte);
  vt->state = vt_state_neutral;
  handle_sequence (vt, vt->argument_buf);
}

static void vt_state_esc_sequence (VT *vt, int byte)
{
  if (_vt_handle_control (vt, byte) == 0)
    {
      if (byte == 27)
        {
        }
      else if (byte >= '@' && byte <= '~')
        {
          vt_argument_buf_add (vt, byte);
          vt->state = vt_state_neutral;
          handle_sequence (vt, vt->argument_buf);
        }
      else
        {
          vt_argument_buf_add (vt, byte);
        }
    }
}

static void vt_state_esc (VT *vt, int byte)
{
  if (_vt_handle_control (vt, byte) == 0)
    switch (byte)
      {
        case 27: /* ESCape */
          break;
        case ')':
        case '#':
        case '(':
          {
            char tmp[]= {byte, '\0'};
            vt_argument_buf_reset (vt, tmp);
            vt->state = vt_state_esc_foo;
          }
          break;
        case '[':
        case '%':
        case '+':
        case '*':
          {
            char tmp[]= {byte, '\0'};
            vt_argument_buf_reset (vt, tmp);
            vt->state = vt_state_esc_sequence;
          }
          break;


#if CTX_VT_SIXELS
        case 'P':
          {
            char tmp[]= {byte, '\0'};
            vt_argument_buf_reset (vt, tmp);
            vt->state = vt_state_sixel;
          }
          break;
#endif
        case ']':
          {
            char tmp[]= {byte, '\0'};
            vt_argument_buf_reset (vt, tmp);
            vt->state = vt_state_osc;
          }
          break;
        case '^':  // privacy message
        case '_':  // APC
        case 'X':  // SOS
          {
            char tmp[]= {byte, '\0'};
            vt_argument_buf_reset (vt, tmp);
            vt->state = vt_state_apc;
          }
          break;
        default:
          {
            char tmp[]= {byte, '\0'};
            tmp[0]=byte;
            vt->state = vt_state_neutral;
            handle_sequence (vt, tmp);
          }
          break;
      }
}

static void vt_state_neutral (VT *vt, int byte)
{
  if (CTX_UNLIKELY(_vt_handle_control (vt, byte) != 0))
    return;
  if (CTX_LIKELY(byte != 27))
  {
    if (vt_decoder_feed (vt, byte) )
      return;
    if (vt->charset[vt->shifted_in] != 0 &&
        vt->charset[vt->shifted_in] != 'B')
      {
        const char **charmap;
        switch (vt->charset[vt->shifted_in])
          {
            case 'A':
              charmap = charmap_uk;
              break;
            case 'B':
              charmap = charmap_ascii;
              break;
            case '0':
              charmap = charmap_graphics;
              break;
            case '1':
              charmap = charmap_cp437;
              break;
            case '2':
              charmap = charmap_graphics;
              break;
            default:
              charmap = charmap_ascii;
              break;
          }
        if ( (vt->utf8_holding[0] >= ' ') && (vt->utf8_holding[0] <= '~') )
          {
            _vt_add_str (vt, charmap[vt->utf8_holding[0]-' ']);
          }
      }
    else
      {
        // ensure vt->utf8_holding contains a valid utf8
        uint32_t codepoint;
        uint32_t state = 0;
        for (int i = 0; vt->utf8_holding[i]; i++)
          { utf8_decode (&state, &codepoint, vt->utf8_holding[i]); }
          /// XXX : fixme use ctx API
        if (state != UTF8_ACCEPT)
          {
            /* otherwise mangle it so that it does */
            vt->utf8_holding[0] &= 127;
            vt->utf8_holding[1] = 0;
            if (vt->utf8_holding[0] == 0)
              { vt->utf8_holding[0] = 32; }
          }
        _vt_add_str (vt, (char *) vt->utf8_holding);
      }
  }
  else // ESCape
  {
    vt->state = vt_state_esc;
  }
}

int vt_poll (VT *vt, int timeout)
{
  if (!vt) return 0;
  int read_size = sizeof (vt->buf);
  int got_data = 0;

  // read_size 1m1.142s
  // read_size*10  52s
  // read_size*5   53.8s
  // read_size*4   53.78s
  // read_size*3   .....s
  // read_size*2   56.99s
  int remaining_chars = read_size * 10;// * 3;// * 100;
  int len = 0;
  //vt_audio_task (vt, 0);
#if 1
  if (vt->cursor_visible && vt->smooth_scroll)
    {
      remaining_chars = vt->cols / 2;
    }
#endif
  read_size = MIN (read_size, remaining_chars);
  long start_ticks = ctx_ticks ();
  long ticks = start_ticks;
  int first = 1;
  while (remaining_chars > 0 &&
         vt_waitdata (vt, first?0:1000*5) &&
         ( ticks - start_ticks < timeout
#if CTX_PARSER
           ||  vt->state == vt_state_ctx
#endif
           
           ))
    {
      first = 0;
#if CTX_AUDIO
      vt_audio_task (vt, 0);
#endif
  if (vt->in_smooth_scroll)
    {
      remaining_chars = 1;
      // XXX : need a bail condition -
      // /// so that we can stop accepting data until autowrap or similar
    }
      len = vt_read (vt, vt->buf, read_size);
      if (len >0)
      {
#if CTX_VT_LOG
        if (vt->log)
          fwrite (vt->buf, len, 1, vt->log);
#endif
     // fwrite (vt->buf, len, 1, stdout);
      }
      for (int i = 0; i < len; i++)
        { vt->state (vt, vt->buf[i]); }
      // XXX allow state to break out in ctx mode on flush
      got_data+=len;
      remaining_chars -= len;
#if CTX_PARSER
      if (vt->state == vt_state_ctx) {
         if (remaining_chars < read_size)
         {
           remaining_chars = read_size * 2;
         }
      }
#endif
      ticks = ctx_ticks ();
    }
  if (got_data < 0)
    {
      vt->empty_count ++;
      if (vt->empty_count > 256)
      {
        if (kill (vt->vtpty.pid, 0) != 0)
        {
          vt->vtpty.done = 1;
        }
        vt->empty_count = 1;
      }
    }
  else
     vt->empty_count = 0;
  return got_data;
}

/******/

static const char *keymap_vt52[][2]=
{
  {"up",    "\033A" },
  {"down",  "\033B" },
  {"right", "\033C" },
  {"left",  "\033D" },
};

static const char *keymap_application[][2]=
{
  {"up",    "\033OA" },
  {"down",  "\033OB" },
  {"right", "\033OC" },
  {"left",  "\033OD" },
};

static const char *keymap_general[][2]=
{
  {"up",             "\033[A"},
  {"down",           "\033[B"},
  {"right",          "\033[C"},
  {"left",           "\033[D"},
  {"end",            "\033[F"},
  {"home",           "\033[H"},
  {"shift-up",       "\033[1;2A"},
  {"shift-down",     "\033[1;2B"},
  {"shift-right",    "\033[1;2C"},
  {"shift-left",     "\033[1;2D"},
  {"alt-a",          "\033a"},
  {"alt-b",          "\033b"},
  {"alt-c",          "\033c"},
  {"alt-d",          "\033d"},
  {"alt-e",          "\033e"},
  {"alt-f",          "\033f"},
  {"alt-g",          "\033g"},
  {"alt-h",          "\033h"},
  {"alt-i",          "\033i"},
  {"alt-j",          "\033j"},
  {"alt-k",          "\033k"},
  {"alt-l",          "\033l"},
  {"alt-m",          "\033m"},
  {"alt-n",          "\033n"},
  {"alt-o",          "\033o"},
  {"alt-p",          "\033p"},
  {"alt-q",          "\033q"},
  {"alt-r",          "\033r"},
  {"alt-s",          "\033s"},
  {"alt-t",          "\033t"},
  {"alt-u",          "\033u"},
  {"alt-v",          "\033v"},
  {"alt-w",          "\033w"},
  {"alt-x",          "\033x"},
  {"alt-y",          "\033y"},
  {"alt-z",          "\033z"},
  {"alt- ",          "\033 "},
  {"alt-space",      "\033 "},
  {"alt-0",          "\0330"},
  {"alt-1",          "\0331"},
  {"alt-2",          "\0332"},
  {"alt-3",          "\0333"},
  {"alt-4",          "\0334"},
  {"alt-5",          "\0335"},
  {"alt-6",          "\0336"},
  {"alt-7",          "\0337"},
  {"alt-8",          "\0338"},
  {"alt-9",          "\0339"},
  {"alt-return",     "\033\r"},
  {"alt-backspace",  "\033\177"},
  {"alt-up",         "\033[1;3A"},
  {"alt-down",       "\033[1;3B"},
  {"alt-right",      "\033[1;3C"},
  {"alt-left",       "\033[1;3D"},
  {"shift-alt-up",   "\033[1;4A"},
  {"shift-alt-down", "\033[1;4B"},
  {"shift-alt-right","\033[1;4C"},
  {"shift-alt-left", "\033[1;4D"},
  {"control-space",  "\000"},
  {"control-up",     "\033[1;5A"},
  {"control-down",   "\033[1;5B"},
  {"control-right",  "\033[1;5C"},
  {"control-left",   "\033[1;5D"},
  {"shift-control-up",    "\033[1;6A"},
  {"shift-control-down",  "\033[1;6B"},
  {"shift-control-right", "\033[1;6C"},
  {"shift-control-left",  "\033[1;6D"},
  {"insert",         "\033[2~"},
  {"delete",         "\033[3~"},
  {"control-delete", "\033[3,5~"},
  {"shift-delete",   "\033[3,2~"},
  {"control-shift-delete",  "\033[3,6~"},
  {"page-up",        "\033[5~"},
  {"page-down",     "\033[6~"},
  {"return",         "\r"},
  {"shift-tab",      "\033Z"},
  {"shift-return",   "\r"},
  {"control-return", "\r"},
  {"space",          " "},
  {"shift-space",    " "},
  {"control-a",      "\001"},
  {"control-b",      "\002"},
  {"control-c",      "\003"},
  {"control-d",      "\004"},
  {"control-e",      "\005"},
  {"control-f",      "\006"},
  {"control-g",      "\007"},
  {"control-h",      "\010"},
  {"control-i",      "\011"},
  {"control-j",      "\012"},
  {"control-k",      "\013"},
  {"control-l",      "\014"},
  {"control-m",      "\015"},
  {"control-n",      "\016"},
  {"control-o",      "\017"},
  {"control-p",      "\020"},
  {"control-q",      "\021"},
  {"control-r",      "\022"},
  {"control-s",      "\023"},
  {"control-t",      "\024"},
  {"control-u",      "\025"},
  {"control-v",      "\026"},
  {"control-w",      "\027"},
  {"control-x",      "\030"},
  {"control-y",      "\031"},
  {"control-z",      "\032"},
  {"escape",         "\033"},
  {"shift-escape",   "\033"},
  {"tab",            "\t"},
  {"backspace",      "\177"},
  {"control-backspace", "\177"},
  {"shift-backspace","\177"},
  {"shift-tab",      "\033[Z"},

  {"control-F1",     "\033[>11~"},
  {"control-F2",     "\033[>12~"},
  {"control-F3",     "\033[>13~"},
  {"control-F4",     "\033[>14~"},
  {"control-F5",     "\033[>15~"},

  {"shift-F1",       "\033[?11~"},
  {"shift-F2",       "\033[?12~"},
  {"shift-F3",       "\033[?13~"},
  {"shift-F4",       "\033[?14~"},
  {"shift-F5",       "\033[?15~"},

  {"F1",             "\033[11~"},  // hold screen   // ESC O P
  {"F2",             "\033[12~"},  // print screen  //       Q
  {"F3",             "\033[13~"},  // set-up                 R
  {"F4",             "\033[14~"},  // data/talk              S
  {"F5",             "\033[15~"},  // break
  {"F6",             "\033[17~"},
  {"F7",             "\033[18~"},
  {"F8",             "\033[19~"},
  {"F9",             "\033[20~"},
  {"F10",            "\033[21~"},
  {"F11",            "\033[22~"},
  {"F12",            "\033[23~"},
  {"control-/",       "\037"},
  {"shift-control-/", "\037"},
  {"control-[",       "\033"},
  {"control-]",       "\035"},
  {"shift-control-[", "\033"},
  {"shift-control-]", "\031"},
  {"shift-control-`", "\036"},
  {"control-'",       "'"},
  {"shift-control-'", "'"},
  {"control-;",       ";"},
  {"shift-control-;", ";"},
  {"control-.",       "."},
  {"shift-control-.", "."},
  {"control-,",       ","},
  {"shift-control-,", ","},
  {"control-\\",      "\034"},
  {"control-1",       "1"},
  {"control-3",       "\033"},
  {"control-4",       "\034"},
  {"control-5",       "\035"},
  {"control-6",       "\036"},
  {"shift-control-6", "\036"},
  {"control-7",       "\037"},
  {"shift-control-7", "\036"},
  {"control-8",       "\177"},
  {"control-9",       "9"},


};

void ctx_client_lock (CtxClient *client);
void ctx_client_unlock (CtxClient *client);

void vt_feed_keystring (VT *vt, CtxEvent *event, const char *str)
{
  if (vt->ctx_events)
  {
    if (!strcmp (str, "control-l") )
    {
      vt->ctx_events = 0;
      return;
    }
    vt_write (vt, str, strlen (str) );
    vt_write (vt, "\n", 1);
    return;
  }
  if (!strncmp (str, "keyup",   5)) return;
  if (!strncmp (str, "keydown", 7)) return;

  if (!strncmp (str, "resize-event", 12)) return;
  if (!strcmp (str, "capslock")) return;

#if 0
  if (!ctx_strstr (str, "-page"))
    vt_set_scroll (vt, 0);
#endif

  if (!strcmp (str, "idle") )
     return;
  else if (!strcmp (str, "shift-control-home"))
    {
      vt_set_scroll (vt, vt->scrollback_count);
      ctx_client_rev_inc (vt->client);
      return;
    }
  else if (!strcmp (str, "shift-control-end"))
    {
      int new_scroll = 0;
      vt_set_scroll (vt, new_scroll);
      ctx_client_rev_inc (vt->client);
      return;
    }
  else if (!strcmp (str, "shift-control-down"))
    {
      int new_scroll = vt_get_scroll (vt) - 1;
      vt_set_scroll (vt, new_scroll);
      ctx_client_rev_inc (vt->client);
      return;
    }
  else if (!strcmp (str, "shift-control-up"))
    {
      int new_scroll = vt_get_scroll (vt) + 1;
      vt_set_scroll (vt, new_scroll);
      ctx_client_rev_inc (vt->client);
      return;
    }
  else if (!strcmp (str, "shift-page-up") ||
           !strcmp (str, "shift-control-page-up"))
    {
      int new_scroll = vt_get_scroll (vt) + vt_get_rows (vt) /2;
      vt_set_scroll (vt, new_scroll);
      ctx_client_rev_inc (vt->client);
      return;
    }
  else if (!strcmp (str, "shift-page-down") ||
           !strcmp (str, "shift-control-page-down"))
    {
      int new_scroll = vt_get_scroll (vt) - vt_get_rows (vt) /2;
      if (new_scroll < 0) { new_scroll = 0; }
      vt_set_scroll (vt, new_scroll);
      ctx_client_rev_inc (vt->client);
      return;
    }
    #if 0
  else if (!strcmp (str, "control-0") ||
           !strcmp (str, "shift-control-0"))
  {
      float font_size = 16.0;
      vt_set_font_size (vt, font_size);
      vt_set_px_size (vt, vt->width, vt->height);
      return;
  }
  else if (!strcmp (str, "shift-control--") ||
           !strcmp (str, "control--") )
    {
      float font_size = vt_get_font_size (vt);
      //font_size /= 1.15;
      font_size -=1;//= roundf (font_size);
      if (font_size < 2) { font_size = 2; }
      vt_set_font_size (vt, font_size);
      vt_set_px_size (vt, vt->width, vt->height);
      return;
    }
  else if (!strcmp (str, "shift-control-=") ||
           !strcmp (str, "shift-control-+") ||
           !strcmp (str, "control-+") ||
           !strcmp (str, "control-=") )
    {
      float font_size = vt_get_font_size (vt);
      float old = font_size;
      font_size+=1;

      if (old == font_size) { font_size = old+1; }
      if (font_size > 200) { font_size = 200; }
      vt_set_font_size (vt, font_size);
      vt_set_px_size (vt, vt->width, vt->height);

      return;
    }
    #endif
#if CTX_VT_LOG
  else if (!strcmp (str, "control-r") )
    {
      vt_open_log (vt, "/tmp/ctx-vt");
      return;
    }
#endif

  else if (!strcmp (str, "shift-control-l") )
    {  // XXX : remove?
      vt_set_local (vt, !vt_get_local (vt) );
      return;
    }
  else if ((!strncmp (str, "control-p", 9)) && (str[9]!=0) && (str[10] == ' '))
    {
      str+=8;
      goto mice; 
    }
  else if ((!strncmp (str, "shift-p", 7)) && (str[7]!=0) && (str[8] == ' '))
    {
      str+=6;
      goto mice; 
    }

  else if (str[0]=='p' && str[1] != 0 && str[2] == ' ')
  {
mice:{
      float cw = vt_cw (vt);
      float ch = vt_ch (vt);
      if (!strncmp (str, "pm", 2))
        {
          int x = 0, y = 0;
          char *s = strchr (str, ' ');
          if (s)
            {
              x = atoi (s);
              s = strchr (s + 1, ' ');
              if (s)
                {
                  y = atoi (s);
                  vt_mouse (vt, event, VT_MOUSE_MOTION, 1, x/cw + 1, y/ch + 1, x, y);
                }
            }
        }
      else if (!strncmp (str, "pp", 2))
        {
          int x = 0, y = 0, b = 0;
          char *s = strchr (str, ' ');
          if (s)
            {
              x = atoi (s);
              s = strchr (s + 1, ' ');
              if (s)
                {
                  y = atoi (s);
                  s = strchr (s + 1, ' ');
                  if (s)
                  {
                    b = atoi (s);
                  }
                  vt_mouse (vt, event, VT_MOUSE_PRESS, b, x/cw + 1, y/ch + 1, x, y);
                }
            }
          //clients[active].drawn_rev = 0;
        }
      else if (!strncmp (str, "pd", 2))
        {
          int x = 0, y = 0, b = 0; // XXX initialize B
          char *s = strchr (str, ' ');
          if (s)
            {
              x = atoi (s);
              s = strchr (s + 1, ' ');
              if (s)
                {
                  y = atoi (s);
                  if (s)
                  {
                    b = atoi (s);
                  }
                  vt_mouse (vt, event, VT_MOUSE_DRAG, b, x/cw + 1, y/ch + 1, x, y);
                }
            }
          //clients[active].drawn_rev = 0;
        }
      else if (!strncmp (str, "pr", 2))
        {
          int x = 0, y = 0, b = 0;
          char *s = strchr (str, ' ');
          if (s)
            {
              x = atoi (s);
              s = strchr (s + 1, ' ');
              if (s)
                {
                  y = atoi (s);
                  s = strchr (s + 1, ' ');
                  if (s)
                  {
                    b = atoi (s);
                  }
                  vt_mouse (vt, event, VT_MOUSE_RELEASE, b, x/cw + 1, y/ch + 1, x, y);
                }
            }
          //clients[active].drawn_rev = 0;
          // queue-draw
        }
      return;
    }
  }
  else if ((!strncmp (str, "alt-p", 5)))
  {
    // or should we handle alt + mouse as if alt was not down?
    return;
  }
  else if ((!strncmp (str, "shift-control-p", 15)))
  {
    return;
  }


  if (vt->scroll_on_input)
  {
    vt->scroll = 0.0;
  }


  if (vt->state == vt_state_vt52)
    {
      for (unsigned int i = 0; i<sizeof (keymap_vt52) /sizeof (keymap_vt52[0]); i++)
        if (!strcmp (str, keymap_vt52[i][0]) )
          { str = keymap_vt52[i][1]; goto done; }
    }
  else
    {
      if (vt->cursor_key_application)
        {
          for (unsigned int i = 0; i<sizeof (keymap_application) /sizeof (keymap_application[0]); i++)
            if (!strcmp (str, keymap_application[i][0]) )
              { str = keymap_application[i][1]; goto done; }
        }
    }


  if (!strcmp (str, "return") )
    {
      if (vt->cr_on_lf)
        { str = "\r\n"; }
      else
        { str = "\r"; }
      goto done;
    }
  if (!strcmp (str, "control-space") ||
      !strcmp (str, "control-`") ||
      !strcmp (str, "control-2") ||
      !strcmp (str, "shift-control-2") ||
      !strcmp (str, "shift-control-space") )
    {
      str = "\0\0";
      vt_write (vt, str, 1);
      return;
    }
  for (unsigned int i = 0; i< sizeof (keymap_general) /
                              sizeof (keymap_general[0]); i++)
    if (!strcmp (str, keymap_general[i][0]) )
      {
        str = keymap_general[i][1];
        break;
      }
done:
  if (strlen (str) )
    {
      //if (ctx_utf8_strlen(str)>1 && str[0]!='\033')
//              //  remove this to get some unhandled
  //      return;       //  things verbosely in input stream
      if (vt->local_editing)
        {
          for (int i = 0; str[i]; i++)
            {
              vt->state (vt, str[i]);
            }
        }
      else
        {
          vt_write (vt, str, strlen (str) );
        }
    }
}


void vt_paste (VT *vt, const char *str)
{
  if (vt->bracket_paste)
    {
      vt_write (vt, "\033[200~", 6);
    }
  vt_feed_keystring (vt, NULL, str);
  if (vt->bracket_paste)
    {
      vt_write (vt, "\033[201~", 6);
    }
}



#if CTX_PTY
void vt_run_command (VT *vt, const char *command, const char *term)
{
#ifdef EMSCRIPTEN
        printf ("run command %s\n", command);
#else
  struct winsize ws;
  //signal (SIGCHLD,signal_child);
#if 0
  int was_pidone = (getpid () == 1);
#else
  int was_pidone = 0; // do no special treatment, all child processes belong
                      // to root
#endif
  signal (SIGINT,SIG_DFL);
  ws.ws_row = vt->rows;
  ws.ws_col = vt->cols;
  ws.ws_xpixel = ws.ws_col * vt->cw;
  ws.ws_ypixel = ws.ws_row * vt->ch;
  vt->vtpty.pid = vt_forkpty (&vt->vtpty.pty, NULL, NULL, &ws);
  if (vt->vtpty.pid == 0)
    {
      ctx_child_prepare_env (was_pidone, term);
      exit (0);
    }
  else if (vt->vtpty.pid < 0)
    {
      VT_error ("forkpty failed (%s)", command);
      return;
    }
  fcntl(vt->vtpty.pty, F_SETFL, O_NONBLOCK|O_NOCTTY);
  _ctx_add_listen_fd (vt->vtpty.pty);
#endif
}
#endif


void vt_destroy (VT *vt)
{
  while (vt->lines)
    {
      vt_line_free (vt->lines->data, 1);
      ctx_list_remove (&vt->lines, vt->lines->data);
      vt->line_count--;
    }
  while (vt->scrollback)
    {
      vt_line_free (vt->scrollback->data, 1);
      ctx_list_remove (&vt->scrollback, vt->scrollback->data);
    }
  while (vt->limbo)
    {
      vt_line_free (vt->limbo->data, 1);
      ctx_list_remove (&vt->limbo, vt->limbo->data);
    }
#if CTX_PARSER
  if (vt->ctxp)
    ctx_parser_destroy (vt->ctxp);
#endif
  //if (vt->ctx)
  //  { ctx_destroy (vt->ctx); }
  free (vt->argument_buf);
  ctx_list_remove (&ctx_vts, vt);
  kill (vt->vtpty.pid, 9);
  _ctx_remove_listen_fd (vt->vtpty.pty);
  close (vt->vtpty.pty);
#if 1
  if (vt->title)
    free (vt->title);
#endif
  if (vt->arg_copy)
    ctx_free (vt->arg_copy);
  free (vt);
}

int vt_get_line_count (VT *vt)
{
  int max_pop = 0;
  int no = 0;
  for (CtxList *l = vt->lines; l; l = l->next, no++)
  {
    CtxString *str = l->data;
    if (str->str[0]) max_pop = no;
  }
  return max_pop + 1;
}

const char *vt_get_line (VT *vt, int no)
{
  if (no >= vt->rows)
  {
    CtxList *l = ctx_list_nth (vt->scrollback, no - vt->rows);
    if (!l)
      { 
         return "";
      }
    CtxString *str = l->data;
    return str->str;
  }
  else
  {
    CtxList *l = ctx_list_nth (vt->lines, no);
    if (!l)
      { 
         return "-";
      }
    CtxString *str = l->data;
    return str->str;
  }
}

int vt_line_is_continuation (VT *vt, int no)
{
  if (no >= vt->rows)
  {
    CtxList *l = ctx_list_nth (vt->scrollback, no - vt->rows);
    if (!l)
      { 
         return 1;
      }
    VtLine *line = l->data;
    return line->wrapped;
  }
  else
  {
    CtxList *l = ctx_list_nth (vt->lines, no);
    if (!l)
      { 
         return 1;
      }
    VtLine *line = l->data;
    return line->wrapped;
  }
}

int vt_get_cols (VT *vt)
{
  return vt->cols;
}

int vt_get_rows (VT *vt)
{
  return vt->rows;
}

int vt_get_cursor_x (VT *vt)
{
  return vt->cursor_x;
}

int vt_get_cursor_y (VT *vt)
{
  return vt->cursor_y;
}

static inline void vt_ctx_glyph_real (Ctx *ctx, VT *vt, int col, float x, float y, int unichar, int italic, int bold, float scale_x, float scale_y, uint8_t red, uint8_t green, uint8_t blue)
{
  int did_save = 0;
  if (unichar <= ' ')
    return;
  scale_x *= vt->scale_x;
  scale_y *= vt->scale_y;

  CtxBackendType backend_type = ctx_backend_type (ctx);

  if (backend_type != CTX_BACKEND_TERM)
  {
    if (!vt_special_glyph (ctx, vt, x, y, vt->cw * scale_x, vt->ch * scale_y,
                           unichar, red, green, blue) )
      return;
  }
  ctx_rgba8 (ctx, red, green, blue, 255);
      if (italic)
        {
          did_save = 1.0;
          ctx_save (ctx);
          //ctx_translate (ctx, (x0 + cw/3), (y0 + vt->ch/2) );
          //ctx_scale (ctx, 0.9, 0.9);
          //ctx_rotate (ctx, 0.15);
          //ctx_translate (ctx, - (x0 + cw/3), - (y0 + vt->ch/2) );
          if (bold)
            ctx_font (ctx, "Mono Bold Italic");
          else
            ctx_font (ctx, "Mono Italic");
        }

  if (scale_x != 1.0 || scale_y != 1.0)
    {
      if (!did_save){
      ctx_save (ctx);
      did_save = 1;
      }

      ctx_translate (ctx, x, y);
      ctx_scale (ctx, scale_x, scale_y);
      ctx_translate (ctx, -x, -y);
    }

  y -= vt->font_size * (1.0f-vt->baseline);
  ctx_move_to (ctx, x, y);
  if (bold)
  {
    if (!did_save)
    {
      ctx_save (ctx);
      did_save = 1;
    }
    // TODO : check if proportional and use other font for that
    ctx_font (ctx, "Mono Bold");
  }
  ctx_glyph_unichar (ctx, unichar, 0);
  if (did_save)
    ctx_restore (ctx);
}

void vt_ctx_glyph_flush (Ctx *ctx, VT *vt)
{
  if (vt->word_length)
  {
    int did_save = 0;

      if (vt->word_italic)
        {
          did_save = 1.0;
          ctx_save (ctx);
          //ctx_translate (ctx, (x0 + cw/3), (y0 + vt->ch/2) );
          //ctx_scale (ctx, 0.9, 0.9);
          //ctx_rotate (ctx, 0.15);
          //ctx_translate (ctx, - (x0 + cw/3), - (y0 + vt->ch/2) );
          if (vt->word_bold)
            ctx_font (ctx, "Mono Bold Italic");
          else
            ctx_font (ctx, "Mono Italic");
        }
        else if (vt->word_bold)
   {
    if (!did_save)
    {
      ctx_save (ctx);
      did_save = 1;
    }
    // TODO : check if proportional and use other font for that
    ctx_font (ctx, "Mono Bold");
  }

  if (vt->word_scale_x != 1.0 || vt->word_scale_y != 1.0)
    {
      if (!did_save){
      ctx_save (ctx);
      did_save = 1;
      }

      ctx_translate (ctx, vt->word_x, vt->word_y);
      ctx_scale (ctx, vt->word_scale_x, vt->word_scale_y);
      ctx_translate (ctx, -vt->word_x, -vt->word_y);
    }

  if (vt->word_offset_y != 0.0f)
  {
    if (!did_save)
    {
      ctx_save (ctx);
      did_save = 1;
    }
    ctx_translate (ctx, 0, vt->font_size * vt->word_offset_y);
  }

    ctx_move_to (ctx, vt->word_x, vt->word_y - vt->font_size * (1.0f-vt->baseline));
    ctx_rgba8 (ctx, vt->word_rgb[0],
                    vt->word_rgb[1],
                    vt->word_rgb[2],255);
    ctx_text (ctx, vt->word->str);

    if (did_save)
      ctx_restore (ctx);
  }
  if (vt->word == NULL) vt->word = ctx_string_new("");
  ctx_string_set (vt->word, "");
  vt->word_length = 0;
}

int ctx_vt_enable_ligatures = 0;

static inline void vt_ctx_glyph (Ctx *ctx, VT *vt, int col, float x, float y, int unichar, int italic, int bold, float scale_x, float scale_y, uint8_t red, uint8_t green, uint8_t blue)
{
  if (ctx_vt_enable_ligatures)
  {
  int fresh = 0;

  if (!vt_special_glyph (ctx, vt, x, y, vt->cw * scale_x * vt->scale_x, vt->ch * scale_y * vt->scale_y,
                         unichar, red, green, blue) )
      return;


  if (vt->word == NULL) vt->word = ctx_string_new("");
  if (vt->word_length == 0)
  {
    fresh = 1;
  }
  else if (vt->word_rgb[0] != red ||
           vt->word_rgb[1] != green ||
           vt->word_rgb[2] != blue ||
           vt->word_scale_x != scale_x ||
           vt->word_scale_y != scale_y ||
           vt->word_bold != bold ||
           vt->word_italic != italic ||
           vt->word_col + 1 != col ||
           vt->word_length > 60)
  {
    vt_ctx_glyph_flush (ctx, vt);
    fresh = 1;
  }

  if (fresh)
  {
    vt->word_rgb[0] = red;
    vt->word_rgb[1] = green ;
    vt->word_rgb[2] = blue ;
    vt->word_scale_x = scale_x ;
    vt->word_scale_y = scale_y ;
    vt->word_x = x ;
    vt->word_y = y ;
    vt->word_bold = bold ;
    vt->word_italic = italic ;
    vt->word_length = 0;
  }
  ctx_string_append_unichar (vt->word, unichar);
  vt->word_length++;
  vt->word_col = col ;
  }
  else
  {
    vt_ctx_glyph_real (ctx, vt, col, x, y, unichar, italic, bold, scale_x, scale_y, red, green, blue);
  }
}


//static uint8_t palette[256][3];

/* optimized for ANSI ART - and avoidance of human metamers
 * among color deficient vision - by distributing and pertubating
 * until all 64 combinations - sans self application, have
 * likely to be discernable by humans.
 */


void vt_ctx_get_color (VT *vt, int no, int intensity, uint8_t *rgba)
{
  uint8_t r = 0, g = 0, b = 0;
  if (no < 16 && no >= 0)
    {
      switch (intensity)
        {
          case 0:
            no = 0;
            break;
          case 1:
            // 15 becomes 7
            if (no == 15) { no = 8; }
            else if (no > 8) { no -= 8; }
            break;
          case 2:
            /* give the normal color special treatment, and in really normal
             * cirumstances it is the dim variant of foreground that is used
             */
            if (no == 15) { no = 7; }
            break;
          case 3:
          case 4:
            if (no < 8)
              { no += 8; }
            break;
          default:
            break;
        }
      r = palettes[vt->palette_no][no][0];
      g = palettes[vt->palette_no][no][1];
      b = palettes[vt->palette_no][no][2];
    }
  else if (no < 16 + 6*6*6)
    {
      no = no-16;
      b = (no % 6) * 255 / 5;
      no /= 6;
      g = (no % 6) * 255 / 5;
      no /= 6;
      r = (no % 6) * 255 / 5;
    }
  else
    {
      int gray = no - (16 + 6*6*6);
      float val = gray * 255 / 24;
      r = g = b = val;
    }
  rgba[0]=r;
  rgba[1]=g;
  rgba[2]=b;
  rgba[3]=255;
}

int vt_keyrepeat (VT *vt)
{
  return vt->keyrepeat;
}

static void vt_flush_bg (VT *vt, Ctx *ctx)
{
  if (vt->bg_active)
  {
    int on_white = vt->reverse_video;

    vt->bg_active = 0;
    if (on_white)
    {
      if (vt->bg_rgba[0] == 255 && vt->bg_rgba[1] == 255 && vt->bg_rgba[2] == 255)
        return;
    }
    if (vt->bg_rgba[0] == 0 && vt->bg_rgba[1] == 0 && vt->bg_rgba[2] == 0)
      return;

    ctx_rgba8 (ctx, vt->bg_rgba[0], vt->bg_rgba[1], vt->bg_rgba[2], vt->bg_rgba[3]);
    ctx_rectangle (ctx, vt->bg_x0, vt->bg_y0 - 1, vt->bg_width, vt->bg_height + 2);
    ctx_fill (ctx);
  }
}

static void vt_draw_bg (VT *vt, Ctx *ctx,
                        float x0, float y0,
                        float width, float height,
                        uint8_t *rgba)
{
   int same_color = !memcmp(rgba, vt->bg_rgba, 4);
   if (vt->bg_active && !same_color)
   {
     vt_flush_bg (vt, ctx);
   }

   if (vt->bg_active && same_color)
   {
     vt->bg_width += width;
   }
   else
   {
     memcpy (vt->bg_rgba, rgba, 4);
     vt->bg_active = 1;
     vt->bg_x0 = x0;
     vt->bg_y0 = y0;
     vt->bg_width = width;
     vt->bg_height = height;
   }
}

static float vt_draw_cell (VT      *vt, Ctx *ctx,
                    int      row, int col, // pass 0 to force draw - like
                    float    x0, float y0, // for scrollback visible
                    uint64_t style,
                    uint32_t unichar,
                    int      dw, int dh,
                    int      in_smooth_scroll,
                    int      in_select,
                    int      is_fg)
// dw is 0 or 1
// dh is 0 1 or -1  1 is upper -1 is lower
{
  int on_white = vt->reverse_video;
  int color = 0;
  int bold = (style & STYLE_BOLD) != 0;
  int dim = (style & STYLE_DIM) != 0;
  int is_hidden = (style & STYLE_HIDDEN) != 0;
  int proportional = (style & STYLE_PROPORTIONAL) != 0;
  int fg_set = (style & STYLE_FG_COLOR_SET) != 0;
  int bg_intensity = 0;
  int fg_intensity = 2;
  int reverse = ( (style & STYLE_REVERSE) != 0) ^ in_select;
  int blink = ( (style & STYLE_BLINK) != 0);
  int blink_fast = ( (style & STYLE_BLINK_FAST) != 0);
  float cw = vt->cw;
  float ch = vt->ch;
  if (proportional)
    {
      if (vt->font_is_mono)
        {
          ctx_font (ctx, "Regular");
          vt->font_is_mono = 0;
        }
      cw = ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, unichar));
    }
  else
    {
      if (vt->font_is_mono == 0)
        {
          ctx_font (ctx, "Mono");
          vt->font_is_mono = 1;
          if (col > 1)
            {
              int x = x0;
              int new_cw = cw - ( (x % (int)cw) );
              if (new_cw < cw*3/2)
                { new_cw += cw; }
              cw = new_cw;
            }
        }
    }
  float scale_x  = 1.0f;
  float scale_y  = 1.0f;
  float offset_y = 0.0f;
  if (dw)
    {
      scale_x = 2.0f;
    }
  if (dh)
    {
      scale_y = 2.0f;
    }
  if (dh == 1)
    {
      offset_y = 0.5f;
    }
  else if (dh == -1)
    {
      offset_y =  0.0f;
    }
  if (in_smooth_scroll)
    {
      offset_y -= vt->scroll_offset / (dh?2:1);
    }
  cw *= scale_x;
  if (blink_fast)
    {
      if ( (vt->blink_state % 2) == 0)
        { blink = 1; }
      else
        { blink = 0; }
    }
  else if (blink)
    {
      if ( (vt->blink_state % 10) < 5)
        { blink = 1; }
      else
        { blink = 0; }
    }
  /*
     from the vt100 technical-manual:

     "Reverse characters [..] normally have dim backgrounds with
     black characters so that large white spaces have the same impact
     on the viewer's eye as the smaller brighter white areas of
     normal characters. Bold and reverse asserted together give a
     background of normal intensity. Blink applied to nonreverse
     characters causes them to alternate between their usual
     intensity and the next lower intensity. (Normal characters vary
     between normal and dim intensity. Bold characters vary between
     bright and normal intensity.) Blink applied to a reverse
     character causes that character to alternate between normal and
     reverse video representations of that character."

     This is in contrast with how the truth table appears to be
     meant used, since it uses a reverse computed as the xor of
     the global screen reverse and the reverse attribute of the
     cell.

     To fulfil the more asthethic resulting from implementing the
     text, and would be useful to show how the on_bright background
     mode of the vt100 actually displays the vttest.

     */
  if (on_white)
    {
          if (bold)
            {
              bg_intensity =           2;
              fg_intensity = blink?1:  0;
            }
          else if (dim)
            {
              bg_intensity =           2;
              fg_intensity = blink?3:  1;
            }
          else
            {
              bg_intensity =           2;
              fg_intensity = blink?1:  0;
            }
          if (fg_set)
            {
              fg_intensity = blink?2:3;
            }
    }
  else /* bright on dark */
    {
          if (bold)
            {
              bg_intensity =           0;
              fg_intensity = blink?2:  3;
            }
          else if (dim)
            {
              bg_intensity =           0;
              fg_intensity = blink?0:  1;
            }
          else
            {
              bg_intensity =           0;
              fg_intensity = blink?1:  2;
            }
    }
  uint8_t bg_rgb[4]= {0,0,0,255};
  uint8_t fg_rgb[4]= {255,255,255,255};
  {
      //ctx_reset_path (ctx);
      if (style &  STYLE_BG24_COLOR_SET)
        {
          uint64_t temp = style >> 40;
          bg_rgb[0] = temp & 0xff;
          temp >>= 8;
          bg_rgb[1] = temp & 0xff;
          temp >>= 8;
          bg_rgb[2] = temp & 0xff;
#if 0
          if (dh)
          {
             bg_rgb[0] = 
             bg_rgb[1] =
             bg_rgb[2] = 30;
          }
#endif
        }
      else
        {
          if (style & STYLE_BG_COLOR_SET)
            {
              color = (style >> 40) & 255;
              bg_intensity = -1;
              vt_ctx_get_color (vt, color, bg_intensity, bg_rgb);
            }
          else
            {
              switch (bg_intensity)
                {
                  case 0:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->bg_color[i]; }
                    break;
                  case 1:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->bg_color[i] * 0.5 + vt->fg_color[i] * 0.5; }
                    break;
                  case 2:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->bg_color[i] * 0.05 + vt->fg_color[i] * 0.95; }
                    break;
                  case 3:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->fg_color[i]; }
                    break;
                }
            }
        }
  }
  if (style & STYLE_FG24_COLOR_SET)
    {
      uint64_t temp = style >> 16;
      fg_rgb[0] = temp & 0xff;
      temp >>= 8;
      fg_rgb[1] = temp & 0xff;
      temp >>= 8;
      fg_rgb[2] = temp & 0xff;
    }
  else
    {
      if ( (style & STYLE_FG_COLOR_SET) == 0)
        {
          switch (fg_intensity)
            {
              case 0:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->bg_color[i] * 0.7 + vt->fg_color[i] * 0.3; }
                break;
              case 1:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->bg_color[i] * 0.5 + vt->fg_color[i] * 0.5; }
                break;
              case 2:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->bg_color[i] * 0.20 + vt->fg_color[i] * 0.80; }
                break;
              case 3:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->fg_color[i]; }
            }
        }
      else
        {
          color = (style >> 16) & 255;
          vt_ctx_get_color (vt, color, fg_intensity, fg_rgb);
        }
  }

  if (reverse)
  {
    for (int c = 0; c < 3; c ++)
    {
      int t = bg_rgb[c];
      bg_rgb[c] = fg_rgb[c];
      fg_rgb[c] = t;
    }
  }

  if (!is_fg)
  {
    if (dh)
    {
      vt_draw_bg (vt, ctx, ctx_floorf(x0),
         ctx_floorf(y0 - ch - ch * (vt->scroll_offset)), cw, ch, bg_rgb);
    }
    else
    {
      vt_draw_bg (vt, ctx, x0, y0 - ch + ch * offset_y, cw, ch, bg_rgb);
    }
    return cw;
  }

  int italic        = (style & STYLE_ITALIC) != 0;
  int strikethrough = (style & STYLE_STRIKETHROUGH) != 0;
  int overline      = (style & STYLE_OVERLINE) != 0;
  int underline     = (style & STYLE_UNDERLINE) != 0;
  int underline_var = (style & STYLE_UNDERLINE_VAR) != 0;
  if (dh == 1)
    {
      underline = underline_var = 0;
    }
  int double_underline = 0;
  int curved_underline = 0;
  if (underline_var)
    {
      if (underline)
        {
          double_underline = 1;
        }
      else
        {
          curved_underline = 1;
        }
    }

  int has_underline = (underline || double_underline || curved_underline);

  if (unichar == ' ' && !has_underline)
    is_hidden = 1;

  if (!is_hidden)
    {
      vt_ctx_glyph (ctx, vt, col, x0, y0 + offset_y * vt->ch, unichar, italic, bold, scale_x, scale_y, fg_rgb[0], fg_rgb[1], fg_rgb[2]);
      if (curved_underline)
        {
          ctx_reset_path (ctx);
          ctx_move_to (ctx, x0, y0 - vt->font_size * 0.07 - vt->ch * vt->scroll_offset);
          ctx_rel_line_to (ctx, (cw+2) /3, -vt->ch * 0.05);
          ctx_rel_line_to (ctx, (cw+2) /3, vt->ch * 0.1);
          ctx_rel_line_to (ctx, (cw+2) /3, -vt->ch * 0.05);
          //ctx_rel_line_to (ctx, cw, 0);
          ctx_line_width (ctx, vt->font_size * (style &  STYLE_BOLD?0.050:0.04) );
          ctx_stroke (ctx);
        }
      else if (double_underline)
        {
          ctx_reset_path (ctx);
          ctx_move_to (ctx, x0, y0 - vt->font_size * 0.130 - vt->ch * vt->scroll_offset);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_move_to (ctx, x0, y0 - vt->font_size * 0.030 - vt->ch * vt->scroll_offset);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_line_width (ctx, vt->font_size * (style &  STYLE_BOLD?0.050:0.04) );
          ctx_stroke (ctx);
        }
      else if (underline)
        {
          ctx_reset_path (ctx);
          ctx_move_to (ctx, x0, y0 - vt->font_size * 0.07 - vt->ch * vt->scroll_offset);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_line_width (ctx, vt->font_size * (style &  STYLE_BOLD?0.075:0.05) );
          ctx_stroke (ctx);
        }
      if (overline)
        {
          ctx_reset_path (ctx);
          ctx_move_to (ctx, x0, y0 - vt->font_size * 0.94 - vt->ch * vt->scroll_offset);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_line_width (ctx, vt->font_size * (style &  STYLE_BOLD?0.075:0.05) );
          ctx_stroke (ctx);
        }
      if (strikethrough)
        {
          ctx_reset_path (ctx);
          ctx_move_to (ctx, x0, y0 - vt->font_size * 0.43 - vt->ch * vt->scroll_offset);
          ctx_rel_line_to (ctx, cw, 0);
          ctx_line_width (ctx, vt->font_size * (style &  STYLE_BOLD?0.075:0.05) );
          ctx_stroke (ctx);
        }
    }
  return cw;
}

static float vt_draw_cell_fg (VT      *vt, Ctx *ctx,
                       int      row, int col, // pass 0 to force draw - like
                       float    x0, float y0, // for scrollback visible
                       uint64_t style,
                       uint32_t unichar,
                       int      dw, int dh,
                       int      in_smooth_scroll,
                       int      in_select)
{
  return vt_draw_cell (vt, ctx, row, col, x0, y0, style, unichar, dw, dh, in_smooth_scroll, in_select, 1);
}

static float vt_draw_cell_bg (VT      *vt, Ctx *ctx,
                       int      row, int col, // pass 0 to force draw - like
                       float    x0, float y0, // for scrollback visible
                       uint64_t style,
                       uint32_t unichar,
                       int      dw, int dh,
                       int      in_smooth_scroll,
                       int      in_select)
{
  int on_white = vt->reverse_video;
  int color = 0;
  int bold = (style & STYLE_BOLD) != 0;
  int dim = (style & STYLE_DIM) != 0;
  int proportional = (style & STYLE_PROPORTIONAL) != 0;
  int fg_set = (style & STYLE_FG_COLOR_SET) != 0;
  int bg_intensity = 0;
  int fg_intensity = 2;
  int reverse = ( (style & STYLE_REVERSE) != 0) ^ in_select;
  int blink = ( (style & STYLE_BLINK) != 0);
  int blink_fast = ( (style & STYLE_BLINK_FAST) != 0);
  float cw = vt->cw;
  float ch = vt->ch;
  if (proportional)
    {
      if (vt->font_is_mono)
        {
          ctx_font (ctx, "Regular");
          vt->font_is_mono = 0;
        }
      cw = ctx_glyph_width (ctx, ctx_glyph_lookup (ctx, unichar));
    }
  else
    {
      if (vt->font_is_mono == 0)
        {
          ctx_font (ctx, "Mono");
          vt->font_is_mono = 1;
          if (col > 1)
            {
              int x = x0;
              int new_cw = cw - ( (x % (int)cw) );
              if (new_cw < cw*3/2)
                { new_cw += cw; }
              cw = new_cw;
            }
        }
    }
  float scale_x  = 1.0f;
  float offset_y = 0.0f;
  if (dw)
    {
      scale_x = 2.0f;
    }
  if (dh == 1)
    {
      offset_y = 0.5f;
    }
  else if (dh == -1)
    {
      offset_y =  0.0f;
    }
  if (in_smooth_scroll)
    {
      offset_y -= vt->scroll_offset / (dh?2:1);
    }
  cw *= scale_x;
  if (blink_fast)
    {
      if ( (vt->blink_state % 2) == 0)
        { blink = 1; }
      else
        { blink = 0; }
    }
  else if (blink)
    {
      if ( (vt->blink_state % 10) < 5)
        { blink = 1; }
      else
        { blink = 0; }
    }
  /*
     from the vt100 technical-manual:

     "Reverse characters [..] normally have dim backgrounds with
     black characters so that large white spaces have the same impact
     on the viewer's eye as the smaller brighter white areas of
     normal characters. Bold and reverse asserted together give a
     background of normal intensity. Blink applied to nonreverse
     characters causes them to alternate between their usual
     intensity and the next lower intensity. (Normal characters vary
     between normal and dim intensity. Bold characters vary between
     bright and normal intensity.) Blink applied to a reverse
     character causes that character to alternate between normal and
     reverse video representations of that character."

     This is in contrast with how the truth table appears to be
     meant used, since it uses a reverse computed as the xor of
     the global screen reverse and the reverse attribute of the
     cell.

     To fulfil the more asthethic resulting from implementing the
     text, and would be useful to show how the on_bright background
     mode of the vt100 actually displays the vttest.

     */
  if (on_white)
    {
          if (bold)
            {
              bg_intensity =           2;
              fg_intensity = blink?1:  0;
            }
          else if (dim)
            {
              bg_intensity =           2;
              fg_intensity = blink?3:  1;
            }
          else
            {
              bg_intensity =           2;
              fg_intensity = blink?1:  0;
            }
          if (fg_set)
            {
              fg_intensity = blink?2:3;
            }
    }
  else /* bright on dark */
    {
          if (bold)
            {
              bg_intensity =           0;
              fg_intensity = blink?2:  3;
            }
          else if (dim)
            {
              bg_intensity =           0;
              fg_intensity = blink?0:  1;
            }
          else
            {
              bg_intensity =           0;
              fg_intensity = blink?1:  2;
            }
    }
  uint8_t bg_rgb[4]= {0,0,0,255};
  uint8_t fg_rgb[4]= {255,255,255,255};
  {
      //ctx_reset_path (ctx);
      if (style &  STYLE_BG24_COLOR_SET)
        {
          uint64_t temp = style >> 40;
          bg_rgb[0] = temp & 0xff;
          temp >>= 8;
          bg_rgb[1] = temp & 0xff;
          temp >>= 8;
          bg_rgb[2] = temp & 0xff;
#if 0
          if (dh)
          {
             bg_rgb[0] = 
             bg_rgb[1] =
             bg_rgb[2] = 30;
          }
#endif
        }
      else
        {
          if (style & STYLE_BG_COLOR_SET)
            {
              color = (style >> 40) & 255;
              bg_intensity = -1;
              vt_ctx_get_color (vt, color, bg_intensity, bg_rgb);
            }
          else
            {
              switch (bg_intensity)
                {
                  case 0:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->bg_color[i]; }
                    break;
                  case 1:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->bg_color[i] * 0.5 + vt->fg_color[i] * 0.5; }
                    break;
                  case 2:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->bg_color[i] * 0.05 + vt->fg_color[i] * 0.95; }
                    break;
                  case 3:
                    for (int i = 0; i <3 ; i++)
                      { bg_rgb[i] = vt->fg_color[i]; }
                    break;
                }
            }
        }
  }
  if (style & STYLE_FG24_COLOR_SET)
    {
      uint64_t temp = style >> 16;
      fg_rgb[0] = temp & 0xff;
      temp >>= 8;
      fg_rgb[1] = temp & 0xff;
      temp >>= 8;
      fg_rgb[2] = temp & 0xff;
    }
  else
    if (reverse) {
      if ( (style & STYLE_FG_COLOR_SET) == 0)
        {
          switch (fg_intensity)
            {
              case 0:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->bg_color[i] * 0.7 + vt->fg_color[i] * 0.3; }
                break;
              case 1:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->bg_color[i] * 0.5 + vt->fg_color[i] * 0.5; }
                break;
              case 2:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->bg_color[i] * 0.20 + vt->fg_color[i] * 0.80; }
                break;
              case 3:
                for (int i = 0; i <3 ; i++)
                  { fg_rgb[i] = vt->fg_color[i]; }
            }
        }
      else
        {
          color = (style >> 16) & 255;
          vt_ctx_get_color (vt, color, fg_intensity, fg_rgb);
        }
  }

  if (reverse)
  {
    for (int c = 0; c < 3; c ++)
    {
      int t = bg_rgb[c];
      bg_rgb[c] = fg_rgb[c];
      fg_rgb[c] = t;
    }
  }

  if (dh)
  {
    vt_draw_bg (vt, ctx, ctx_floorf(x0),
       ctx_floorf(y0 - ch - ch * (vt->scroll_offset)), cw, ch, bg_rgb);
  }
  else
  {
    vt_draw_bg (vt, ctx, x0, y0 - ch + ch * offset_y, cw, ch, bg_rgb);
  }
  return cw;
}

int vt_has_blink (VT *vt)
{
  if (!vt) return 0;
  return (vt->in_smooth_scroll ?  10 : 0);
  //return vt->has_blink + (vt->in_smooth_scroll ?  10 : 0);
}

//extern int enable_terminal_menu;
//

//void ctx_set_popup (Ctx *ctx, void (*popup)(Ctx *ctx, void *data), void *popup_data);

static char *primary = NULL;
static void scrollbar_drag (CtxEvent *event, void *data, void *data2);
static int scrollbar_down = 0;
static void mt_drag (CtxEvent *event, void *data, void *data2);

float ctx_vt_scrollbar_width_visible = 1.0f;
float ctx_vt_scrollbar_width_event   = 4.0f;

void ctx_client_mouse_event (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = data;
  if (!client)
  {
    event->stop_propagate = 1;
    return;
  }
  VT *vt = client->vt;

  float  x = event->x;
  float  y = event->y;
  int device_no = event->device_no;
  char buf[128]="";


  if (vt)
  {
  if ((!vt->in_alt_screen) &&
      (event->x > vt->width - vt->cw * ctx_vt_scrollbar_width_event || scrollbar_down) &&
      (event->type == CTX_DRAG_MOTION ||
       event->type == CTX_DRAG_PRESS ||
       event->type == CTX_DRAG_RELEASE))
  {
    scrollbar_drag (event, vt, data2);
    return;
  }
  switch (event->type)
  {
    case CTX_MOTION:
    case CTX_DRAG_MOTION:
      if (event->device_no > 4)
      {
        vt->select_start_col = 
        vt->select_end_col = vt->select_begin_col;
        vt->select_active = 0;

        mt_drag (event, vt, data2);
        return;
      }


      //if (event->device_no==1)
      {
        sprintf (buf, "pm %.0f %.0f %i", x, y, device_no);
//      ctx_queue_draw (event->ctx);
        ctx_client_lock (client);
        vt_feed_keystring (vt, event, buf);
        ctx_client_unlock (client);
//      vt->rev++;
      }
      break;
    case CTX_TAP_AND_HOLD:
      {
         //printf("got tap and hold!\n");
         //terminal_long_tap (event->ctx, vt);
      }
      break;
    case CTX_DRAG_PRESS:
      if (event->device_no==2)
      {
        if (primary)
        {
          if (vt)
            vt_paste (vt, primary);
        }
      }
      else if (event->device_no==3 && !vt->in_alt_screen)
      {
        vt->popped = 1;
      }
      else
      {
        sprintf (buf, "pp %.0f %.0f %i", x, y, device_no);
        ctx_client_lock (client);
        vt_feed_keystring (vt, event, buf);
        ctx_client_unlock (client);
        ctx_client_focus (event->ctx, vt->id);
//      ctx_queue_draw (event->ctx);
//      vt->rev++;
      }
      break;
    case CTX_DRAG_RELEASE:
      if (event->device_no==3 && !vt->in_alt_screen)
      {
        vt->popped = 0;
      }
        ctx_queue_draw (event->ctx);
        sprintf (buf, "pr %.0f %.0f %i", x, y, device_no);
        ctx_client_lock (client);
        vt_feed_keystring (vt, event, buf);
        ctx_client_unlock (client);
        ctx_client_focus (event->ctx, vt->id);
      break;
    default:
      // we should not stop propagation
      return;
      break;
  }
  }
  else
  {
     CtxEvent *copy = ctx_event_copy (event);
     ctx_list_append (&client->ctx_events, copy);
  }
  event->stop_propagate = 1;
//vt->rev++;
}

void vt_mouse_event (CtxEvent *event, void *data, void *data2)
{
  VT   *vt = data;
  CtxClient *client = vt_get_client (vt);
  if (!client)
  {
    event->stop_propagate = 1;
    return;
  }
  float  x = event->x;
  float  y = event->y;
  int device_no = event->device_no;
  char buf[128]="";
  if ((!vt->in_alt_screen) &&
      (event->x > vt->width - vt->cw * ctx_vt_scrollbar_width_event || scrollbar_down) &&
      (event->type == CTX_DRAG_MOTION ||
      event->type == CTX_DRAG_PRESS ||
      event->type == CTX_DRAG_RELEASE))
   {
    scrollbar_drag (event, vt, data2);return;
   }
  switch (event->type)
  {
    case CTX_MOTION:
    case CTX_DRAG_MOTION:
      //if (event->device_no==1)
      {
        sprintf (buf, "pm %.0f %.0f %i", x, y, device_no);
//      ctx_queue_draw (event->ctx);
        ctx_client_lock (client);
        vt_feed_keystring (vt, event, buf);
        ctx_client_unlock (client);
//      vt->rev++;
      }
      break;
    case CTX_DRAG_PRESS:
      if (event->device_no==2)
      {
        if (primary)
        {
          if (vt)
            vt_paste (vt, primary);
        }
      }
      else if (event->device_no==3 && !vt->in_alt_screen)
      {
        vt->popped = 1;
      }
      else
      {
        sprintf (buf, "pp %.0f %.0f %i", x, y, device_no);
        ctx_client_lock (client);
        vt_feed_keystring (vt, event, buf);
        ctx_client_unlock (client);
//      ctx_queue_draw (event->ctx);
//      vt->rev++;
      }
      break;
    case CTX_DRAG_RELEASE:
      if (event->device_no==3 && !vt->in_alt_screen)
      {
        vt->popped = 0;
      }
        ctx_queue_draw (event->ctx);
        sprintf (buf, "pr %.0f %.0f %i", x, y, device_no);
        ctx_client_lock (client);
        vt_feed_keystring (vt, event, buf);
        ctx_client_unlock (client);
      break;
    default:
      // we should not stop propagation
      return;
      break;
  }
  event->stop_propagate = 1;
//vt->rev++;
}
static int scrollbar_focused = 0;
#if 0
static void scrollbar_enter (CtxEvent *event, void *data, void *data2)
{
  VT *vt = data;
  vt->rev++;
  scrollbar_focused = 1;
}

static void scrollbar_leave (CtxEvent *event, void *data, void *data2)
{
  VT *vt = data;
  vt->rev++;
  scrollbar_focused = 0;
}
#endif

int ctx_vt_had_alt_screen (VT *vt)
{
  return vt?vt->had_alt_screen:0;
}

static void mt_drag (CtxEvent *event, void *data, void *data2)
{
  VT *vt = data;

  vt->scroll += event->delta_y / vt->ch;

  if (vt->scroll < 0) { vt->scroll = 0.0; }
  if (vt->scroll > vt->scrollback_count) { vt->scroll = vt->scrollback_count; }

  ctx_client_rev_inc (vt->client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}


static void scrollbar_drag (CtxEvent *event, void *data, void *data2)
{
  VT *vt = data;
  float disp_lines = vt->rows;
  float tot_lines = vt->line_count + vt->scrollback_count;

  vt->scroll = tot_lines - disp_lines - (event->y*1.0/ ctx_client_height (vt->root_ctx, vt->id)) * tot_lines + disp_lines/2;
  if (vt->scroll < 0) { vt->scroll = 0.0; }
  if (vt->scroll > vt->scrollback_count) { vt->scroll = vt->scrollback_count; }
  ctx_client_rev_inc (vt->client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;

  switch (event->type)
  {
    case CTX_DRAG_PRESS:
      scrollbar_down = 1;
      break;
    case CTX_DRAG_RELEASE:
      scrollbar_down = 0;
      break;
    default:
      break;
  }
}

#if 0
static void scroll_handle_drag (CtxEvent *event, void *data, void *data2)
{
  VT *vt = data;
  float tot_lines = vt->line_count + vt->scrollback_count;
  if (event->type == CTX_DRAG_MOTION)
  {
    vt->scroll -= (event->delta_y * tot_lines) / (vt->rows * vt->ch);
  }
  if (vt->scroll < 0) { vt->scroll = 0.0; }
  if (vt->scroll > vt->scrollback_count) { vt->scroll = vt->scrollback_count; }
  vt->rev++;
  event->stop_propagate = 1;
}
#endif

#if 0
static void test_popup (Ctx *ctx, void *data)
{
  VT *vt = data;

  float x = ctx_client_x (vt->root_ctx, vt->id);
  float y = ctx_client_y (vt->root_ctx, vt->id);
  ctx_rectangle (ctx, x, y, 100, 100);
  ctx_rgb (ctx, 1,0,0);
  ctx_fill (ctx);
}
#endif

//void css_style_color (Ctx *ctx, const char *name); // only itk fun used in vt

void vt_use_images (VT *vt, Ctx *ctx)
{
  /*  this is a call intended for minimized/shaded fully obscured
   *  clients to make sure their textures are kept alive
   *  in the server
   */
  //float x0=0;
  float y0=0;
  //vt->has_blink = 0;
  //vt->blink_state++;

  ctx_save (ctx);

  {
    /* draw graphics */
    for (int row = ((vt->scroll!=0.0f)?vt->scroll:0);
         row < (vt->scroll) + vt->rows * 4;
         row ++)
    {
       CtxList *l = ctx_list_nth (vt->lines, row);
       float y = y0 + vt->ch * (vt->rows - row);

       if (row >= vt->rows && !vt->in_alt_screen)
         {
           l = ctx_list_nth (vt->scrollback, row-vt->rows);
         }

       if (l && y <= (vt->rows - vt->scroll) *  vt->ch)
         {
           VtLine *line = l->data;
           if (line->ctx_copy)
             {
               ctx_render_ctx_textures (line->ctx_copy, ctx);
             }
         }
    }
  }
  ctx_restore (ctx);
}

static void ctx_client_scroll_event (CtxEvent *event, void *c, void *u)
{
  CtxClient *client = (CtxClient*)c;
  VT *vt = client->vt;

  int new_scroll = vt_get_scroll (vt);

  if (event->scroll_direction == CTX_SCROLL_DIRECTION_UP)
    new_scroll -= 1;
  else if (event->scroll_direction == CTX_SCROLL_DIRECTION_DOWN)
    new_scroll += 1;
  vt_set_scroll (vt, new_scroll);
  ctx_client_rev_inc (vt->client);
}


void ctx_client_register_events (CtxClient *client, Ctx *ctx, double x0, double y0)
{
  ctx_reset_path (ctx);
  ctx_save (ctx);
  ctx_translate (ctx, x0, y0);
  ctx_rectangle (ctx, 0, 0, client->width, client->height);
  ctx_listen (ctx, CTX_DRAG,   ctx_client_mouse_event, client, NULL);
  //ctx_listen (ctx, CTX_TAP_AND_HOLD, ctx_client_mouse_event, client, NULL);
  ctx_listen (ctx, CTX_MOTION, ctx_client_mouse_event, client, NULL);
  ctx_listen (ctx, CTX_SCROLL, ctx_client_scroll_event, client, NULL);
  ctx_reset_path (ctx);
  ctx_restore (ctx);
}

#if 0
void vt_register_events (VT *vt, Ctx *ctx, double x0, double y0)
{
  ctx_reset_path (ctx);
  ctx_save (ctx);
  ctx_translate (ctx, x0, y0);
  ctx_rectangle (ctx, 0, 0, vt->cols * vt->cw, vt->rows * vt->ch);
  ctx_listen (ctx, CTX_DRAG,   vt_mouse_event, vt, NULL);
  ctx_listen (ctx, CTX_MOTION, vt_mouse_event, vt, NULL);
  ctx_reset_path (ctx);
  ctx_restore (ctx);
}
#endif

void vt_draw (VT *vt, Ctx *ctx, double x0, double y0, int has_focus)
{
  vt->ctx = ctx;
  ctx_reset_path (ctx);
  ctx_save (ctx);
  ctx_translate (ctx, x0, y0);
  x0 = 0;
  y0 = 0;
  ctx_font (ctx, "Mono");
  vt->font_is_mono = 1;
  ctx_font_size (ctx, vt->font_size * vt->font_to_cell_scale);
  vt->has_blink = 0;
  vt->blink_state++;
#if 1
  int cursor_x_px = 0;
  int cursor_y_px = 0;
  int cursor_w = vt->cw;
  int cursor_h = vt->ch;
  cursor_x_px = x0 + (vt->cursor_x - 1) * vt->cw;
  cursor_y_px = y0 + (vt->cursor_y - 1) * vt->ch;
  cursor_w = vt->cw;
  cursor_h = vt->ch;
#endif
  ctx_save (ctx);
  //if (vt->scroll || full)
    {
      ctx_reset_path (ctx);
//#if CTX_PTY
      ctx_rectangle (ctx, 0, 0, vt->width, //(vt->cols) * vt->cw,
                     vt->height);
      if (vt->reverse_video)
        {
          ctx_rgba8 (ctx, palettes[0][15][0],
                          palettes[0][15][1],
                          palettes[0][15][2], 255);
          ctx_fill  (ctx);
        }
      else
        {
          ctx_rgba8 (ctx, palettes[0][0][0],
                          palettes[0][0][1],
                          palettes[0][0][2], 255);
          ctx_fill  (ctx);
        }
//#else
//          ctx_rgba (ctx,0,0,0,1.0f);
//          ctx_fill  (ctx);
//#endif
      if (vt->scroll != 0.0f)
        ctx_translate (ctx, 0.0, vt->ch * vt->scroll);
    }
  /* draw terminal lines */
   {
     for (int row = (vt->scroll!=0.0f)?vt->scroll:0; row < (vt->scroll) + vt->rows; row ++)
       {
         CtxList *l = ctx_list_nth (vt->lines, row);
         float y = y0 + vt->ch * (vt->rows - row);
         if (row >= vt->rows)
           {
             l = ctx_list_nth (vt->scrollback, row-vt->rows);
           }
         if (l && y <= (vt->rows - vt->scroll) *  vt->ch)
           {
             VtLine *line = l->data;
             int r = vt->rows - row;
             const char *data = line->string.str;

             vt->bg_active = 0;
             for (int is_fg = 0; is_fg < 2; is_fg++)
             {
               const char *d = data;
               float x = x0;
               uint64_t style = 0;
               uint32_t unichar = 0;
               int in_scrolling_region = vt->in_smooth_scroll &&
                   ((r >= vt->margin_top && r <= vt->margin_bottom) || r <= 0);
               if (is_fg)
                  vt_flush_bg (vt, ctx);
  
               for (int col = 1; col <= vt->cols * 1.33 && x < vt->cols * vt->cw; col++)
                 {
                   int c = col;
                   float real_cw;
                   int in_selected_region = 0;
                   //if (vt->in_alt_screen == 0)
                   {
                   if (r > vt->select_start_row && r < vt->select_end_row)
                     {
                       in_selected_region = 1;
                     }
                   else if (r == vt->select_start_row)
                     {
                       if (col >= vt->select_start_col) { in_selected_region = 1; }
                       if (r == vt->select_end_row)
                         {
                           if (col > vt->select_end_col) { in_selected_region = 0; }
                         }
                     }
                   else if (r == vt->select_end_row)
                     {
                       in_selected_region = 1;
                       if (col > vt->select_end_col) { in_selected_region = 0; }
                     }
                   }
                   if (vt->select_active == 0) in_selected_region = 0;
                   style = vt_line_get_style (line, col-1);
                   unichar = d?ctx_utf8_to_unichar (d) :' ';
  
                   int is_cursor = 0;
                   if (vt->cursor_x == col && vt->cursor_y == vt->rows - row && vt->cursor_visible)
                   {
                      if (has_focus)
                        is_cursor = 1;
                      else
  /* draw cursor (done inline with fg/bg reversing, some cursor styles might need
   * additional drawing though
   */
    {
    //  ctx_rgba (ctx, 0.9, 0.8, 0.0, 0.5333);
      ctx_rgba (ctx, 0.75,0.75,0.75,1);//1.0,1.0,1.0,1.0);
      ctx_reset_path (ctx);
      ctx_rectangle (ctx,
                     cursor_x_px+1, cursor_y_px+1,
                     cursor_w-2, cursor_h-2);
      ctx_line_width (ctx, 2.0f);//-1.0f);
      if (has_focus)
      ctx_fill (ctx);
      else
      ctx_stroke (ctx);
    }

                   }
  
                   if (is_fg)
                     real_cw=vt_draw_cell_fg (vt, ctx, r, c, x, y, style, unichar,
                                            line->double_width,
                                            line->double_height_top?1:
                                            line->double_height_bottom?-1:0,
                                            in_scrolling_region,
                                            in_selected_region ^ is_cursor);
                   else
                     real_cw=vt_draw_cell_bg (vt, ctx, r, c, x, y, style, unichar,
                                              line->double_width,
                                              line->double_height_top?1:
                                              line->double_height_bottom?-1:0,
                                              in_scrolling_region,
                                              in_selected_region ^ is_cursor);
                   if (r == vt->cursor_y && col == vt->cursor_x)
                     {
#if 0
                       cursor_x_px = x;
#endif
                     }
                   //fprintf (stderr, "{%f %f %f}", x, real_cw, vt->cw);
                   x+=real_cw;
                   if (style & STYLE_BLINK ||
                       style & STYLE_BLINK_FAST)
                     {
                       vt->has_blink = 1;
                     }
                   if (d)
                     {
                       d = ctx_utf8_skip (d, 1);
                       if (!*d) { d = NULL; }
                     }
                 }
             }
#if 0
             if (line->wrapped)
             {
               ctx_rectangle (ctx, x0, y, 10, 10);
               ctx_rgb (ctx, 1,0,0);
               ctx_fill (ctx);
             }
#endif
          }

          vt_ctx_glyph_flush (ctx, vt);
      }
  }



  {
    /* draw graphics */
     for (int row = ((vt->scroll!=0.0f)?vt->scroll:0); row < (vt->scroll) + vt->rows * 4; row ++)
      {
        CtxList *l = ctx_list_nth (vt->lines, row);
        float y = y0 + vt->ch * (vt->rows - row);

        if (row >= vt->rows && !vt->in_alt_screen)
          {
            l = ctx_list_nth (vt->scrollback, row-vt->rows);
          }

        if (l && y <= (vt->rows - vt->scroll) *  vt->ch)
          {
            VtLine *line = l->data;
            {
            for (int i = 0; i < 4; i++)
              {
                Image *image = line->images[i];
                if (image)
                  {
                    int u = (line->image_col[i]-1) * vt->cw + (line->image_X[i] * vt->cw);
                    int v = y - vt->ch + (line->image_Y[i] * vt->ch);
                //  int rows = (image->height + (vt->ch-1) ) /vt->ch;
                //
                //
                    if (v + image->height +vt->scroll * vt->ch > 0.0 &&
                        image->width && image->height /* some ghost images appear with these */
                        )
                    {
                    ctx_save (ctx);
                    ctx_rectangle (ctx, (int)x0, (int)(y0 - vt->scroll * vt->ch),
                                   vt->width, vt->height);
                    ctx_clip (ctx);
                    char texture_n[65]; 

                    sprintf (texture_n, "vtimg%i", image->eid_no);
                    ctx_rectangle (ctx, u, v, image->width, image->height);
                    ctx_translate (ctx, u, v);

                    //replace this texture_n with NULL to
                    // be content addressed - but bit slower
                    ctx_define_texture (ctx, texture_n, image->width,
                                        image->height,
                                        0,
                                        image->kitty_format == 32 ?
                                                 CTX_FORMAT_RGBA8 :
                                                 CTX_FORMAT_RGB8,
                                        image->data, texture_n);
                    ctx_fill (ctx);

                    ctx_restore (ctx);
                    }
                  }
              }

            if (line->ctx_copy)
              {
                //fprintf (stderr, " [%i]\n", ctx_textureclock (ctx));
                //ctx_render_stream (line->ctx_copy, stderr, 1);

                ctx_reset_path (ctx);
                ctx_save (ctx);
                ctx_font (ctx, "Regular");
                ctx_rectangle (ctx, (int)x0, (int)(y0 - vt->scroll * vt->ch),
                               vt->width, vt->height);
                ctx_clip (ctx);  // it would be nice if we could not clip
                                 // since it incurs a performance overhead
                                 // look into making sure rectangular aligned clip is
                                 // hit.
                ctx_translate (ctx, 0.0, y - vt->ch);

                ctx_render_ctx (line->ctx_copy, ctx);
                ctx_restore (ctx);
              }
            }
          }
    //  y -= vt->ch;
      }
  }


#if 0
  for (int i = 0; i < 4; i++)
    {
      if (vt->leds[i])
        {
          ctx_rgba (ctx, .5,1,.5,0.8);
          ctx_rectangle (ctx, vt->cw * i + vt->cw * 0.25, vt->ch * 0.25, vt->cw/2, vt->ch/2);
          ctx_fill (ctx);
        }
    }
#endif

  ctx_restore (ctx);
//#define SCROLL_SPEED 0.25;
#define SCROLL_SPEED 0.01;
  if (vt->in_smooth_scroll)
   {
     if (vt->in_smooth_scroll<0)
       {
         vt->scroll_offset += SCROLL_SPEED;
         if (vt->scroll_offset >= 0.0)
           {
             vt->scroll_offset = 0;
             vt->in_smooth_scroll = 0;
             ctx_client_rev_inc (vt->client);
           }
       }
     else
       {
         vt->scroll_offset -= SCROLL_SPEED;
         if (vt->scroll_offset <= 0.0)
           {
             vt->scroll_offset = 0;
             vt->in_smooth_scroll = 0;
             ctx_client_rev_inc (vt->client);
           }
       }
   }

    if (vt->size_age) {
      char buf[20];
      if (vt->size_age + 1000 * 1000 * 2 < ctx_ticks ())
      {
        vt->size_age = 0;
      }
      else
      {
        sprintf (buf, "%ix%i", vt->cols, vt->rows);
        ctx_rgba (ctx, 0,0,0,0.7f);
        float w = ctx_text_width (ctx, buf);
        ctx_rectangle (ctx, vt->width - w - vt->cw, vt->height - vt->ch, vt->cw + w, vt->ch);
        ctx_fill (ctx);
        ctx_rgba (ctx, 1,1,1,0.7f);
        ctx_move_to (ctx, vt->width - w, vt->height - 0.2f * vt->ch);
        ctx_text (ctx, buf);
      } 
    }


    /* scrollbar */
    if (!vt->in_alt_screen && vt->scrollbar_visible)
    {
      float disp_lines = vt->rows;
      float tot_lines = vt->line_count + vt->scrollback_count;
      float offset = (tot_lines - disp_lines - vt->scroll) / tot_lines;
      float win_len = disp_lines / tot_lines;

#if 0
      ctx_rectangle (ctx, (vt->cols *vt->cw), 0, 
                       (vt->width) - (vt->cols * vt->cw),
                       vt->rows *  vt->ch);
      ctx_rgb (ctx,1,0,0);
      ctx_fill (ctx);
#endif

      ctx_rectangle (ctx, (vt->width) - vt->cw * ctx_vt_scrollbar_width_visible,
                     0, ctx_vt_scrollbar_width_visible * vt->cw,
                     vt->height);
      //ctx_listen (ctx, CTX_DRAG,  scrollbar_drag, vt, NULL);
      //ctx_listen (ctx, CTX_ENTER, scrollbar_enter, vt, NULL);
      //ctx_listen (ctx, CTX_LEAVE, scrollbar_leave, vt, NULL);
      if (vt->scroll != 0 || scrollbar_focused)
        ctx_rgba (ctx, 1, 1, 1, .06);
      else
        ctx_rgba (ctx, 1, 1, 1, .01);
      ctx_fill (ctx);
      ctx_round_rectangle (ctx, (vt->width) - vt->cw * ctx_vt_scrollbar_width_visible,
                           offset * vt->height,
                           (ctx_vt_scrollbar_width_visible) * vt->cw,
                           win_len * vt->height,
                           vt->cw * ctx_vt_scrollbar_width_visible /2);
      //ctx_listen (ctx, CTX_DRAG, scroll_handle_drag, vt, NULL);
      if (vt->scroll != 0 || scrollbar_focused)
        ctx_rgba (ctx, 1, 1, 1, .15);
      else
        ctx_rgba (ctx, 1, 1, 1, .05);
      ctx_fill (ctx);
    }


    ctx_rectangle (ctx, 0, 0, vt->width, vt->height);
    ctx_listen (ctx, CTX_DRAG,   vt_mouse_event, vt, NULL);
    ctx_listen (ctx, CTX_MOTION, vt_mouse_event, vt, NULL);
    ctx_reset_path (ctx);


    ctx_restore (ctx);

    if (vt->popped)
    {
       //ctx_set_popup (ctx, test_popup, vt);
    }
}


int vt_is_done (VT *vt)
{
  return vt->vtpty.done;
}

int vt_get_result (VT *vt)
{
  /* we could block - at least for a while, here..? */
  return vt->result;
}

void vt_set_scrollback_lines (VT *vt, int scrollback_lines)
{
  vt->scrollback_limit = scrollback_lines;
}

int  vt_get_scrollback_lines (VT *vt)
{
  return vt->scrollback_limit;
}

void vt_set_scroll (VT *vt, int scroll)
{
  if (vt->scroll == scroll)
    return;
  vt->scroll = scroll;
  if (vt->scroll > ctx_list_length (vt->scrollback) )
    { vt->scroll = ctx_list_length (vt->scrollback); }
  if (vt->scroll < 0)
    { vt->scroll = 0; }
}

int vt_get_scroll (VT *vt)
{
  return vt->scroll;
}

char *
vt_get_selection (VT *vt)
{
  CtxString *str = ctx_string_new ("");
  char *ret;
  for (int row = vt->select_start_row; row <= vt->select_end_row; row++)
    {
      const char *line_str = vt_get_line (vt, vt->rows - row);
      int col = 1;
      for (const char *c = line_str; *c; c = ctx_utf8_skip (c, 1), col ++)
        {
          if (row == vt->select_end_row && col > vt->select_end_col)
            { continue; }
          if (row == vt->select_start_row && col < vt->select_start_col)
            { continue; }
          ctx_string_append_utf8char (str, c);
        }
      if (row < vt->select_end_row && !vt_line_is_continuation (vt, vt->rows-row-1))
      {
        ctx_string_append_byte (str, '\n');
      }
    }
  ret = str->str;
  ctx_string_free (str, 0);
  return ret;
}

int vt_get_local (VT *vt)
{
  return vt->local_editing;
}

void vt_set_local (VT *vt, int local)
{
  vt->local_editing = local;
}

static unsigned long prev_press_time = 0;
static int short_count = 0;

void terminal_set_primary (const char *text)
{
  if (primary) ctx_free (primary);
  primary = NULL;
  if (text) primary = ctx_strdup (text);
}

void terminal_long_tap (Ctx *ctx, VT *vt);
static int long_tap_cb_id = 0;
static int single_tap (Ctx *ctx, void *data)
{
#if 0 // XXX
  VT *vt = data;
  if (short_count == 0 && !vt->select_active)
    terminal_long_tap (ctx, vt);
#endif
  return 0;
}

void vt_mouse (VT *vt, CtxEvent *event, VtMouseEvent type, int button, int x, int y, int px_x, int px_y)
{
//#if CTX_PTY
 char buf[64]="";
 int button_state = 0;
 ctx_client_rev_inc (vt->client);
 ctx_ticks();
 if ((! (vt->mouse | vt->mouse_all | vt->mouse_drag)) ||
     (event && (event->state & CTX_MODIFIER_STATE_SHIFT)))
   {
     // regular mouse select, this is incomplete
     // fully ignorant of scrollback for now
     //
     if (type == VT_MOUSE_PRESS)
       {
         vt->cursor_down = 1;
         vt->select_begin_col = x;
         vt->select_begin_row = y - (int)vt->scroll;
         vt->select_start_col = x;
         vt->select_start_row = y - (int)vt->scroll;
         vt->select_end_col = x;
         vt->select_end_row = y - (int)vt->scroll;
         vt->select_active = 0;
         if (long_tap_cb_id)
           {
             ctx_remove_idle (vt->root_ctx, long_tap_cb_id);
             long_tap_cb_id = 0;
           }
         
         if ((ctx_ticks () - prev_press_time) < 1000*300 &&
             abs(px_x - vt->select_begin_x) + 
             abs(px_y - vt->select_begin_y) < 8)
         {
           short_count++;
           switch (short_count)
           {
             case 1:
             {
               /* extend selection until space, XXX  should handle utf8 instead of ascii here!  */

               int hit_space = 0;
           
               while (vt->select_start_col > 1 && !hit_space)
               {
                 vt->select_start_col --;
                 char *sel = vt_get_selection (vt);
                 if (sel[0] == ' ' || sel[0] == '\0')
                   hit_space = 1;
                 ctx_free (sel);
               }
               if (hit_space)
                 vt->select_start_col++;

               hit_space = 0;
               while ((hit_space == 0) &&
                      (vt->select_end_col < vt->cols))
               {
                 vt->select_end_col ++;
                 char *sel = vt_get_selection (vt);
                 int len = strlen(sel);
                 if (sel[len-1]==' ')
                   hit_space = 1;
                 ctx_free (sel);
               }
               if (hit_space)
                 vt->select_end_col--;

               vt->select_active = 1;

               { char *sel = vt_get_selection (vt);
                 if (sel)
                 {
                    terminal_set_primary (sel);
                    ctx_free (sel);
                 }
               }
               }
               break;
             case 2:
               vt->select_start_col = 1;
               vt->select_end_col = vt->cols;
               vt->select_active = 1;
               {
                 char *sel = vt_get_selection (vt);
                 if (sel){
                    terminal_set_primary (sel);
                    ctx_free (sel);
                 }
               }
               break;
             case 3:
               short_count = 0;
               vt->select_start_col = 
               vt->select_end_col = vt->select_begin_col;
               vt->select_active = 0;
               terminal_set_primary ("");
               break;
           }
         }
         else
         {
           if (vt->root_ctx && short_count == 0)
             long_tap_cb_id = ctx_add_timeout (vt->root_ctx, 1000, single_tap, vt);
           short_count = 0;
           //vt->select_start_col = 
           //vt->select_end_col = vt->select_begin_col;
         }
         vt->select_begin_x = px_x;
         vt->select_begin_y = px_y;
         prev_press_time = ctx_ticks ();
         ctx_client_rev_inc (vt->client);
       }
     else if (type == VT_MOUSE_RELEASE)
       {
         if (long_tap_cb_id)
           {
             ctx_remove_idle (vt->root_ctx, long_tap_cb_id);
             long_tap_cb_id = 0;
           }
         vt->cursor_down = 0;
       }
     else if (type == VT_MOUSE_MOTION && vt->cursor_down)
       {
         int row = y - (int)vt->scroll;
         int col = x;
         if ((row > vt->select_begin_row) ||
             ((row == vt->select_begin_row) && (col >= vt->select_begin_col)))
         {
           vt->select_start_col = vt->select_begin_col;
           vt->select_start_row = vt->select_begin_row;
           vt->select_end_col = col;
           vt->select_end_row = row;
         }
         else
         {
           vt->select_start_col = col;
           vt->select_start_row = row;
           vt->select_end_col = vt->select_begin_col;
           vt->select_end_row = vt->select_begin_row;
         }
         if (vt->select_end_row == vt->select_start_row &&
             abs (vt->select_begin_x - px_x) < vt->cw/2)
         {
           vt->select_active = 0;
         }
         else
         {
           vt->select_active = 1;
           char *selection = vt_get_selection (vt);
           if (selection)
           {
             terminal_set_primary (selection);
             ctx_free (selection);
           }
         }

         if (y < 1)
         {
           vt->scroll += 1.0f;
           if (vt->scroll > vt->scrollback_count)
             vt->scroll = vt->scrollback_count;
         }
         else if (y > vt->rows)
         {
           vt->scroll -= 1.0f;
           if (vt->scroll < 0)
             vt->scroll = 0.0f;
         }

         ctx_client_rev_inc (vt->client);
       }
     return;
   }
 if (type == VT_MOUSE_MOTION)
   { button_state = 3; }

 if (vt->unit_pixels && vt->mouse_decimal)
   {
     x = px_x;
     y = px_y;
   }
 switch (type)
   {
     case VT_MOUSE_MOTION:
       if (!vt->mouse_all)
         return;
       if (x==vt->lastx && y==vt->lasty)
         return;
       vt->lastx = x;
       vt->lasty = y;
   //  sprintf (buf, "\033[<35;%i;%iM", x, y);
       break;
     case VT_MOUSE_RELEASE:
       if (vt->mouse_decimal == 0)
         button_state = 3;
       break;
     case VT_MOUSE_PRESS:
       button_state = 0;
       break;
     case VT_MOUSE_DRAG: // XXX not really used - remove
       if (! (vt->mouse_all || vt->mouse_drag) )
         return;
       button_state = 32;
       break;
   }
 // todo : mix in ctrl/meta state
 if (vt->mouse_decimal)
   {
     sprintf (buf, "\033[<%i;%i;%i%c", button_state, x, y, type == VT_MOUSE_RELEASE?'m':'M');
   }
 else
   { 
     sprintf (buf, "\033[M%c%c%c", button_state + 32, x + 32, y + 32);
   }
 if (buf[0])
   {
     vt_write (vt, buf, strlen (buf) );
#ifndef PICO_BUILD
     fsync (vt->vtpty.pty);
#endif
   }
//#endif
}

pid_t vt_get_pid (VT *vt)
{
  return vt->vtpty.pid;
}

void vt_set_ctx (VT *vt, Ctx *ctx)
{
  vt->root_ctx = ctx;
}

#endif

float ctx_target_fps = 50.0f;

#if CTX_VT


#ifndef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE
#endif

#if !__COSMOPOLITAN__
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
//#include <sys/ioctl.h>
#include <signal.h>
#include <math.h>
#include <sys/time.h>
#include <time.h>
#endif

extern Ctx *ctx;
#define flag_is_set(a, f) (((a) & (f))!=0)
//#define flag_set(a, f)    ((a) |= (f));
//#define flag_unset(a, f)  ((a) &= ~(f));


void terminal_update_title    (const char *title);
void ctx_sdl_set_fullscreen   (Ctx *ctx, int val);
int  ctx_sdl_get_fullscreen   (Ctx *ctx);
static int ctx_fetched_bytes = 1;

CtxClient *vt_get_client (VT *vt);

void ctx_client_set_title        (Ctx *ctx, int id, const char *title)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client)
     return;
   if (client->title)
     ctx_free (client->title);
   client->title = NULL;
   if (title)
     client->title = ctx_strdup (title);
}
const char *ctx_client_get_title (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client)
     return NULL;
   return client->title;
}

int vt_set_prop (Ctx *ctx, VT *vt, uint32_t key_hash, const char *val)
{
#if CTX_VT
#if 1
  switch (key_hash)
  {
    case SQZ_title:  
     {
       CtxClient *client = vt_get_client (vt);
       if (client)
       {
         ctx_client_set_title (vt->root_ctx, client->id, val);
         //if (client->title) ctx_free (client->title);
         //client->title = ctx_strdup (val);
       }
     }
     break;
  }
#else
  float fval = strtod (val, NULL);
  CtxClient *client = ctx_client_by_id (ct->id);
  uint32_t val_hash = ctx_strhash (val);
  if (!client)
    return 0;

  if (key_hash == ctx_strhash("start_move"))
  {
    start_moving (client);
    moving_client = 1;
    return 0;
  }

// set "pcm-hz"       "8000"
// set "pcm-bits"     "8"
// set "pcm-encoding" "ulaw"
// set "play-pcm"     "d41ata312313"
// set "play-pcm-ref" "foo.wav"

// get "free"
// storage of blobs for referencing when drawing or for playback
// set "foo.wav"      "\3\1\1\4\"
// set "fnord.png"    "PNG12.4a312"

  switch (key_hash)
  {
    case SQZ_title:  ctx_client_set_title (ct->id, val); break;
    case SQZ_x:      client->x = fval; break;
    case SQZ_y:      client->y = fval; break;
    case SQZ_width:  ctx_client_resize (ct->id, fval, client->height); break;
    case SQZ_height: ctx_client_resize (ct->id, client->width, fval); break;
    case SQZ_action:
      switch (val_hash)
      {
        case SQZ_maximize:     ctx_client_maximize (client); break;
        case SQZ_unmaximize:   ctx_client_unmaximize (client); break;
        case SQZ_lower:        ctx_client_lower (client); break;
        case SQZ_lowerBottom:  ctx_client_lower_bottom (client);  break;
        case SQZ_raise:        ctx_client_raise (client); break;
        case SQZ_raiseTop:     ctx_client_raise_top (client); break;
      }
      break;
  }
  ct->rev++;
#endif
#endif
  return 0;
}

static float _ctx_font_size = 10.0;


int ctx_client_resize (Ctx *ctx, int id, int width, int height);
void ctx_client_maximize (Ctx *ctx, int id);

CtxClient *vt_get_client (VT *vt)
{
#if CTX_VT
  for (CtxList *l = ctx_clients (vt->root_ctx); l; l =l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if (client->vt == vt)
            return client;
  }
#endif
  return NULL;
}

static void ctx_client_init (Ctx *ctx, CtxClient *client, int x, int y, int width, int height, float font_size,
                             CtxClientFlags flags, void *user_data, CtxClientFinalize finalize)
{
  static int global_id = 0;


  if (font_size <= 0.0) font_size = ctx_get_font_size (ctx);
  if (ctx_backend_type (ctx) == CTX_BACKEND_TERM)
  {
    font_size = 3;
  }
  client->id = ++global_id; // starting at 1 is nicer, then we can use 0 for none
  client->x = x;
  client->y = y;
  client->flags = flags;
  client->ctx = ctx;
  client->width = width;
  client->height = height;
  client->user_data = user_data;
  client->finalize = finalize;
  #if 0
  client->opacity = 1.0f;
  #endif

      //fprintf (stderr, "client new:%f\n", font_size);
#if CTX_THREADS
  mtx_init (&client->mtx, mtx_plain);
#endif
}

CtxClient *ctx_client_new (Ctx *ctx,
                           const char *commandline,
                           int x, int y, int width, int height,
                           float font_size,
                           CtxClientFlags flags,
                           void *user_data,
                           CtxClientFinalize finalize)
{
  CtxClient *client = (CtxClient*)ctx_calloc (1, sizeof (CtxClient));
  ctx_list_append (&ctx->events.clients, client);
  ctx_client_init (ctx, client, x, y, width, height, font_size, flags, user_data, finalize);
  float line_spacing = 1.0f;
  client->vt = vt_new (commandline, width, height, font_size,line_spacing, client->id, (flags & CTX_CLIENT_CAN_LAUNCH)!=0);
  client->vt->client = client;
  vt_set_ctx (client->vt, ctx);
  vt_set_title (client->vt, "ctx - native vectors");
  return client;
}

CtxClient *ctx_client_new_argv (Ctx *ctx, char **argv, int x, int y, int width, int height, float font_size, CtxClientFlags flags, void *user_data, CtxClientFinalize finalize)
{

  CtxClient *client = (CtxClient*)ctx_calloc (1, sizeof (CtxClient));
  ctx_client_init (ctx, client, x, y, width, height, font_size, flags, user_data, finalize);
  ctx_list_append (&ctx->events.clients, client);

  float line_spacing = 1.0f;
  client->vt = vt_new_argv (argv, width, height, font_size,line_spacing, client->id, (flags & CTX_CLIENT_CAN_LAUNCH)!=0);
  client->vt->client = client;
  vt_set_ctx (client->vt, ctx);
  vt_set_title (client->vt, "ctx - native vectors");
  return client;
}

#ifndef EMSCRIPTEN
#if 0
static void *launch_client_thread (void *data)
{
  CtxClient *client = data;

  client->sub_ctx = ctx_new (client->width, client->height,
                                "headless");

  client->start_routine (client->sub_ctx, client->user_data);

  fprintf (stderr, "%s: cleanup\n", __FUNCTION__);
  ctx_destroy (client->sub_ctx);
  return NULL;
}

CtxClient *ctx_client_new_thread (Ctx *ctx, void (*start_routine)(Ctx *ctx, void *user_data),
                                  int x, int y, int width, int height, float font_size, CtxClientFlags flags, void *user_data, CtxClientFinalize finalize)
{
  CtxClient *client = ctx_calloc (1, sizeof (CtxClient));
  ctx_client_init (ctx, client, x, y, width, height, font_size, flags, user_data, finalize);

  ctx_list_append (&ctx->events.clients, client);


  client->start_routine = start_routine;
  thrd_create (&client->tid, launch_client_thread, client);
  //float line_spacing = 2.0f;
  //client->vt = vt_new_thread (start_routine, userdata, width, height, font_size,line_spacing, client->id, (flags & CTX_CLIENT_CAN_LAUNCH)!=0);
  //vt_set_ctx (client->vt, ctx);
  if (client->vt)
    client->vt->client = client;
  return client;
}
#endif
#endif

#if CTX_THREADS
extern int _ctx_max_threads;
#endif

static int focus_follows_mouse = 0;

int ctx_client_is_active_tab (Ctx *ctx, CtxClient *client)
{
  return ((client->flags & CTX_CLIENT_MAXIMIZED) && client == ctx->events.active_tab);
}

static CtxClient *find_active (Ctx *ctx, int x, int y)
{
  CtxClient *ret = NULL;
  float titlebar_height = _ctx_font_size;
  int resize_border = titlebar_height/2;

  for (CtxList *l = ctx_clients (ctx); l; l = l->next)
  {
     CtxClient *c = (CtxClient*)l->data;
     if ((c->flags & CTX_CLIENT_MAXIMIZED) && c == ctx->events.active_tab)
     if (x > c->x - resize_border && x < c->x+c->width + resize_border &&
         y > c->y - titlebar_height && y < c->y+c->height + resize_border)
     {
       ret = c;
     }
  }

  for (CtxList *l = ctx_clients (ctx); l; l = l->next)
  {
     CtxClient *c = (CtxClient*)l->data;
     if (!(c->flags &  CTX_CLIENT_MAXIMIZED))
     if (x > c->x - resize_border && x < c->x+c->width + resize_border &&
         y > c->y - titlebar_height && y < c->y+c->height + resize_border)
     {
       ret = c;
     }
  }
  return ret;
}

int id_to_no (Ctx *ctx, int id)
{
  CtxList *l;
  int no = 0;

  for (l = ctx_clients (ctx); l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if (client->id == id)
      return no;
    no++;
  }
  return -1;
}

void ctx_client_move (Ctx *ctx, int id, int x, int y);
int ctx_client_resize (Ctx *ctx, int id, int w, int h);
void ctx_client_shade_toggle (Ctx *ctx, int id);
float ctx_client_min_y_pos (Ctx *ctx);
float ctx_client_max_y_pos (Ctx *ctx);

static void ctx_clients_ensure_layout (Ctx *ctx)
{
  CtxList *clients = ctx_clients (ctx);
  int n_clients = ctx_list_length (clients);
  if (n_clients == 1)
  {
    CtxClient *client = (CtxClient*)clients->data;
    if (client->flags & CTX_CLIENT_MAXIMIZED)
    {
      ctx_client_move (ctx, client->id, 0, 0);
      ctx_client_resize (ctx, client->id, ctx_width (ctx), ctx_height(ctx));
      if (ctx->events.active_tab == NULL)
        ctx->events.active_tab = client;
    }
  }
  else
  for (CtxList *l = clients; l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if (client->flags & CTX_CLIENT_MAXIMIZED)
    {
      ctx_client_move (ctx, client->id, 0, 0);//ctx_client_min_y_pos (ctx));
      ctx_client_resize (ctx, client->id, ctx_width (ctx), ctx_height(ctx));
      if (ctx->events.active_tab == NULL)
        ctx->events.active_tab = client;
    }
  }
}

CtxClient *ctx_client_by_id (Ctx *ctx, int id)
{
  for (CtxList *l = ctx_clients (ctx); l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if (client->id == id)
      return client;
  }
  return NULL;
}

void ctx_client_remove (Ctx *ctx, CtxClient *client)
{
  ctx_client_lock (client);
  if (!client->internal)
  {

    if (client->vt)
      vt_destroy (client->vt);
  }

  if (client->title)
    ctx_free (client->title);

#if CTX_VT_DRAWLIST
  if (client->recording)
    ctx_destroy (client->recording);
#endif
  if (client->finalize)
     client->finalize (client, client->user_data);

  CtxClient *next = NULL;
  CtxClient *last = NULL;
  CtxClient *prev = NULL;

  int matched = 0;
  for (CtxList *l = ctx->events.clients; l; l = l->next)
  {
    if (l->data == client)
    {
       if (l->next)
         next = (CtxClient*) l->next->data;
       matched = 1;
    }
    else
      last = (CtxClient*) l->data;

    if (!matched)
      prev = (CtxClient*) l->data;
  }
  //if (!next) next = last;
  if (!prev) prev = last;

  ctx_list_remove (&ctx->events.clients, client);

  if (client == ctx->events.active_tab)
  {
    ctx->events.active_tab = next;
  }

  if (client == ctx->events.active)
    ctx->events.active = prev;

  ctx_client_unlock (client);
  ctx_free (client);
}

void ctx_client_remove_by_id (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (client)
    ctx_client_remove (ctx, client);
}

int ctx_client_width (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return 0;
  return client->width;
}

int ctx_client_height (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return 0;
  return client->height;
}

int ctx_client_x (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return 0;
  return client->x;
}

int ctx_client_y (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return 0;
  return client->y;
}

// XXX : register a callback to happen on focus instead
//       of fixing the raise top behavior..

void ctx_set_focus_cb (Ctx *ctx, void(*focus_cb)(Ctx *ctx, int id, void *user_data), void *user_data)
{
  ctx->events.focus_cb = focus_cb;
  ctx->events.focus_cb_user_data = user_data;
}

void ctx_client_focus (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return;

  if (ctx->events.active != client)
  {
    ctx->events.active = client;

   if ((client->flags & CTX_CLIENT_MAXIMIZED))
      ctx->events.active_tab = client;

   if (ctx->events.focus_cb)
     ctx->events.focus_cb (ctx, id, ctx->events.focus_cb_user_data);

   // ctx_client_raise_top (ctx, id);
    ctx_queue_draw (ctx);
  }
}

void ctx_client_raise_almost_top (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  CtxClient *last= NULL;
  CtxClient *prevlast= NULL;
  if (!client) return;
  for (CtxList *l = ctx->events.clients; l; l=l->next)
  {
    prevlast = last;
    last = (CtxClient*) l->data;
  }
  if (client == last)
  {
    if (prevlast)
    {
      ctx_list_remove (&ctx->events.clients, prevlast);
      ctx_list_append (&ctx->events.clients, prevlast);
      ctx_queue_draw (ctx);
      return;
    }
  }
  if (!last)
    return;
  if (prevlast == client)
    return;
  ctx_list_remove (&ctx->events.clients, client);
  ctx_list_append (&ctx->events.clients, client);
  ctx_list_remove (&ctx->events.clients, last);
  ctx_list_append (&ctx->events.clients, last);
  ctx_queue_draw (ctx);
}

void ctx_client_raise_top (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return;
  ctx_list_remove (&ctx->events.clients, client);
  ctx_list_append (&ctx->events.clients, client);
  ctx_queue_draw (ctx);
}

void ctx_client_lower_bottom (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return;
  ctx_list_remove (&ctx->events.clients, client);
  ctx_list_prepend (&ctx->events.clients, client);
  ctx_queue_draw (ctx);
}

void ctx_client_lower_almost_bottom (Ctx *ctx, int id)
{
  CtxClient *client = ctx_client_by_id (ctx, id);
  if (!client) return;
  CtxClient *first = (CtxClient*)ctx->events.clients->data;

  ctx_list_remove (&ctx->events.clients, client);
  ctx_list_prepend (&ctx->events.clients, client);
  ctx_list_remove (&ctx->events.clients, first);
  ctx_list_prepend (&ctx->events.clients, first);
  ctx_queue_draw (ctx);
}

void ctx_client_flag_unset (Ctx *ctx, int id, int flag)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client) return;
   client->flags = (CtxClientFlags) (client->flags & (~flag));
   ctx_queue_draw (ctx);
}

void ctx_client_flag_set (Ctx *ctx, int id, int flag)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client) return;
   client->flags = (CtxClientFlags) (client->flags| flag);
}

int ctx_client_flag_is_set (Ctx *ctx, int id, int flag)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client) return 0;
   return (client->flags & flag) != 0;
}

void ctx_client_iconify (Ctx *ctx, int id)
{
   ctx_client_flag_set (ctx, id, CTX_CLIENT_ICONIFIED);
}

int ctx_client_is_iconified (Ctx *ctx, int id)
{
   return ctx_client_flag_is_set (ctx, id, CTX_CLIENT_ICONIFIED);
}

void ctx_client_uniconify (Ctx *ctx, int id)
{
   ctx_client_flag_unset (ctx, id, CTX_CLIENT_ICONIFIED);
}

void ctx_client_maximize (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client) return;
   if (!(client->flags &  CTX_CLIENT_MAXIMIZED))
   {
     client->flags = (CtxClientFlags) (client->flags | CTX_CLIENT_MAXIMIZED);
     client->unmaximized_x = client->x;
     client->unmaximized_y = client->y;
     client->unmaximized_width  = client->width;
     client->unmaximized_height = client->height;
     ctx_client_move (ctx, id, 0, ctx_client_min_y_pos (client->ctx));
   }

   // enforce_layout does the size
   //client_resize (ctx, id, ctx_width (ctx), ctx_height(ctx) - ctx_client_min_y_pos (ctx));
   
   ctx->events.active = ctx->events.active_tab = client;
   ctx_queue_draw (ctx);
}

int ctx_client_is_maximized (Ctx *ctx, int id)
{
   return ctx_client_flag_is_set (ctx, id, CTX_CLIENT_MAXIMIZED);
}

void ctx_client_unmaximize (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client) return;
   if ((client->flags & CTX_CLIENT_MAXIMIZED) == 0)
     return;
   client->flags = (CtxClientFlags) (client->flags & ~CTX_CLIENT_MAXIMIZED);
   ctx_client_resize (ctx, id, client->unmaximized_width, client->unmaximized_height);
   ctx_client_move (ctx, id, client->unmaximized_x, client->unmaximized_y);
   ctx->events.active_tab = NULL;
   ctx_queue_draw (ctx);
}

void ctx_client_maximized_toggle (Ctx *ctx, int id)
{
  if (ctx_client_is_maximized (ctx, id))
    ctx_client_unmaximize (ctx, id);
  else
    ctx_client_maximize (ctx, id);
}


void ctx_client_shade (Ctx *ctx, int id)
{
  ctx_client_flag_set (ctx, id, CTX_CLIENT_SHADED);
}

int ctx_client_is_shaded (Ctx *ctx, int id)
{
   return ctx_client_flag_is_set (ctx, id, CTX_CLIENT_SHADED);
}

void ctx_client_unshade (Ctx *ctx, int id)
{
  ctx_client_flag_unset (ctx, id, CTX_CLIENT_SHADED);
}

void ctx_client_toggle_maximized (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client) return;
   if (ctx_client_is_maximized (ctx, id))
     ctx_client_unmaximize (ctx, id);
   else
     ctx_client_maximize (ctx, id);
}

void ctx_client_shade_toggle (Ctx *ctx, int id)
{
   if (ctx_client_is_shaded (ctx, id))
     ctx_client_shade (ctx, id);
   else
     ctx_client_unshade (ctx, id);
}


void ctx_client_paste (Ctx *ctx, int id, const char *str)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client && client->vt)
     vt_paste (client->vt, str);
}

char  *ctx_client_get_selection (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client && client->vt)
     return vt_get_selection (client->vt);
   return ctx_strdup ("");
}

void ctx_client_move (Ctx *ctx, int id, int x, int y)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client && (client->x != x || client->y != y))
   {
     client->x = x;
     client->y = y;
     ctx_client_rev_inc (client);
     ctx_queue_draw (ctx);
   }
}

void ctx_client_set_font_size (Ctx *ctx, int id, float font_size)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client->vt)
   {
     if (vt_get_font_size (client->vt) != font_size)
       vt_set_font_size (client->vt, font_size);
     ctx_queue_draw (ctx);
   }
}

int ctx_client_get_x (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client) return client->x;
   return 0;
}

int ctx_client_get_y (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client) return client->y;
   return 0;
}

int ctx_client_get_width (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client) return client->width;
   return 0;
}

int ctx_client_get_height (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client) return client->height;
   return 0;
}

float ctx_client_get_font_size (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (client && client->vt)
     return vt_get_font_size (client->vt);
   return 14.0;
}

#if 0
void ctx_client_set_opacity (Ctx *ctx, int id, float opacity)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client)
     return;
   if (opacity > 0.98) opacity = 1.0f;
   client->opacity = opacity;
   ctx_queue_draw (ctx);
}

float ctx_client_get_opacity (Ctx *ctx, int id)
{
   CtxClient *client = ctx_client_by_id (ctx, id);
   if (!client)
     return 1.0f;
   return client->opacity;
}
#endif

int ctx_client_resize (Ctx *ctx, int id, int width, int height)
{
   CtxClient *client = ctx_client_by_id (ctx, id);

   if (client && ((height != client->height) || (width != client->width) ))
   {
     client->width  = width;
     client->height = height;
     if (client->vt)
       vt_set_px_size (client->vt, width, height);
     ctx_queue_draw (ctx);
     return 1;
   }
   return 0;
}

void ctx_client_titlebar_drag (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;

  if (event->type == CTX_DRAG_RELEASE)
  {
  // TODO : reintroduce as a hookable event?
  #if 0
    static int prev_drag_end_time = 0;
    if (event->time - prev_drag_end_time < 500)
    {
      //client_shade_toggle (ctx, client->id);
      ctx_client_maximized_toggle (event->ctx, client->id);
    }
    prev_drag_end_time = event->time;
  #endif
  }

  float new_x = client->x +  event->delta_x;
  float new_y = client->y +  event->delta_y;

  //float snap_threshold = 6;
  //if (ctx_backend_type (event->ctx) == CTX_BACKEND_TERM)
  //   snap_threshold = 1;

  if (new_y + client->height > ctx_client_max_y_pos (event->ctx))
     new_y = ctx_client_max_y_pos (event->ctx) - client->height;
  if (new_y < ctx_client_min_y_pos (event->ctx)) new_y = ctx_client_min_y_pos (event->ctx);

  if (new_x + client->width > ctx_width (event->ctx))
     new_x = ctx_width (event->ctx) - client->width;
  if (new_x < 0) new_x = 0;


#if 0
  if (fabs (new_x - 0) < snap_threshold) new_x = 0.0;
  if (fabs (ctx_width (event->ctx) - (new_x + client->width)) < snap_threshold)
       new_x = ctx_width (event->ctx) - client->width;
#endif



  ctx_client_move (event->ctx, client->id, new_x, new_y);
  ctx_client_focus (event->ctx, client->id);

  event->stop_propagate = 1;
}

static float min_win_dim = 32;

void ctx_client_resize_se (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  int new_w = client->width + event->delta_x;
  int new_h = client->height + event->delta_y;
  if (new_w <= min_win_dim) new_w = min_win_dim;
  if (new_h <= min_win_dim) new_h = min_win_dim;
  ctx_client_resize (event->ctx, client->id, new_w, new_h);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_e (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  int new_w = client->width + event->delta_x;
  if (new_w <= min_win_dim) new_w = min_win_dim;
  ctx_client_resize (event->ctx, client->id, new_w, client->height);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_s (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  int new_h = client->height + event->delta_y;
  if (new_h <= min_win_dim) new_h = min_win_dim;
  ctx_client_resize (event->ctx, client->id, client->width, new_h);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_n (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  float new_y = client->y +  event->delta_y;
  int new_h = client->height - event->delta_y;
  if (new_h <= min_win_dim) new_h = min_win_dim;
  ctx_client_resize (event->ctx, client->id, client->width, new_h);
  ctx_client_move (event->ctx, client->id, client->x, new_y);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_ne (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  float new_y = client->y +  event->delta_y;
  int new_h = client->height - event->delta_y;
  int new_w = client->width + event->delta_x;
  if (new_h <= min_win_dim) new_h = min_win_dim;
  if (new_w <= min_win_dim) new_w = min_win_dim;
  ctx_client_resize (event->ctx, client->id, new_w, new_h);
  ctx_client_move (event->ctx, client->id, client->x, new_y);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_sw (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;

  float new_x = client->x +  event->delta_x;
  int new_w = client->width - event->delta_x;
  int new_h = client->height + event->delta_y;

  if (new_h <= min_win_dim) new_h = min_win_dim;
  if (new_w <= min_win_dim) new_w = min_win_dim;
  ctx_client_resize (event->ctx, client->id, new_w, new_h);
  ctx_client_move (event->ctx, client->id, new_x, client->y);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_nw (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  float new_x = client->x +  event->delta_x;
  float new_y = client->y +  event->delta_y;
  int new_w = client->width - event->delta_x;
  int new_h = client->height - event->delta_y;
  if (new_h <= min_win_dim) new_h = min_win_dim;
  if (new_w <= min_win_dim) new_w = min_win_dim;
  ctx_client_resize (event->ctx, client->id, new_w, new_h);
  ctx_client_move (event->ctx, client->id, new_x, new_y);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void ctx_client_resize_w (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;

  float new_x = client->x +  event->delta_x;
  int new_w = client->width - event->delta_x;
  if (new_w <= min_win_dim) new_w = min_win_dim;
  ctx_client_resize (event->ctx, client->id, new_w, client->height);
  ctx_client_move (event->ctx, client->id, new_x, client->y);
  ctx_client_rev_inc (client);
  ctx_queue_draw (event->ctx);

  event->stop_propagate = 1;
}

void ctx_client_close (CtxEvent *event, void *data, void *data2)
{
  //Ctx *ctx = event->ctx;
  CtxClient *client = (CtxClient*)data;

 // client->do_quit = 1;
  
  ctx_client_remove (event->ctx, client);

  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

/********************/
void vt_use_images (VT *vt, Ctx *ctx);
//float _ctx_green = 0.5;

void ctx_client_draw (Ctx *ctx, CtxClient *client, float x, float y)
{
    int focused = (client == ctx->events.active);
    if (focused)
      focused = ctx_has_focus (ctx);
#if 0
    if (client->tid)
    {
      ctx_save (ctx);
      ctx_translate (ctx, x, y);
      int width = client->width;
      int height = client->height;
      css_panel_start (itk, "", 0, 0, width, height);
      //css_seperator (itk);
#if 0
      if (css_button (itk, "add tab"))
      {
        add_tab (ctx_find_shell_command(), 1);
      }
#endif
      //css_sameline (itk);
      on_screen_keyboard = css_toggle (itk, "on screen keyboard", on_screen_keyboard);
      focus_follow_mouse = css_toggle (itk, "focus follows mouse", focus_follows_mouse);
      css_slider_float (itk, "CTX_GREEN", &_ctx_green, 0.0, 1.0, 0.5);
      css_ctx_settings (itk);
      css_css_settings (itk);
      css_panel_end (itk);
      css_done (itk);
      //css_key_bindings (itk);
      ctx_restore (ctx);
    }
    else
#endif
    {
       ctx_client_lock (client);

#if CTX_GSTATE_PROTECT
       ctx_gstate_protect (ctx);
#endif

       int found = 0;
       for (CtxList *l2 = ctx_clients (ctx); l2; l2 = l2->next)
         if (l2->data == client) found = 1;
       if (found)
       {

      int rev = ctx_client_rev (client);
#if CTX_VT_DRAWLIST
      if (client->drawn_rev != rev)
      {
        if (!client->recording)
          client->recording = ctx_new_drawlist (client->width, client->height);
        else
          ctx_start_frame (client->recording);
        vt_draw (client->vt, client->recording, x, y, focused);

        // XXX : invalidate caches on focus change?
      }

      if (client->recording)
      {
        ctx_save (ctx);
        ctx_translate (ctx, x, y);
        #if 0
        if (client->opacity != 1.0f)
        {
          ctx_global_alpha (ctx, client->opacity);
        }
        #endif
        ctx_render_ctx (client->recording, ctx);
        ctx_restore (ctx);
        ctx_client_register_events (client, ctx, x, y);
      }
#else
#if 0
      if (client->opacity != 1.0)
      {
        ctx_save (ctx);
        ctx_global_alpha (ctx, client->opacity);
      }
    #endif
      vt_draw (client->vt, ctx, x, y, focused);
      #if 0
      if (client->opacity != 1.0)
      {
        ctx_restore (ctx);
      }
      #endif
      ctx_client_register_events (client, ctx, x, y);
#endif
      client->drawn_rev = rev;

#if CTX_GSTATE_PROTECT
       ctx_gstate_unprotect (ctx);
#endif

      ctx_client_unlock (client);
      }
    }
}

void ctx_client_use_images (Ctx *ctx, CtxClient *client)
{
  if (!client->internal)
  {
      uint32_t rev = ctx_client_rev (client);
#if CTX_VT_DRAWLIST
      if (client->drawn_rev != rev)
      {
        if (!client->recording)
          client->recording = ctx_new_drawlist (client->width, client->height);
        else
          ctx_start_frame (client->recording);
        vt_draw (client->vt, client->recording, 0.0, 0.0, 0);
      }

      if (client->recording)
      {
        ctx_save (ctx);
        #if 0
        if (client->opacity != 1.0f)
        {
          ctx_global_alpha (ctx, client->opacity);
        }
        #endif
        ctx_render_ctx_textures (client->recording, ctx);
        ctx_restore (ctx);
      }
#else
    if (client->vt)vt_use_images (client->vt, ctx);
#endif
    client->drawn_rev = rev;
  }
}

void ctx_client_lock (CtxClient *client)
{
#if CTX_THREADS
    mtx_lock (&client->mtx);
#endif
}

void ctx_client_unlock (CtxClient *client)
{
#if CTX_THREADS
    mtx_unlock (&client->mtx);
#endif
}


CtxEvent *ctx_event_copy (CtxEvent *event)
{
  CtxEvent *copy = (CtxEvent*)ctx_calloc (1, sizeof (CtxEvent));
  *copy = *event;
  if (copy->string) {
    copy->string = ctx_strdup (copy->string);
    copy->owns_string = 1;
  }
  return copy;
}

static int ctx_clients_dirty_count (Ctx *ctx)
{
  int changes = 0;
  for (CtxList *l = ctx_clients (ctx); l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if ((client->drawn_rev != ctx_client_rev (client) ) ||
        vt_has_blink (client->vt))
      changes++;
  }
  return changes;
}

void ctx_client_titlebar_drag_maximized (CtxEvent *event, void *data, void *data2)
{
  CtxClient *client = (CtxClient*)data;
  Ctx *ctx = event->ctx;
  ctx->events.active = ctx->events.active_tab = client;
  if (event->type == CTX_DRAG_RELEASE)
  {
    static int prev_drag_end_time = 0;
    if (event->time - prev_drag_end_time < 500)
    {
      //client_shade_toggle (ctx, client->id);
      ctx_client_unmaximize (ctx, client->id);
      ctx_client_raise_top (ctx, client->id);
      ctx->events.active_tab = NULL;
    }
    prev_drag_end_time = event->time;
  }
  ctx_queue_draw (event->ctx);
  ctx_client_rev_inc (client);
  event->stop_propagate = 1;
}

float ctx_client_min_y_pos (Ctx *ctx)
{
  return _ctx_font_size * 2; // a titlebar and a panel
}

float ctx_client_max_y_pos (Ctx *ctx)
{
  return ctx_height (ctx);
}

void ctx_client_titlebar_draw (Ctx *ctx, CtxClient *client,
                               float x, float y, float width, float titlebar_height)
{
#if CTX_PTY==0
  ctx_move_to (ctx, x, y + titlebar_height * 0.8);
  if (client == ctx->events.active)
    ctx_rgba (ctx, 1, 1,0.4, 1.0);
  else
    ctx_rgba (ctx, 1, 1,1, 0.8);
  ctx_move_to (ctx, x + width * 0.5, y - titlebar_height * 0.22);
  ctx_save (ctx);
  ctx_text_align (ctx, CTX_TEXT_ALIGN_CENTER);
  ctx_text (ctx, client->title);
  ctx_restore (ctx);
#else
  ctx_rectangle (ctx, x, y - titlebar_height,
                 width, titlebar_height);
#if CTX_CSS
  if (client == ctx->events.active)
     css_style_color (ctx, "titlebar-focused-bg");
  else
     css_style_color (ctx, "titlebar-bg");
#else
  if (client == ctx->events.active)
    ctx_rgba (ctx, 0.2, 0.2,0.2, 1.0);
  else
    ctx_rgba (ctx, 0, 0,0, 1.0);
#endif

  int flags = ctx_client_flags (client);
  if (flag_is_set(flags, CTX_CLIENT_MAXIMIZED) || y == titlebar_height)
  {
    ctx_listen (ctx, CTX_DRAG, ctx_client_titlebar_drag_maximized, client, NULL);
    ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_ALL);
  }
  else
  {
    ctx_listen (ctx, CTX_DRAG, ctx_client_titlebar_drag, client, NULL);
    ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_ALL);
  }
  ctx_fill (ctx);
  //ctx_font_size (ctx, itk->font_size);//titlebar_height);// * 0.85);

  if (client == ctx->events.active &&
      (flag_is_set(flags, CTX_CLIENT_MAXIMIZED) || y != titlebar_height))
#if 1
  ctx_rectangle (ctx, x + width - titlebar_height,
                  y - titlebar_height, titlebar_height,
                  titlebar_height);
#endif
  ctx_rgb (ctx, 1, 0,0);
  ctx_listen (ctx, CTX_PRESS, ctx_client_close, client, NULL);
  ctx_listen_set_cursor (ctx, CTX_CURSOR_ARROW);
  //ctx_fill (ctx);
  ctx_reset_path (ctx);
  ctx_move_to (ctx, x + width - titlebar_height * 0.8, y - titlebar_height * 0.22);

#if CTX_CSS
  if (client == ctx->events.active)
    css_style_color (ctx, "titlebar-focused-close");
  else
    css_style_color (ctx, "titlebar-close");
#else
  if (client == ctx->events.active)
    ctx_rgba (ctx, 1, 0.2,0.2, 1.0);
  else
    ctx_rgba (ctx, 1, 1,1, 0.8);
#endif
  ctx_text (ctx, "X");

  ctx_move_to (ctx, x +  width/2, y - titlebar_height * 0.22);
#if CTX_CSS
  if (client == ctx->events.active)
    css_style_color (ctx, "titlebar-focused-fg");
  else
    css_style_color (ctx, "titlebar-fg");
#else
  if (client == ctx->events.active)
    ctx_rgba (ctx, 1, 1,1.0, 1.0);
  else
    ctx_rgba (ctx, 0.7, 0.7,0.7, 1.0);

#endif

  ctx_save (ctx);
  ctx_text_align (ctx, CTX_TEXT_ALIGN_CENTER);
  if (client->title)
    ctx_text (ctx, client->title);
  else
    ctx_text (ctx, "untitled");
  ctx_restore (ctx);
#endif
}

#if 0
static void key_down (CtxEvent *event, void *data1, void *data2)
{
  fprintf (stderr, "down %i %s\n", event->unicode, event->string);
}
static void key_up (CtxEvent *event, void *data1, void *data2)
{
  fprintf (stderr, "up %i %s\n", event->unicode, event->string);
}
static void key_press (CtxEvent *event, void *data1, void *data2)
{
  fprintf (stderr, "press %i %s\n", event->unicode, event->string);
}
#endif

#if 1
int ctx_clients_draw (Ctx *ctx, int layer2)
{
  CtxList *clients = ctx_clients (ctx);
  int n_clients         = ctx_list_length (clients);

  {
    CtxClient *client = ctx->events.active;
    int flags = ctx_client_flags (client);
    if (client && flag_is_set(flags, CTX_CLIENT_MAXIMIZED) && n_clients == 1)
    {
      ctx_client_draw (ctx, client, 0, 0);
      return 0;
    }
  }
  _ctx_font_size = ctx_get_font_size (ctx);
  float titlebar_height = _ctx_font_size;

  //float em = _ctx_font_size;
  //float screen_width = ctx_width (ctx) - 3 * em;
  //float screen_height = ctx_height (ctx);

  if (!layer2)
  for (CtxList *l = clients; l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    int flags = ctx_client_flags (client);
    if (flag_is_set(flags, CTX_CLIENT_MAXIMIZED))
    {
      if (client == ctx->events.active_tab)
      {
        ctx_client_draw (ctx, client, 0, titlebar_height);
      }
      else
      {
        ctx_client_use_images (ctx, client);
      }
    }
  }

  {
  for (CtxList *l = clients; l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    VT *vt = client->vt;
    int flags = ctx_client_flags (client);

    if (layer2)
    {
      if (!flag_is_set (flags, CTX_CLIENT_LAYER2))
        continue;
    }
    else
    {
      if (flag_is_set (flags, CTX_CLIENT_LAYER2))
        continue;
    }

    if (vt && !flag_is_set(flags, CTX_CLIENT_MAXIMIZED))
    {
      if (flag_is_set(flags, CTX_CLIENT_SHADED))
      {
        ctx_client_use_images (ctx, client);
      }
      else
      {
        ctx_client_draw (ctx, client, client->x, client->y);

      // resize regions
      if (client == ctx->events.active &&
         !flag_is_set(flags, CTX_CLIENT_SHADED) &&
         !flag_is_set(flags, CTX_CLIENT_MAXIMIZED) &&
         flag_is_set(flags, CTX_CLIENT_UI_RESIZABLE))
      {
#if CTX_CSS
        css_style_color (ctx, "titlebar-focused-bg");
#else
        ctx_rgba(ctx,0.2,0.2,0.2, 1.0);
#endif

        ctx_rectangle (ctx,
                       client->x,
                       client->y - titlebar_height * 2,
                       client->width, titlebar_height);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_n, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_N);
        ctx_reset_path (ctx);

        ctx_rectangle (ctx,
                       client->x,
                       client->y + client->height - titlebar_height,
                       client->width, titlebar_height * 2);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_s, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_S);
        ctx_reset_path (ctx);

        ctx_rectangle (ctx,
                       client->x + client->width,
                       client->y - titlebar_height,
                       titlebar_height, client->height + titlebar_height);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_e, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_E);
        ctx_reset_path (ctx);

        ctx_rectangle (ctx,
                       client->x - titlebar_height,
                       client->y - titlebar_height,
                       titlebar_height, client->height + titlebar_height);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_w, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_W);
        ctx_reset_path (ctx); 

        ctx_rectangle (ctx,
                       client->x + client->width - titlebar_height,
                       client->y - titlebar_height * 2,
                       titlebar_height * 2, titlebar_height * 2);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_ne, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_NE);
        ctx_reset_path (ctx);

        ctx_rectangle (ctx,
                       client->x - titlebar_height,
                       client->y - titlebar_height * 2,
                       titlebar_height * 2, titlebar_height * 2);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_nw, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_NW);
        ctx_reset_path (ctx);

        ctx_rectangle (ctx,
                       client->x - titlebar_height,
                       client->y + client->height - titlebar_height,
                       titlebar_height * 2, titlebar_height * 2);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_sw, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_SW);
        ctx_reset_path (ctx);

        ctx_rectangle (ctx,
                       client->x + client->width - titlebar_height,
                       client->y + client->height - titlebar_height,
                       titlebar_height * 2, titlebar_height * 2);
        ctx_listen (ctx, CTX_DRAG, ctx_client_resize_se, client, NULL);
        ctx_listen_set_cursor (ctx, CTX_CURSOR_RESIZE_SE);
        ctx_reset_path (ctx);

      }

      }

      if (flags & CTX_CLIENT_TITLEBAR)
        ctx_client_titlebar_draw (ctx, client, client->x, client->y, client->width, titlebar_height);
    }
  }
  }
  return 0;
}
#endif

extern int _ctx_enable_hash_cache;

void vt_audio_task (VT *vt, int click);

int ctx_input_pending (Ctx *ctx, int timeout);
int ctx_clients_active (Ctx *ctx)
{
  if (ctx->events.active) return ctx->events.active->id;
  return -1;
}

int ctx_clients_need_redraw (Ctx *ctx)
{
  int changes = 0;
  int follow_mouse = focus_follows_mouse;
      CtxList *to_remove = NULL;
  ctx_clients_ensure_layout (ctx);

//  if (print_shape_cache_rate)
//    fprintf (stderr, "\r%f ", ctx_shape_cache_rate);

   CtxClient *client = find_active (ctx, ctx_pointer_x (ctx),
                                    ctx_pointer_y (ctx));

    // this should be osk - keyboard height dependent
// if (ctx_pointer_y (ctx) > ctx_height (ctx) * 0.5f)
//   client = NULL; 

   if (follow_mouse || //ctx_pointer_is_down (ctx, 0) ||
//#if CTX_MAX_DEVICES>1
//       ctx_pointer_is_down (ctx, 1) ||
//#endif
        (ctx->events.active==NULL))
   {
        if (client)
        {
          if (ctx->events.active != client)
          {
            ctx->events.active = client;
            if (follow_mouse == 0 ||
                (ctx_pointer_is_down (ctx, 0) 
#if CTX_MAX_DEVICES > 1
                 || ctx_pointer_is_down (ctx, 1)
#endif
                ))
            {
              //if (client != clients->data)
       #if 1
              if ((client->flags & CTX_CLIENT_MAXIMIZED)==0)
              {
                ctx_list_remove (&ctx->events.clients, client);
                ctx_list_append (&ctx->events.clients, client);
              }
#endif
            }
            changes ++;
          }
        }
   }

   for (CtxList *l = ctx_clients (ctx); l; l = l->next)
   {
     CtxClient *client = (CtxClient*)l->data;
     if (client->vt)
       {
         if (vt_is_done (client->vt))
         {
           if ((client->flags & CTX_CLIENT_KEEP_ALIVE))
           {
             client->flags = (CtxClientFlags)(client->flags | CTX_CLIENT_FINISHED);
           }
           else
           {
             ctx_list_prepend (&to_remove, client);
           }
         }
       }
   }
   while (to_remove)
   {
     changes++;
     ctx_client_remove (ctx, (CtxClient*)to_remove->data);
     ctx_list_remove (&to_remove, to_remove->data);
   }

   changes += ctx_clients_dirty_count (ctx);
   return changes != 0;
}
float ctx_avg_bytespeed = 0.0;

int ctx_clients_tab_to_id (Ctx *ctx, int tab_no)
{
  CtxList *clients = ctx_clients (ctx);
  int no = 0;
  for (CtxList *l = clients; l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if (flag_is_set(client->flags, CTX_CLIENT_MAXIMIZED))
    {
      if (no == tab_no)
        return client->id;
      no++;
    }
  }
  return -1;
}

CtxList *ctx_clients (Ctx *ctx)
{
  return ctx?ctx->events.clients:NULL;
}

#endif /* CTX_VT */

#if CTX_EVENTS
int ctx_clients_handle_events (Ctx *ctx)
{
  //int n_clients = ctx_list_length (clients);
#if CTX_VT
  int pending_data = 0;
  long time_start = ctx_ticks ();
  int sleep_time = 1000000/ctx_target_fps;
  pending_data += ctx_input_pending (ctx, sleep_time);

  CtxList *clients = ctx_clients (ctx);
  if (!clients)
    return pending_data != 0;
  ctx_fetched_bytes = 0;
  if (pending_data)
  {
    if (!pending_data)pending_data = 1;
    /* record amount of time spent - and adjust time of reading for
     * vts?
     */
    //long int fractional_sleep = sleep_time / pending_data;
    long int fractional_sleep = sleep_time * 0.75;
    for (CtxList *l = clients; l; l = l->next)
    {
      CtxClient *client = (CtxClient*)l->data;
      ctx_client_lock (client);
      int found = 0;
      for (CtxList *l2 = clients; l2; l2 = l2->next)
        if (l2->data == client) found = 1;
      if (!found)
        goto done; // XXX : skipping unlock?
      
      ctx_fetched_bytes += vt_poll (client->vt, fractional_sleep);
      //ctx_fetched_bytes += vt_poll (client->vt, sleep_time); //fractional_sleep);
      ctx_client_unlock (client);
    }
done:
    if(0){
    }
  }
  else
  {
#if CTX_AUDIO
    for (CtxList *l = clients; l; l = l->next)
    {
      CtxClient *client = (CtxClient*)l->data;
      vt_audio_task (client->vt, 0);
    }
#endif
  }

  //int got_events = 0;

  //while (ctx_get_event (ctx)) { }
#if 0
  if (changes /*|| pending_data */)
  {
    ctx_target_fps *= 1.6;
    if (ctx_target_fps > 60) ctx_target_fps = 60;
  }
  else
  {
    ctx_target_fps = ctx_target_fps * 0.95 + 30.0 * 0.05;

    // 20fps is the lowest where sun 8bit ulaw 8khz works reliably
  }

  if (ctx_avg_bytespeed > 1024 * 1024) ctx_target_fps = 10.0;

  if (_ctx_green < 0.4)
    ctx_target_fps = 120.0;
  else if (_ctx_green > 0.6)
    ctx_target_fps = 25.0;

  //ctx_target_fps = 30.0;
#else
  ctx_target_fps = 100.0; // need to be higher than vsync rate to hit vsync
#endif

  long time_end = ctx_ticks ();

  int timed = (time_end-time_start);
  float bytespeed = ctx_fetched_bytes / ((timed)/ (1000.0f * 1000.0f));

  ctx_avg_bytespeed = bytespeed * 0.2 + ctx_avg_bytespeed * 0.8;
#if 0
  static int frame_no = 0;
  frame_no++;
  if (frame_no % 100 == 0)
  fprintf (stderr, "%.2fmb/s %i/%i  %.2f                    \r", ctx_avg_bytespeed/1024/1024, ctx_fetched_bytes, timed, ctx_target_fps);
#endif

#endif
  return 0;
}
#endif

void ctx_client_rev_inc (CtxClient *client)
{
  if (client) client->rev++;
}
long ctx_client_rev (CtxClient *client)
{
  return client?client->rev:0;
}

void
ctx_client_feed_keystring (CtxClient *client, CtxEvent *event, const char *str)
{
#if CTX_VT
  if (!client || !client->vt) return;
  vt_feed_keystring (client->vt, event, str);
#endif
}

#if CTX_VT
int ctx_client_id (CtxClient *client)
{
  return client?client->id:-1;
}

VT *ctx_client_vt (CtxClient *client)
{
  return client?client->vt:NULL;
}

void ctx_client_add_event (CtxClient *client, CtxEvent *event)
{
  ctx_list_append (&client->ctx_events, ctx_event_copy (event));
}

void ctx_client_quit (CtxClient *client)
{
   if (!client) return;
  client->do_quit = 1;
}

int ctx_client_flags (CtxClient *client)
{
  return client?client->flags:0;
}

void *ctx_client_userdata (CtxClient *client)
{
  return client?client->user_data:NULL;
}

const char *ctx_client_title (CtxClient *client)
{
  return client?client->title:NULL;
}

CtxClient *ctx_client_find (Ctx *ctx, const char *label)
{
  for (CtxList *l = ctx_clients (ctx); l; l = l->next)
  {
    CtxClient *client = (CtxClient*)l->data;
    if (client->user_data && !strcmp ((char*)client->user_data, label))
    {
      return client;
    }
  }
  return NULL;
}

#endif

#if 0
#include "local.conf"
#include "ctx.h"
SQZ_ui
#endif

#if CTX_CSS
//#include "squoze/squoze.h"

//#include "static.inc"

//#include "itk.h"   // for completeness, itk wants to be built in the ctx
                   // compilation unit to be influenced by the ctx config



#define CTX_MAX_STYLE_DEPTH  CTX_MAX_STATES
#define CTX_MAX_STATE_DEPTH  CTX_MAX_STATES

#if 0
#define CTX_MAX_FLOATS           16
#define CTX_MAX_SELECTOR_LENGTH  64
#define CTX_MAX_CSS_STRINGLEN    512
#define CTX_MAX_CSS_RULELEN      32 
#define CTX_MAX_CSS_RULES        128

/* other important maximums */
#define CTX_MAX_TEXT_LISTEN      256
#define CTX_XML_INBUF_SIZE       1024
#else

#define CTX_MAX_FLOATS           8
#define CTX_MAX_SELECTOR_LENGTH  64
#define CTX_MAX_CSS_STRINGLEN    256
#define CTX_MAX_CSS_RULELEN      32
#define CTX_MAX_CSS_RULES        64

/* other important maximums */
#define CTX_MAX_TEXT_LISTEN      16
#define CTX_XML_INBUF_SIZE       256 
#endif

#define PROP(a)          (ctx_get_float(mrg->ctx, SQZ_##a))
#define PROPS(a)         (ctx_get_string(mrg->ctx, SQZ_##a))
#define SET_PROPh(a,v)   (ctx_set_float(mrg->ctx, a, v))
#define SET_PROP(a,v)    SET_PROPh(SQZ_##a, v)
#define SET_PROPS(a,v)   (ctx_set_string(mrg->ctx, SQZ_##a, v))
#define SET_PROPSh(a,v)  (ctx_set_string(mrg->ctx, a, v))

#define SQZ_1      374u
#define SQZ_Aelig  2540544426u
#define SQZ_AElig  2622343083u
#define SQZ_Aring  3473872814u
#define SQZ_Oslash 3911734189u

/*
 *  extra hashed strings to be picked up
 *
 *  SQZ_id  SQZ_class  SQZ_d SQZ_rel    SQZ_viewbox
 *
 */

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif


/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

#include <string.h>
#include <math.h>

typedef struct _Css          Css;


void mrg_clear (Css *mrg);

static void mrg_queue_draw (Css *mrg, CtxIntRectangle *rect)
{
}

typedef struct _CtxStyleNode CtxStyleNode;

#define CTX_STYLE_MAX_CLASSES 8
#define CTX_STYLE_MAX_PSEUDO  8

struct _CtxStyleNode
{
  uint32_t    element_hash;
  uint32_t    classes_hash[CTX_STYLE_MAX_CLASSES];
  uint32_t    id_hash;
  const char *pseudo[CTX_STYLE_MAX_PSEUDO];
  uint32_t    pseudo_hash[CTX_STYLE_MAX_PSEUDO];
              // TODO : to hash pseudos we need to store
              //   argument (like for nth-child)
  int         direct_descendant; /* for use in selector chains with > */
  const char *id;
};
 
typedef enum {
  CTX_FLOAT_NONE = 0,
  CTX_FLOAT_LEFT,
  CTX_FLOAT_RIGHT,
  CTX_FLOAT_FIXED
} CtxFloat;


typedef struct CtxFloatData {
  CtxFloat  type;
  float     x;
  float     y;
  float     width;
  float     height;
} CtxFloatData;

typedef void (*CssNewText)       (const char *new_text, void *data);
typedef void (*UiRenderFun)      (Css *mrg, void *ui_data);

typedef struct _Css Css;

typedef enum {
  CTX_DISPLAY_INLINE = 0,
  CTX_DISPLAY_BLOCK,
  CTX_DISPLAY_LIST_ITEM,
  CTX_DISPLAY_NONE,
  CTX_DISPLAY_INLINE_BLOCK,
  CTX_DISPLAY_FLOW_ROOT,
  CTX_DISPLAY_FLEX,
  CTX_DISPLAY_GRID,
  CTX_DISPLAY_INLINE_FLEX,
  CTX_DISPLAY_INLINE_GRID,
  CTX_DISPLAY_INLINE_TABLE,
  CTX_DISPLAY_RUN_IN,
  CTX_DISPLAY_TABLE,
  CTX_DISPLAY_TABLE_CAPTION,
  CTX_DISPLAY_TABLE_COLUMN_GROUP,
  CTX_DISPLAY_TABLE_HEADER_GROUP,
  CTX_DISPLAY_TABLE_FOOTER_GROUP,
  CTX_DISPLAY_TABLE_ROW_GROUP,
  CTX_DISPLAY_TABLE_CELL,
  CTX_DISPLAY_TABLE_COLUMN
} CtxDisplay;

/* matches cairo order */
typedef enum
{
  CTX_FONT_WEIGHT_NORMAL = 0,
  CTX_FONT_WEIGHT_BOLD
} CtxFontWeight;

/* matches cairo order */
typedef enum
{
  CTX_FONT_STYLE_NORMAL = 0,
  CTX_FONT_STYLE_ITALIC,
  CTX_FONT_STYLE_OBLIQUE
} CtxFontStyle;

typedef enum
{
  CTX_BOX_SIZING_CONTENT_BOX = 0,
  CTX_BOX_SIZING_BORDER_BOX
} CtxBoxSizing;

/* matching nchanterm definitions */

typedef enum {
  CTX_TEXT_DECORATION_REGULAR     = 0,
  CTX_TEXT_DECORATION_BOLD        = (1 << 0),
  CTX_TEXT_DECORATION_DIM         = (1 << 1),
  CTX_TEXT_DECORATION_UNDERLINE   = (1 << 2),
  CTX_TEXT_DECORATION_REVERSE     = (1 << 3),
  CTX_TEXT_DECORATION_OVERLINE    = (1 << 4),
  CTX_TEXT_DECORATION_LINETHROUGH = (1 << 5),
  CTX_TEXT_DECORATION_BLINK       = (1 << 6)
} CtxTextDecoration;

typedef enum {
  CTX_POSITION_STATIC = 0,
  CTX_POSITION_RELATIVE,
  CTX_POSITION_FIXED,
  CTX_POSITION_ABSOLUTE
} CtxPosition;

typedef enum {
  CTX_OVERFLOW_VISIBLE = 0,
  CTX_OVERFLOW_HIDDEN,
  CTX_OVERFLOW_SCROLL,
  CTX_OVERFLOW_AUTO
} CtxOverflow;

typedef enum {
  CTX_CLEAR_NONE = 0,
  CTX_CLEAR_LEFT,  // 1
  CTX_CLEAR_RIGHT, // 2
  CTX_CLEAR_BOTH   // 3   ( LEFT | RIGHT )
} CtxClear;


typedef enum {
  CTX_WHITE_SPACE_NORMAL = 0,
  CTX_WHITE_SPACE_NOWRAP,
  CTX_WHITE_SPACE_PRE,
  CTX_WHITE_SPACE_PRE_LINE,
  CTX_WHITE_SPACE_PRE_WRAP
} CtxWhiteSpace;

typedef enum {
  CTX_VERTICAL_ALIGN_BASELINE = 0,
  CTX_VERTICAL_ALIGN_MIDDLE,
  CTX_VERTICAL_ALIGN_BOTTOM,
  CTX_VERTICAL_ALIGN_TOP,
  CTX_VERTICAL_ALIGN_SUB,
  CTX_VERTICAL_ALIGN_SUPER
} CtxVerticalAlign;

typedef enum {
  MRG_CURSOR_AUTO = 0,
  MRG_CURSOR_ALIAS,
  MRG_CURSOR_ALL_SCROLL,
  MRG_CURSOR_CELL,
  MRG_CURSOR_CONTEXT_MENU,
  MRG_CURSOR_COL_RESIZE,
  MRG_CURSOR_COPY,
  MRG_CURSOR_CROSSHAIR,
  MRG_CURSOR_DEFAULT,
  MRG_CURSOR_E_RESIZE,
  MRG_CURSOR_EW_RESIZE,
  MRG_CURSOR_HELP,
  MRG_CURSOR_MOVE,
  MRG_CURSOR_N_RESIZE,
  MRG_CURSOR_NE_RESIZE,
  MRG_CURSOR_NESW_RESIZE,
  MRG_CURSOR_NS_RESIZE,
  MRG_CURSOR_NW_RESIZE,
  MRG_CURSOR_NO_DROP,
  MRG_CURSOR_NONE,
  MRG_CURSOR_NOT_ALLOWED,
  MRG_CURSOR_POINTER,
  MRG_CURSOR_PROGRESS,
  MRG_CURSOR_ROW_RESIZE,
  MRG_CURSOR_S_RESIZE,
  MRG_CURSOR_SE_RESIZE,
  MRG_CURSOR_SW_RESIZE,
  MRG_CURSOR_TEXT,
  MRG_CURSOR_VERTICAL_TEXT,
  MRG_CURSOR_W_RESIZE,
  MRG_CURSOR_WAIT,
  MRG_CURSOR_ZOOM_IN,
  MRG_CURSOR_ZOOM_OUT
} CssCursor;


typedef enum {
  CTX_UNICODE_BIDI_NORMAL = 0,
  CTX_UNICODE_BIDI_EMBED,
  CTX_UNICODE_BIDI_BIDI_OVERRIDE
} CtxUnicodeBidi;

typedef enum {
  CTX_VISIBILITY_VISIBLE = 0,
  CTX_VISIBILITY_HIDDEN
} CtxVisibility;

typedef enum {
  CTX_LIST_STYLE_OUTSIDE = 0,
  CTX_LIST_STYLE_INSIDE
} CtxListStyle;

/* This style class should be able to grow to contain some color names with
 * semantic meaning.
 */
struct _CtxStyle {
  /* text-related, we could potentially store *all* variables in keydb
   * that would both be slower and more bloatful than tightly packed bits,
   * some things currently in keydb should maybe be moved out for
   * performance.
   */
  float               font_size; // used for mrg_em() should be direct
  float               line_height;
  CtxVisibility       visibility:1;
  CtxFillRule         fill_rule:1;
  CtxFontStyle        font_style:3;
  CtxFontWeight       font_weight:4;
  CtxLineCap          stroke_linecap:2;
  CtxLineJoin         stroke_linejoin:2;
  CtxTextAlign        text_align:3;
  CtxPosition         position:2;
  CtxBoxSizing        box_sizing:1;
  CtxVerticalAlign    vertical_align:3;
  CtxWhiteSpace       white_space:3;
  CtxUnicodeBidi      unicode_bidi:2;
  CtxTextDirection    direction:2;
  CtxListStyle        list_style:1;
  CtxClear            clear:2;
  unsigned char       fill:1;
  CssCursor           cursor:6;
  CtxTextDecoration   text_decoration:7;
  unsigned char       width_auto:1;
  unsigned char       margin_left_auto:1;
  unsigned char       margin_right_auto:1;
  unsigned char       print_symbols:1;
  CtxFloat            float_:2;
  unsigned char       stroke:1;
  CtxOverflow         overflow:2;
  CtxDisplay          display:5;
  void               *id_ptr;
  int                 z_index;
};

typedef struct _CtxStyle CtxStyle;

typedef struct CssState {
  CtxStyleNode style_node;

  float        original_x;
  float        original_y;
  float        block_start_x;
  float        block_start_y;
  float        ptly;
  float        vmarg;
  int          flow_root; // is
  int          float_base;

  float      (*wrap_edge_left)  (Css *mrg, void *data);
  float      (*wrap_edge_right) (Css *mrg, void *data);
  void        *wrap_edge_data;
  float        edge_top;
  float        edge_left;
  float        edge_right;
  float        edge_bottom;

  int          skip_lines;  /* better with an em offset? */
  int          max_lines;   /* better with max-y in ems? ? */

  char        *style_id;
  CtxStyle     style;

  int          children;
  unsigned int overflowed:1;
  unsigned int span_bg_started:1;

  int          drawlist_start_offset;
} CssState;

typedef struct _CssAbsolute CssAbsolute;

struct _CssAbsolute {
  int       z_index;
  int       fixed;
  float     top;
  float     left;
  float     relative_x;
  float     relative_y;
  CtxEntry *entries;
  int       count; 
};


struct _Css {
  Ctx             *ctx;
  Ctx            *document_ctx;
  Ctx            *fixed_ctx;
  Ctx            *absolute_ctx;
  float            rem;
  float            ddpx;
  int              in_svg;
  CtxList         *absolutes;
  CtxList         *stylesheet;
  void            *css_parse_state;
  CtxString       *style;
  CtxString       *style_global;
  int              quit;
  float            x; /* in px */
  float            y; /* in px */
  float            relative_x;
  float            relative_y;
  CtxIntRectangle     dirty;
  CtxIntRectangle     dirty_during_paint; // queued during painting
  CssState        *state;
  CssState         states[CTX_MAX_STATE_DEPTH];
  int              state_no;
  void            *backend_data;
  int              do_clip;
  int (*mrg_get_contents) (const char  *referer,
                           const char  *input_uri,
                           char       **contents,
                           long        *length,
                           void        *get_contents_data);
  void *get_contents_data;

  CtxFloatData float_data[CTX_MAX_FLOATS];
  int          floats;

    /** text editing state follows **/
  int              text_edited;
  int              got_edit;
  CtxString       *edited_str;
  char           **edited;

  int              text_edit_blocked;
  CssNewText       update_string;
  void            *update_string_user_data;

  CtxDestroyNotify update_string_destroy_notify;
  void            *update_string_destroy_data;

  int              cursor_pos;
  float            e_x;
  float            e_y;
  float            e_ws;
  float            e_we;
  float            e_em;

  CtxEventType     text_listen_types[CTX_MAX_TEXT_LISTEN];
  CtxCb            text_listen_cb[CTX_MAX_TEXT_LISTEN];
  void            *text_listen_data1[CTX_MAX_TEXT_LISTEN];
  void            *text_listen_data2[CTX_MAX_TEXT_LISTEN];

  void     (*text_listen_finalize[CTX_MAX_TEXT_LISTEN])(void *listen_data, void *listen_data2, void *finalize_data);
  void      *text_listen_finalize_data[CTX_MAX_TEXT_LISTEN];
  int        text_listen_count;
  int        text_listen_active;

  int        line_level; // nesting level for active-line 
                         //
  float      line_max_height[CTX_MAX_STATES];
  int        line_got_baseline[CTX_MAX_STATES]; // whether the current mrg position of
                                                // baseline is correctly configured
                                                // for relative drawing.
                                                //
                                                // XXX refactor into a bitfield
  ////////////////////////////////////////////////
  ////////////////////////////////////////////////
  //////////////////// end of css ////////////////

  // the following used to be the original Css struct

  int (*ui_fun)(Css *itk, void *data);
  void *ui_data;

  // the following should be removed in favor
  // of the css|mrg data?
  float edge_left;
  float edge_top;
  float edge_right;
  float edge_bottom;
  float width;
  float height;

  float font_size;
  float rel_hmargin;
  float rel_vmargin;
  float label_width;

  float scale;

  float rel_ver_advance;
  float rel_hpad;
  float rel_vgap;
  float scroll_speed;

  int   return_value; // when set to 1, we return the internally held from the
                      // defining app state when the widget was drawn/intercations
                      // started.

  float slider_value; // for reporting back slider value

  int   active;  // 0 not actively editing
                 // 1 currently in edit-mode of focused widget
                 // 2 means return edited value

  int   active_entry;
  int   focus_wraparound;

  int   focus_no;
  int   focus_x;
  int   focus_y;
  int   focus_width;
  char *focus_label;

  char *entry_copy;
  int   entry_pos;
  CssPanel *panel;
  char *uri_base;

  CtxList *old_controls;
  CtxList *controls;
  CtxList *choices;
  CtxList *panels;
  int hovered_no;
  int control_no;
  int choice_active;

  int choice_no;  // the currenlt active choice if the choice context is visible (or the current control is a choice)

  int popup_x;
  int popup_y;
  int popup_width;
  int popup_height;

  char *active_menu_path;
  char *menu_path;

  uint64_t next_flags;
  void    *next_id; // to pre-empt a control and get it a more unique
                 // identifier than the numeric pos
  int   line_no;
  int   lines_drawn;
  int   light_mode;


////////////////////////////////

  int   in_choices;

  int   unresolved_line;

};

float css_panel_scroll (Css *itk);

static Ctx *mrg_ctx (Css *mrg)
{
  return mrg->ctx;
}


/* XXX: stopping sibling grabs should be an addtion to stop propagation,
 * this would permit multiple events to co-register, and use that
 * to signal each other,.. or perhaps more coordination is needed
 */
void _mrg_clear_text_closures (Css *mrg)
{
  int i;
  for (i = 0; i < mrg->text_listen_count; i ++)
  {
    if (mrg->text_listen_finalize[i])
       mrg->text_listen_finalize[i](
         mrg->text_listen_data1[i],
         mrg->text_listen_data2[i],
         mrg->text_listen_finalize_data[i]);
  }
  mrg->text_listen_count  = 0;
  mrg->text_listen_active = 0;
}

static CtxList *interns = NULL;

const char * mrg_intern_string (const char *str)
{
  CtxList *i;
  for (i = interns; i; i = i->next)
  {
    if (!strcmp ((char*)i->data, str))
      return (char*)i->data;
  }
  str = strdup (str);
  ctx_list_append (&interns, (void*)str);
  return str;
}

int
mrg_get_contents (Css         *mrg,
                  const char  *referer,
                  const char  *input_uri,
                  char       **contents,
                  long        *length);

/*
 * Copyright (c) 2002, 2003, Øyvind Kolås <pippin@hodefoting.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 */

#if 0
void _ctX_bindings_key_down (CtxEvent *event, void *data1, void *data2)
{
  Ctx *ctx = event->ctx;
  CtxEvents *mrg = &ctx->events;
  int i;
  int handled = 0;

  for (i = mrg->n_bindings-1; i>=0; i--)
    if (!strcmp (mrg->bindings[i].nick, event->string))
    {
      if (mrg->bindings[i].cb)
      {
        mrg->bindings[i].cb (event, mrg->bindings[i].cb_data, NULL);
        if (event->stop_propagate)
          return;
        handled = 1;
      }
    }
  if (!handled)
  for (i = mrg->n_bindings-1; i>=0; i--)
    if (!strcmp (mrg->bindings[i].nick, "any"))
    {
      if (mrg->bindings[i].cb)
      {
        mrg->bindings[i].cb (event, mrg->bindings[i].cb_data, NULL);
        if (event->stop_propagate)
          return;
      }
    }
}
#endif

#ifndef XMLTOK_H
#define XMLTOK_H

#include <stdio.h>

typedef struct _Css    Css;
typedef struct _CssXml CssXml;

enum
{
  t_none = 0,
  t_whitespace,
  t_prolog,
  t_dtd,
  t_comment,
  t_word,
  t_tag,
  t_closetag,
  t_closeemptytag,
  t_endtag,
  t_att = 10,
  t_val,
  t_eof,
  t_entity,
  t_error
};

CssXml *xmltok_new     (FILE *file_in);
CssXml *xmltok_buf_new (char *membuf);
void    xmltok_free    (CssXml *t);
int     xmltok_lineno  (CssXml *t);
int     xmltok_get     (CssXml *t, char **data, int *pos);

#endif /*XMLTOK_H */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>


/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */


/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct _CssXml
{
  FILE      *file_in;
  int        state;
  CtxString *curdata;
  CtxString *curtag;
  int        c;
  int        c_held;

  unsigned char *inbuf;
  int            inbuflen;
  int            inbufpos;
  int            line_no;
};

enum
{
  s_null = 0,
  s_start,
  s_tag,
  s_tagnamestart,
  s_tagname,
  s_tagnamedone,
  s_intag,
  s_attstart,
  s_attname,
  s_attdone,
  s_att,
  s_atteq,
  s_eqquot,
  s_eqvalstart,
  s_eqapos,
  s_eqaposval,
  s_eqaposvaldone,
  s_eqval,
  s_eqvaldone,
  s_eqquotval,
  s_eqquotvaldone,
  s_tagend,
  s_empty,
  s_inempty,
  s_emptyend,
  s_whitespace,
  s_whitespacedone,
  s_entitystart,
  s_entity,
  s_entitydone,
  s_word,
  s_worddone,
  s_tagclose,
  s_tagclosenamestart,
  s_tagclosename,
  s_tagclosedone,
  s_tagexcl,
  s_commentdash1,
  s_commentdash2,
  s_incomment,
  s_commentenddash1,
  s_commentenddash2,
  s_commentdone,
  s_dtd,
  s_prolog,
  s_prologq,
  s_prologdone,
  s_eof,
  s_error
};

const char     *c_ws = " \n\r\t";

enum
{
  c_nil = 0,
  c_eat = 1,                    /* request that another char be used for the next state */
  c_store = 2                   /* store the current char in the output buffer */
};


typedef struct
{
  int           state;
  char         *chars;
  unsigned char r_start;
  unsigned char r_end;
  int           next_state;
  int           resetbuf;
  int           charhandling;
  int           return_type;        /* if set return current buf, with type set to the type */
}
state_entry;

#define max_entries 20

static state_entry state_table[s_error][max_entries];

static void
a (int state,
   const char *chars,
   unsigned char r_start,
   unsigned char r_end, int charhandling, int next_state)
{
  int       no = 0;
  while (state_table[state][no].state != s_null)
    no++;
  state_table[state][no].state = state;
  state_table[state][no].r_start = r_start;
  if (chars)
    state_table[state][no].chars = (char*)chars;
  state_table[state][no].r_end = r_end;
  state_table[state][no].charhandling = charhandling;
  state_table[state][no].next_state = next_state;
}

static void
r (int state, int return_type, int next_state)
{
  state_table[state][0].state = state;
  state_table[state][0].return_type = return_type;
  state_table[state][0].next_state = next_state;
}

/* *INDENT-OFF* */

static void
init_statetable (void) {
    static int inited=0;
    if(inited)
        return;
    inited=1;
    memset(state_table,0,sizeof(state_table));
    a(s_start,        "<",  0,0,              c_eat,            s_tag);
    a(s_start,        c_ws, 0,0,              c_eat+c_store,    s_whitespace);
    a(s_start,        "&",  0,0,              c_eat,            s_entitystart);
    a(s_start,        NULL, 0,255,            c_eat+c_store,    s_word);
    a(s_tag,          c_ws, 0,0,              c_eat,            s_tag);
    a(s_tag,          "/",  0,0,              c_eat,            s_tagclose);
    a(s_tag,          "!",  0,0,              c_eat,            s_tagexcl);
    a(s_tag,          "?",  0,0,              c_eat,            s_prolog);
    a(s_tag,          NULL, 0,255,            c_eat+c_store,    s_tagnamestart);
    a(s_tagclose,     NULL, 0,255,         c_eat+c_store,    s_tagclosenamestart);
    a(s_tagclosenamestart,    ">",    0,0,    c_eat,            s_tagclosedone);
    a(s_tagclosenamestart,    NULL,    0,255, c_eat+c_store,    s_tagclosename);
    a(s_tagclosename,    ">",    0,0,         c_eat,            s_tagclosedone);
    a(s_tagclosename,    NULL,    0,255,      c_eat+c_store,    s_tagclosename);
    r(s_tagclosedone,    t_closetag,                            s_start);

    a(s_whitespace,        c_ws,    0,0,      c_eat+c_store,    s_whitespace);
    a(s_whitespace,        NULL,    0,255,    c_nil,            s_whitespacedone);
    r(s_whitespacedone,    t_whitespace,                        s_start);

    a(s_entitystart,";",    0,0,              c_eat,            s_entitydone);
    a(s_entitystart,NULL,    0,255,           c_eat+c_store,    s_entity);
    a(s_entity,        ";",    0,0,           c_eat,            s_entitydone);
    a(s_entity,NULL,        0,255,            c_eat+c_store,    s_entity);
    r(s_entitydone,    t_entity,                                s_start);

    a(s_word,        c_ws,    0,0,            c_nil,            s_worddone);
    a(s_word,        "<&",    0,0,            c_nil,            s_worddone);
    a(s_word,        NULL,    0,255,          c_eat+c_store,    s_word);
    r(s_worddone,    t_word,                                    s_start);

    a(s_tagnamestart,c_ws,    0,0,            c_nil,            s_tagnamedone);
    a(s_tagnamestart,    "/>",    0,0,        c_nil,            s_tagnamedone);
    a(s_tagnamestart,NULL,    0,255,          c_eat+c_store,    s_tagname);
    a(s_tagname,    c_ws,    0,0,             c_nil,            s_tagnamedone);
    a(s_tagname,    "/>",    0,0,             c_nil,            s_tagnamedone);
    a(s_tagname,    NULL,    0,255,           c_eat+c_store,    s_tagname);
    r(s_tagnamedone,    t_tag,                                s_intag);

    a(s_intag,        c_ws,    0,0,           c_eat,            s_intag);
    a(s_intag,        ">",    0,0,            c_eat,            s_tagend);
    a(s_intag,        "/",    0,0,            c_eat,            s_empty);
    a(s_intag,        NULL,    0,255,         c_eat+c_store,    s_attstart);

    a(s_attstart,    c_ws,    0,0,            c_eat,            s_attdone);
    a(s_attstart,    "=/>",    0,0,           c_nil,            s_attdone);
    a(s_attstart,    NULL,    0,255,          c_eat+c_store,    s_attname);
    a(s_attname,    "=/>",    0,0,            c_nil,            s_attdone);
    a(s_attname,    c_ws,    0,0,             c_eat,            s_attdone);
    a(s_attname,    NULL,    0,255,           c_eat+c_store,    s_attname);
    r(s_attdone,    t_att,                                    s_att);
    a(s_att,        c_ws,    0,0,             c_eat,            s_att);
    a(s_att,        "=",    0,0,              c_eat,            s_atteq);
    a(s_att,        NULL,    0,255,           c_eat,            s_intag);
    a(s_atteq,        "'",    0,0,            c_eat,            s_eqapos);
    a(s_atteq,        "\"",    0,0,           c_eat,            s_eqquot);
    a(s_atteq,        c_ws,    0,0,           c_eat,            s_atteq);
    a(s_atteq,        NULL,    0,255,         c_nil,            s_eqval);

    a(s_eqapos,        "'",    0,0,           c_eat,            s_eqaposvaldone);
    a(s_eqapos,        NULL,    0,255,        c_eat+c_store,    s_eqaposval);
    a(s_eqaposval,        "'",    0,0,        c_eat,            s_eqaposvaldone);
    a(s_eqaposval,        NULL,    0,255,     c_eat+c_store,    s_eqaposval);
    r(s_eqaposvaldone,    t_val,                                    s_intag);

    a(s_eqquot,        "\"",    0,0,          c_eat,            s_eqquotvaldone);
    a(s_eqquot,        NULL,    0,255,        c_eat+c_store,    s_eqquotval);
    a(s_eqquotval,     "\"",    0,0,          c_eat,            s_eqquotvaldone);
    a(s_eqquotval,     NULL,    0,255,        c_eat+c_store,    s_eqquotval);
    r(s_eqquotvaldone, t_val,                                    s_intag);

    a(s_eqval,        c_ws,    0,0,          c_nil,            s_eqvaldone);
    a(s_eqval,        "/>",    0,0,          c_nil,            s_eqvaldone);
    a(s_eqval,        NULL,    0,255,        c_eat+c_store,    s_eqval);

    r(s_eqvaldone,    t_val,                 s_intag);

    r(s_tagend,       t_endtag,              s_start);

    r(s_empty,          t_endtag,                               s_inempty);
    a(s_inempty,        ">",0,0,             c_eat,            s_emptyend);
    a(s_inempty,        NULL,0,255,          c_eat,            s_inempty);
    r(s_emptyend,    t_closeemptytag,        s_start);

    a(s_prolog,        "?",0,0,              c_eat,            s_prologq);
    a(s_prolog,        NULL,0,255,           c_eat+c_store,    s_prolog);

    a(s_prologq,    ">",0,0,                 c_eat,            s_prologdone);
    a(s_prologq,    NULL,0,255,              c_eat+c_store,    s_prolog);
    r(s_prologdone,    t_prolog,             s_start);

    a(s_tagexcl,    "-",0,0,                 c_eat,            s_commentdash1);
    a(s_tagexcl,    "D",0,0,                 c_nil,            s_dtd);
    a(s_tagexcl,    NULL,0,255,              c_eat,            s_start);

    a(s_commentdash1,    "-",0,0,            c_eat,            s_commentdash2);
    a(s_commentdash1,    NULL,0,255,         c_eat,            s_error);

    a(s_commentdash2,    "-",0,0,            c_eat,            s_commentenddash1);
    a(s_commentdash2,    NULL,0,255,         c_eat+c_store,    s_incomment);

    a(s_incomment,       "-",0,0,            c_eat,            s_commentenddash1);
    a(s_incomment,       NULL,0,255,         c_eat+c_store,    s_incomment);

    a(s_commentenddash1, "-",0,0,            c_eat,            s_commentenddash2);
    a(s_commentenddash1, NULL,0,255,         c_eat+c_store,    s_incomment);

    a(s_commentenddash2, ">",0,0,            c_eat,            s_commentdone);
    a(s_commentenddash2, NULL,0,255,         c_eat+c_store,    s_incomment);

    r(s_commentdone,     t_comment,          s_start);

}

/* *INDENT-ON* */

static int
is_oneof (char c, char *chars)
{
  while (*chars)
    {
      if (c == *chars)
        return 1;
      chars++;
    }
  return 0;
}

static int
nextchar (CssXml *t)
{
  int       ret;

  if (t->file_in)
    {
      if (t->inbufpos >= t->inbuflen)
        {
          t->inbuflen = fread (t->inbuf, 1, CTX_XML_INBUF_SIZE, t->file_in);
          t->inbufpos = 0;
          if (!t->inbuflen)
            return -1;
        }

      ret = (int) t->inbuf[t->inbufpos++];

      if (ret == '\n')
        t->line_no++;
    }
  else
    {
      if (t->inbufpos >= t->inbuflen)
        {
          return -1;
        }
      ret = (int) t->inbuf[t->inbufpos++];
      if (ret == '\n')
        t->line_no++;
    }
  return ret;
}

int
xmltok_get (CssXml *t, char **data, int *pos)
{
  state_entry *s;

  init_statetable ();
  ctx_string_clear (t->curdata);
  while (t->state != s_error && t->state != s_eof)
    {
      if (!t->c_held)
        {
          t->c = nextchar (t);
          if (t->c == -1)
          {
            if (pos)*pos = t->inbufpos;
            return t_eof;
          }
          t->c_held = 1;
        }
      if (t->state == s_dtd)
        {     /* FIXME: should make better code for skipping DTD */

          /*            int angle = 0; */
          int       squote = 0;
          int       dquote = 0;
          int       abracket = 1;

          /*            int sbracket = 0; */

          ctx_string_append_byte (t->curdata, t->c);

          while (abracket)
            {
              switch (t->c = nextchar (t))
                {
                case -1:
                  return t_eof;
                case '<':
                  if ((!squote) && (!dquote))
                    abracket++;
                  ctx_string_append_byte (t->curdata, t->c);
                  break;
                case '>':
                  if ((!squote) && (!dquote))
                    abracket--;
                  if (abracket)
                    ctx_string_append_byte (t->curdata, t->c);
                  break;
                case '"':
                case '\'':
                case '[':
                case ']':
                default:
                  ctx_string_append_byte (t->curdata, t->c);
                  break;
                }
            }
          t->c_held = 0;
          t->state = s_start;

          if (pos)*pos = t->inbufpos;
          return t_dtd;
        }
      s = &state_table[t->state][0];
      while (s->state && s->state != s_error && s->state != s_eof)
        {
          if (s->return_type != t_none)
            {
              *data = (char *) ctx_string_get (t->curdata);
              t->state = s->next_state;
              if (s->return_type == t_tag)
                ctx_string_set (t->curtag, ctx_string_get (t->curdata));
              if (s->return_type == t_endtag)
                *data = (char *) ctx_string_get (t->curtag);
              if (s->return_type == t_closeemptytag)
                *data = (char *) ctx_string_get (t->curtag);
              if (pos)
                *pos = t->inbufpos;
              return s->return_type;
            }
          if ((s->chars && is_oneof (t->c, s->chars))
              || ((s->r_start + s->r_end)
                  && (t->c >= s->r_start && t->c <= s->r_end)))
            {
              if (s->charhandling & c_store)
                {
                  ctx_string_append_byte (t->curdata, t->c);
                }
              if (s->charhandling & c_eat)
                {
                  t->c_held = 0;
                }
              t->state = s->next_state;
              break;
            }
          s++;
        }
    }
  if (pos)
    *pos = t->inbufpos;
  //if (t->state == s_error)
  //  return t_eof;
  return t_eof;
}

CssXml *
xmltok_new (FILE * file_in)
{
  CssXml *ret;

  ret = (CssXml*)calloc (1, sizeof (CssXml));
  ret->file_in = file_in;
  ret->state = s_start;
  ret->curtag = ctx_string_new ("");
  ret->curdata = ctx_string_new ("");
  ret->inbuf = (uint8_t*) calloc (1, CTX_XML_INBUF_SIZE);
  return ret;
}

CssXml *
xmltok_buf_new (char *membuf)
{
  CssXml *ret;

  ret = (CssXml*)calloc (1, sizeof (CssXml));
  ret->file_in = NULL;
  ret->state = s_start;
  ret->curtag = ctx_string_new ("");
  ret->curdata = ctx_string_new ("");
  ret->inbuf = (uint8_t*)membuf;
  ret->inbuflen = strlen (membuf);
  ret->inbufpos = 0;
  return ret;
}

void
xmltok_free (CssXml *t)
{
  ctx_string_free (t->curtag, 1);
  ctx_string_free (t->curdata, 1);

  if (t->file_in)
    {
      /*        fclose (t->file_in); */
      free (t->inbuf);
    }
  free (t);
}

const char *empty_tags[] = {
  "img", "IMG", "br", "BR", "hr", "HR", "META", "meta", "link", "LINK",
  NULL
};

const char *endomission_tags[] = {
  "li", "LI", "p", "P", "td", "TD", "tr", "TR", NULL
};

int
xmltok_lineno (CssXml *t)
{
  return t->line_no;
}


void ctx_events_clear (Ctx *ctx)
{
  if (ctx_events_frozen (ctx))
    return;

  ctx_events_clear_items (ctx);
  //if (mrg->backend->mrg_clear)
  //  mrg->backend->mrg_clear (mrg);

  ctx_clear_bindings (ctx);
}

void mrg_clear (Css *mrg)
{
  ctx_events_clear (mrg->ctx);
  _mrg_clear_text_closures (mrg);
}

void css_set_edge_right (Css *mrg, float val);
void css_set_edge_left (Css *mrg, float val);
void css_set_edge_top (Css *mrg, float val);
void css_set_edge_bottom (Css *mrg, float val);
float mrg_edge_right (Css *mrg);
float mrg_edge_left (Css *mrg);
float mrg_y (Css *mrg);
float mrg_x (Css *mrg);

float mrg_em (Css *mrg);
void mrg_set_xy (Css *mrg, float x, float y);

static float _mrg_dynamic_edge_right2 (Css *mrg, CssState *state)
{
  float ret = mrg_edge_right (mrg);
  float y   = mrg_y (mrg);
  float em  = mrg_em (mrg);
  int i;

  if (mrg->floats)
    for (i = state->float_base; i < mrg->floats; i++)
    {
      CtxFloatData *f = &mrg->float_data[i];
      if (f->type == CTX_FLOAT_RIGHT &&
          y >= f->y  &&
          y - em < f->y + f->height &&

          f->x < ret)
          ret = f->x;
    }
  return ret;
}

static float _mrg_dynamic_edge_left2 (Css *mrg, CssState *state)
{
  float ret = mrg_edge_left (mrg);
  float y   = mrg_y (mrg);
  float em  = mrg_em (mrg);
  int i;

  if (mrg->floats)
    for (i = state->float_base; i < mrg->floats; i++)
    {
      CtxFloatData *f = &mrg->float_data[i];
      if (f->type == CTX_FLOAT_LEFT &&
          y >= f->y &&
          y - em < f->y + f->height &&
          f->x + f->width > ret)
          ret = f->x + f->width;
    }
  return ret;
}

static float _mrg_parent_dynamic_edge_left (Css *mrg)
{
  CssState *state = mrg->state;
  if (mrg->state_no)
    state = &mrg->states[mrg->state_no-1];
  return _mrg_dynamic_edge_left2 (mrg, state);
}

static float _mrg_parent_dynamic_edge_right (Css *mrg)
{
  CssState *state = mrg->state;
  if (mrg->state_no)
    state = &mrg->states[mrg->state_no-1];
  return _mrg_dynamic_edge_right2 (mrg, state);
}

static float _mrg_dynamic_edge_left (Css *mrg)
{
  if (mrg->state->wrap_edge_left)
    return mrg->state->wrap_edge_left (mrg, mrg->state->wrap_edge_data);
  return mrg->state->edge_left;
}
float mrg_width (Css *mrg)
{
  if (!mrg) return 640;
  return ctx_width (mrg->ctx) / mrg->ddpx;
}

float mrg_height (Css *mrg)
{
  if (!mrg) return 480;
  return ctx_height (mrg->ctx) / mrg->ddpx;
}

static float _mrg_dynamic_edge_right (Css *mrg)
{
  if (mrg->state->wrap_edge_right)
    return mrg->state->wrap_edge_right (mrg, mrg->state->wrap_edge_data);
  return mrg->state->edge_right;
}

static float wrap_edge_left (Css *mrg, void *data)
{
  CssState *state = mrg->state;
  return _mrg_dynamic_edge_left2 (mrg, state);
}

static float wrap_edge_right (Css *mrg, void *data)
{
  CssState *state = mrg->state;
  return _mrg_dynamic_edge_right2 (mrg, state);
}

static void clear_left (Css *mrg)
{
  float y = mrg_y (mrg);
  int i;

  if (mrg->floats)
  {
    for (i = mrg->state->float_base; i < mrg->floats; i++)
      {
        CtxFloatData *f = &mrg->float_data[i];
        {
          if (f->type == CTX_FLOAT_LEFT)
          {
            if (f->y + f->height > y)
              y = f->y + f->height;
          }
        }
      }
  }
  mrg_set_xy (mrg, mrg_x (mrg), y);
}

static void clear_right (Css *mrg)
{
  float y = mrg_y (mrg);
  int i;

  if (mrg->floats)
  {
    for (i = mrg->state->float_base; i < mrg->floats; i++)
      {
        CtxFloatData *f = &mrg->float_data[i];
        {
          if (f->type == CTX_FLOAT_RIGHT)
          {
            if (f->y + f->height > y)
              y = f->y + f->height;
          }
        }
      }
  }
  //fprintf (stderr, "%f}", y);
  mrg_set_xy (mrg, mrg_x (mrg), y);
}

/**
 * ctx_style:
 * @mrg the mrg-context
 *
 * Returns the currently 
 *
 */
CtxStyle *ctx_style (Css *mrg)
{
  return &mrg->state->style;
}

static void clear_both (Css *mrg)
{
#if 0
  clear_left (mrg);
  clear_right (mrg);
#else
  float y = mrg_y (mrg);
  int i;

  if (!mrg->state)return;
  if (mrg->floats)
  {
    for (i = mrg->state->float_base; i < mrg->floats; i++)
      {
        CtxFloatData *f = &mrg->float_data[i];
        {
          if (f->y + f->height > y)
            y = f->y + f->height;
        }
      }
  }
  //y += mrg_em (mrg) * ctx_style(mrg)->line_height;
  mrg_set_xy (mrg, mrg_x (mrg), y);
#endif
}

static float mrg_edge_bottom  (Css *mrg)
{
  return mrg->state->edge_bottom;
}

static float mrg_edge_top  (Css *mrg)
{
  return mrg->state->edge_top;
}

float mrg_edge_left  (Css *mrg)
{
  return mrg->state->edge_left;
}

float mrg_edge_right (Css *mrg)
{
  return mrg->state->edge_right;
}

float _mrg_dynamic_edge_right (Css *mrg);
float _mrg_dynamic_edge_left (Css *mrg);

void css_set_edge_top (Css *itk, float edge)
{
  Css *mrg = itk;
  itk->state->edge_top = edge;

  // we always set top last, since it causes the
  // reset of line handling
  //
  mrg_set_xy (mrg, _mrg_dynamic_edge_left (mrg) +
                  ctx_get_float (mrg_ctx(mrg), SQZ_text_indent)
      , mrg->state->edge_top);// + mrg_em (mrg));


   itk->edge_top = edge;
   itk->edge_bottom = itk->height + itk->edge_top;
}

void  css_set_edge_left (Css *itk, float val)
{
  itk->state->edge_left = val;
  itk->edge_left = val;
  itk->edge_right = itk->width + itk->edge_left;
}

void css_set_edge_bottom (Css *itk, float edge)
{
   itk->state->edge_bottom = edge;
   itk->edge_bottom = edge;
   itk->height = itk->edge_bottom - itk->edge_top;
}

void css_set_edge_right (Css *itk, float edge)
{
   itk->state->edge_right = edge;
   itk->edge_right = edge;
   itk->width      = itk->edge_right - itk->edge_left;
}

float mrg_rem (Css *mrg)
{
  return mrg->rem;
}


void css_start            (Css *mrg, const char *class_name, void *id_ptr);
void css_start_with_style (Css        *mrg,
                           const char *style_id,
                           void       *id_ptr,
                           const char *style);
void css_start_with_stylef (Css *mrg, const char *style_id, void *id_ptr,
                            const char *format, ...);

static void ctx_parse_style_id (Css          *mrg,
                                const char   *style_id,
                                CtxStyleNode *node)
{
  const char *p;
  char temp[128] = "";
  unsigned int  temp_l = 0;
  if (!style_id)
  {
    return; // XXX: why does this happen?
  }

  memset (node, 0, sizeof (CtxStyleNode));

  for (p = style_id; ; p++)
  {
    switch (*p)
    {
      case '.':
      case ':':
      case '#':
      case 0:
        if (temp_l)
        {
          switch (temp[0])
          {
            case '.':
              {
                int i = 0;
                for (i = 0; i < CTX_STYLE_MAX_CLASSES && node->classes_hash[i]; i++);
                node->classes_hash[i] = ctx_strhash (&temp[1]);
              }
              break;
            case ':':
              {
                int i = 0;
                for (i = 0; i < CTX_STYLE_MAX_PSEUDO && node->pseudo[i]; i++);
                node->pseudo[i] = mrg_intern_string (&temp[1]);
                for (i = 0; i < CTX_STYLE_MAX_PSEUDO && node->pseudo_hash[i]; i++);
                node->pseudo_hash[i] = ctx_strhash (&temp[1]);
              }
              break;
            case '#':
              node->id = mrg_intern_string (&temp[1]);
              node->id_hash = ctx_strhash (&temp[1]);
              break;
            default:
              node->element_hash = ctx_strhash (temp);
              break;
          }
          temp_l = 0;
        }
        if (*p == 0)
          return;
        if (temp_l + 1 < sizeof(temp))
          temp[temp_l++] = *p;  // XXX: added to make reported fallthrough
        temp[temp_l]=0;       //      not be reported - butexplicit
        break;
      default:
        if (temp_l + 1 < sizeof(temp))
          temp[temp_l++] = *p;
        temp[temp_l]=0;
    }
  }
}

void _ctx_initial_style (Css *mrg)
{
  CtxStyle *s = ctx_style (mrg);

  /* things not set here, are inherited from the parent style context,
   * more properly would be to rig up a fresh context, and copy inherited
   * values over, that would permit specifying inherit on any propery.
   */

  s->text_decoration= (CtxTextDecoration)0;
  s->display  = CTX_DISPLAY_INLINE;
  s->float_   = CTX_FLOAT_NONE;
  s->clear    = CTX_CLEAR_NONE;
  s->overflow = CTX_OVERFLOW_VISIBLE;
  s->position = CTX_POSITION_STATIC;

  SET_PROP(border_top_width,    0);
  SET_PROP(border_left_width,   0);
  SET_PROP(border_right_width,  0);
  SET_PROP(border_bottom_width, 0);
  SET_PROP(margin_top,    0);
  SET_PROP(margin_left,   0);
  SET_PROP(margin_right,  0);
  SET_PROP(margin_bottom, 0);
  SET_PROP(padding_top,    0);
  SET_PROP(padding_left,   0);
  SET_PROP(padding_right,  0);
  SET_PROP(padding_bottom, 0);
  SET_PROP(top,    0);
  SET_PROP(left,   0);
  SET_PROP(right,  0);
  SET_PROP(bottom, 0);

  SET_PROP(min_width, 0);
  SET_PROP(max_width, 0);
  s->width_auto = 1;
  s->margin_left_auto = 0;
  s->margin_right_auto = 0;
  //SET_PROP(width, 42);

  SET_PROPS(class,"");
  SET_PROPS(id,"");

  //ctx_set_float (mrg->ctx, SQZ_stroke_width, 4.0);

  CtxColor *color = ctx_color_new ();
  ctx_get_color (mrg->ctx, SQZ_color, color);

  ctx_set_color (mrg->ctx, SQZ_border_top_color, color);
  ctx_set_color (mrg->ctx, SQZ_border_bottom_color, color);
  ctx_set_color (mrg->ctx, SQZ_border_left_color, color);
  ctx_set_color (mrg->ctx, SQZ_border_right_color, color);

#if 0
  s->stroke_color.red = 1;
  s->stroke_color.green = 0;
  s->stroke_color.blue = 1;
  s->stroke_color.alpha = 1;
  s->fill_color.red = 1;
  s->fill_color.green = 1;
  s->fill_color.blue = 0;
  s->fill_color.alpha = 1;
#endif

  ctx_color_set_from_string (mrg->ctx, color, "transparent");
  ctx_set_color (mrg->ctx, SQZ_background_color, color);
  ctx_color_free (color);
}



/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

const char * html_css =
"html,address,\n"
"blockquote,\n"
"body,dd, div,\n"
"dl,dt,fieldset, form,\n"
"frame,frameset,\n"
"h1,h2,h3, h4,\n"
"h5,h6,noframes,\n"
"ol,p,ul,center,\n"
"dir,hr,menu,pre{display:block;unicode-bidi:embed}\n"
"h1,h2,h3,h4,h5{page-break-after:avoid}\n"
"li{display:list-item}\n"
"table{display:block;}\n"
//"table{display:table}\n"
//"tr{display:table-row}\n"
"tr{display:block}\n"
"thead{display:table-header-group }\n"
"tbody{display:table-row-group }\n"
"tfoot{display:table-footer-group }\n"
"col{display:table-column}\n"
"img{display:inline-block}\n"
"colgroup{display:table-column-group}\n"
"td,th{display:block-inline}\n"
//"td,th{display:table-cell}\n"
"caption{display:table-caption}\n"
"th{font-weight:bolder;text-align:center}\n"
"caption{text-align:center}\n"
"body{margin:8px;}\n" // was 0.5em
"h1{font-size:2em;margin:.67em 0;}\n"
"h2{font-size:1.5em;margin:.75em 0}\n"
"h3{font-size:1.17em;margin:.83em 0}\n"
"h4,p,"
"blockquote,ul,"
"fieldset,form,"
"ol,dl,dir,"
"menu{margin:1.12em 0}\n"
"h5{font-size:.83em;margin: 1.5em 0}\n"
"h6{font-size:.75em;margin: 1.67em 0}\n"
"h1,h2,h3,h4,\n"
"h5,h6,b,\n"
"strong{font-weight:bolder}\n"
"blockquote{margin-left:4em;margin-right:4em}\n"
"i,cite,em,\n"
"var,address{font-style:italic}\n"
"pre,tt,code,\n"
"kbd,samp{font-family:monospace}\n"
"pre{white-space:pre}\n"
"button,textarea,\n"
"input,select{display:inline-block}\n"
"big{font-size:1.17em}\n"
"small,sub,sup{font-size:.83em}\n"
"sub{vertical-align:sub}\n"
"sup{vertical-align:super}\n"
"table{border-spacing:2px;}\n"
"thead,tbody,\n"
"tfoot{vertical-align:middle}\n"
"td,th,tr{vertical-align:inherit}\n"
"s,strike,del{text-decoration:line-through}\n"
"ol,ul,dir,"
"menu{padding-left:2.5em}\n"
"dd{margin-left:3em}\n"
"ol{list-style-type:decimal}\n"
"ol ul,ul ol,"
"ul ul,ol ol{margin-top: 0;margin-bottom: 0}\n"
"u,ins{text-decoration:underline}\n"
//"br:before{content:\"\\A\";white-space:pre-line}\n"
"center{text-align:center}\n"
":link,:visited{text-decoration:underline}\n"
":focus{outline:thin dotted invert}\n"
".cursor{color:white;background: black;} \n"
"br{display:block;}\n"
"html{font-weight:normal;background-color:white;}\n"
"body{background-color:transparent;color:#000;}\n"
"a{color:blue;text-decoration: underline;}\n"
"a:hover{background:black;color:white;text-decoration:underline; }\n"
"head{display:none;}\n"
"title{display:none;}\n"
//"hr{border:1px inset black;margin-bottom: 0.5em;margin-top:0.5em;}\n"
"hr{font-size:1px;border-bottom: 1px solid red;display:block;}\n"

".scroll{background:blue;}\n"
".wallpaper, .itk{background:#16161d;color:#f43}\n"
".focused{background:#fff;color:#000}\n"

" .children{ border:1px solid green;padding-left:3em; }\n"
" .selection{background:white; color: red; }\n"
" :focused {color: green; }\n"
"   .item { border: 1px solid transparent; color: white; }"
"   .item:focused { color: yellow; border: 1px solid blue;}"
 /*  .item>.text::before { content:"-";display:block;position:absolute;margin-left:-1.2em; } */

" .file { border: 1px solid green; margin-left:0;margin-right:0.2em; width: 3em; margin-bottom: 0.2em; height: 3em; display: inline-block;  }"


//"h1,h2,h3,h4,h5,h6,p,div,b,span,ul,li,ol,dl,dt,dl,propline,button{border-left-color:gray;border-right-color:gray;}\n"

//"html{font-size:10.0px;color:white;}\n" // from ACID1 - not parsed right

//// itk defaults stylesheet
"toggle        {border: 1px solid green;border: 1px solid red;color:white;display:block;}\n"
"button        {border: 1px solid green;display:block; height: 1em;background:#000;color:#f00;}\n"
"button:focused{color:#f0f;border: 1px solid purple;background:blue;}\n"

"choice        {border: 1px solid brown;display:inline-block;}\n"
".choice_menu_wrap  {border: 1px solid red;display:block;position:relative;top:-1.2em;left:4em;height:0;width:0;}\n"
".choice_menu  {border: 1px solid red;display:block;position:absolute;width:7em;}\n"
".choice       {border: 1px solid brown;display:block;background:black}\n"
".choice:chosen{border: 1px solid brown;display:block;background:red;}\n"
"label         {display:inline; color:white;}\n"
"slider        {display:block; color:white;}\n"
"propline      {display:block;margin-top:0.25em;margin-bottom:0.25em;border:2 px solid cyan;}\n"
"propline:focused {border:2px solid red;background:#444;}\n"
;


typedef struct CtxStyleEntry {
  char        *selector;
  CtxStyleNode parsed[CTX_MAX_SELECTOR_LENGTH];
  int          sel_len;
  char        *css;
  int          specificity;
} CtxStyleEntry;

static void free_entry (CtxStyleEntry *entry, void*a)
{
  free (entry->selector);
  free (entry->css);
  free (entry);
}

static int ctx_css_compute_specifity (const char *selector, int priority)
{
  const char *p;
  int n_id = 0;
  int n_class = 0;
  int n_tag = 0;
  int n_pseudo = 0;
  int in_word = 0;

  for (p = selector; *p; p++)
  {
    switch (*p)
    {
      case ' ':
        in_word = 0;
        break;
      case ':':
        in_word = 1;
        n_pseudo++;
        break;
      case '.':
        in_word = 1;
        n_class++;
        break;
      case '#':
        in_word = 1;
        n_id++;
        break;
      default:
        if (!in_word)
        {
          in_word = 1;
          n_tag++;
        }
    }
  }
  return priority * 100000 + n_pseudo * 10000 + n_id * 1000 + n_class * 100 + n_tag * 10;
}

static void ctx_css_parse_selector (Css *mrg, const char *selector, CtxStyleEntry *entry)
{
  const char *p = selector;
  char section[256];
  int sec_l = 0;

  char type = ' ';

  int direct_descendant = 0;
  for (p = selector; ; p++)
  {
    switch (*p)
    {
        case '.': case ':': case '#': case ' ': case 0: case '>':
        if (sec_l)
        {
          switch (type)
          {
            case ' ':
              entry->parsed[entry->sel_len].element_hash = ctx_strhash (section);
              entry->parsed[entry->sel_len].direct_descendant = direct_descendant;
              direct_descendant = 0;
              break;
            case '#':
              entry->parsed[entry->sel_len].id = mrg_intern_string (section);
              entry->parsed[entry->sel_len].id_hash = ctx_strhash (section);
              entry->parsed[entry->sel_len].direct_descendant = direct_descendant;
              direct_descendant = 0;
              break;
            case '.':
              {
                int i = 0;
                for (i = 0; entry->parsed[entry->sel_len].classes_hash[i]; i++);
                entry->parsed[entry->sel_len].classes_hash[i] = ctx_strhash (section);
              }
              entry->parsed[entry->sel_len].direct_descendant = direct_descendant;
              direct_descendant = 0;
              break;
            case ':':
              {
                int i = 0;
                for (i = 0; entry->parsed[entry->sel_len].pseudo[i]; i++);
                entry->parsed[entry->sel_len].pseudo[i] = mrg_intern_string (section);
                for (i = 0; entry->parsed[entry->sel_len].pseudo_hash[i]; i++);
                entry->parsed[entry->sel_len].pseudo_hash[i] = ctx_strhash (section);
                entry->parsed[entry->sel_len].direct_descendant = direct_descendant;
                direct_descendant = 0;
              }
              break;
          }
        if (*p == ' ' || *p == 0 || *p == '>')
        {
          entry->sel_len ++;
        }
        }
        type = *p;
        if (*p == '>')
        {
          direct_descendant = 1;
          type = ' ';
        }
        if (*p == 0)
        {

#if 0
  fprintf (stderr, "%s: ", selector);
  for (int i = 0; i < entry->sel_len; i++)
  {
    if (entry->parsed[i].direct_descendant)
            fprintf (stderr, "DP ");
    fprintf (stderr, "e: %s ", ctx_str_decode (entry->parsed[i].element_hash));
    for (int j = 0; entry->parsed[i].classes_hash[j]; j++)
      fprintf (stderr, "c: %s ", ctx_str_decode (entry->parsed[i].classes_hash[j]));
  }
  fprintf (stderr, "\n");
#endif

          return;
        }
        section[(sec_l=0)] = 0;
        break;
      default:
        section[sec_l++] = *p;
        section[sec_l] = 0;
        break;
    }
  }

  // not reached
}

static void ctx_stylesheet_add_selector (Css *mrg, const char *selector, const char *css, int priority)
{
  CtxStyleEntry *entry = (CtxStyleEntry*) calloc (1, sizeof (CtxStyleEntry));
  entry->selector = strdup (selector);
  entry->css = strdup (css);
  entry->specificity = ctx_css_compute_specifity (selector, priority);

  //fprintf (stderr, "\nsel:%s]\ncss:%s\npri:%i\n", selector, css, priority);

  ctx_css_parse_selector (mrg, selector, entry);
  ctx_list_prepend_full (&mrg->stylesheet, entry, (void (*)(void*, void*))free_entry, NULL);
}


#define MAKE_ERROR \
 if (error)\
 {\
   char errbuf[128];\
   sprintf (errbuf, "%i unexpected %c at %i'  %c%c%c", __LINE__, *p, (int)(p-css),\
     p[0], p[1], p[2]);\
   *error = strdup (errbuf);\
 }


typedef struct _CtxCssParseState CtxCssParseState;

struct _CtxCssParseState {
  int   state;
  char  rule[CTX_MAX_CSS_RULES][CTX_MAX_CSS_RULELEN];
  int   rule_no ;
  int   rule_l[CTX_MAX_CSS_RULES];
  char  val[CTX_MAX_CSS_STRINGLEN];
  int   val_l;
};

/* XXX: this funciton has no buffer bounds checking */
/* doesnt balance {} () [] and quotes */

enum
{
  NEUTRAL = 0,
  NEUTRAL_COMMENT,
  IN_RULE,
  RULE_COMMENT,
  IN_ARULE,
  ARULE_COMMENT,
  IN_IMPORT,
  IMPORT_COMMENT,
  EXPECT_COLON,
  COLON_COMMENT,
  EXPECT_VAL,
  EXPECT_VAL_COMMENT,
  IN_VAL,
  VAL_COMMENT,
};


static void _ctx_stylesheet_add (CtxCssParseState *ps,
                                 Css *mrg,
                                 const char *css,
                                 const char *uri_base,
                                 int priority, char **error)
{
  const char *p;
  if (!ps)
  {
    ps = (CtxCssParseState*)calloc (1, sizeof (CtxCssParseState));
    mrg->css_parse_state = ps;
  }

  if (!css)
    return;

  for (p = css; *p; p++)
  {
    switch (ps->state)
    {
      case NEUTRAL_COMMENT:
      case RULE_COMMENT:
      case ARULE_COMMENT:
      case IMPORT_COMMENT:
      case VAL_COMMENT:
      case EXPECT_VAL_COMMENT:
      case COLON_COMMENT:      if (p[0] == '*' && p[1] == '/') { p++; ps->state--; } break;
      case NEUTRAL:
        switch (*p)
        {
          case '/': if (p[1] == '*') { p++; ps->state = NEUTRAL_COMMENT; } break;
          case ' ':
          case '\n':
          case '\r':
          case '\t':
          case ';':
            break;
          case '{':
          case '}':
            MAKE_ERROR;
            return;
          case '@':
            ps->state = IN_ARULE;
            if (ps->rule_l[ps->rule_no]+1 < CTX_MAX_CSS_RULELEN)
              ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]++] = *p;
            ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]] = 0;
            break;
          default:
            ps->state = IN_RULE;
            if (ps->rule_l[ps->rule_no]+1 < CTX_MAX_CSS_RULELEN)
              ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]++] = *p;
            ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]] = 0;
            break;
        }
        break;
      case IN_ARULE:
        switch (*p)
        {
          case '/': if (p[1] == '*') { p++; ps->state = ARULE_COMMENT; } break;
          case '{':
            ps->state = IN_VAL; // should be AVAL for media sections...
            break;
          case '\n':
          case '\r':
          case '\t':
          case ' ':
            if (!strcmp (ps->rule[0], "import"))
            {
              MAKE_ERROR;
            }
            else
            {
              ps->state = IN_IMPORT;
            }
            break;
          case ';':
          case '}':
            MAKE_ERROR;
            return;
          default:
            ps->state = IN_ARULE;
            if (ps->rule_l[ps->rule_no]+ 1 < CTX_MAX_CSS_RULELEN)
              ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]++] = *p;
            ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]] = 0;
            break;
        }
        break;
      case IN_IMPORT:
        switch (*p)
        {
          int no;
          case '/': if (p[1] == '*') { p++; ps->state = IMPORT_COMMENT; } break;
          case ';':
            while (ps->val_l && (
                ps->val[ps->val_l-1] == ' ' ||
                ps->val[ps->val_l-1] == '\n' ||
                ps->val[ps->val_l-1] == '\r' ||
                ps->val[ps->val_l-1] == '\t'))
              ps->val_l--;
            while (ps->val_l && ps->val[ps->val_l-1] != ')')
              ps->val_l--;
            if (ps->val[ps->val_l-1] == ')')
              ps->val_l--;
            if (ps->val[ps->val_l-1] == '"')
              ps->val_l--;
            ps->val[ps->val_l]=0;

            if(mrg->mrg_get_contents){
              char *contents = NULL;
              long length;
              char *uri = ps->val;

              /* really ugly string trimming to get to import uri.. */
              while (uri[0]==' ') uri++;
              if (!memcmp (uri, "url", 3)) uri+=3;
              if (uri[0]=='(') uri++;
              if (uri[0]=='"') uri++;
      
              /* XXX: should parse out the media part, and check if we should
               * really include this file
               */

              mrg_get_contents (mrg, mrg->uri_base, uri, &contents, &length);
              if (contents)
              {
                CtxCssParseState child_parser = {0,};
                _ctx_stylesheet_add (&child_parser, mrg, contents, uri, priority, error);
                free (contents);
              }
              else
              {
                 fprintf (stderr, "404 - %s\n", uri);
              }
            }

            for (no = 0; no < ps->rule_no+1; no ++)
              ps->rule[no][ps->rule_l[no]=0] = 0;
            ps->val_l = 0;
            ps->val[0] = 0;
            ps->rule_no = 0;
            ps->state = NEUTRAL;
            break;
          default:
            ps->state = IN_IMPORT;
            if (ps->val_l + 1 < CTX_MAX_CSS_STRINGLEN)
              ps->val[ps->val_l++] = *p;
            ps->val[ps->val_l] = 0;
            break;

        }
        break;
      case IN_RULE:
        switch (*p)
        {
          case '/': if (p[1] == '*') { p++; ps->state = RULE_COMMENT; } break;
          case '{':
            ps->state = IN_VAL;
            break;
          case '\n':
          case '\r':
          case '\t':
            if (ps->rule_l[ps->rule_no]+1 < CTX_MAX_CSS_RULELEN)
              ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]++] = ' ';
            ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]] = 0;
            break;
          case ',':
            ps->state = NEUTRAL;
            if (ps->rule_no + 1 < CTX_MAX_CSS_RULES)
              ps->rule_no++;
            break;
          case ';':
          case '}':
            MAKE_ERROR;
            return;
          default:
            ps->state = IN_RULE;
            if (ps->rule_l[ps->rule_no]+1 < CTX_MAX_CSS_RULELEN)
              ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]++] = *p;
            ps->rule[ps->rule_no][ps->rule_l[ps->rule_no]] = 0;
            break;
        }
        break;
      case EXPECT_COLON:
        switch (*p)
        {
          case '/': if (p[1] == '*') { p++; ps->state = COLON_COMMENT; } break;
          case ' ':
          case '\n':
          case '\r':
          case '\t':
            break;
          case ':':
            ps->state = EXPECT_VAL;
            break;
          default:
            MAKE_ERROR;
            return;
        }
        break;
      case EXPECT_VAL:
        switch (*p)
        {
          case '/': if (p[1] == '*') { p++; ps->state = EXPECT_VAL_COMMENT; } break;
          case ' ':
          case '\n':
          case '\r':
          case '\t':
          case ';':
            break;
          case '{':
            ps->state = IN_VAL;
            break;
          default:
            MAKE_ERROR;
            return;
        }
        break;
      case IN_VAL:
        switch (*p)
        {
          int no;

          case '/': if (p[1] == '*') { p++; ps->state = VAL_COMMENT; } break;
          case '}':
            while (ps->val_l && (
                ps->val[ps->val_l-1] == ' ' ||
                ps->val[ps->val_l-1] == '\n' ||
                ps->val[ps->val_l-1] == '\r' ||
                ps->val[ps->val_l-1] == '\t'))
              ps->val_l--;
            ps->val[ps->val_l]=0;

            for (no = 0; no < ps->rule_no+1; no ++)
            {
              while (ps->rule_l[no] && (
                  ps->rule[no][ps->rule_l[no]-1] == ' ' ||
                  ps->rule[no][ps->rule_l[no]-1] == '\n' ||
                  ps->rule[no][ps->rule_l[no]-1] == '\r' ||
                  ps->rule[no][ps->rule_l[no]-1] == '\t'))
                ps->rule_l[no]--;
              ps->rule[no][ps->rule_l[no]]=0;

              ctx_stylesheet_add_selector (mrg, ps->rule[no], ps->val, priority);
              ps->rule[no][ps->rule_l[no]=0] = 0;
            }

            ps->val_l = 0;
            ps->val[0] = 0;
            ps->rule_no = 0;
            ps->state = NEUTRAL;
            break;
          default:
            ps->state = IN_VAL;
            if (ps->val_l + 1 < CTX_MAX_CSS_STRINGLEN)
              ps->val[ps->val_l++] = *p;
            ps->val[ps->val_l] = 0;
            break;

        }
        break;
    }
  }
}

void ctx_stylesheet_add (Css *mrg, const char *css, const char *uri_base,
                         int priority, char **error)
{
  CtxCssParseState *ps = (CtxCssParseState*)mrg->css_parse_state;
  _ctx_stylesheet_add (ps, mrg, css, uri_base, priority, error);
}
#define CTX_STYLE_INTERNAL 10
#define CTX_STYLE_GLOBAL   15
#define CTX_STYLE_XML      20
#define CTX_STYLE_APP      20
#define CTX_STYLE_INLINE   25
#define CTX_STYLE_CODE     30

void css_css_default (Css *mrg)
{
  char *error = NULL;
  ctx_stylesheet_add (mrg, html_css, NULL, CTX_STYLE_INTERNAL, &error);
  if (error)
  {
    fprintf (stderr, "Css css parsing error: %s\n", error);
  }

  ctx_stylesheet_add (mrg,
"bold{font-weight:bold;}"
"dim*,dim{opacity:0.5;}"
"underline*,underline{text-decoration:underline;}"
"reverse*,selected*,reverse,selected{text-decoration:reverse;}"
"unhandled{color:cyan;}"
"binding:key{background-color:white;color:black;}"
"binding:label{color:cyan;}"
      ,NULL, CTX_STYLE_INTERNAL, &error);

  if (error)
  {
    fprintf (stderr, "mrg css parsing error: %s\n", error);
  }
}

void ctx_stylesheet_clear (Css *mrg)
{
  if (mrg->stylesheet)
    ctx_list_free (&mrg->stylesheet);
  css_css_default (mrg);
}

typedef struct CtxStyleMatch
{
  CtxStyleEntry *entry;
  int score;
} CtxStyleMatch;

static int compare_matches (const void *a, const void *b, void *d)
{
  const CtxStyleMatch *ma = (const CtxStyleMatch*)a;
  const CtxStyleMatch *mb = (const CtxStyleMatch*)b;
  return mb->score - ma->score;
}

static inline int _ctx_nth_match (const char *selector, int child_no)
{
  const char *tmp = selector + 10;
  int a = 0;
  int b = 0;

  if (!strcmp (tmp, "odd)"))
  {
    a = 2; b = 1;
  }
  else if (!strcmp (tmp, "even)"))
  {
    a = 2; b = 0;
  }
  else
  {
    if (ctx_strchr (tmp, 'n'))
    {
      a = atoi (tmp);
      b = atoi (ctx_strchr (tmp, 'n')+1);
    }
    else
    {
      b = atoi (tmp);
    }
  }

  if (!a)
    return child_no == b;
  else
    if (child_no == b ||
       ((child_no - b > 0) == (a>0)))
      return !((child_no - b) % a);

  return 0;
}

int _ctx_child_no (Css *mrg)
{
  if (mrg->state_no <= 0) return 0;
  return mrg->states[mrg->state_no-1].children;
}

static inline int match_nodes (Css *mrg, CtxStyleNode *sel_node, CtxStyleNode *subject)
{
  int j, k;

  if (sel_node->element_hash &&
      sel_node->element_hash != subject->element_hash)
    return 0;

  if (sel_node->id &&
      sel_node->id != subject->id)
    return 0;

  for (j = 0; j < CTX_STYLE_MAX_CLASSES && sel_node->classes_hash[j]; j++)
  {
    int found = 0;
    for (k = 0; k < CTX_STYLE_MAX_CLASSES && subject->classes_hash[k] && !found; k++)
    {
      if (sel_node->classes_hash[j] == subject->classes_hash[k])
        found = 1;
    }
    if (!found)
      return 0;
  }
  for (j = 0; j < CTX_STYLE_MAX_PSEUDO && sel_node->pseudo[j]; j++)
  {
    if (ctx_strhash (sel_node->pseudo[j]) == SQZ_first_child)
    {
      if (!(_ctx_child_no (mrg) == 1))
        return 0;
    }
    else if (!strncmp (sel_node->pseudo[j], "nth-child(", 10))
    {
      if (!_ctx_nth_match (sel_node->pseudo[j], _ctx_child_no (mrg)))
        return 0;
    }
    else
    {
      int found = 0;

      for (k = 0; k < CTX_STYLE_MAX_PSEUDO && subject->pseudo[k] && !found; k++)
      {
        if (sel_node->pseudo_hash[j] == subject->pseudo_hash[k])
          found = 1;
      }
      if (!found)
        return 0;
    }
  }
  return 1;
}

static int ctx_selector_vs_ancestry (Css *mrg,
                                     CtxStyleEntry *entry,
                                     CtxStyleNode **ancestry,
                                     int a_depth)
{
  int s = entry->sel_len - 1;
  //a_depth = mrg->state_no + 1;
#if 1

#if 0
  for (int i = 1; i < a_depth; i++)
  {
          if (ancestry[i] != &mrg->states[i].style_node)
          {
            fprintf (stderr, "%i %p!=%p %i \n", i, ancestry[i],
                          &mrg->states[i].style_node, a_depth);
            fprintf (stderr, "%p\n", &mrg->states[mrg->state_no].style_node);
            fprintf (stderr, "%p\n", &mrg->states[mrg->state_no+1].style_node);
            fprintf (stderr, "%p\n", &mrg->states[mrg->state_no-1].style_node);
          }
  }
#endif

  if (entry->parsed[s].direct_descendant == 0)
  {
    /* right most part of selector must match */
    if (a_depth == 1)
    {
      // XXX it is an oddity how we need to use this instead of mrg->states[0].style_node directly..
      if (!match_nodes (mrg, &entry->parsed[s], ancestry[a_depth-1]))
      //if (!match_nodes (mrg, &entry->parsed[s], &mrg->states[0].style_node))
        return 0;
    }
    else
    {
      if (!match_nodes (mrg, &entry->parsed[s], &mrg->states[a_depth-1].style_node))
        return 0;
    }

    s--;
    a_depth--;
  }

  if (s < 0 || a_depth < 0)
    return 1;
#endif

  while (s >= 0)
  {
    int ai;
    int found_node = 0;

    if (entry->parsed[s].direct_descendant && s > 0)
    {  // s>0 should always be true when direct_descendant is true
      ai = a_depth-1;
      {
        if (s >0 && ai >0 && match_nodes (mrg, &entry->parsed[s], &mrg->states[ai].style_node) &&
            match_nodes (mrg, &entry->parsed[s-1], &mrg->states[ai-1].style_node))
          found_node = 1;
      }
      ai--;
      s-=2;
    }
    else
    {
      for (ai = a_depth-1; ai >= 0 && !found_node; ai--)
      {
        if (match_nodes (mrg, &entry->parsed[s], &mrg->states[ai].style_node))
          found_node = 1;
      }
      s--;
    }
    if (found_node)
    {
      a_depth = ai;
    }
    else
    {
      return 0;
    }
  }

  return 1;
}

static int ctx_css_selector_match (Css *mrg, CtxStyleEntry *entry, CtxStyleNode **ancestry, int a_depth)
{
  if (entry->selector[0] == '*' &&
      entry->selector[1] == 0)
    return entry->specificity;

  if (a_depth == 0)
    return 0;

  if (ctx_selector_vs_ancestry (mrg, entry, ancestry, a_depth))
    return entry->specificity;

  return 0;
}

void ctx_wrap_free (void *a, void *b)
{
  free(a);
}

static char *_ctx_css_compute_style (Css *mrg, CtxStyleNode **ancestry, int a_depth)
{
  CtxList *l;
  CtxList *matches = NULL;
  int totlen = 2;
  char *ret = NULL;

  for (l = mrg->stylesheet; l; l = l->next)
  {
    CtxStyleEntry *entry = (CtxStyleEntry*)l->data;
    int score  = ctx_css_selector_match (mrg, entry, ancestry, a_depth);
    if (score)
    {
      CtxStyleMatch *match = (CtxStyleMatch*)malloc (sizeof (CtxStyleMatch));
      match->score = score;
      match->entry = entry;
      ctx_list_prepend_full (&matches, match, ctx_wrap_free, NULL);
      totlen += strlen (entry->css) + 1;
    }
  }

  if (matches)
  {
    CtxList *l;
    char *p;

    p = ret = (char*)malloc (totlen);

    ctx_list_sort (&matches, compare_matches, NULL);
    for (l = matches; l; l = l->next)
    {
      CtxStyleMatch *match = (CtxStyleMatch*)l->data;
      CtxStyleEntry *entry = (CtxStyleEntry*)match->entry;
      strcpy (p, entry->css);
      p += strlen (entry->css);
      strcpy (p, ";");
      p ++;
    }
    ctx_list_free (&matches);
  }
  return ret;
}

static void _ctx_get_ancestry (Css *mrg, CtxStyleNode **ancestry)
{
  if (mrg->state_no>0)
      ancestry[0] = &mrg->states[0].style_node;
}

char *_ctx_stylesheet_collate_style (Css *mrg)
{
  CtxStyleNode *ancestry[1];
  _ctx_get_ancestry (mrg, ancestry);
  char *ret = _ctx_css_compute_style (mrg, ancestry, mrg->state_no + 1);
  return ret;
}

void  mrg_set_line_height (Css *mrg, float line_height)
{
  ctx_style (mrg)->line_height = line_height;
}

float mrg_line_height (Css *mrg)
{
  return ctx_style (mrg)->line_height;
}

void  mrg_set_rem         (Css *mrg, float em)
{
  mrg->rem = em;
}

float mrg_em (Css *mrg)
{
  return mrg->state->style.font_size;
}

void  mrg_set_em (Css *mrg, float em)
{
  mrg->state->style.font_size = em;
}

void ctx_css_set (Css *mrg, const char *css)
{
  ctx_string_set (mrg->style, css);
}

void ctx_css_add (Css *mrg, const char *css)
{
  ctx_string_append_str (mrg->style, css);
}

void ctx_stylesheet_clear (Css *mrg);
void ctx_stylesheet_add (Css *mrg, const char *css, const char *uri,
                         int priority,
                         char **error);

void ctx_css_set (Css *mrg, const char *css);
void ctx_css_add (Css *mrg, const char *css);

static inline float mrg_parse_px_x (Css *mrg, const char *str, char **endptr)
{
  float result = 0;
  char *end = NULL;
#define PPI   96

  if (!str)
    return 0.0;

  result = _ctx_parse_float (str, &end);
  if (endptr)
    *endptr=end;

  //if (end[0]=='%v') /// XXX  % of viewport; regard less of stacking
  if (end[0]=='%')
  {
    result = result / 100.0 * (mrg_edge_right (mrg) - mrg_edge_left (mrg));

    if (endptr)
      *endptr=end + 1;
  }
  else if (end[0]=='v' && end[1] == 'h')
  {
    result = result / 100.0 * (mrg_edge_bottom (mrg) - mrg_edge_top (mrg));
    if (endptr)
      *endptr=end + 1;
  }
  else if (end[0]=='v' && end[1] == 'w')
  {
    result = result / 100.0 * (mrg_edge_right (mrg) - mrg_edge_left (mrg));
    if (endptr)
      *endptr=end + 1;
  }
  else if (end[0]=='r' && end[1]=='e' && end[2]=='m')
  {
    result *= mrg_rem (mrg);
    if (endptr)
      *endptr=end + 3;
  }
  else if (end[0]=='e' && end[1]=='m')
  {
    result *= mrg_em (mrg);
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='p' && end[1]=='x')
  {
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='p' && end[1]=='t')
  {
    result = (result / PPI) * 72;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='p' && end[1]=='c')
  {
    result = (result / PPI) * 72 / 12;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='i' && end[1]=='n')
  {
    result = result / PPI;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='c' && end[1]=='m')
  {
    result = (result / PPI) * 2.54;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='m' && end[1]=='m')
  {
    result = (result / PPI) * 25.4;
    if (endptr)
      *endptr=end + 2;
  }
  return result;
}

static inline float mrg_parse_px_y (Css *mrg, const char *str, char **endptr)
{
  float result = 0;
  char *end = NULL;
  if (!str)
    return 0.0;

  result = _ctx_parse_float (str, &end);
  if (endptr)
    *endptr=end;

  if (end[0]=='%')
  {
    result = result / 100.0 * (mrg_edge_bottom (mrg) - mrg_edge_top (mrg));
    if (endptr)
      *endptr=end + 1;
  }
  else if (end[0]=='v' && end[1] == 'h')
  {
    result = result / 100.0 * (mrg_edge_bottom (mrg) - mrg_edge_top (mrg));
    if (endptr)
      *endptr=end + 1;
  }
  else if (end[0]=='v' && end[1] == 'w')
  {
    result = result / 100.0 * (mrg_edge_right (mrg) - mrg_edge_left (mrg));
    if (endptr)
      *endptr=end + 1;
  }
  else if (end[0]=='r' && end[1]=='e' && end[2]=='m')
  {
    result *= mrg_rem (mrg);
    if (endptr)
      *endptr=end + 3;
  }
  else if (end[0]=='e' && end[1]=='m')
  {
    result *= mrg_em (mrg);
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='p' && end[1]=='x')
  {
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='p' && end[1]=='t')
  {
    result = (result / PPI) * 72;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='p' && end[1]=='c')
  {
    result = (result / PPI) * 72 / 12;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='i' && end[1]=='n')
  {
    result = result / PPI;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='c' && end[1]=='m')
  {
    result = (result / PPI) * 2.54;
    if (endptr)
      *endptr=end + 2;
  }
  else if (end[0]=='m' && end[1]=='m')
  {
    result = (result / PPI) * 25.4;
    if (endptr)
      *endptr=end + 2;
  }
  return result;
}

static inline int mrg_parse_pxs (Css *mrg, const char *str, float *vals)
{
  int n_floats = 0;
  char *p =    (char*)str;
  char *prev = (char*)NULL;

  for (; p && p != prev && *p; )
  {
    float val;
    prev = p;
    val = n_floats%2==1?
      mrg_parse_px_x (mrg, p, &p):mrg_parse_px_y (mrg, p, &p);
    if (p != prev)
    {
      vals[n_floats++] = val;
    }
  }

  return n_floats;
}


static inline void ctx_css_handle_property_pass0 (Css *mrg, uint32_t key,
                                                  const char *value)
{
  /* pass0 deals with properties that parsing of many other property
   * definitions rely on */
  if (key == SQZ_font_size)
  {
    float parsed;
    
    if (mrg->state_no)
    {
      mrg->state_no--;
      parsed = mrg_parse_px_y (mrg, value, NULL);
      mrg->state_no++;
    }
    else
    {
      parsed = mrg_parse_px_y (mrg, value, NULL);
    }
    mrg_set_em (mrg, parsed);
  }
  else if (key == SQZ_color)
  {
    CtxColor *color = ctx_color_new ();
    ctx_color_set_from_string (mrg->ctx, color, value);
    ctx_set_color (mrg->ctx, SQZ_color, color);
    ctx_color_free (color);
  }
}

static void ctx_css_handle_property_pass1 (Css *mrg, uint32_t key,
                                           const char *value)
{
  CtxStyle *s = ctx_style (mrg);
  uint32_t val_hash = ctx_strhash (value);

  switch (key)
  {
    default:
      SET_PROPSh(key, value);
      break;
    case SQZ_right:
    case SQZ_bottom:
    case SQZ_color:     // handled in pass0
    case SQZ_font_size: // handled in pass0
      break;
    case SQZ_top:
    case SQZ_height:
    case SQZ_line_width:
    case SQZ_text_indent:
    case SQZ_letter_spacing:
    case SQZ_word_spacing:
    case SQZ_stroke_width:
    case SQZ_text_stroke_width:
    case SQZ_line_height:
    case SQZ_border_top_width:
    case SQZ_border_bottom_width:
    case SQZ_margin_top:
    case SQZ_margin_bottom:
    case SQZ_padding_bottom:
    case SQZ_padding_top:
    case SQZ_min_height:
    case SQZ_max_height:
      SET_PROPh(key, mrg_parse_px_y (mrg, value, NULL));
      break;
    case SQZ_border_right_width:
    case SQZ_border_left_width:
    case SQZ_left:
    case SQZ_tab_size:
    case SQZ_min_width:
    case SQZ_max_width:
    case SQZ_padding_left:
    case SQZ_padding_right:
    case SQZ_width:     // handled in pass1m
      SET_PROPh(key, mrg_parse_px_x (mrg, value, NULL));
      break;
    case SQZ_margin:
      {
        float vals[10];
        int   n_vals;
        n_vals = mrg_parse_pxs (mrg, value, vals);
        float res[4] = {0.0f,0.0f,0.0f,0.0f};
        switch (n_vals)
        {
          case 1:
            res[0] = res[1] = res[2] = res[3] = vals[0];
            break;
          case 2:
            res[0] = vals[0]; res[1] = vals[1]; res[0] = vals[0]; res[1] = vals[1];
            break;
          case 3:
            res[0] = vals[0]; res[1] = vals[1]; res[2] = vals[2]; res[3] = vals[1];
            break;
          case 4:
            res[0] = vals[0]; res[1] = vals[1]; res[2] = vals[2]; res[3] = vals[3];
            break;
        }
        SET_PROP(margin_top,    res[0]);
        SET_PROP(margin_right,  res[1]);
        SET_PROP(margin_bottom, res[2]);
        SET_PROP(margin_left,   res[3]);
      }
      break;
    case SQZ_margin_left:
    {
      if (val_hash == SQZ_auto)
      {
        s->margin_left_auto = 1;
      }
      else
      {
        SET_PROP(margin_left, mrg_parse_px_x (mrg, value, NULL));
        s->margin_left_auto = 0;
      }
    }
      break;
    case SQZ_margin_right:
    {
      if (val_hash == SQZ_auto)
      {
        s->margin_right_auto = 1;
      }
      else
      {
        SET_PROP(margin_right, mrg_parse_px_x (mrg, value, NULL));
        s->margin_right_auto = 0;
      }
    }
      break;
  
    case SQZ_padding:
      {
        float vals[10];
        int   n_vals;
        n_vals = mrg_parse_pxs (mrg, value, vals);
        float res[4] = {0.0f,0.0f,0.0f,0.0f};
        switch (n_vals)
        {
          case 1:
            res[0] = res[1] = res[2] = res[3] = vals[0];
            break;
          case 2:
            res[0] = vals[0]; res[1] = vals[1]; res[0] = vals[0]; res[1] = vals[1];
            break;
          case 3:
            res[0] = vals[0]; res[1] = vals[1]; res[2] = vals[2]; res[3] = vals[1];
            break;
          case 4:
            res[0] = vals[0]; res[1] = vals[1]; res[2] = vals[2]; res[3] = vals[3];
            break;
        }
        SET_PROP(padding_top,    res[0]);
        SET_PROP(padding_right,  res[1]);
        SET_PROP(padding_bottom, res[2]);
        SET_PROP(padding_left,   res[3]);
      }
      break;
    case SQZ_visibility:
    {
      if      (val_hash == SQZ_visible) s->visibility = CTX_VISIBILITY_VISIBLE;
      else if (val_hash == SQZ_hidden)  s->visibility = CTX_VISIBILITY_HIDDEN;
      else                              s->visibility = CTX_VISIBILITY_VISIBLE;
    }
    break;
  
    case SQZ_border_width:
      {
        float vals[10];
        int   n_vals;
        n_vals = mrg_parse_pxs (mrg, value, vals);
        float res[4] = {0.0f,0.0f,0.0f,0.0f};
        switch (n_vals)
        {
          case 1:
            res[0] = res[1] = res[2] = res[3] = vals[0];
            break;
          case 2:
            res[0] = vals[0]; res[1] = vals[1]; res[0] = vals[0]; res[1] = vals[1];
            break;
          case 3:
            res[0] = vals[0]; res[1] = vals[1]; res[2] = vals[2]; res[3] = vals[1];
            break;
          case 4:
            res[0] = vals[0]; res[1] = vals[1]; res[2] = vals[2]; res[3] = vals[3];
            break;
        }
        SET_PROP(border_top_width,    res[0]);
        SET_PROP(border_right_width,  res[1]);
        SET_PROP(border_bottom_width, res[2]);
        SET_PROP(border_left_width,   res[3]);
      }
      break;
    case SQZ_border_color:
      {
        CtxColor *color = ctx_color_new ();
        ctx_color_set_from_string (mrg->ctx, color, value);
        ctx_set_color (mrg->ctx, SQZ_border_top_color, color);
        ctx_set_color (mrg->ctx, SQZ_border_left_color, color);
        ctx_set_color (mrg->ctx, SQZ_border_right_color, color);
        ctx_set_color (mrg->ctx, SQZ_border_bottom_color, color);
        ctx_color_free (color);
      }
      break;
    case SQZ_border:
      {
        char word[64];
        int w = 0;
        const char *p;
        for (p = value; ; p++)
        {
          switch (*p)
          {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
            case '\0':
              if (w)
              {
                uint32_t word_hash = ctx_strhash (word);
                if ((word[0] >= '0' && word[0]<='9') || word[0] == '.')
                {
                  float valf = mrg_parse_px_y (mrg, word, NULL);
                  SET_PROP(border_top_width, valf);
                  SET_PROP(border_bottom_width, valf);
                  SET_PROP(border_right_width, valf);
                  SET_PROP(border_left_width, valf);
                } else if (word_hash == SQZ_solid ||
                           word_hash == SQZ_dotted ||
                           word_hash == SQZ_inset) {
                } else {
                  CtxColor *color = ctx_color_new ();
                  ctx_color_set_from_string (mrg->ctx, color, word);
                  ctx_set_color (mrg->ctx, SQZ_border_top_color, color);
                  ctx_set_color (mrg->ctx, SQZ_border_left_color, color);
                  ctx_set_color (mrg->ctx, SQZ_border_right_color, color);
                  ctx_set_color (mrg->ctx, SQZ_border_bottom_color, color);
                  ctx_color_free (color);
                }
                word[0]=0;
                w=0;
              }
              break;
            default:
              word[w++]=*p;
              word[w]=0;
              break;
          }
          if (!*p)
            break;
        }
      }
      break;
    case SQZ_border_bottom:
    case SQZ_border_left:
    case SQZ_border_right:
    case SQZ_border_top:
      {
        char word[64];
        int w = 0;
        const char *p;
        for (p = value; ; p++)
        {
          switch (*p)
          {
            case ' ':
            case '\n':
            case '\r':
            case '\t':
            case '\0':
              if (w)
              {
                uint32_t word_hash = ctx_strhash (word);
                if ((word[0] >= '0' && word[0]<='9') || (word[0] == '.'))
                {
                  float valf = mrg_parse_px_x (mrg, word, NULL);
                  if (key == SQZ_border_bottom)
                    SET_PROP(border_bottom_width, valf);
                  else if (key == SQZ_border_left)
                    SET_PROP(border_left_width, valf);
                  else if (key == SQZ_border_right)
                    SET_PROP(border_right_width, valf);
                  else
                    SET_PROP(border_top_width, valf);
                } else if (word_hash == SQZ_solid ||
                           word_hash == SQZ_dotted ||
                           word_hash == SQZ_inset) {
                } else {
                  CtxColor *color = ctx_color_new ();
                  ctx_color_set_from_string (mrg->ctx, color, word);
                  if (key == SQZ_border_bottom)
                    ctx_set_color (mrg->ctx, SQZ_border_bottom_color, color);
                  else if (key == SQZ_border_top)
                    ctx_set_color (mrg->ctx, SQZ_border_top_color, color);
                  else if (key == SQZ_border_left)
                    ctx_set_color (mrg->ctx, SQZ_border_left_color, color);
                  else if (key == SQZ_border_right)
                    ctx_set_color (mrg->ctx, SQZ_border_right_color, color);
                  ctx_color_free (color);
                }
                word[0]=0;
                w=0;
              }
              break;
            default:
              word[w++]=*p;
              word[w]=0;
              break;
          }
          if (!*p)
            break;
        }
      }
      break;
  
    case SQZ_background_color:
    case SQZ_background:
    {
      CtxColor *color = ctx_color_new ();
      ctx_color_set_from_string (mrg->ctx, color, value);
      ctx_set_color (mrg->ctx, SQZ_background_color, color);
      ctx_color_free (color);
    }
      break;
    case SQZ_fill_color:
    case SQZ_fill:
    {
      CtxColor *color = ctx_color_new ();
      ctx_color_set_from_string (mrg->ctx, color, value);
      ctx_set_color (mrg->ctx, SQZ_fill_color, color);
      ctx_color_free (color);
    }
      break;
    case SQZ_stroke_color:
    case SQZ_stroke:
    {
      CtxColor *color = ctx_color_new ();
      ctx_color_set_from_string (mrg->ctx, color, value);
      ctx_set_color (mrg->ctx, SQZ_stroke_color, color);
      ctx_color_free (color);
    }
      break;
    case SQZ_text_stroke_color:
    {
      CtxColor *color = ctx_color_new ();
      ctx_color_set_from_string (mrg->ctx, color, value);
      ctx_set_color (mrg->ctx, SQZ_text_stroke_color, color);
      ctx_color_free (color);
    }
      break;
    case SQZ_text_stroke:
    {
      char *col = NULL;
      SET_PROP(text_stroke_width, mrg_parse_px_y (mrg, value, &col));
  
      if (col)
      {
        CtxColor *color = ctx_color_new ();
        ctx_color_set_from_string (mrg->ctx, color, col + 1);
        ctx_set_color (mrg->ctx, SQZ_text_stroke_color, color);
        ctx_color_free (color);
      }
    }
      break;
    case SQZ_opacity:
    {
      ctx_global_alpha (mrg->ctx, _ctx_parse_float (value, NULL));
      SET_PROP(opacity, _ctx_parse_float (value, NULL));
    }
    break;
    case SQZ_z_index:
      s->z_index = _ctx_parse_float (value, NULL);
    break;
    case SQZ_print_symbols:
    switch (val_hash)
    {
        case SQZ_true:
        case SQZ_1:
        case SQZ_yes:
          s->print_symbols = 1;
          break;
        default:
          s->print_symbols = 0;
    }
      break;
    case SQZ_font_weight:
      switch (val_hash)
      {
        case SQZ_bold:
        case SQZ_bolder:
          s->font_weight = CTX_FONT_WEIGHT_BOLD;
          s->text_decoration = (CtxTextDecoration)((s->text_decoration)|CTX_TEXT_DECORATION_BOLD);
          break;
        default:
          s->text_decoration = (CtxTextDecoration)(s->text_decoration ^ (s->text_decoration & CTX_TEXT_DECORATION_BOLD));
          s->font_weight = CTX_FONT_WEIGHT_NORMAL;
      }
  #if 0 // XXX 
        cairo_select_font_face (mrg_ctx (mrg),
            s->font_family,
            s->font_style,
            s->font_weight);
  #endif
      break;
    case SQZ_white_space:
      {
        switch (val_hash)
        {
          default:
          case SQZ_normal:   s->white_space = CTX_WHITE_SPACE_NORMAL; break;
          case SQZ_nowrap:   s->white_space = CTX_WHITE_SPACE_NOWRAP; break;
          case SQZ_pre:      s->white_space = CTX_WHITE_SPACE_PRE; break;
          case SQZ_pre_line: s->white_space = CTX_WHITE_SPACE_PRE_LINE; break;
          case SQZ_pre_wrap: s->white_space = CTX_WHITE_SPACE_PRE_WRAP; break;
        }
      }
      break;
    case SQZ_box_sizing:
      {
        if (val_hash == SQZ_border_box)
        {
          s->box_sizing = CTX_BOX_SIZING_BORDER_BOX;
          s->box_sizing = CTX_BOX_SIZING_CONTENT_BOX;
        }
      }
      break;
    case SQZ_float:
      switch (val_hash)
      {
        case SQZ_left:  s->float_ = CTX_FLOAT_LEFT;  break;
        case SQZ_right: s->float_ = CTX_FLOAT_RIGHT; break;
        default:        s->float_ = CTX_FLOAT_NONE;
      }
      break;
    case SQZ_overflow:
      switch(val_hash)
      {
        case SQZ_visible: s->overflow = CTX_OVERFLOW_VISIBLE; break;
        case SQZ_hidden:  s->overflow = CTX_OVERFLOW_HIDDEN;  break;
        case SQZ_scroll:  s->overflow = CTX_OVERFLOW_SCROLL;  break;
        case SQZ_auto:    s->overflow = CTX_OVERFLOW_AUTO;    break;
        default:          s->overflow = CTX_OVERFLOW_VISIBLE; break;
      }
      break;
    case SQZ_clear:
      switch(val_hash)
      {
        case SQZ_left:  s->clear = CTX_CLEAR_LEFT;  break;
        case SQZ_right: s->clear = CTX_CLEAR_RIGHT; break;
        case SQZ_both:  s->clear = CTX_CLEAR_BOTH;  break;
        default:        s->clear = CTX_CLEAR_NONE;  break;
      }
      break;
    case SQZ_font_style:
      switch(val_hash)
      {
        case SQZ_italic:  s->font_style = CTX_FONT_STYLE_ITALIC;  break;
        case SQZ_oblique: s->font_style = CTX_FONT_STYLE_OBLIQUE; break;
        default:          s->font_style = CTX_FONT_STYLE_NORMAL;
  #if 0 // XXX
        cairo_select_font_face (mrg_ctx (mrg),
            s->font_family,
            s->font_style,
            s->font_weight);
  #endif
      }
      break;
    case SQZ_font_family:
      {
        SET_PROPS(font_family, value);
        if (!strcmp (value, "monospace"))
          value = "Mono";
        ctx_font (mrg_ctx (mrg), value);
      }
      break;
    case SQZ_syntax_highlight:
      SET_PROPS(syntax_highlight, value);
      break;
    case SQZ_fill_rule:
      switch (val_hash)
      { 
        default:
        case  SQZ_evenodd: s->fill_rule = CTX_FILL_RULE_EVEN_ODD; break;
        case  SQZ_nonzero: s->fill_rule = CTX_FILL_RULE_WINDING;  break;
      }
      if (s->fill_rule == CTX_FILL_RULE_EVEN_ODD)
        ctx_fill_rule (mrg_ctx (mrg), CTX_FILL_RULE_EVEN_ODD);
      else
        ctx_fill_rule (mrg_ctx (mrg), CTX_FILL_RULE_WINDING);
      break;
    case SQZ_stroke_linejoin:
      switch (val_hash)
      { 
        case SQZ_miter: s->stroke_linejoin = CTX_JOIN_MITER; break;
        case SQZ_round: s->stroke_linejoin = CTX_JOIN_ROUND; break;
        case SQZ_bevel: s->stroke_linejoin = CTX_JOIN_BEVEL; break;
        default:        s->stroke_linejoin = CTX_JOIN_MITER;
      }
      ctx_line_join (mrg_ctx (mrg), (CtxLineJoin)s->stroke_linejoin);
      break;
    case SQZ_stroke_linecap:
      switch (val_hash)
      { 
        case  SQZ_butt:   s->stroke_linecap = CTX_CAP_NONE;   break;
        case  SQZ_round:  s->stroke_linecap = CTX_CAP_ROUND;  break;
        case  SQZ_square: s->stroke_linecap = CTX_CAP_SQUARE; break;
        default:          s->stroke_linecap = CTX_CAP_NONE;
      }
      // XXX : keep track of what we have set - so we at least do not
      // keep re-setting it..
      ctx_line_cap (mrg_ctx (mrg), s->stroke_linecap);
      break;
    case SQZ_vertical_align:
      switch (val_hash)
      {
        case SQZ_middle: s->vertical_align = CTX_VERTICAL_ALIGN_MIDDLE; break;
        case SQZ_top:    s->vertical_align = CTX_VERTICAL_ALIGN_TOP;    break;
        case SQZ_sub:    s->vertical_align = CTX_VERTICAL_ALIGN_SUB;    break;
        case SQZ_super:  s->vertical_align = CTX_VERTICAL_ALIGN_SUPER;  break;
        case SQZ_bottom: s->vertical_align = CTX_VERTICAL_ALIGN_BOTTOM; break;
        default:         s->vertical_align = CTX_VERTICAL_ALIGN_BASELINE;
      }
      break;
    case SQZ_cursor:
      switch (val_hash)
      {
        default:
        case SQZ_default:       s->cursor = MRG_CURSOR_DEFAULT;      break;
        case SQZ_auto:          s->cursor = MRG_CURSOR_AUTO;         break;
        case SQZ_alias:         s->cursor = MRG_CURSOR_ALIAS;        break;
        case SQZ_all_scroll:    s->cursor = MRG_CURSOR_ALL_SCROLL;   break;
        case SQZ_cell:          s->cursor = MRG_CURSOR_CELL;         break;
        case SQZ_context_menu:  s->cursor = MRG_CURSOR_CONTEXT_MENU; break;
        case SQZ_col_resize:    s->cursor = MRG_CURSOR_COL_RESIZE;   break;
        case SQZ_copy:          s->cursor = MRG_CURSOR_COPY;         break;
        case SQZ_crosshair:     s->cursor = MRG_CURSOR_CROSSHAIR;    break;
        case SQZ_e_resize:      s->cursor = MRG_CURSOR_E_RESIZE;     break;
        case SQZ_ew_resize:     s->cursor = MRG_CURSOR_EW_RESIZE;    break;
        case SQZ_help:          s->cursor = MRG_CURSOR_HELP;         break;
        case SQZ_move:          s->cursor = MRG_CURSOR_MOVE;         break;
        case SQZ_n_resize:      s->cursor = MRG_CURSOR_N_RESIZE;     break;
        case SQZ_ne_resize:     s->cursor = MRG_CURSOR_NE_RESIZE;    break;
        case SQZ_nesw_resize:   s->cursor = MRG_CURSOR_NESW_RESIZE;  break;
        case SQZ_ns_resize:     s->cursor = MRG_CURSOR_NS_RESIZE;    break;
        case SQZ_nw_resize:     s->cursor = MRG_CURSOR_NW_RESIZE;    break;
        case SQZ_no_drop:       s->cursor = MRG_CURSOR_NO_DROP;      break;
        case SQZ_none:          s->cursor = MRG_CURSOR_NONE;         break;
        case SQZ_not_allowed:   s->cursor = MRG_CURSOR_NOT_ALLOWED;  break;
        case SQZ_pointer:       s->cursor = MRG_CURSOR_POINTER;      break;
        case SQZ_progress:      s->cursor = MRG_CURSOR_PROGRESS;     break;
        case SQZ_row_resize:    s->cursor = MRG_CURSOR_ROW_RESIZE;   break;
        case SQZ_s_resize:      s->cursor = MRG_CURSOR_S_RESIZE;     break;
        case SQZ_se_resize:     s->cursor = MRG_CURSOR_SE_RESIZE;    break;
        case SQZ_sw_resize:     s->cursor = MRG_CURSOR_SW_RESIZE;    break;
        case SQZ_text:          s->cursor = MRG_CURSOR_TEXT;         break;
        case SQZ_vertical_text: s->cursor = MRG_CURSOR_VERTICAL_TEXT;break;
        case SQZ_w_resize:      s->cursor = MRG_CURSOR_W_RESIZE;     break;
        case SQZ_cursor_wait:   s->cursor = MRG_CURSOR_WAIT;         break;
        case SQZ_zoom_in:       s->cursor = MRG_CURSOR_ZOOM_IN;      break;
        case SQZ_zoom_out:      s->cursor = MRG_CURSOR_ZOOM_OUT;     break;
      }
      break;
    case SQZ_display:
      switch (val_hash)
      {
        case SQZ_none:
        case SQZ_hidden:       s->display = CTX_DISPLAY_NONE;         break;
        case SQZ_block:        s->display = CTX_DISPLAY_BLOCK;        break;
        case SQZ_list_item:    s->display = CTX_DISPLAY_LIST_ITEM;    break;
        case SQZ_inline_block: s->display = CTX_DISPLAY_INLINE_BLOCK; break;
        case SQZ_flow_root:    s->display = CTX_DISPLAY_FLOW_ROOT;    break;
        default:               s->display = CTX_DISPLAY_INLINE;
      }
      break;
    case SQZ_position:
      switch (val_hash)
      {
        case SQZ_relative:  s->position = CTX_POSITION_RELATIVE; break;
        case SQZ_static:    s->position = CTX_POSITION_STATIC;   break;
        case SQZ_absolute:  s->position = CTX_POSITION_ABSOLUTE; break;
        case SQZ_fixed:     s->position = CTX_POSITION_FIXED;    break;
        default:            s->position = CTX_POSITION_STATIC;
      }
      break;
    case SQZ_direction:
      switch (val_hash)
      {
        case SQZ_rtl: s->direction = CTX_TEXT_DIRECTION_RTL; break;
        case SQZ_ltr: s->direction = CTX_TEXT_DIRECTION_LTR; break;
        default:      s->direction = CTX_TEXT_DIRECTION_LTR;
      }
      break;
    case SQZ_unicode_bidi:
      switch (val_hash)
      {
        case SQZ_normal: s->unicode_bidi = CTX_UNICODE_BIDI_NORMAL; break;
        case SQZ_embed:  s->unicode_bidi = CTX_UNICODE_BIDI_EMBED;  break;
        case SQZ_bidi_override: s->unicode_bidi = CTX_UNICODE_BIDI_BIDI_OVERRIDE; break;
        default:         s->unicode_bidi = CTX_UNICODE_BIDI_NORMAL; break;
      }
      break;
    case SQZ_text_align:
    case SQZ_text_anchor:
      switch (val_hash)
      {
        case SQZ_start:   s->text_align = CTX_TEXT_ALIGN_START;   break;
        case SQZ_end:     s->text_align = CTX_TEXT_ALIGN_END;     break;
        case SQZ_left:    s->text_align = CTX_TEXT_ALIGN_LEFT;    break;
        case SQZ_right:   s->text_align = CTX_TEXT_ALIGN_RIGHT;   break;
        case SQZ_justify: s->text_align = CTX_TEXT_ALIGN_JUSTIFY; break;
        case SQZ_middle:
        case SQZ_center:  s->text_align = CTX_TEXT_ALIGN_CENTER;  break;
        default:          s->text_align = CTX_TEXT_ALIGN_LEFT;
      }
      break;
    case SQZ_text_decoration:
      switch (val_hash)
      {
        case SQZ_reverse:     s->text_decoration|= CTX_TEXT_DECORATION_REVERSE; break;
        case SQZ_underline:   s->text_decoration|= CTX_TEXT_DECORATION_UNDERLINE; break;
        case SQZ_overline:    s->text_decoration|= CTX_TEXT_DECORATION_OVERLINE; break;
        case SQZ_linethrough: s->text_decoration|= CTX_TEXT_DECORATION_LINETHROUGH; break;
        case SQZ_blink:       s->text_decoration|= CTX_TEXT_DECORATION_BLINK; break;
        case SQZ_none:
          s->text_decoration ^= (s->text_decoration &
        (CTX_TEXT_DECORATION_UNDERLINE|CTX_TEXT_DECORATION_REVERSE|CTX_TEXT_DECORATION_OVERLINE|CTX_TEXT_DECORATION_LINETHROUGH|CTX_TEXT_DECORATION_BLINK));
        break;
      }
      break;
  }
}

static void ctx_css_handle_property_pass1med (Css *mrg, uint32_t key,
                                              const char *value)
{
  CtxStyle *s = ctx_style (mrg);

  if (key == SQZ_width)
  {
    if (ctx_strhash (value) == SQZ_auto)
    {
      s->width_auto = 1;
      SET_PROP(width, 42);
    }
    else
    {
      s->width_auto = 0;
      SET_PROP(width, mrg_parse_px_x (mrg, value, NULL));

      if (s->position == CTX_POSITION_FIXED) // XXX: seems wrong
      {
        //s->width -= s->border_left_width + s->border_right_width;
      }
    }
  }
}

enum
{
  MRG_CSS_PROPERTY_PARSER_STATE_NEUTRAL = 0,
  MRG_CSS_PROPERTY_PARSER_STATE_IN_NAME,
  MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_COLON,
  MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_VAL,
  MRG_CSS_PROPERTY_PARSER_STATE_IN_VAL
};

static void css_parse_properties (Css *mrg, const char *style,
  void (*handle_property) (Css *mrg, uint32_t key,
                           const char *value))
{
  const char *p;
  char name[CTX_MAX_CSS_STRINGLEN] = "";
  char string[CTX_MAX_CSS_STRINGLEN] = "";
  int name_l = 0;
  int string_l = 0;
  int state = MRG_CSS_PROPERTY_PARSER_STATE_NEUTRAL;
  if (!style)
    return;
  for (p = style; *p; p++)
  {
    switch (state)
    {
      case MRG_CSS_PROPERTY_PARSER_STATE_NEUTRAL:
        switch (*p)
        {
          case ' ':
          case '\t':
          case ';':
          case '\n':
          case '\r':
            break;
          default:
            if (name_l < CTX_MAX_CSS_STRINGLEN - 1)
              name[name_l++]=*p;
            name[name_l]=0;
            state = MRG_CSS_PROPERTY_PARSER_STATE_IN_NAME;
            break;
        }
        break;
      case MRG_CSS_PROPERTY_PARSER_STATE_IN_NAME:
        switch (*p)
        {
          case ':':
            state = MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_VAL;
            break;
          case ' ':
          case '\n':
          case '\r':
          case '\t':
            state = MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_COLON;
            break;
#if 0
          case '-':
            name[name_l++]='_';
            name[name_l]=0;
            break;
#endif
          default:
            if (name_l < CTX_MAX_CSS_STRINGLEN - 1)
              name[name_l++]=*p;
            name[name_l]=0;
            break;
        }
        break;
      case MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_COLON:
        switch (*p)
        {
          case ':':
            state = MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_VAL;
            break;
          default:
            break;
        }
        break;
      case MRG_CSS_PROPERTY_PARSER_STATE_EXPECT_VAL:
        switch (*p)
        {
          case ' ':
          case '\n':
          case '\r':
          case '\t':
            break;
          default:
            if (string_l < CTX_MAX_CSS_STRINGLEN - 1)
              string[string_l++]=*p;
            string[string_l]=0;
            state = MRG_CSS_PROPERTY_PARSER_STATE_IN_VAL;
            break;
        }
        break;
      case MRG_CSS_PROPERTY_PARSER_STATE_IN_VAL:
        switch (*p)
        {
          case ';':
#if 0
            for (int i = 0; name[i];i++)
              if (name[i]=='-')name[i]='_';
#endif
            handle_property (mrg, ctx_strhash (name), string);
            state = MRG_CSS_PROPERTY_PARSER_STATE_NEUTRAL;
            name_l = 0;
            name[0] = 0;
            string_l = 0;
            string[0] = 0;
            break;
          default:
            if (string_l < CTX_MAX_CSS_STRINGLEN - 1)
              string[string_l++]=*p;
            string[string_l]=0;
            break;
        }
        break;
    }
  }
  if (name[0])
  {
#if 0
    for (int i = 0; name[i];i++)
      if (name[i]=='-')
        name[i]='_';
#endif
    handle_property (mrg, ctx_strhash (name), string);
  }
}


static void ctx_css_handle_property_pass2 (Css *mrg, uint32_t key,
                                           const char *value)
{
  /* this pass contains things that might depend on values
   * generated by the previous pass.
   */
  CtxStyle *s = ctx_style (mrg);

  if (key == SQZ_right)
  {
    float width = PROP(width);
    float right = mrg_parse_px_x (mrg, value, NULL);

    SET_PROP(right, right);

    if (width == 0)
    {
      width = 8 * s->font_size;
      mrg_queue_draw (mrg, NULL);
    }
    SET_PROP(right, right);
    SET_PROP(left,
         (mrg_width(mrg)-right) - width - PROP(border_left_width) - PROP(padding_left) - PROP(padding_right) - PROP(border_right_width) - PROP(margin_right));
  }
  else if (key == SQZ_bottom)
  {
    float height = PROP(height);

    SET_PROP (bottom, mrg_parse_px_y (mrg, value, NULL));

    if (height == 0)
    {
            // XXX
      height = 2 * s->font_size;
      mrg_queue_draw (mrg, NULL);
    }
    SET_PROP(top, mrg_height(mrg) - PROP(bottom) - height - PROP(padding_top) - PROP(border_top_width) - PROP(padding_bottom) - PROP(border_bottom_width) - PROP(margin_bottom));
  }
}


static float deco_width (Css *mrg)
{
  return PROP (padding_left) + PROP(padding_right) + PROP(border_left_width) + PROP(border_right_width);
}

void css_set_style (Css *mrg, const char *style)
{
  CtxStyle *s;

  css_parse_properties (mrg, style, ctx_css_handle_property_pass0);
  css_parse_properties (mrg, style, ctx_css_handle_property_pass1);
  css_parse_properties (mrg, style, ctx_css_handle_property_pass1med);

  s = ctx_style (mrg);

  if (!mrg->in_svg)
  {
  if (s->position == CTX_POSITION_STATIC &&
      !s->float_)
  {
    if (s->width_auto && (s->margin_right_auto || s->margin_left_auto))
    {
      if (s->margin_left_auto && s->margin_right_auto)
      {
        s->margin_right_auto = 0;
      }
      else if (s->margin_left_auto)
        s->margin_left_auto = 0;
      else
        s->margin_right_auto = 0;
    }

    if ( s->margin_left_auto && !s->width_auto && !s->margin_right_auto)
    {
      SET_PROP (margin_left,
        (mrg->state->edge_right - mrg->state->edge_left)
        - deco_width (mrg) - PROP(margin_right) - PROP(width));
    }
    else if ( !s->margin_left_auto &&
              s->width_auto &&
              !s->margin_right_auto)
    {
      SET_PROP (width,
        (mrg->state->edge_right - mrg->state->edge_left)
        - deco_width (mrg) - PROP(margin_left) - PROP(margin_right));
    }
    else if ( !s->margin_left_auto && !s->width_auto && s->margin_right_auto)
    {
      SET_PROP (margin_right,
        (mrg->state->edge_right - mrg->state->edge_left)
        - deco_width (mrg) - PROP(margin_left) - PROP(width));
    }
    else if ( s->margin_left_auto && !s->width_auto && s->margin_right_auto)
    {
      float avail_width = (mrg->state->edge_right - mrg->state->edge_left) - deco_width (mrg);
      float width = PROP(width);
      if (width == 0.0f)
      {
         float max_width = PROP(max_width);
         float min_width = PROP(min_width);
         if (max_width != 0.0f)
           width = ctx_minf (max_width, avail_width);
         else
           width = avail_width; // should not happen?
         if (min_width != 0.0f)
         {
           if (width < min_width) width = min_width;
         }

      }

      {
        float val = (avail_width - width)/2;
        SET_PROP (margin_left, val);
        SET_PROP (margin_right, val);
      }
    }
  }

  }

  css_parse_properties (mrg, style, ctx_css_handle_property_pass2);
}

void _css_set_style_properties (Css *mrg, const char *style_properties)
{
  _ctx_initial_style (mrg);

  if (style_properties)
  {
    css_set_style (mrg, style_properties);
  }
}

void
css_set_stylef (Css *mrg, const char *format, ...)
{
  va_list ap;
  size_t needed;
  char  *buffer;
  va_start(ap, format);
  needed = vsnprintf(NULL, 0, format, ap) + 1;
  buffer = malloc(needed);
  va_end (ap);
  va_start(ap, format);
  vsnprintf(buffer, needed, format, ap);
  va_end (ap);
  css_set_style (mrg, buffer);
  free (buffer);
}

void ctx_style_defaults (Css *mrg)
{
  Ctx *ctx = mrg->ctx;
  float em = 32;
  mrg_set_em (mrg,  em);
  mrg_set_rem (mrg, em);
  css_set_edge_left (mrg, 0);
  css_set_edge_right (mrg, mrg_width (mrg));
  css_set_edge_bottom (mrg, mrg_height (mrg));
  css_set_edge_top (mrg, 0);
  mrg_set_line_height (mrg, 1.2);

  SET_PROP(stroke_width, 1.0f);
  {
    CtxColor *color = ctx_color_new ();
    ctx_color_set_from_string (mrg->ctx, color, "transparent");
    ctx_set_color (ctx, SQZ_stroke_color, color);
    ctx_color_free (color);
  }
  {
    CtxColor *color = ctx_color_new ();
    ctx_color_set_from_string (mrg->ctx, color, "black");
    ctx_set_color (ctx, SQZ_fill_color, color);
    ctx_color_free (color);
  }
  {
    CtxColor *color = ctx_color_new ();
    ctx_color_set_from_string (mrg->ctx, color, "green");
    ctx_set_color (ctx, SQZ_color, color);
    ctx_color_free (color);
  }

  ctx_stylesheet_clear (mrg);
  _ctx_initial_style (mrg);

  if (mrg->style_global->length)
  {
    ctx_stylesheet_add (mrg, mrg->style_global->str, NULL, CTX_STYLE_GLOBAL, NULL);
  }

  if (mrg->style->length)
    ctx_stylesheet_add (mrg, mrg->style->str, NULL, CTX_STYLE_GLOBAL, NULL);
}

void mrg_set_mrg_get_contents (Css *mrg,
  int (*mrg_get_contents) (const char  *referer,
                      const char  *input_uri,
                      char       **contents,
                      long        *length,
                      void        *get_contents_data),
  void *get_contents_data)

{
  mrg->mrg_get_contents = mrg_get_contents;
  mrg->get_contents_data = get_contents_data;
}

int
mrg_get_contents (Css         *mrg,
                  const char  *referer,
                  const char  *input_uri,
                  char       **contents,
                  long        *length)
{
  if (!referer) referer = mrg->uri_base;
  if (mrg->mrg_get_contents)
  {
    int ret;
    ret = mrg->mrg_get_contents (referer, input_uri, contents, length,
                                 mrg->get_contents_data);
    return ret;
  }
  else
  {
    *contents = NULL;
    *length = 0;
    return -1;
  }
}

int css_print (Css *mrg, const char *string);
static int is_block_item (CtxStyle *style)
{
  return ((style->display == CTX_DISPLAY_BLOCK
           ||style->float_
           ||style->display == CTX_DISPLAY_LIST_ITEM
           ||style->display == CTX_DISPLAY_FLOW_ROOT
           ||style->display == CTX_DISPLAY_INLINE_BLOCK
           ));
}

float mrg_ddpx (Css *mrg)
{
  return mrg->ddpx;
}

static void
mrg_ctx_set_source_color (Ctx *ctx, CtxColor *color)
{
   float rgba[4];
   ctx_color_get_rgba (ctx_get_state (ctx), color, rgba);
   ctx_rgba (ctx, rgba[0], rgba[1], rgba[2], rgba[3]);
}

static void set_line_height (Ctx *ctx, void *userdata, const char *name, int count, float *x, float *y, float *w, float *h)
{
  float *fptr = (float*)userdata;
  *y = fptr[0];
}

static void _mrg_nl (Css *mrg)
{
  float ascent, descent;
  ctx_font_extents (mrg->ctx, &ascent, &descent, NULL);
  mrg->y += mrg->line_max_height[mrg->line_level] * mrg->state->style.line_height;
  float val = mrg->line_max_height[mrg->line_level]* ascent;
  char name[10]="lin_";
  name[3]=mrg->line_level+2;

  ctx_resolve (mrg->ctx, name, set_line_height, &val);
  mrg->line_max_height[mrg->line_level]=0.0f;
  mrg->line_got_baseline[mrg->line_level]=0;

  mrg->x = _mrg_dynamic_edge_left(mrg);
#ifdef SNAP
  float em = mrg_em (mrg);  /* XXX: a global body-line spacing 
                               snap is better grid design */
  mrg->x = ceil (mrg->x / em) * em;
  mrg->y = ceil (mrg->y / em) * em;
#endif

  if (mrg->y >= 
      mrg->state->edge_bottom - PROP(padding_bottom))
  {
    mrg->state->overflowed=1;
  }
}

void _mrg_layout_pre (Css *mrg)
{
  CtxStyle *style;
  float dynamic_edge_left, dynamic_edge_right;


  style = ctx_style (mrg);

  mrg->state->original_x = mrg_x (mrg);
  mrg->state->original_y = mrg_y (mrg);

  mrg->state->flow_root = (style->display == CTX_DISPLAY_FLOW_ROOT ||
                            style->float_ != CTX_FLOAT_NONE ||
                           style->display == CTX_DISPLAY_INLINE_BLOCK ||
                          style->overflow != CTX_OVERFLOW_VISIBLE);
  if (mrg->state->flow_root)
    mrg->state->float_base = mrg->floats;

  // newline hacks
  if (mrg->state->style_node.element_hash == SQZ_br
      || ( mrg->unresolved_line && is_block_item (style))
                  )
  {
    _mrg_nl (mrg);
  }

  if (is_block_item (style))
  {
     mrg->line_level++;
     mrg->line_max_height[mrg->line_level] = 0.0f;
     mrg->line_got_baseline[mrg->line_level]=0;


  }
     mrg->unresolved_line = 0;



  if (mrg->state_no)
  {
    dynamic_edge_right = _mrg_parent_dynamic_edge_right(mrg);
    dynamic_edge_left  = _mrg_parent_dynamic_edge_left(mrg);
  }
  else
  {
    dynamic_edge_right = mrg_edge_right(mrg);
    dynamic_edge_left  = mrg_edge_left(mrg);
  }

  if (style->clear & CTX_CLEAR_RIGHT)
    clear_right (mrg);
  if (style->clear & CTX_CLEAR_LEFT)
    clear_left (mrg);

  // extra box dimensions once, reducing overhead of property storage
  //
  float padding_left = PROP(padding_left);
  float margin_left = PROP(margin_left);
  float border_left_width = PROP(border_left_width);
  float padding_right = PROP(padding_right);
  float margin_right = PROP(margin_right);
  float border_right_width = PROP(border_right_width);
  float padding_top = PROP(padding_top);
  float margin_top = PROP(margin_top);
  float border_top_width = PROP(border_top_width);
  float padding_bottom = PROP(padding_bottom);
  //float margin_bottom = PROP(margin_bottom);
  float border_bottom_width = PROP(border_bottom_width);

  float left = PROP(left);
  float top = PROP(top);
  float width = PROP(width);
  float height = PROP(height);

  if (style->display == CTX_DISPLAY_BLOCK ||
      style->display == CTX_DISPLAY_FLOW_ROOT ||
      style->display == CTX_DISPLAY_LIST_ITEM)
  {
    if (padding_left + margin_left + border_left_width != 0)
    {
      css_set_edge_left (mrg, mrg_edge_left (mrg) +
        padding_left + margin_left + border_left_width);
    }
    if (padding_right + margin_right + border_right_width
        != 0)
    {
      css_set_edge_right (mrg, mrg_edge_right (mrg) -
        (padding_right + margin_right + border_right_width));
    }


    /* collapsing of vertical margins */
    float actual_top = margin_top;
    if (actual_top >= mrg->state->vmarg)
      actual_top = actual_top - mrg->state->vmarg;
    else
      actual_top = 0;

    css_set_edge_top (mrg, mrg_y (mrg) + border_top_width + padding_top + actual_top);

    mrg->state->block_start_x = mrg_edge_left (mrg);
    mrg->state->block_start_y = mrg_y (mrg);
 // mrg->floats = 0;
  }
  else if (style->display == CTX_DISPLAY_INLINE_BLOCK)
  {
    float left_margin_pad_and_border  = padding_left + margin_left + border_left_width;
    float right_margin_pad_and_border = padding_right + margin_right + border_right_width;

    if (mrg_x (mrg) + width + left_margin_pad_and_border + right_margin_pad_and_border
                    >= dynamic_edge_right)
       _mrg_nl (mrg);

    if (left_margin_pad_and_border != 0.0f)
    {
      css_set_edge_left (mrg, mrg_x (mrg) +
        padding_left + margin_left + border_left_width);
    }


#if 0
    if (right_margin_pad_and_border != 0.0f)
    {
      css_set_edge_right (mrg, mrg_edge_right (mrg) - right_margin_pad_and_border);
    }
#else
      css_set_edge_right (mrg, mrg_x (mrg) + width);
#endif

    css_set_edge_top (mrg, mrg_y (mrg) + border_top_width);// + actual_top);

    mrg->state->block_start_x = mrg_x (mrg);
    mrg->state->block_start_y = mrg_y (mrg);
 //   mrg->floats = 0;
  }
          

  /* the list-item is a cheap hack; can be implemented directly
   * in later versions of css
   */
  if (style->display == CTX_DISPLAY_LIST_ITEM)
  {
    float x = mrg->x;
    
    mrg->x -= mrg_em (mrg) * 0.5;
    css_print (mrg, "•");
    mrg->x = x;
    mrg->line_max_height[mrg->line_level] = 0.0f;
    mrg->line_got_baseline[mrg->line_level]=0;
  }

  switch (style->position)
  {
    case CTX_POSITION_RELATIVE:
      /* XXX: deal with style->right and style->bottom */
      ctx_translate (mrg_ctx (mrg), left, top);
      mrg->relative_x += left;
      mrg->relative_y += top;
      /* fallthrough */

    case CTX_POSITION_STATIC:

      if (style->float_ == CTX_FLOAT_RIGHT)
      {
        if (width == 0.0)
        {
          width = mrg_edge_right (mrg) - mrg_edge_left (mrg);
        }

        width = (width + padding_right + padding_left + border_left_width + border_right_width);


        if (width + margin_left + margin_right >
            mrg_edge_right(mrg)-mrg_edge_left(mrg))
        {
          clear_both (mrg);
          css_set_edge_left (mrg, mrg_edge_right (mrg) - width);
          css_set_edge_right (mrg, mrg_edge_right (mrg) - (margin_right + padding_right + border_right_width));

        }
        else
        {
        while (dynamic_edge_right - dynamic_edge_left < width + margin_left + margin_right)
        {
          mrg_set_xy (mrg, mrg_x (mrg), mrg_y (mrg) + 1.0);
          dynamic_edge_right = _mrg_parent_dynamic_edge_right(mrg);
          dynamic_edge_left = _mrg_parent_dynamic_edge_left(mrg);
        }

        css_set_edge_left (mrg, dynamic_edge_right - width);
        css_set_edge_right (mrg, dynamic_edge_right - (margin_right + padding_right + border_right_width));

        }

        css_set_edge_top (mrg, mrg_y (mrg) + (PROP(margin_top))); // - mrg->state->vmarg));

        mrg->state->block_start_x = mrg_x (mrg);
        mrg->state->block_start_y = mrg_y (mrg);
        //mrg->floats = 0;

      } else if (style->float_ == CTX_FLOAT_LEFT)
      {
        float left;
        float widt = width;

        if (widt == 0.0)
        {
          widt = 4 * mrg_em (mrg);//mrg_edge_right (mrg) - mrg_edge_left (mrg);
        }

        widt = (widt + padding_right + padding_left + border_left_width + border_right_width);

        if (widt + margin_left + margin_right >
            mrg_edge_right(mrg)-mrg_edge_left(mrg))
        {
          clear_both (mrg);
          left = mrg_edge_left (mrg) + padding_left + border_left_width + margin_left;
        }
        else
        {
        while (dynamic_edge_right - dynamic_edge_left < widt + margin_left + margin_right)
        {
          mrg_set_xy (mrg, mrg_x (mrg), mrg_y (mrg) + 1.0);
          dynamic_edge_right = _mrg_parent_dynamic_edge_right(mrg);
          dynamic_edge_left = _mrg_parent_dynamic_edge_left(mrg);
        }
          left = dynamic_edge_left;// + padding_left + border_left_width + margin_left;
        }

        css_set_edge_left (mrg, left);
        css_set_edge_right (mrg,  left + widt +
            padding_left /* + border_right_width*/);
        css_set_edge_top (mrg, mrg_y (mrg) + (margin_top));// - mrg->state->vmarg));
                        //));//- mrg->state->vmarg));
        mrg->state->block_start_x = mrg_x (mrg);
        mrg->state->block_start_y = mrg_y (mrg);// + padding_top + border_top_width;
        //mrg->floats = 0;

        /* change cursor point after floating something left; if pushed far
         * down, the new correct
         */
#if 0
        if(0)   
        mrg_set_xy (mrg, mrg->state->original_x = left + width + padding_left + border_right_width + padding_right + margin_right + margin_left + border_left_width,
            mrg_y (mrg) + padding_top + border_top_width);
#endif
      } /* XXX: maybe spot for */
      else if (1)
      {
         if (width)
           css_set_edge_right (mrg, mrg->state->block_start_x  + width);
      }
      break;
    case CTX_POSITION_ABSOLUTE:
      ctx_get_drawlist (mrg->ctx, &mrg->state->drawlist_start_offset);
      mrg->state->drawlist_start_offset--;
      {
        if (left == 0.0f) // XXX 0.0 should also be a valid value!
          left = mrg->x;
        if (top == 0.0f)  // XXX 0.0 should also be a valid value!
          top = mrg->y;

        //mrg->floats = 0;
        css_set_edge_left (mrg, left + margin_left + border_left_width + padding_left);
        css_set_edge_right (mrg, left + width);
        css_set_edge_top (mrg, top + margin_top + border_top_width + padding_top);
        mrg->state->block_start_x = mrg_x (mrg);
        mrg->state->block_start_y = mrg_y (mrg);
      }
      break;
    case CTX_POSITION_FIXED:
      ctx_get_drawlist (mrg->ctx, &mrg->state->drawlist_start_offset);
      mrg->state->drawlist_start_offset--;
      {
        if (!width)
        {
          width = mrg_edge_right (mrg) - mrg_edge_left (mrg);
        }

        ctx_translate (mrg_ctx(mrg), 0, css_panel_scroll (mrg));
        ctx_scale (mrg_ctx(mrg), mrg_ddpx (mrg), mrg_ddpx (mrg));
        //mrg->floats = 0;

        css_set_edge_left (mrg, left + margin_left + border_left_width + padding_left);
        css_set_edge_right (mrg, left + margin_left + border_left_width + padding_left + width);
        css_set_edge_top (mrg, top + margin_top + border_top_width + padding_top);
        mrg->state->block_start_x = mrg_x (mrg);
        mrg->state->block_start_y = mrg_y (mrg);
      }
      break;
  }

  if (is_block_item (style))
  {
     if (!height)
       {
         height = mrg_em (mrg) * 4;
       }
     if (!width)
       {
         width = mrg_em (mrg) * 4;
       }

    if (height  /* XXX: if we knew height of dynamic elements
                        from previous frame, we could use it here */
       && style->overflow == CTX_OVERFLOW_HIDDEN)
       {
         ctx_rectangle (mrg_ctx(mrg),
            mrg->state->block_start_x - padding_left - border_left_width,
            mrg->state->block_start_y - mrg_em(mrg) - padding_top - border_top_width,
            width + border_right_width + border_left_width + padding_left + padding_right, //mrg_edge_right (mrg) - mrg_edge_left (mrg) + padding_left + padding_right + border_left_width + border_right_width,
            height + padding_top + padding_bottom + border_top_width + border_bottom_width);
         ctx_clip (mrg_ctx(mrg));
       }

    mrg->state->ptly = 0;
    char name[10]="ele_";
    name[3]=mrg->state_no+2;

  CtxColor *background_color = ctx_color_new ();
  ctx_get_color (mrg->ctx, SQZ_background_color, background_color);
  if (!ctx_color_is_transparent (background_color))
  {
    mrg_ctx_set_source_color (mrg->ctx, background_color);
    if (is_block_item (style))
    {
      ctx_reset_path (mrg->ctx); // XXX : this should not need be here!
      ctx_deferred_rectangle (mrg->ctx, name,
         mrg->state->block_start_x - padding_left,
         mrg->state->block_start_y - padding_top,
         width + padding_left + padding_right,
         height + padding_top + padding_bottom);
    }
    else
    {
      ctx_deferred_rectangle (mrg->ctx, name,
         mrg_x (mrg), mrg_y (mrg),
         width  + padding_left + padding_right,
         height + padding_top + padding_bottom);
    }
    ctx_fill (mrg->ctx);
  }
  ctx_color_free (background_color);
  }
}
void _mrg_layout_post (Css *mrg, CtxFloatRectangle *ret_rect);

void css_set_style (Css *mrg, const char *style);

void css_start_with_style (Css        *mrg,
                           const char *style_id,
                           void       *id_ptr,
                           const char *style)
{
  mrg->states[mrg->state_no].children++;
  if (mrg->state_no+1 >= CTX_MAX_STATES)
    return;
  mrg->state_no++; 
  mrg->state = &mrg->states[mrg->state_no];
  *mrg->state = mrg->states[mrg->state_no-1];
  mrg->states[mrg->state_no].children = 0;
  mrg->state->style_id = style_id ? strdup (style_id) : NULL;

  ctx_parse_style_id (mrg, mrg->state->style_id, &mrg->state->style_node);

  mrg->state->style.id_ptr = id_ptr;

  ctx_save (mrg_ctx (mrg));

  _ctx_initial_style (mrg);

  {
    char *collated_style = _ctx_stylesheet_collate_style (mrg);
    if (collated_style)
    {
      css_set_style (mrg, collated_style);
      free (collated_style);
    }
  }
  if (style)
  {
    css_set_style (mrg, style);
  }
  _mrg_layout_pre (mrg);
}

void
css_start_with_stylef (Css *mrg, const char *style_id, void *id_ptr,
                       const char *format, ...)
{
  va_list ap;
  size_t needed;
  char  *buffer;
  va_start(ap, format);
  needed = vsnprintf(NULL, 0, format, ap) + 1;
  buffer = malloc(needed);
  va_end (ap);
  va_start(ap, format);
  vsnprintf(buffer, needed, format, ap);
  va_end (ap);
  css_start_with_style (mrg, style_id, id_ptr, buffer);
  free (buffer);
}

void css_start (Css *mrg, const char *style_id, void *id_ptr)
{
  css_start_with_style (mrg, style_id, id_ptr, NULL);
}

static int compare_zindex (const void *a, const void *b, void *d)
{
  const CssAbsolute *ma = a;
  const CssAbsolute *mb = b;
  return mb->z_index- ma->z_index;
}

void css_end (Css *mrg, CtxFloatRectangle *ret_rect)
{
  _mrg_layout_post (mrg, ret_rect);
  if (mrg->state_no == 0)
  {
    ctx_list_reverse (&mrg->absolutes);
    ctx_list_sort (&mrg->absolutes, compare_zindex, NULL); // oh - wow, we do get some z-index with the drawlist use!

    /* TODO: handle negative z-index */
    /* TODO: also copy/paste registered interaction points */
    while (mrg->absolutes)
    {
      CssAbsolute *absolute = mrg->absolutes->data;
      ctx_save (mrg->ctx);
      ctx_translate (mrg->ctx, absolute->relative_x, absolute->relative_y);
      ctx_append_drawlist (mrg->ctx, absolute->entries+1, (absolute->count-1)*9);
      ctx_list_remove (&mrg->absolutes, absolute);
      free (absolute);
    }
  }
}

void  mrg_set_line_height (Css *mrg, float line_height);
float mrg_line_height (Css *mrg);


typedef struct _ItkCssDef ItkCssDef;

struct _ItkCssDef {
  uint32_t   id;
  CtxString *str;
  ItkCssDef *next;
};

static CtxString *css_svg_add_def (ItkCssDef **defs, uint32_t id)
{
  ItkCssDef *iter = *defs;
  while (iter)
  {
    if (iter->id == id)
      return iter->str;
    iter = iter->next;
  }
  iter = ctx_calloc (1, sizeof (ItkCssDef));
  iter->str = ctx_string_new ("");
  iter->id = id;
  iter->next = *defs;
  *defs = iter;
  return iter->str;
}

static void mrg_path_fill_stroke (Css *mrg, ItkCssDef **defs)
{
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *fill_color = ctx_color_new ();
  CtxColor *stroke_color = ctx_color_new ();

  const char *fill = ctx_get_string (mrg->ctx, SQZ_fill);
  const char *stroke = ctx_get_string (mrg->ctx, SQZ_stroke);


  ctx_get_color (ctx, SQZ_stroke_color, stroke_color);

  int has_stroke = (PROP(stroke_width) > 0.001f &&
                    (!ctx_color_is_transparent (stroke_color)
                     || (stroke != NULL)));

  if (fill && fill[0] == 'u' && strstr(fill, "url("))
  {
    char *id = strchr(fill, '#');
    if (id)
    {
      id ++;
      if (*id && id[strlen(id)-1]==')')
        id[strlen(id)-1]=0;
      if (*id && id[strlen(id)-1]=='\'')
        id[strlen(id)-1]=0;
      if (*id && id[strlen(id)-1]=='"')
        id[strlen(id)-1]=0;
      CtxString *str = css_svg_add_def (defs, ctx_strhash(id));
      ctx_parse (ctx, str->str);
    }

    if (has_stroke)
      ctx_preserve (ctx);
    ctx_fill (ctx);
  }
  else
  {

  ctx_get_color (ctx, SQZ_fill_color, fill_color);

  if (!ctx_color_is_transparent (fill_color))
  {
    mrg_ctx_set_source_color (ctx, fill_color);

    if (has_stroke)
      ctx_preserve (ctx);
    ctx_fill (ctx);
  }

  }
  ctx_color_free (fill_color);

  if (has_stroke)
  {
    ctx_line_width (ctx, PROP(stroke_width));
    if (stroke && stroke[0] == 'u' && strstr(stroke, "url("))
    {
      char *id = strchr(stroke, '#');
      if (id)
      {
        id ++;
        if (*id && id[strlen(id)-1]==')')
          id[strlen(id)-1]=0;
        if (*id && id[strlen(id)-1]=='\'')
          id[strlen(id)-1]=0;
        if (*id && id[strlen(id)-1]=='"')
          id[strlen(id)-1]=0;
        CtxString *str = css_svg_add_def (defs, ctx_strhash(id));
        ctx_parse (ctx, str->str);
      }
    }
    else
    {
      mrg_ctx_set_source_color (ctx, stroke_color);
    }
    ctx_stroke (ctx);
  }
  ctx_color_free (stroke_color);
}

void _mrg_border_top (Css *mrg, int x, int y, int width, int height)
{
  float border_top_width = PROP(border_top_width);
  if (border_top_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_top_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x - PROP(padding_left) - PROP(border_left_width),
                       y - PROP(padding_top) - border_top_width);
    ctx_rel_line_to (ctx, width + PROP(padding_left) + PROP(padding_right) + PROP(border_left_width) + PROP(border_right_width), 0);
    ctx_rel_line_to (ctx, -PROP(border_right_width), border_top_width);
    ctx_rel_line_to (ctx, - (width + PROP(padding_right) + PROP(padding_left)), 0);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }
  ctx_color_free (color);
}

void _mrg_border_bottom (Css *mrg, int x, int y, int width, int height)
{
  float border_bottom_width = PROP(border_bottom_width);
  if (border_bottom_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_top_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x + width + PROP(padding_right), y + height + PROP(padding_bottom));
    ctx_rel_line_to (ctx, PROP(border_right_width), border_bottom_width);
    ctx_rel_line_to (ctx, - (width + PROP(padding_left) + PROP(padding_right) + PROP(border_left_width) + PROP(border_right_width)), 0);
    ctx_rel_line_to (ctx, PROP(border_left_width), -border_bottom_width);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }

  ctx_color_free (color);
}

void _mrg_border_top_r (Css *mrg, int x, int y, int width, int height)
{
  float border_top_width = PROP(border_top_width);
  if (border_top_width < 0.01f)
    return;
  Ctx *cr = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (cr, SQZ_border_top_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (cr);
    ctx_reset_path (cr);
    ctx_move_to (cr, x, y - PROP(padding_top) - border_top_width);
    ctx_rel_line_to (cr, width + PROP(padding_right) + PROP(border_right_width), 0);
    ctx_rel_line_to (cr, -PROP(border_right_width), border_top_width);
    ctx_rel_line_to (cr, - (width + PROP(padding_right)), 0);

    mrg_ctx_set_source_color (cr, color);
    ctx_fill (cr);
  ctx_restore (cr);
  }
  ctx_color_free (color);
}
void _mrg_border_bottom_r (Css *mrg, int x, int y, int width, int height)
{
  float border_bottom_width = PROP(border_bottom_width);
  if (border_bottom_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_bottom_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x + width + PROP(padding_right), y + height + PROP(padding_bottom));
    ctx_rel_line_to (ctx, PROP(border_right_width), border_bottom_width);
    ctx_rel_line_to (ctx, - (width + PROP(padding_left) + PROP(padding_right) + PROP(border_left_width) + PROP(border_right_width)), 0);
    ctx_rel_line_to (ctx, PROP(border_left_width), -border_bottom_width);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }

  ctx_color_free (color);
}

void _mrg_border_top_l (Css *mrg, int x, int y, int width, int height)
{
  float border_top_width = PROP(border_top_width);
  if (border_top_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_top_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x - PROP(padding_left) - PROP(border_left_width),
                       y - PROP(padding_top) - border_top_width);
    ctx_rel_line_to (ctx, width + PROP(padding_left) + PROP(padding_right) + PROP(border_left_width), 0);
    ctx_rel_line_to (ctx, 0, border_top_width);
    ctx_rel_line_to (ctx, - (width + PROP(padding_left)), 0);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }
  ctx_color_free (color);
}
void _mrg_border_bottom_l (Css *mrg, int x, int y, int width, int height)
{
  float border_bottom_width = PROP(border_bottom_width);
  if (border_bottom_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_bottom_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x + width, y + height + PROP(padding_bottom));
    ctx_rel_line_to (ctx, 0, border_bottom_width);
    ctx_rel_line_to (ctx, - (width + PROP(padding_left) + PROP(border_left_width)), 0);
    ctx_rel_line_to (ctx, PROP(border_left_width), -border_bottom_width);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }

  ctx_color_free (color);
}


void _mrg_border_top_m (Css *mrg, int x, int y, int width, int height)
{
  float border_top_width = PROP(border_top_width);
  if (border_top_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_top_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x,
                       y - PROP(padding_top) - border_top_width);
    ctx_rel_line_to (ctx, width, 0);
    ctx_rel_line_to (ctx, 0, border_top_width);
    ctx_rel_line_to (ctx, -width, 0);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }
  ctx_color_free (color);
}
void _mrg_border_bottom_m (Css *mrg, int x, int y, int width, int height)
{
  float border_bottom_width = PROP(border_bottom_width);
  if ((border_bottom_width) < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_bottom_color, color);

  if (!ctx_color_is_transparent (color))
  {
    ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x + width, y + height + PROP(padding_bottom));
    ctx_rel_line_to (ctx, 0, border_bottom_width);
    ctx_rel_line_to (ctx, - width, 0);
    ctx_rel_line_to (ctx, 0, -border_bottom_width);

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
    ctx_restore (ctx);
  }

  ctx_color_free (color);
}
void _mrg_border_left (Css *mrg, int x, int y, int width, int height)
{
  float border_left_width = PROP(border_left_width);
  if (border_left_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_left_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x - PROP(padding_left) - border_left_width,
                       y - PROP(padding_top) - PROP(border_top_width));
    ctx_rel_line_to (ctx, border_left_width, PROP(border_top_width));
    ctx_rel_line_to (ctx, 0, height + PROP(padding_top) + PROP(padding_bottom) );
    ctx_rel_line_to (ctx, -border_left_width, PROP(border_bottom_width));
    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }

  ctx_color_free (color);
}

void _mrg_border_right (Css *mrg, int x, int y, int width, int height)
{
  float border_right_width = PROP(border_right_width);
  if (border_right_width < 0.01f)
    return;
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_border_right_color, color);

  if (!ctx_color_is_transparent (color))
  {
  ctx_save (ctx);
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x + width + PROP(padding_right), y + height + PROP(padding_bottom));
    ctx_rel_line_to (ctx, border_right_width, PROP(border_bottom_width));
    ctx_rel_line_to (ctx, 0, - (height + PROP(padding_top) + PROP(padding_bottom) + PROP(border_top_width) + PROP(border_bottom_width)));
    ctx_rel_line_to (ctx, -border_right_width, PROP(border_top_width));

    mrg_ctx_set_source_color (ctx, color);
    ctx_fill (ctx);
  ctx_restore (ctx);
  }

  ctx_color_free (color);
}

static void mrg_box (Css *mrg, int x, int y, int width, int height)
{
  _mrg_border_top (mrg, x, y, width, height);
  _mrg_border_left (mrg, x, y, width, height);
  _mrg_border_right (mrg, x, y, width, height);
  _mrg_border_bottom (mrg, x, y, width, height);
}

#if 0
static void mrg_box_fill (Css *mrg, CtxStyle *style, float x, float y, float width, float height)
{
  Ctx *ctx = mrg_ctx (mrg);
  CtxColor *background_color = ctx_color_new ();
  ctx_get_color (ctx, SQZ_background_color, background_color);
  if (ctx_color_is_transparent (background_color))
  {
    ctx_color_free (background_color);
    return;
  }

  height = ctx_floorf (y + height) - ctx_floorf(y);
  y = ctx_floorf (y);

  ctx_save (ctx);
  {
    ctx_reset_path (ctx);
    ctx_move_to (ctx, x,
                       y);
    ctx_rel_line_to (ctx, 0, height );
    ctx_rel_line_to (ctx, width, 0);
    ctx_rel_line_to (ctx, 0, -(height ));

    ctx_fill_rule (ctx, CTX_FILL_RULE_EVEN_ODD);
    mrg_ctx_set_source_color (ctx, background_color);
    ctx_fill (ctx);
  }
  ctx_restore (ctx);
  ctx_color_free (background_color);
}
#endif

/*
 *  each style state level needs to know how far down it has
 *  painted background,.. on background increment we do all of them..
 *  .. floats are problematic - maybe draw them in second layer.
 *
 */


#if 0
static void
_mrg_resolve_line_height (Css *mrg, void *data, int last)
{
  //CssState *state = &mrg->states[mrg->state_no];
  //CtxStyle *style = &state->style;
  float ascent, descent;
  ctx_font_extents (mrg->ctx, &ascent, &descent, NULL);

  float val = mrg->line_max_height[mrg->line_level] * ascent;

  char name[10]="lin_";
  name[3]=mrg->line_level+2;

  ctx_resolve (mrg->ctx, name, set_line_height, &val);

  mrg->line_max_height[mrg->line_level] = 0.0f;//style->font_size;//0.0f;
  mrg->line_got_baseline[mrg->line_level]=0;
}
#endif

/* mrg - MicroRaptor Gui
 * Copyright (c) 2014 Øyvind Kolås <pippin@hodefoting.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

/**************/

static float measure_word_width (Css *mrg, const char *word)
{
  return ctx_text_width (mrg->ctx, word);
}

const char * hl_punctuation[] =
{";", ",", "(", ")", "{", "}", NULL};
const char * hl_operators [] =
{"-", "+", "=", "*", "/", "return", "<", ">", ":",
 "if", "else", "break", "case", NULL};
const char * hl_types[] =
// XXX anything ending in _t ?
{"int", "uint32_t", "uint64_t", "uint8_t", "Ctx", "cairo_t", "Css", "float", "double",
  "char", "const", "static", "void", "NULL",
  "#include", "#define", NULL};

static int is_one_of (const char *word, const char **words)
{
  int i;
  for (i = 0; words[i]; i++)
  {
    if (!strcmp (words[i], word))
      return 1;
  }
  return 0;
}

static int is_a_number (const char *word)
{
  int yep = 1;
  int i;
  for (i = 0; word[i]; i++)
  {
    if ((word[i] < '0' || word[i] > '9') && word[i] != '.')
      yep = 0;
  }
  return yep;
}

/* the syntax highlighting is done with static globals; deep in the text
 * rendering, this permits the editing code to recognize which string is
 * edited and directly work with pointer arithmetic on that instead of
 * marked up xml for the highlighting - it limits the syntax highlighting
 * context ability
 */
enum {
  MRG_HL_NEUTRAL      = 0,
  MRG_HL_NEXT_NEUTRAL = 1,
  MRG_HL_STRING       = 2,
  MRG_HL_STRING_ESC   = 3,
  MRG_HL_QSTRING      = 4,
  MRG_HL_QSTRING_ESC  = 5,
  MRG_HL_SLASH        = 6,
  MRG_HL_LINECOMMENT  = 7,
  MRG_HL_COMMENT      = 8,
  MRG_HL_COMMENT_STAR = 9,
};

static int hl_state_c = MRG_HL_NEUTRAL;

static void mrg_hl_token (Ctx *cr, const char *word)
{
  switch (hl_state_c)
  {
    case MRG_HL_NEUTRAL:
      if (!strcmp (word, "\""))
      {
        hl_state_c = MRG_HL_STRING;
      }
      else if (!strcmp (word, "'"))
      {
        hl_state_c = MRG_HL_QSTRING;
      }
      else if (!strcmp (word, "/"))
      {
        hl_state_c = MRG_HL_SLASH;
      }
      break;
    case MRG_HL_SLASH:
      if (!strcmp (word, "/"))
      {
        hl_state_c = MRG_HL_LINECOMMENT;
      } else if (!strcmp (word, "*"))
      {
        hl_state_c = MRG_HL_COMMENT;
      } else
      {
        hl_state_c = MRG_HL_NEUTRAL;
      }
      break;
    case MRG_HL_LINECOMMENT:
      if (!strcmp (word, "\n"))
      {
        hl_state_c = MRG_HL_NEXT_NEUTRAL;
      }
      break;
    case MRG_HL_COMMENT:
      if (!strcmp (word, "*"))
      {
        hl_state_c = MRG_HL_COMMENT_STAR;
      }
      break;
    case MRG_HL_COMMENT_STAR:
      if (!strcmp (word, "/"))
      {
        hl_state_c = MRG_HL_NEUTRAL;
      }
      else
      {
        hl_state_c = MRG_HL_COMMENT;
      }
      break;
    case MRG_HL_STRING:
      if (!strcmp (word, "\""))
      {
        hl_state_c = MRG_HL_NEXT_NEUTRAL;
      }
      else if (!strcmp (word, "\\"))
      {
        hl_state_c = MRG_HL_STRING_ESC;
      }
      break;
    case MRG_HL_STRING_ESC:
      hl_state_c = MRG_HL_STRING;
      break;
    case MRG_HL_QSTRING:
      if (!strcmp (word, "'"))
      {
        hl_state_c = MRG_HL_NEXT_NEUTRAL;
      }
      else if (!strcmp (word, "\\"))
      {
        hl_state_c = MRG_HL_QSTRING_ESC;
      }
      break;
    case MRG_HL_QSTRING_ESC:
      hl_state_c = MRG_HL_QSTRING;
      break;
    case MRG_HL_NEXT_NEUTRAL:
      hl_state_c = MRG_HL_NEUTRAL;
      break;
  }

  switch (hl_state_c)
  {
    case MRG_HL_NEUTRAL:
      if (is_a_number (word))
        ctx_rgb (cr, 0.5, 0.0, 0.0);
      else if (is_one_of (word, hl_punctuation))
        ctx_rgb (cr, 0.4, 0.4, 0.4);
      else if (is_one_of (word, hl_operators))
        ctx_rgb (cr, 0, 0.5, 0);
      else if (is_one_of (word, hl_types))
        ctx_rgb (cr, 0.2, 0.2, 0.5);
      else 
        ctx_rgb (cr, 0, 0, 0);
      break;
    case MRG_HL_STRING:
    case MRG_HL_QSTRING:
        ctx_rgb (cr, 1, 0, 0.5);
      break;
    case MRG_HL_COMMENT:
    case MRG_HL_COMMENT_STAR:
    case MRG_HL_LINECOMMENT:
        ctx_rgb (cr, 0.4, 0.4, 1);
      break;
  }

  ctx_text (cr, word);
}

/* hook syntax highlighter in here..  */
void mrg_hl_text (Ctx *cr, const char *text)
{
  int i;
  CtxString *word = ctx_string_new ("");
  for (i = 0; i < text[i]; i++)
  {
    switch (text[i])
    {
      case ';':
      case '-':
      case '\'':
      case '>':
      case '<':
      case '=':
      case '+':
      case ' ':
      case ':':
      case '"':
      case '*':
      case '/':
      case '\\':
      case '[':
      case ']':
      case ')':
      case ',':
      case '(':
        if (word->length)
        {
          mrg_hl_token (cr, word->str);
          ctx_string_set (word, "");
        }
        ctx_string_append_byte (word, text[i]);
        mrg_hl_token (cr, word->str);
        ctx_string_set (word, "");
        break;
      default:
        ctx_rgb (cr, 0,0,0);
        ctx_string_append_byte (word, text[i]);
        break;
    }
  }
  if (word->length)
    mrg_hl_token (cr, word->str);

  ctx_string_free (word, 1);
}

void ctx_listen (Ctx     *ctx,
                 CtxEventType  types,
                 CtxCb    cb,
                 void*    data1,
                 void*    data2);



/* x and y in cairo user units ; returns x advance in user units  */
float mrg_draw_string (Css *mrg, CtxStyle *style, 
                       const char *string,
                       int utf8_len)
{
  float y;
  float new_x, old_x;
  char *temp_string = NULL;
  Ctx *cr = mrg_ctx (mrg);

  //css_set_xy (mrg, new_x, y);
  old_x = mrg->x;
  y = mrg->y;
  ctx_move_to (cr, old_x, y + style->font_size);

  if (utf8_len < 0)
    utf8_len = _ctx_utf8_strlen (string);

  if (_ctx_utf8_strlen (string) != utf8_len)
  {
    const char *t;
    int i;

    temp_string = strdup (string);
    for (i = 0, t = temp_string ;i < utf8_len && *t; i++)
    {
      t += _ctx_utf8_len (*t);
    }
    *(char *)t = 0;
    string = temp_string;
  }
  //if (mrg->in_paint)
  {
    ctx_font_size (cr, style->font_size);

#if 0
    if (PROP(text_stroke_width) > 0.01)
    {
      CtxColor *color = ctx_color_new ();
      ctx_get_color (cr, SQZ_text_stroke_color, color);
      mrg_ctx_set_source_color (cr, color);
      ctx_reset_path (cr);
      ctx_move_to   (cr, x, y - _mrg_text_shift (mrg));
      ctx_line_width (cr, PROP(text_stroke_width));
      ctx_line_join (cr, CTX_JOIN_ROUND);
      ctx_text_stroke (cr, string);
      ctx_color_free (color);
    }
#endif

    {
    CtxColor *color = ctx_color_new ();
    ctx_get_color (cr, SQZ_color, color);
    mrg_ctx_set_source_color (cr, color);
    ctx_color_free (color);
    }
    //ctx_move_to   (cr, x, y - _mrg_text_shift (mrg));

    /* when syntax highlighting,.. should do it as a coloring
     * directly here..
     */

    const char *syntax_highlight = PROPS(syntax_highlight);
    if (!syntax_highlight) syntax_highlight = "";

//  ctx_current_point (cr, &old_x, NULL);
    //ctx_move_to (cr, old_x, y);// - style->font_size);
    if (syntax_highlight[0] == 0)
      ctx_text (cr, string);
    else if (!strcmp (syntax_highlight, "C"))
      mrg_hl_text (cr, string);
    else
      ctx_text (cr, string);

    ctx_current_point (cr, &new_x, NULL);

    if (style->text_decoration & CTX_TEXT_DECORATION_UNDERLINE)
      {
        //ctx_rel_move_to (cr, -(new_x-old_x), 0);
        //ctx_rel_line_to (cr, new_x-old_x, 0);
        ctx_move_to (cr, old_x, y + style->font_size * 1.1f);
        ctx_line_to (cr, new_x, y + style->font_size * 1.1f);
        ctx_stroke (cr);
      }
    if (style->text_decoration & CTX_TEXT_DECORATION_LINETHROUGH)
      {
        ctx_move_to (cr, old_x, y - style->font_size / 2);
        ctx_line_to (cr, new_x, y - style->font_size / 2);
        ctx_stroke (cr);
      }
    if (style->text_decoration & CTX_TEXT_DECORATION_OVERLINE)
      {
        ctx_move_to (cr, old_x, y - style->font_size);
        ctx_line_to (cr, new_x, y - style->font_size);
        ctx_stroke (cr);
      }
    //css_set_xy (mrg, new_x, y);
    //ctx_move_to (cr, new_x, y + style->font_size * style->line_height);
  }
#if 0
  else
  {
    ctx_font_size (cr, style->font_size);
    new_x = old_x + ctx_text_width (cr, string);
  }
#endif

  if (mrg->text_listen_active)
  {
    float em = mrg_em (mrg);
    int no = mrg->text_listen_count-1;
    float x, y;
    x = mrg->x; y=mrg->y;
    ctx_reset_path (cr);
    ctx_rectangle (cr,
        old_x, y, new_x - old_x + 1, em * mrg->state->style.line_height);
    ctx_listen (cr,
                mrg->text_listen_types[no],
                mrg->text_listen_cb[no],
                mrg->text_listen_data1[no],
                mrg->text_listen_data2[no]);
    ctx_reset_path (cr);
    css_set_xy (mrg, x, y);
  }
  //css_set_xy (mrg, new_x, y);
  //ctx_move_to (cr, new_x, y + style->font_size);

  if (temp_string)
    free (temp_string);

  return new_x - old_x;
}

float mrg_addstr (Css *mrg, const char *string, int utf8_length);

float paint_span_bg_final (Css   *mrg, float x, float y,
                           float  width)
{
  CtxStyle *style = ctx_style (mrg);
  Ctx *cr = mrg_ctx (mrg);
  if (style->display != CTX_DISPLAY_INLINE)
    return 0.0;
  CtxColor *background_color = ctx_color_new ();
  ctx_get_color (cr, SQZ_background_color, background_color);

  if (!ctx_color_is_transparent (background_color))
  {
    ctx_save (cr);
    ctx_rectangle (cr, x, y + mrg_em (mrg),
                       width + PROP(padding_right),
                       mrg_em (mrg) * style->line_height);
    mrg_ctx_set_source_color (cr, background_color);
    ctx_fill (cr);
    ctx_restore (cr);
  }

  _mrg_border_top_r (mrg, x, y , width, mrg_em (mrg));
  _mrg_border_bottom_r (mrg, x,y, width, mrg_em (mrg));
  _mrg_border_right (mrg, x, y ,width, mrg_em (mrg));

  ctx_color_free (background_color);
  return PROP(padding_right) + PROP(border_right_width);
}

float paint_span_bg (Css   *mrg, float x, float y,
                     float  width)
{
  CtxStyle *style = ctx_style (mrg);
  Ctx *cr = mrg_ctx (mrg);
  if (!cr)
    return 0.0;
  float left_pad = 0.0;
  float left_border = 0.0;
  if (style->display != CTX_DISPLAY_INLINE)
    return 0.0;

  CtxColor *background_color = ctx_color_new ();
  ctx_get_color (cr, SQZ_background_color, background_color);

  if (!mrg->state->span_bg_started)
  {
    left_pad = PROP(padding_left);
    left_border = PROP(border_left_width);
    mrg->state->span_bg_started = 1;
  }

  if (!ctx_color_is_transparent (background_color))
  {
    ctx_save (cr);
    ctx_rectangle (cr, x + left_border, y,
                         width + left_pad,
                         mrg_em (mrg) * style->line_height);
    mrg_ctx_set_source_color (cr, background_color);
    ctx_fill (cr);
    ctx_restore (cr);
  }

  if (left_pad || left_border)
  {
    _mrg_border_left (mrg, x + left_pad + left_border, y, width, mrg_em (mrg));
    _mrg_border_top_l (mrg, x + left_pad + left_border, y, width , mrg_em (mrg));
    _mrg_border_bottom_l (mrg, x + left_pad + left_border, y, width , mrg_em (mrg));
  }
  else
  {
    _mrg_border_top_m (mrg, x, y, width, mrg_em (mrg));
    _mrg_border_bottom_m (mrg, x, y, width, mrg_em (mrg));
  }

  ctx_color_free (background_color);

  return left_pad + left_border;
}

float
mrg_addstr (Css *mrg, const char *string, int utf8_length)
{
  float x = mrg->x;
  float y = mrg->y;
  CtxStyle *style = ctx_style (mrg);
  float wwidth = measure_word_width (mrg, string);
  float left_pad;
  left_pad = paint_span_bg (mrg, x, y, wwidth); // TODO avoid doing this for out of bounds

  mrg->line_max_height[mrg->line_level] =
      ctx_maxf (mrg->line_max_height[mrg->line_level],
                style->font_size);
  {
    float tx = x;
    float ty = y;
    ctx_user_to_device (mrg_ctx (mrg), &tx, &ty);
    if (ty > ctx_height (mrg->ctx) * 2 ||
        tx > ctx_width (mrg->ctx)* 2 ||
        tx < -ctx_width (mrg->ctx) * 2 ||
        ty < -ctx_height (mrg->ctx) * 2)
    {
      /* bailing early*/
    }
    else
    {

     if (mrg->line_got_baseline[mrg->line_level] == 0)
     {
        ctx_move_to (mrg->ctx, mrg->x, mrg->y);

        char name[10]="lin_";
        name[3]=mrg->line_level+2;

        ctx_deferred_rel_move_to (mrg->ctx, name, 0.0, 0.0);//mrg_em (mrg));
        mrg->line_got_baseline[mrg->line_level] = 1;
      }

      if (left_pad != 0.0f)
      {
        ctx_rel_move_to (mrg->ctx, left_pad, 0.0f);
      }
      mrg_draw_string (mrg, &mrg->state->style, string, utf8_length);
    }
  }

  return wwidth + left_pad;
}

/******** end of core text-drawing primitives **********/

#if 0
void mrg_xy (Css *mrg, float x, float y)
{
  mrg->x = x * mrg_em (mrg);
  mrg->y = y * mrg_em (mrg);
}
#endif

void mrg_set_xy (Css *mrg, float x, float y)
{
  mrg->x = x;
  mrg->y = y;
  mrg->state->overflowed = 0;
}

float mrg_x (Css *mrg)
{
  return mrg->x;
}

float mrg_y (Css *mrg)
{
  return mrg->y;
}

void mrg_set_wrap_skip_lines (Css *mrg, int skip_lines);
void mrg_set_wrap_max_lines  (Css *mrg, int max_lines);

void mrg_set_wrap_skip_lines (Css *mrg, int skip_lines)
{
    mrg->state->skip_lines = skip_lines;
}

void mrg_set_wrap_max_lines  (Css *mrg, int max_lines)
{
    mrg->state->max_lines = max_lines;
}

static void _mrg_spaces (Css *mrg, int count)
{
  while (count--)
    {
     if (mrg->state->style.print_symbols)
        mrg->x+=mrg_addstr (mrg, "␣", -1);
     else
     {
        float diff = mrg_addstr (mrg, " ", 1);

#if 0
        if (mrg_is_terminal (mrg) && mrg_em (mrg) <= CPX * 4 / mrg->ddpx)
        {
        }
        else
#endif
        {
          if (mrg->state->style.text_decoration & CTX_TEXT_DECORATION_REVERSE)
          {
            Ctx *cr = mrg_ctx (mrg);
            ctx_rectangle (cr, mrg->x + diff*0.1, mrg->y + mrg_em(mrg)*0.2, diff*0.8, -mrg_em (mrg)*1.1);
            ctx_rgb (cr, 1,1,1);
            ctx_fill (cr);
          }
        }
        mrg->x += diff;
     }
    }
}

#define EMIT_NL() \
    do {wraps++; \
    if (wraps >= max_lines)\
      return wraps;\
    if (skip_lines-- <=0)\
      {\
         if (print) { if (gotspace)\
             _mrg_spaces (mrg, 1);\
         if (cursor_start == pos -1 && cursor_start>0 && mrg->text_edited)\
           {\
             css_start (mrg, ".cursor", NULL);\
             _mrg_spaces (mrg, 1);\
             _mrg_nl (mrg);\
             css_end (mrg, NULL);\
           }\
         else\
           _mrg_nl (mrg);\
         } else _mrg_nl (mrg);\
      }\
    if (skip_lines<=0)\
      mrg_set_xy (mrg, _mrg_dynamic_edge_left(mrg), mrg_y (mrg));}while(0)

#define EMIT_NL2() \
    do {\
    if (skip_lines-- <=0)\
      {\
         if (print) {if (gotspace)\
             _mrg_spaces (mrg, 1);\
         if (cursor_start == *pos -1 && cursor_start>0 && mrg->text_edited)\
           {\
             css_start (mrg, ".cursor", NULL);\
             _mrg_spaces (mrg, 1);\
             _mrg_nl (mrg);\
             css_end (mrg, NULL);\
           }\
         else\
           _mrg_nl (mrg);\
         } else _mrg_nl (mrg);\
      }\
    if (skip_lines<=0)\
      mrg_set_xy (mrg, _mrg_dynamic_edge_left(mrg), mrg_y (mrg));}while(0)



static void mrg_get_edit_state (Css *mrg, 
     float *x, float *y, float *s, float *e,
     float *em_size)
{
  if (x) *x = mrg->e_x;
  if (y) *y = mrg->e_y;
  if (s) *s = mrg->e_ws;
  if (e) *e = mrg->e_we;
  if (em_size) *em_size = mrg->e_em;
}


static void emit_word (Css *mrg,
                       int  print,
                       const char *data,
                       const char *word,
                       int         max_lines,
                       int         skip_lines,
                       int         cursor_start,
                       int        *pos,
                       int        *wraps,
                       int        *wl,
                       int         c,
                       int         gotspace)
{
    float len = _ctx_utf8_strlen (word);
    float wwidth = measure_word_width (mrg, word);

    if (mrg->x + wwidth >= _mrg_dynamic_edge_right (mrg))
    {
      if (mrg->x > mrg_edge_left(mrg) || *wraps != 0)
      {
        EMIT_NL2();
      }
    }
    if (mrg->x != mrg_edge_left(mrg) && gotspace)
      { 
        if ((skip_lines<=0)) 
          { 
            if (cursor_start == *pos-1 && cursor_start>=0 && mrg->text_edited)
            { 
              if (print) { 
               css_start (mrg, ".cursor", NULL);
               _mrg_spaces (mrg, 1); 
               css_end (mrg, NULL);
              } else { 
               mrg->x += measure_word_width (mrg, " ");
              }
            }
            else 
              {
                if (print){
                  if (mrg->state->style.print_symbols)
                    {
                      css_start (mrg, "dim", NULL);
                      mrg->x += mrg_addstr (mrg, "␣", -1);
                      css_end (mrg, NULL);
                    }
                  else
                    _mrg_spaces (mrg, 1);
                } else {
                  if (mrg->state->style.print_symbols)
                  {
                    mrg->x += measure_word_width (mrg, "␣");
                  }
                  else
                  {
                    mrg->x += measure_word_width (mrg, " ");
                  }
                }
              } 
          }
      } 
    if ((skip_lines<=0)) {
      if (print){if (cursor_start >= *pos && *pos + len > cursor_start && mrg->text_edited)
        { 
#if 0  // XXX: there is a bug in mrg_addstr it doesn't respect the length argument 
          mrg->x += mrg_addstr (mrg,  word, cursor_start - *pos);
          css_start (mrg, ".cursor", NULL);
          mrg->x += mrg_addstr (mrg,  mrg_utf8_skip (word, cursor_start - *pos), 1);
          css_end (mrg, NULL);
          mrg->x += mrg_addstr (mrg,  mrg_utf8_skip (word, cursor_start - *pos + 1), len - (cursor_start - *pos) - 1);
#else

          char *dup, *dup2, *dup3;

          dup = strdup (word);
          dup2 = strdup (_ctx_utf8_skip (dup, cursor_start - *pos));
          dup3 = strdup (_ctx_utf8_skip (dup, cursor_start - *pos + 1));
          *((char*)_ctx_utf8_skip (dup,  cursor_start - *pos)) = 0;
          *((char*)_ctx_utf8_skip (dup2, 1)) = 0;

          mrg->x += mrg_addstr (mrg,  dup, -1);
          css_start (mrg, ".cursor", NULL);
          mrg->x += mrg_addstr (mrg,  dup2, -1);
          css_end (mrg, NULL);
          mrg->x += mrg_addstr (mrg,  dup3, -1);

          free (dup);
          free (dup2);
          free (dup3);
#endif
        }
      else
        {
          mrg->x += mrg_addstr (mrg,  word, len); 
        }
      } else {
          mrg->x += wwidth;
      }
    }
    *pos += len;
    *wl = 0;

}

static int css_print_wrap (Css        *mrg,
                           int         print,
                           const char *data, int length,
                           int         max_lines,
                           int         skip_lines,
                           int         cursor_start,
                           float     *retx,
                           float     *rety)
{
#define MAX_WORDL 1024
  char word[MAX_WORDL+1]="";
  int wl = 0;
  int c;
  int wraps = 0;
  int pos;
  int gotspace = 0;

  if (mrg->state->overflowed)
  {
    return 0;
  }

  float space_width = measure_word_width (mrg, " ");

  pos = 0;

  if (max_lines <= 0)
    max_lines = 4096;
  if (retx)
    *retx = -1;

  if (mrg->text_edited && print)
    {
      mrg->e_x = mrg->x;
      mrg->e_y = mrg->y;
      mrg->e_ws = mrg_edge_left(mrg);
      mrg->e_we = mrg_edge_right(mrg);
      mrg->e_em = mrg_em (mrg);
    }

  ctx_font_size (mrg_ctx (mrg), ctx_style(mrg)->font_size);

  for (c = 0 ; c < length && data[c] && ! mrg->state->overflowed; c++)
    switch (data[c])
      {
        case '\n':
          if (wl)
            {
              emit_word (mrg, print, data, word, 
                         max_lines, skip_lines,
                         cursor_start,
                         &pos, &wraps, &wl, c, gotspace);
            }
          pos++;

          if (mrg->state->style.print_symbols && print)
          {
            css_start (mrg, "dim", NULL);
            mrg->x+=mrg_addstr (mrg,  "¶", -1);\
            css_end (mrg, NULL);
          }
          EMIT_NL();
          gotspace = 0;
          break;
        case '\t': // XXX: this collapses tabs to a single space
        case ' ':
          if (wl == 0)
            {
              if (cursor_start == pos-1 && cursor_start>=0 && mrg->text_edited)
                {
                  if (print)
                  {
                    css_start (mrg, ".cursor", NULL);
                    _mrg_spaces (mrg, 1);
                    css_end (mrg, NULL);
                  }
                  else
                    mrg->x+=mrg_addstr (mrg,  " ", -1);
                }
              else
                {
                  if (mrg->state->style.print_symbols)
                    {
                      css_start (mrg, "dim", NULL);
                      mrg->x+=mrg_addstr (mrg,  "␣", -1);
                      css_end (mrg, NULL);
                    }
                  else
                    {
                      mrg->x+=mrg_addstr (mrg,  " ", -1);

                    }
                }
            }
          else
            {
              emit_word (mrg, print, data, word,
                         max_lines, skip_lines,
                         cursor_start,
                         &pos, &wraps, &wl, c, gotspace);
            }
          pos++;

          if (retx && *retx < 0 && pos >= cursor_start)
            {
              float tailwidth;
              const char *rest = &word[_ctx_utf8_strlen (word) - (pos-cursor_start)];
#if 0
              if (mrg_is_terminal (mrg))
                tailwidth = (pos-cursor_start -1) * CPX / mrg->ddpx;
              else
#endif
                tailwidth = measure_word_width (mrg, rest);
              *retx = mrg->x - tailwidth;
              *rety = mrg->y;
              return pos;
            }
          gotspace = 1;
          break;
        default:
          word[wl++]= data[c];
          wl = ctx_mini (wl, MAX_WORDL-1);
          word[wl]  = '\0';
          break;
      }
  if (wl) /* orphaned word for last line. */
    {
      emit_word (mrg, print, data, word, 
                 max_lines, skip_lines,
                 cursor_start,
                 &pos, &wraps, &wl, c, gotspace);
    }
   /* cursor at end */
   if (cursor_start == pos && cursor_start>=0 && mrg->text_edited)
    {
      if (print)
      {
        if (c && data[c-1]==' ')
          mrg->x += space_width;
        css_start (mrg, ".cursor", NULL);
        _mrg_spaces (mrg, 1);
        css_end (mrg, NULL);
      }
      else
        mrg->x += space_width;
    }
  if (retx && *retx < 0 && pos >= cursor_start)
    {
       *retx = mrg->x; 
       *rety = mrg->y;
      return pos;
    }
  return wraps;
}

int css_print_get_xy (Css *mrg, const char *string, int no, float *x, float *y)
{
  int ret;
  if (!string)
    return 0;

  if (mrg_edge_left(mrg) != mrg_edge_right(mrg))
    {
      float ox, oy;
      ox = mrg->x;
      oy = mrg->y;
      ret = css_print_wrap (mrg, 0, string, strlen (string), mrg->state->max_lines,
                             mrg->state->skip_lines, no, x, y);
      mrg->x = ox;
      mrg->y = oy;
      return ret;
    }
  if (y) *y = mrg->y;
  if (x) *x = mrg->x + no; // XXX: only correct for nct/monospace

  return 0;
}

typedef struct _CssGlyph CssGlyph;

struct _CssGlyph{
  unsigned long index; /*  done this way, the remnants of layout; before feeding
                        *  glyphs positions in cairo, similar to how pango would do
                        *  can be reused for computing the caret nav efficiently.
                        */
  float x;
  float y;
  int   no;
};

static int css_print_wrap2 (Css        *mrg,
                           int         print,
                           const char *data, int length,
                           int         max_lines,
                           int         skip_lines,
                           CtxList   **list)
{
  char word[400]="";
  int wl = 0;
  int c;
  int wraps = 0;
  int pos;
  int gotspace = 0;
  int cursor_start = -1;

  CssGlyph *g = calloc (1, sizeof (CssGlyph));
  g->x = length;
  g->y = 42;
  g->index = 44;
  g->no = 2;
  ctx_list_append (list, g);

  if (mrg->state->overflowed)
  {
    return 0;
  }

  pos = 0;

  if (max_lines <= 0)
    max_lines = 4096;

  if (mrg->text_edited && print)
    {
      mrg->e_x = mrg->x;
      mrg->e_y = mrg->y;
      mrg->e_ws = mrg_edge_left(mrg);
      mrg->e_we = mrg_edge_right(mrg);
      mrg->e_em = mrg_em (mrg);
#if 0
      if (mrg->scaled_font)
        cairo_scaled_font_destroy (mrg->scaled_font);
#endif
      ctx_font_size (mrg_ctx (mrg), ctx_style(mrg)->font_size);
#if 0
      mrg->scaled_font = cairo_get_scaled_font (mrg_ctx (mrg));
      cairo_scaled_font_reference (mrg->scaled_font);
#endif
    }

  for (c = 0 ; c < length && data[c] && ! mrg->state->overflowed; c++)
    switch (data[c])
      {
        case '\n':
          if (wl)
            {
              emit_word (mrg, print, data, word, 
                         max_lines, skip_lines,
                         cursor_start,
                         &pos, &wraps, &wl, c, gotspace);
            }
          pos++;

          if (mrg->state->style.print_symbols && print)
          {
            css_start (mrg, "dim", NULL);
            mrg->x+=mrg_addstr (mrg,  "¶", -1);\
            css_end (mrg, NULL);
          }
          EMIT_NL();
          gotspace = 0;
          break;
        case ' ':
          if (wl == 0)
            {
              if (cursor_start == pos-1 && cursor_start>=0 && mrg->text_edited)
                {
                  if (print)
                  {
                    css_start (mrg, ".cursor", NULL);
                    _mrg_spaces (mrg, 1);
                    css_end (mrg, NULL);
                  }
                  else
                    mrg->x+=mrg_addstr (mrg,  " ", -1);
                }
              else
                {
                  if (mrg->state->style.print_symbols)
                    {
                      css_start (mrg, "dim", NULL);
                      mrg->x+=mrg_addstr (mrg,  "␣", -1);
                      css_end (mrg, NULL);
                    }
                  else
                    {
                      mrg->x+=mrg_addstr (mrg,  " ", -1);
                    }
                }
            }
          else
            {
              emit_word (mrg, print, data, word, 
                         max_lines, skip_lines,
                         cursor_start,
                         &pos, &wraps, &wl, c, gotspace);
            }
          pos++;
          
#if 0
          if (retx && *retx < 0 && pos >= cursor_start)
            {
              float tailwidth;
              const char *rest = &word[_ctx_utf8_strlen (word) - (pos-cursor_start)];
              if (mrg_is_terminal (mrg))
                tailwidth = (pos-cursor_start -1) * CPX / mrg->ddpx;
              else
                tailwidth = measure_word_width (mrg, rest);
              *retx = mrg->x - tailwidth;
              *rety = mrg->y;
              return pos;
            }
#endif
          gotspace = 1;
          break;
        default:
          word[wl++]= data[c];
          word[wl]  = '\0';
          break;
      }
  if (wl) /* orphaned word for last line. */
    {
      emit_word (mrg, print, data, word, 
                 max_lines, skip_lines,
                 cursor_start, 
                 &pos, &wraps, &wl, c, gotspace);
    }
   /* cursor at end */
   if (cursor_start == pos && cursor_start>=0 && mrg->text_edited)
    {
      if (print)
      {
        css_start (mrg, ".cursor", NULL);
        _mrg_spaces (mrg, 1);
        css_end (mrg, NULL);
      }
      else
        mrg->x += measure_word_width (mrg, " ");
    }
#if 0
  if (retx && *retx < 0 && pos >= cursor_start)
    {
       *retx = mrg->x; 
       *rety = mrg->y;
      return pos;
    }
#endif
  return wraps;
}

CtxList *css_print_get_coords (Css *mrg, const char *string)
{
  CtxList *ret = NULL;
  if (!string)
    return ret;

  if (mrg_edge_left(mrg) != mrg_edge_right(mrg))
    {
      float ox, oy;
      ox = mrg->x;
      oy = mrg->y;
      css_print_wrap2 (mrg, 0, string, strlen (string), mrg->state->max_lines,
                       mrg->state->skip_lines, &ret);
      mrg->x = ox;
      mrg->y = oy;
      return ret;
    }

  return ret;
}

#include <math.h>

int css_print (Css *mrg, const char *string)
{
  float ret;
  CtxStyle *style = ctx_style (mrg);
  mrg->unresolved_line = 1;

#ifdef SNAP
  float em = mrg_em (mrg);  /* XXX: a global body-line spacing 
                               snap is better grid design */
  mrg->x = ceil (mrg->x / em) * em;
  mrg->y = ceil (mrg->y / em) * em;
#endif

  if (mrg->text_edited && mrg->edited_str)
    ctx_string_append_str (mrg->edited_str, string);

  if (style->display == CTX_DISPLAY_NONE)
    return 0.0;

  if (!string)
    return 0;

  if (mrg_edge_left(mrg) != mrg_edge_right(mrg))
   return css_print_wrap (mrg, 1, string, strlen (string), mrg->state->max_lines, mrg->state->skip_lines, mrg->cursor_pos, NULL, NULL);

  ret  = mrg_addstr (mrg,  string, _ctx_utf8_strlen (string));
  mrg->x += ret;
  return ret;
}

void _mrg_text_prepare (Css *mrg)
{
  hl_state_c = MRG_HL_NEUTRAL;
}

void _mrg_text_init (Css *mrg)
{
  // XXX: this should be done in a prepre,.. not an init?
  //
  mrg->state->style.line_height = 1.0;
  mrg->state->style.print_symbols = 0;
}

void  mrg_text_listen_done (Css *mrg)
{
  mrg->text_listen_active = 0;
}

void  mrg_text_listen_full (Css *mrg, CtxEventType types,
                            CtxCb cb, void *data1, void *data2,
                      void   (*finalize)(void *listen_data, void *listen_data2, void *finalize_data),
                      void    *finalize_data)
{
  int no = mrg->text_listen_count;
  if (cb == NULL)
  {
    mrg_text_listen_done (mrg);
    return;
  }
  if (no + 1 >= CTX_MAX_TEXT_LISTEN)
  {
    fprintf (stderr, "mrg text listen overflow\n");
    return;
  }

  mrg->text_listen_types[no] = types;
  mrg->text_listen_cb[no] = cb;
  mrg->text_listen_data1[no] = data1;
  mrg->text_listen_data2[no] = data2;
  mrg->text_listen_finalize[no] = finalize;
  mrg->text_listen_finalize_data[no] = finalize_data;
  mrg->text_listen_count++;
  mrg->text_listen_active = 1;
}

void  mrg_text_listen (Css *mrg, CtxEventType types,
                       CtxCb cb, void *data1, void *data2)
{
  mrg_text_listen_full (mrg, types, cb, data1, data2, NULL, NULL);
}


static void cmd_home (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  mrg->cursor_pos = 0;
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

static void cmd_end (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  mrg->cursor_pos = _ctx_utf8_strlen (mrg->edited_str->str);
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

static void cmd_backspace (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  char *new;
  const char *rest = ctx_utf8_skip (mrg->edited_str->str, mrg->cursor_pos);
  const char *mark = ctx_utf8_skip (mrg->edited_str->str, mrg->cursor_pos-1);

  if (mrg->cursor_pos <= 0)
    {
      mrg->cursor_pos = 0;
    }
  else
    {
      new = malloc (strlen (mrg->edited_str->str) + 1);
      memcpy (new, mrg->edited_str->str, ((mark - mrg->edited_str->str)));
      memcpy (new + ((mark - mrg->edited_str->str)), rest, strlen (rest));
      new [strlen (mrg->edited_str->str)-(rest-mark)] = 0;
      mrg->update_string (new, mrg->update_string_user_data);
      ctx_string_set (mrg->edited_str, new);
      free (new);
      mrg->cursor_pos--;
    }
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

static void cmd_delete (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  char *new;
  const char *rest = ctx_utf8_skip (mrg->edited_str->str, mrg->cursor_pos+1);
  const char *mark = ctx_utf8_skip (mrg->edited_str->str, mrg->cursor_pos);

  new = malloc (strlen (mrg->edited_str->str) + 1);
  memcpy (new, mrg->edited_str->str, ((mark - mrg->edited_str->str)));
  memcpy (new + ((mark - mrg->edited_str->str)), rest, strlen (rest));
  new [strlen (mrg->edited_str->str)-(rest-mark)] = 0;

  mrg->update_string (new, mrg->update_string_user_data);
  ctx_string_set (mrg->edited_str, new);
  free (new);
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

static void cmd_down (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  float e_x, e_y, e_s, e_e, e_em;
  float cx, cy;
  cx = cy = 0;
 
  mrg_get_edit_state (mrg, &e_x, &e_y, &e_s, &e_e, &e_em);
  css_set_edge_left (mrg, e_s - PROP (padding_left));
  css_set_edge_right (mrg, e_e + PROP (padding_right));
  mrg_set_xy (mrg, e_x, e_y);
  css_print_get_xy (mrg, mrg->edited_str->str, mrg->cursor_pos, &cx, &cy);

  {
    int no;
    int best = mrg->cursor_pos;
    float best_score = 10000000000.0;
    float best_y = cy;
    int strl = ctx_utf8_strlen (mrg->edited_str->str);
    for (no = mrg->cursor_pos + 1; no < mrg->cursor_pos + 256 && no < strl; no++)
    {
      float x = 0, y = 0;
      float attempt_score = 0.0;
      mrg_set_xy (mrg, e_x, e_y);
      css_print_get_xy (mrg, mrg->edited_str->str, no, &x, &y);

      if (y > cy && best_y == cy)
        best_y = y;

      if (y > cy)
        attempt_score = (y - best_y);
      else
        attempt_score = 1000.0;

      attempt_score += fabs(cx-x) / 10000000.0;

      if (attempt_score <= best_score)
      {
        best_score = attempt_score;
        best = no;
      }
    }
    if (best_y == cy)
    {
      mrg->cursor_pos = strl;
#if 0
      ctx_key_press (mrg, 0, "down-nudge", 0);
#endif
      mrg_queue_draw (mrg, NULL);
      return;
    }
    mrg->cursor_pos = best;
  }

  if (mrg->cursor_pos >= ctx_utf8_strlen (mrg->edited_str->str))
    mrg->cursor_pos = ctx_utf8_strlen (mrg->edited_str->str) - 1;
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

static void cmd_up (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  float e_x, e_y, e_s, e_e, e_em;
  float cx = 0.0f, cy = 0.0f;
  mrg_get_edit_state (mrg, &e_x, &e_y, &e_s, &e_e, &e_em);

  css_set_edge_left  (mrg, e_s - PROP(padding_left));
  css_set_edge_right (mrg, e_e + PROP(padding_right));

  mrg_set_xy (mrg, e_x, e_y);
  css_print_get_xy (mrg, mrg->edited_str->str, mrg->cursor_pos, &cx, &cy);

  /* XXX: abstract the finding of best cursor pos for x coord to a function */
  {
    int no;
    int best = mrg->cursor_pos;
    float best_y = cy;
    float best_score = 1000000000000.0;
    for (no = mrg->cursor_pos - 1; no>= mrg->cursor_pos - 256 && no > 0; no--)
    {
      float x = 0, y = 0;
      float attempt_score = 0.0;
      mrg_set_xy (mrg, e_x, e_y);
      css_print_get_xy (mrg, mrg->edited_str->str, no, &x, &y);

      if (y < cy && best_y == cy)
        best_y = y;

      if (y < cy)
        attempt_score = (best_y - y);
      else
        attempt_score = 1000.0;

      attempt_score += fabs(cx-x) / 10000000.0;

      if (attempt_score < best_score)
      {
        best_score = attempt_score;
        best = no;
      }
    }
    mrg->cursor_pos = best;
    if (best_y == cy)
    {
      mrg->cursor_pos = 0;
      mrg_queue_draw (mrg, NULL);
      ctx_key_press (event->ctx, 0, "up-nudge", 0);
      return; // without stop propagate this should permit things registered earlier to fire
    }
  }

  if (mrg->cursor_pos < 0)
    mrg->cursor_pos = 0;
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

int mrg_get_cursor_pos (Css *mrg)
{
  return mrg->cursor_pos;
}

void mrg_set_cursor_pos (Css *mrg, int pos)
{
  mrg->cursor_pos = pos;
  mrg_queue_draw (mrg, NULL);
}

static void cmd_page_down (CtxEvent *event, void *data1, void *data2)
{
  int i;
  for (i = 0; i < 6; i++)
    cmd_down (event, data1, data2);
  ctx_event_stop_propagate (event);
}

static void cmd_page_up (CtxEvent *event, void *data1, void *data2)
{
  int i;
  for (i = 0; i < 6; i++)
    cmd_up (event, data1, data2);
  ctx_event_stop_propagate (event);
}

static void cmd_left (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  mrg->cursor_pos--;
  if (mrg->cursor_pos < 0)
    mrg->cursor_pos = 0;
  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}

static void cmd_right (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  mrg->cursor_pos++;

  /* should mrg have captured the text printed in-between to build its idea
   * of what is being edited, thus being able to do its own internal cursor
   * positioning with that cache?
   */

  if (mrg->cursor_pos > ctx_utf8_strlen (mrg->edited_str->str))
    mrg->cursor_pos = ctx_utf8_strlen (mrg->edited_str->str);

  mrg_queue_draw (mrg, NULL);
  ctx_event_stop_propagate (event);
}


/* the added utf8 bits go to edited_str as well, so that successive edits do work out
 *
 */

static void add_utf8 (Css *mrg, const char *string)
{
  char *new;
  const char *rest;
  /* XXX: this is the code the should be turned into a callback/event
   * to digest for the user of the framework, with a reasonable default
   * for using it from C with a string
   */

  rest = ctx_utf8_skip (mrg->edited_str->str, mrg->cursor_pos);

  new = malloc (strlen (mrg->edited_str->str) + strlen (string) + 1);
  memcpy (new, mrg->edited_str->str, (rest-mrg->edited_str->str));
  memcpy (new + (rest-mrg->edited_str->str), string,  strlen (string));
  memcpy (new + (rest-mrg->edited_str->str) + strlen (string),
          rest, strlen (rest));
  new [strlen (string) + strlen (mrg->edited_str->str)] = 0;
  mrg->update_string (new, mrg->update_string_user_data);
  ctx_string_set (mrg->edited_str, new);
  free (new);
  mrg_queue_draw (mrg, NULL);
  mrg->cursor_pos++;
}

static void cmd_unhandled (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  if (!strcmp (event->string, "space"))
  {
    add_utf8 (mrg, " ");
    ctx_event_stop_propagate (event);
  }

  if (ctx_utf8_strlen (event->string) != 1)
    return;

  add_utf8 (mrg, event->string);
  ctx_event_stop_propagate (event);
}

#if 0
static void cmd_space (CtxEvent *event, void *data1, void *data2)
{
  if (!ctx_utf8_strlen (event->key_name) == 1)
    return 0;

  add_utf8 (event->mrg, " ");
  return 1;
}
#endif

static void cmd_return (CtxEvent *event, void *data1, void *data2)
{
  Css *mrg = data1;
  // this check excludes terminal from working
  //if (!(ctx_utf8_strlen (event->key_name) == 1))
  //  return;

  add_utf8 (mrg, "\n");
  ctx_event_stop_propagate (event);
}

static void cmd_escape (CtxEvent *event, void *data, void *data2)
{
#if 0
  mrg_edit_string (event->mrg, NULL, NULL, NULL);
#endif
}

void mrg_text_edit_bindings (Css *mrg)
{
  ctx_add_key_binding (mrg->ctx, "escape",    NULL, "stop editing",    cmd_escape,      mrg);
  ctx_add_key_binding (mrg->ctx, "return",    NULL, "add newline",     cmd_return,    mrg);
  ctx_add_key_binding (mrg->ctx, "home",      NULL, "cursor to start", cmd_home, mrg);
  ctx_add_key_binding (mrg->ctx, "end",       NULL, "cursor to end",   cmd_end,    mrg);
  ctx_add_key_binding (mrg->ctx, "left",      NULL, "cursor left",     cmd_left,    mrg);
  ctx_add_key_binding (mrg->ctx, "right",     NULL, "cursor right",    cmd_right,  mrg);
  ctx_add_key_binding (mrg->ctx, "up",        NULL, "cursor up",       cmd_up,        mrg);
  ctx_add_key_binding (mrg->ctx, "down",      NULL, "cursor down",     cmd_down,    mrg);
  ctx_add_key_binding (mrg->ctx, "page-up",   NULL, "cursor up",       cmd_page_up,     mrg);
  ctx_add_key_binding (mrg->ctx, "page-down", NULL, "cursor down",     cmd_page_down, mrg);
  ctx_add_key_binding (mrg->ctx, "backspace", NULL, "remove preceding character", cmd_backspace, mrg);
  ctx_add_key_binding (mrg->ctx, "delete",    NULL, "remove character under cursor", cmd_delete, mrg);
  ctx_add_key_binding (mrg->ctx, "any", NULL, "add if key name is 1 char long", cmd_unhandled, mrg);
}

#if 1
void mrg_edit_string (Css *mrg, char **string,
                      void (*update_string)(Css *mrg,
                        char **string_loc,
                        const char *new_string,
                        void  *user_data),
                      void *user_data)
{
  if (mrg->edited == string)
    return;
  mrg->edited = string;
  mrg->update_string = (void*)update_string;
  mrg->update_string_user_data = user_data;
  if (string)
    mrg->cursor_pos = ctx_utf8_strlen (*string);
  else
    mrg->cursor_pos = 0;
  mrg_queue_draw (mrg, NULL);
}
#endif

void
css_printf (Css *mrg, const char *format, ...)
{
  va_list ap;
  size_t needed;
  char  *buffer;
  va_start(ap, format);
  needed = vsnprintf(NULL, 0, format, ap) + 1;
  buffer = malloc(needed);
  va_end (ap);
  va_start(ap, format);
  vsnprintf(buffer, needed, format, ap);
  va_end (ap);
  css_print (mrg, buffer);
  free (buffer);
}

void  css_set_font_size (Css *mrg, float font_size)
{
  mrg->font_size = font_size;
  //css_set_stylef (mrg, "font-size:%fpx;", font_size);
}

void _mrg_block_edit (Css *mrg)
{
  mrg->text_edit_blocked = 1;
}
void _mrg_unblock_edit (Css *mrg)
{
  mrg->text_edit_blocked = 0;
}

void mrg_edit_start_full (Css *mrg,
                          CssNewText  update_string,
                          void *user_data,
                          CtxDestroyNotify destroy,
                          void *destroy_data)
{
  if (mrg->update_string_destroy_notify)
  {
    mrg->update_string_destroy_notify (mrg->update_string_destroy_data);
  }
  mrg->got_edit                     = 1;
  mrg->text_edited                  = 1;
  mrg->update_string                = update_string;
  mrg->update_string_user_data      = user_data;
  mrg->update_string_destroy_notify = destroy;
  mrg->update_string_destroy_data   = destroy_data;
}

void  mrg_edit_start (Css *mrg,
                      CssNewText  update_string,
                      void *user_data)
{
  return mrg_edit_start_full (mrg, update_string, user_data, NULL, NULL);
}

void  mrg_edit_end (Css *mrg)
{
  mrg->text_edited = 0;
  mrg_text_edit_bindings (mrg);
}


#if 0
static void ctx_css_add_class (Css *mrg, const char *class_name)
{
  int i;
  CtxStyleNode *node = &mrg->state->style_node;
  for (i = 0; node->classes[i]; i++);
  node->classes[i] = mrg_intern_string (class_name);
}

static void ctx_css_add_pseudo_class (Css *mrg, const char *pseudo_class)
{
  int i;
  CtxStyleNode *node = &mrg->state->style_node;
  for (i = 0; node->pseudo[i]; i++);
  node->pseudo[i] = mrg_intern_string (pseudo_class);
}
#endif

void _mrg_set_wrap_edge_vfuncs (Css *mrg,
    float (*wrap_edge_left)  (Css *mrg, void *wrap_edge_data),
    float (*wrap_edge_right) (Css *mrg, void *wrap_edge_data),
    void *wrap_edge_data)
{
  mrg->state->wrap_edge_left = wrap_edge_left;
  mrg->state->wrap_edge_right = wrap_edge_right;
  mrg->state->wrap_edge_data = wrap_edge_data;
}

static void update_rect_geo (Ctx *ctx, void *userdata, const char *name, int count,
                             float *x, float *y, float *w, float *h)
{
  CtxFloatRectangle *geo = userdata;
  *w = geo->width;
  *h = geo->height;
}


void _mrg_layout_post (Css *mrg, CtxFloatRectangle *ret_rect)
{
  Ctx *ctx         = mrg->ctx;
  float vmarg      = 0;
  CtxStyle *style  = ctx_style (mrg);
  float height     = PROP(height);
  float width      = PROP(width);

  float padding_left = PROP(padding_left);
  float margin_left = PROP(margin_left);
  float border_left_width = PROP(border_left_width);
  float padding_right = PROP(padding_right);
  //float margin_right = PROP(margin_right);
  //float border_right_width = PROP(border_right_width);
  float padding_top = PROP(padding_top);
  float margin_top = PROP(margin_top);
  float border_top_width = PROP(border_top_width);
  float padding_bottom = PROP(padding_bottom);
  float margin_bottom = PROP(margin_bottom);
  float border_bottom_width = PROP(border_bottom_width);
  float left = PROP(left);
  float top = PROP(top);

  int returned_dim = 0;
  float ascent, descent;
  ctx_font_extents (mrg->ctx, &ascent, &descent, NULL);
  
  if (mrg->state->flow_root)
    clear_both (mrg);

  if (is_block_item (style))
  {
    if (style->display == CTX_DISPLAY_INLINE_BLOCK)
    {
      
    }
    else
    {
      if (mrg->line_got_baseline[mrg->line_level])
        _mrg_nl (mrg);
    }
    mrg->line_level--;
    //mrg->line_got_baseline [mrg->line_level] = 0;
  }

  /* remember data to store about float, XXX: perhaps better to store
   * straight into parent state?
   */
  if (style->float_)
  {
    CtxFloatData *float_data = &mrg->float_data[mrg->floats];
    if (mrg->floats + 1 < CTX_MAX_FLOATS)
      mrg->floats++;

    float_data->type = style->float_;
    float_data->x = 
       mrg->state->block_start_x - padding_left - border_left_width - margin_left;
    float_data->y = 
         mrg->state->block_start_y - mrg_em(mrg) - padding_top - border_top_width
      - margin_top;

    float_data->width = 
         mrg_edge_right (mrg) - mrg_edge_left (mrg)
     //+ border_left_width 
     //+ border_right_width
#if 0
     /*+ padding_left +*/ + border_left_width + margin_left
     /*+ padding_right +*/ + border_right_width + margin_right
#endif
     ;

    float_data->height = 
       mrg_y (mrg) - (mrg->state->block_start_y)
         + margin_bottom + padding_top + padding_bottom + border_top_width + border_bottom_width;
  }


  if (style->display == CTX_DISPLAY_INLINE_BLOCK)
  {
     if (height == 0)
       height = mrg_y (mrg) - (mrg->state->block_start_y);
      
     mrg->line_max_height[mrg->line_level-1] =
        ctx_maxf (mrg->line_max_height[mrg->line_level-1],
                  height);

    CtxFloatRectangle _geo;
    CtxFloatRectangle *geo = &_geo;
    memset (geo, 0, sizeof (_geo));

    if (width == 0)
    {
      width = mrg_x (mrg) - (mrg->state->block_start_x) + padding_right;
    }
    geo->width = width;
    geo->height = height;

    char name[10]="ele_";
    name[3]=mrg->state_no+2;

    ctx_resolve (mrg->ctx, name, update_rect_geo, geo);
    mrg_box (mrg,
        mrg->state->block_start_x,
        mrg->state->block_start_y,
        geo->width,
        geo->height);
    if (ret_rect)
    {
       ret_rect->x = mrg->state->block_start_x;
       ret_rect->y = mrg->state->block_start_y;
       ret_rect->width = geo->width;
       ret_rect->height = geo->height;
       returned_dim = 1;
    }

    {
      CtxMatrix transform;
      ctx_get_matrix (mrg_ctx (mrg), &transform);
      float x = ctx_pointer_x (ctx);
      float y = ctx_pointer_y (ctx);
      ctx_matrix_invert (&transform);
      ctx_matrix_apply_transform (&transform, &x, &y);
    }

    //mrg_edge_right (mrg) - mrg_edge_left (mrg), mrg_y (mrg) - (mrg->state->block_start_y - mrg_em(mrg)));

      mrg_set_xy (mrg, 
          mrg_x (mrg) + width,
          mrg_y (mrg));
  }
  else if (is_block_item (style))
  {
    CtxFloatRectangle _geo;
    CtxFloatRectangle *geo = &_geo;
    memset (geo, 0, sizeof (_geo));

    geo->width = width;
    if (width == 0)
    {
#if 0
      if (mrg_y (mrg) == (ctx->state->block_start_y))
        geo->width = mrg_x (mrg) - (ctx->state->block_start_x);
      else
        geo->width = mrg->state->edge_right  - (ctx->state->block_start_x);
#endif
      if (style->float_)
      {
        geo->width = mrg_x (mrg) - (mrg->state->block_start_x);
      }
      else
      {
        geo->width = _mrg_dynamic_edge_right(mrg)-
                      _mrg_dynamic_edge_left (mrg);
      }
    }

    if (height == 0)
      height = mrg_y (mrg) - (mrg->state->block_start_y);
    geo->height = height;

    char name[10]="ele_";
    name[3]=mrg->state_no+2;


    mrg_box (mrg,
        mrg->state->block_start_x,
        mrg->state->block_start_y,
        geo->width,
        geo->height);
    if (ret_rect)
    {
       ret_rect->x = mrg->state->block_start_x;
       ret_rect->y = mrg->state->block_start_y;
       ret_rect->width = geo->width;
       ret_rect->height = geo->height;
       returned_dim = 1;
    }

    geo->width += padding_right + padding_left;
    geo->height += padding_top + padding_bottom;
    ctx_resolve (mrg->ctx, name, update_rect_geo, geo);

    {
      CtxMatrix transform;
      ctx_get_matrix (mrg_ctx (mrg), &transform);
      float x = ctx_pointer_x (ctx);
      float y = ctx_pointer_y (ctx);
      ctx_matrix_invert (&transform);
      ctx_matrix_apply_transform (&transform, &x, &y);
    }

    //mrg_edge_right (mrg) - mrg_edge_left (mrg), mrg_y (mrg) - (mrg->state->block_start_y - mrg_em(mrg)));

    if (!style->float_ && (style->display == CTX_DISPLAY_BLOCK ||
                           style->display == CTX_DISPLAY_FLOW_ROOT ||
                           style->display == CTX_DISPLAY_LIST_ITEM))
    {
      vmarg = margin_bottom;

      mrg_set_xy (mrg, 
          mrg_edge_left (mrg),
          mrg_y (mrg) + vmarg + border_bottom_width + padding_bottom);
    }
  }
  else if (style->display == CTX_DISPLAY_INLINE)
  {
    float x0     = mrg->state->original_x;
    float y0     = mrg->state->original_y;
    float width  = mrg->x - x0;
    float height = mrg->y - y0;

    if (ret_rect)
    {
       ret_rect->x = x0;
       ret_rect->y = y0;
       ret_rect->width = width;
       ret_rect->height = height;

       returned_dim = 1;
    }
    mrg_box (mrg, x0, y0, width, height);

    mrg->x += paint_span_bg_final (mrg, mrg->x, mrg->y, 0);
  }


  /* restore insert position when having been out-of-context */
  if (style->float_ ||
      style->position == CTX_POSITION_ABSOLUTE ||
      style->position == CTX_POSITION_FIXED)
  {
    mrg_set_xy (mrg, mrg->state->original_x,
                     mrg->state->original_y);
  }

#if 0
  /* restore state to parent */
  mrg->state_no--;
  if (mrg->state_no<0)
     mrg->state_no=0;
  mrg->state = &mrg->states[mrg->state_no];
#endif

  if (mrg->state->style_id)
  {
    free (mrg->state->style_id);
    mrg->state->style_id = NULL;
  }
  /* restore relative shift */
  if (style->position == CTX_POSITION_RELATIVE)
  {
    //ctx_translate (mrg_ctx (mrg), -left, -top); // not really
    //                                            // needed we'll
    //                                                        // restore..
    mrg->relative_x -= left;
    mrg->relative_y -= top;
  }

  ctx_restore (mrg_ctx (mrg));

  if (style->position == CTX_POSITION_ABSOLUTE ||
      style->position == CTX_POSITION_FIXED)
  {
    int start_offset = mrg->state->drawlist_start_offset;
    int end_offset;
    const CtxEntry *entries = ctx_get_drawlist (mrg->ctx, &end_offset);
    int count = end_offset - start_offset;

    CssAbsolute *absolute = calloc (1, sizeof (CssAbsolute) + count * 9);
    absolute->z_index = style->z_index;
    absolute->top    = top;
    absolute->left   = left;
    if (style->position == CTX_POSITION_FIXED)
      absolute->fixed = 1;
    absolute->relative_x = mrg->relative_x;
    absolute->relative_y = mrg->relative_y;
    absolute->entries    = (CtxEntry*) (absolute + 1);
    absolute->count      = count;
    memcpy (absolute->entries, entries + start_offset, count * 9);

    ctx_list_prepend (&mrg->absolutes, absolute);

    ctx_drawlist_force_count (mrg->ctx, mrg->state->drawlist_start_offset);
  }



  mrg->state_no--;
  if (mrg->state_no < 0)
  {
    fprintf (stderr, "unbalanced css_start/css_end, enderflow %i\n", mrg->state_no);
    mrg->state_no = 0;
  }
  mrg->state = &mrg->states[mrg->state_no];

  mrg->state->vmarg = vmarg;

  if (ret_rect && !returned_dim)
    fprintf (stderr, "didnt return dim!\n");

  mrg->unresolved_line = 0;
}

enum {
  HTML_ATT_UNKNOWN = 0,
  HTML_ATT_STYLE,
  HTML_ATT_CLASS,
  HTML_ATT_ID,
  HTML_ATT_HREF,
  HTML_ATT_REL,
  HTML_ATT_SRC
};

typedef struct CssEntity {
   uint32_t    name;
   const char *value;
} CssEntity;

static CssEntity entities[]={
  {SQZ_shy,    ""},   // soft hyphen,. should be made use of in wrapping..
  {SQZ_nbsp,   " "},  //
  {SQZ_lt,     "<"},
  {SQZ_gt,     ">"},
  {SQZ_trade,  "™"},
  {SQZ_copy,   "©"},
  {SQZ_middot, "·"},
  {SQZ_bull,   "•"},
  {SQZ_Oslash, "Ø"},
  {SQZ_oslash, "ø"},
  {SQZ_hellip, "…"},
  {SQZ_aring,  "å"},
  {SQZ_Aring,  "Å"},
  {SQZ_aelig,  "æ"},
  {SQZ_AElig,  "Æ"},
  {SQZ_Aelig,  "Æ"},
  {SQZ_laquo,  "«"},
  {SQZ_raquo,  "»"},

  /*the above were added as encountered, the rest in anticipation  */

  {SQZ_reg,    "®"},
  {SQZ_deg,    "°"},
  {SQZ_plusmn, "±"},
  {SQZ_sup2,   "²"},
  {SQZ_sup3,   "³"},
  {SQZ_sup1,   "¹"},
  {SQZ_ordm,   "º"},
  {SQZ_para,   "¶"},
  {SQZ_cedil,  "¸"},
  {SQZ_bull,   "·"},
  {SQZ_amp,    "&"},
  {SQZ_mdash,  "–"},
  {SQZ_apos,   "'"},
  {SQZ_quot,   "\""},
  {SQZ_iexcl,  "¡"},
  {SQZ_cent,   "¢"},
  {SQZ_pound,  "£"},
  {SQZ_euro,   "€"},
  {SQZ_yen,    "¥"},
  {SQZ_curren, "¤"},
  {SQZ_sect,   "§"},
  {SQZ_phi,    "Φ"},
  {SQZ_omega,  "Ω"},
  {SQZ_alpha,  "α"},

  /* XXX: incomplete */

  {0, NULL}
};

void
ctx_set (Ctx *ctx, uint32_t key_hash, const char *string, int len);

static int 
mrg_parse_transform (Css *mrg, CtxMatrix *matrix, const char *str_in)
{
  // TODO : parse combined transforms

  const char *str = str_in;

  //int panic = 500;

  do {

  if (!strncmp (str, "matrix", 5))
  {
    char *s;
    int numbers = 0;
    double number[12]={0.0,};
    ctx_matrix_identity (matrix);
    s = (void*) ctx_strchr (str, '(');
    if (!s)
      return 0;
    s++;
    for (; *s &&  numbers < 11; s++)
    {
      switch (*s)
      {
        case '+':case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
        {
                char *olds = s;
        number[numbers] = strtod (s, &s);
        if (s == olds) return 0;
        //panic--;
        //if (panic < 0) return 0;
        }
        s--;
        numbers++;
      }
    }

    matrix->m[0][0] = number[0];
    matrix->m[0][1] = number[2];
    matrix->m[0][2] = number[4];
    matrix->m[1][0] = number[1];
    matrix->m[1][1] = number[3];
    matrix->m[1][2] = number[5];
  }
  else if (!strncmp (str, "scale", 5))
  {
    char *s;
    int numbers = 0;
    double number[12]={0,0};
    ctx_matrix_identity (matrix);
    s = (void*) ctx_strchr (str, '(');
    if (!s)
      return 0;
    s++;
    for (; *s; s++)
    {
      switch (*s)
      {
        case '+':case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
        {char *olds=s;
        number[numbers] = strtod (s, &s);
        if (s == olds) return 0;
        }
        s--;
        if (numbers<11)
          numbers++;
      }
    }
    if (numbers <= 1)
      ctx_matrix_scale (matrix, number[0], number[0]);
    else
      ctx_matrix_scale (matrix, number[0], number[1]);
  }
  else if (!strncmp (str, "translate", 5))
  {
    char *s;
    int numbers = 0;
    double number[12];
    ctx_matrix_identity (matrix);
    s = (void*) ctx_strchr (str, '(');
    if (!s)
      return 0;
    s++;
    for (; *s; s++)
    {
      switch (*s)
      {
        case '+':case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
         {
           char *olds = s;
           number[numbers] = strtod (s, &s);
           if (s == olds) return 0;
           s--;
        }
        if (numbers < 11)
        numbers++;
      }
    }
    ctx_matrix_translate (matrix, number[0], number[1]);
  }
  else if (!strncmp (str, "rotate", 5))
  {
    char *s;
    int numbers = 0;
    double number[12];
    ctx_matrix_identity (matrix);
    s = (void*) ctx_strchr (str, '(');
    if (!s)
      return 0;
    s++;
    for (; *s; s++)
    {
      switch (*s)
      {
        case '+':case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
        {
        char *prevs = s;
        number[numbers] = strtod (s, &s);
        if (prevs == s) return 0;
        if (numbers < 11)
          numbers++;
        }
      }
    }
    if (numbers == 3)
    {
      ctx_matrix_translate (matrix, -number[1], -number[2]);
      ctx_matrix_rotate (matrix, number[0] / 360.0 * 2 * M_PI);
      ctx_matrix_translate (matrix, number[1], number[2]);
    }
    else
    ctx_matrix_rotate (matrix, number[0] / 360.0 * 2 * M_PI);
  }
  else
  {
    //fprintf (stderr, "unhandled transform: %s\n", str);
    ctx_matrix_identity (matrix);
    return 0;
  }
    str = strchr (str, ')');
    if (str) {
        str++;
        while (*str == ' ')str++;
    }
  }
  while (str && strchr (str, '('));
  return 1;
}

int
mrg_parse_svg_path (Css *mrg, const char *str)
{
  /* this function is the seed of the ctx parser */
  char  command = 'm';
  char *s;
  int numbers = 0;
  double number[12];
  double pcx, pcy, cx, cy;

  if (!str)
    return -1;

  Ctx *ctx = mrg_ctx (mrg);
  ctx_parse (ctx, str);
  return 0;
  //ctx_move_to (ctx, 0, 0);
  //ctx_reset_path (ctx);
  cx = 0; cy = 0;
  pcx = cx; pcy = cy;

  s = (void*)str;
again:
  numbers = 0;

  for (; s && *s; s++)
  {
    switch (*s)
    {
      case 'z':
      case 'Z':
        pcx = cx; pcy = cy;
        ctx_close_path (ctx);
        break;
      case 'm':
      case 'a':
      case 's':
      case 'S':
      case 'M':
      case 'c':
      case 'C':
      case 'l':
      case 'L':
      case 'h':
      case 'H':
      case 'v':
      case 'V':
         command = *s;
         break;

      case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
      if (*s == '-')
      {
        number[numbers] = -strtod (s+1, &s);
        s--;
      }
      else
      {
        number[numbers] = strtod (s, &s);
        s--;
      }
      if (numbers < 11)
        numbers++;

      switch (command)
      {
        case 'a':
          if (numbers == 9)
          {
            /// XXX: NYI
            s++;
            goto again;
          }
          /* FALLTHROUGH */
        case 'A':
          if (numbers == 7)
          {
            /// XXX: NYI
            s++;
            goto again;
          }
          /* FALLTHROUGH */
        case 'm':
          if (numbers == 2)
          {
            ctx_rel_move_to (ctx, number[0], number[1]);
            cx += number[0];
            cy += number[1];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'h':
          if (numbers == 1)
          {
            ctx_rel_line_to (ctx, number[0], 0.0);
            cx += number[0];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'v':
          if (numbers == 1)
          {
            ctx_rel_line_to (ctx, 0.0, number[0]);
            cy += number[0];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'l':
          if (numbers == 2)
          {
            ctx_rel_line_to (ctx, number[0], number[1]);
            cx += number[0];
            cy += number[1];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'c':
          if (numbers == 6)
          {
            ctx_rel_curve_to (ctx, number[0], number[1],
                                    number[2], number[3],
                                    number[4], number[5]);
            pcx = cx + number[2];
            pcy = cy + number[3];
            cx += number[4];
            cy += number[5];
            s++;
            goto again;
          }
          break;
        case 's':
          if (numbers == 4)
          {
            ctx_curve_to (ctx, 2 * cx - pcx, 2 * cy - pcy,
                                number[0] + cx, number[1] + cy,
                                number[2] + cx, number[3] + cy);
            pcx = number[0] + cx;
            pcy = number[1] + cy;
            cx += number[2];
            cy += number[3];
            s++;
            goto again;
          }
          break;
        case 'M':
          if (numbers == 2)
          {
            ctx_move_to (ctx, number[0], number[1]);
            cx = number[0];
            cy = number[1];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'H':
          if (numbers == 1)
          {
            ctx_line_to (ctx, number[0], cy);
            cx = number[0];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'V':
          if (numbers == 1)
          {
            ctx_line_to (ctx, cx, number[0]);
            cy = number[0];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'L':
          if (numbers == 2)
          {
            ctx_line_to (ctx, number[0], number[1]);
            cx = number[0];
            cy = number[1];
            pcx = cx; pcy = cy;
            s++;
            goto again;
          }
          break;
        case 'C':
          if (numbers == 6)
          {
            ctx_curve_to (ctx, number[0], number[1],
                                number[2], number[3],
                                number[4], number[5]);
            pcx = number[2];
            pcy = number[3];
            cx = number[4];
            cy = number[5];
            s++;
            goto again;
          }
          break;
        case 'S':
          if (numbers == 4)
          {
            float ax = 2 * cx - pcx;
            float ay = 2 * cy - pcy;
            ctx_curve_to (ctx, ax, ay,
                                number[0], number[1],
                                number[2], number[3]);
            pcx = number[0];
            pcy = number[1];
            cx = number[2];
            cy = number[3];
            s++;
            goto again;
          }
          break;
        default:
          fprintf (stderr, "_%c", *s);
          break;
      }
      break;
      default:
        break;
    }
  }
  return 0;
}

static void
mrg_parse_polygon (Css *mrg, const char *str)
{
  Ctx *ctx = mrg_ctx (mrg);
  char *s;
  int numbers = 0;
  int started = 0;
  double number[12];

  if (!str)
    return;
  //ctx_move_to (ctx, 0, 0);

  s = (void*)str;
again:
  numbers = 0;

  for (; *s; s++)
  {
    switch (*s)
    {
      case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
      number[numbers] = _ctx_parse_float (s, &s);
      s--;
      if (numbers<11)
        numbers++;

      if (numbers == 2)
      {
        if (started)
          ctx_line_to (ctx, number[0], number[1]);
        else
        {
          ctx_move_to (ctx, number[0], number[1]);
          started = 1;
        }
        s++;
        goto again;
      }
      default:
        break;
    }
  }
}

#if 0
static void
mrg_parse_ellipse (Css *mrg, const char *str)
{
  Ctx *ctx = mrg_ctx (mrg);
  char *s;
  int numbers = 0;
  int started = 0;
  double number[12];

  if (!str)
    return;
  //ctx_move_to (ctx, 0, 0);

  s = (void*)str;
again:
  numbers = 0;

  for (; *s; s++)
  {
    switch (*s)
    {
      case '-':case '.':case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7': case '8': case '9':
      number[numbers] = _ctx_parse_float (s, &s);
      s--;
      if (numbers<11)
        numbers++;

      if (numbers == 2)
      {
        if (started)
          ctx_line_to (ctx, number[0], number[1]);
        else
        {
          ctx_move_to (ctx, number[0], number[1]);
          started = 1;
        }
        s++;
        goto again;
      }
      default:
        break;
    }
  }
}
#endif


void _mrg_set_wrap_edge_vfuncs (Css *mrg,
    float (*wrap_edge_left)  (Css *mrg, void *wrap_edge_data),
    float (*wrap_edge_right) (Css *mrg, void *wrap_edge_data),
    void *wrap_edge_data);

int mrg_get_contents (Css         *mrg,
                      const char  *referer,
                      const char  *input_uri,
                      char       **contents,
                      long        *length);


void  mrg_text_listen (Css *mrg, CtxEventType types,
                       CtxCb cb, void *data1, void *data2);

void  mrg_text_listen_full (Css *mrg, CtxEventType types,
                            CtxCb cb, void *data1, void *data2,
          void (*finalize)(void *listen_data, void *listen_data2, void *finalize_data),
          void  *finalize_data);
void  mrg_text_listen_done (Css *mrg);

char *_mrg_resolve_uri (const char *base_uri, const char *uri);
typedef struct _CssImage CssImage;
struct _CssImage
{
  char *uri;
  char *path;
  int width;
  int height;
  CtxBuffer *surface;
};

static CtxList *images = NULL;

static CssImage *_mrg_image (Css *mrg, const char *path)
{
  char *uri =  _mrg_resolve_uri (mrg->uri_base, path);

  for (CtxList *l = images; l; l = l->next)
  {
    CssImage *image = l->data;
    if (!strcmp (path, image->uri))
    {
       return image;
    }
  }

  int w = 0, h = 0;
#if 0
  char *p = strchr (uri, ':');
  if (p)
  {
    if (*p) p++;
    if (*p) p++;
    if (*p) p++;
  }
  else p = uri;
  ctx_texture_load (mrg->ctx, p, &w, &h, NULL);
#else
  ctx_texture_load (mrg->ctx, uri, &w, &h, NULL);
#endif

  if (w)
  {
    CssImage *image = calloc (1, sizeof (CssImage));
    image->width = w;
    image->height = h;
    image->uri = strdup (path);
    image->path = strdup (uri);
    ctx_list_prepend (&images, image);
    free (uri);
    return _mrg_image (mrg, path);
  }
  free (uri);
  return NULL;
}

int mrg_query_image (Css        *mrg,
                     const char *path,
                     int        *width,
                     int        *height)
{
  CssImage *image = _mrg_image (mrg, path);
  if (image)
  {
    *width = image->width;
    *height = image->height;
    return 1;
  }
  return 0;
}

void mrg_image (Css *mrg, float x0, float y0, float width, float height, float opacity, const char *path, int *used_width, int *used_height)
{
  CssImage *image = _mrg_image (mrg, path);
  if (image)
  {
    ctx_draw_image (mrg->ctx, image->path, x0, y0, width, height);
  }


}

enum
{
  URI_STATE_IN_PROTOCOL = 0,
  URI_STATE_IN_HOST,
  URI_STATE_IN_PORT,
  URI_STATE_E_S1,
  URI_STATE_E_S2,
  URI_STATE_IN_PATH,
  URI_STATE_IN_FRAGMENT,
};

int split_uri (char *uri,
               char **protocol,
               char **host,
               char **port,
               char **path,
               char **fragment)
{
  char *p;
  *protocol =
  *host =
  *port =
  *path =
  *fragment = NULL;

  if (strstr (uri, "//") || strchr(uri, ':'))
  {
    int mr = URI_STATE_IN_PROTOCOL;

    if (protocol)
      *protocol = uri;

    if (uri[0] == '/' &&
        uri[1] == '/')
    {
      mr = URI_STATE_E_S1;
      *protocol = NULL;
    }

    for (p = uri; *p; p++)
    {
      switch (mr)
     {
        case URI_STATE_IN_PROTOCOL:
          switch (*p)
          {
            default:
              break;
            case ':':
              *p = '\0';
              mr = URI_STATE_E_S1;
              break;
          }
          break;
        case URI_STATE_E_S1:
          switch (*p)
          {
            default:
              mr = URI_STATE_IN_HOST;
              if (path) *path = p;
              break;
            case '/':
              mr = URI_STATE_E_S2;
              break;
          }
          break;
        case URI_STATE_E_S2:
          switch (*p)
          {
            default:
              // XXX ?
              break;
            case '/':
              mr = URI_STATE_IN_HOST;
              if (host) *host = p+1;
              break;
          }
          break;
        case URI_STATE_IN_HOST:
          switch (*p)
          {
            default:
              break;
            case ':':
              *p = '\0';
              mr = URI_STATE_IN_PORT;
              if (port) *port = p+1;
              break;
            case '/':
              *p = '\0';
              mr = URI_STATE_IN_PATH;
              if (path) *path = p+1;
              break;
          }
         break;
        case URI_STATE_IN_PORT:
          switch (*p)
          {
            default:
              break;
            case '/':
              *p = '\0';
              mr = URI_STATE_IN_PATH;
              if (path) *path = p+1;
              break;
          }
          break;
        case URI_STATE_IN_PATH:
          switch (*p)
          {
            default:
              break;
            case '#':
              *p = '\0';
              mr = URI_STATE_IN_FRAGMENT;
              if (fragment) *fragment = p+1;
              break;
          }
          break;
      }
    }
  }
  else
  {

    int mr = URI_STATE_IN_HOST;
    if (protocol)
      *protocol = NULL;

    if (uri[0]=='/')
    {
      if (host)
        *host = NULL;
      if (port)
        *port = NULL;
      *uri = '\0';
      mr = URI_STATE_IN_PATH;
      if (path) *path = uri+1;
    }
    else
    {
      mr = URI_STATE_IN_PATH;
      if (path) *path = uri;
    }

    for (p = uri; *p; p++)
    {
      switch (mr)
      {
        case URI_STATE_IN_PROTOCOL:
          switch (*p)
          {
            default:
              break;
            case ':':
              *p = '\0';
              mr = URI_STATE_E_S1;
              break;
          }
          break;
        case URI_STATE_E_S1:
          switch (*p)
          {
            default:
              // XXX ?
              break;
            case '/':
              mr = URI_STATE_E_S2;
              break;
          }
          break;
        case URI_STATE_E_S2:
         switch (*p)
          {
            default:
              // XXX ?
              break;
            case '/':
              mr = URI_STATE_IN_HOST;
              if (host) *host = p+1;
              break;
          }
          break;
        case URI_STATE_IN_HOST:
          switch (*p)
          {
            default:
              break;
            case ':':
              *p = '\0';
              mr = URI_STATE_IN_PORT;
              if (port) *port = p+1;
              break;
            case '/':
              *p = '\0';
              mr = URI_STATE_IN_PATH;
              if (path) *path = p+1;
              break;
          }
          break;
        case URI_STATE_IN_PORT:
          switch (*p)
          {
            default:
              break;
            case '/':
              *p = '\0';
              mr = URI_STATE_IN_PATH;
              if (path) *path = p+1;
              break;
          }
          break;
        case URI_STATE_IN_PATH:
          switch (*p)
          {
            default:
              break;
            case '#':
              *p = '\0';
              mr = URI_STATE_IN_FRAGMENT;
              if (fragment) *fragment = p+1;
              break;
          }
          break;
      }
   }
  }
  if (*protocol && (*protocol)[0] == 0)
    *protocol = NULL;
  return 0;
}

char *_mrg_resolve_uri (const char *base_uri, const char *uri)
{
  char *ret;
  char *uri_dup = strdup (uri);

  if (!base_uri)
    return uri_dup;

  char *base_dup = strdup (base_uri);

  char *protocol = NULL;
  char *host = NULL;
  char *port = NULL;
  char *path = NULL;
  char *fragment = NULL;
  char *base_protocol = NULL;
  char *base_host = NULL;
  char *base_port = NULL;
  char *base_path = NULL;
  char *base_fragment = NULL;

  //int retlen = 0;
  int samehost = 0;

  split_uri (uri_dup, &protocol, &host, &port, &path, &fragment);
  split_uri (base_dup, &base_protocol, &base_host, &base_port, &base_path, &base_fragment);

  if (!protocol)
    protocol = base_protocol;
  if (!host)
  {
    host = base_host;
    port = base_port;
    samehost = 1;
  }
  ret = malloc (
      (path?strlen (path):0)
      + (fragment?strlen (fragment):0) +
      (host?strlen (host):0) + 640);
  if (protocol)
  {
    if (uri[0] == '/' && uri[1] != '/')
      sprintf (ret, "%s://%s%s%s%s", protocol, host, port?":":"", port?port:"", uri);
    else if (uri[0] == '.' && uri[1] == '.' && uri[2] == '/' &&
             uri[3] == '.' && uri[4] == '.')
    {
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      if (base_path[strlen (base_path)-1] == '/')
        base_path[strlen (base_path)-1] = 0;
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      else
        base_path[0]=0;
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      if (base_path[strlen (base_path)-1] == '/')
        base_path[strlen (base_path)-1] = 0;
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      else
        base_path[0]=0;

      sprintf (ret, "c%s://%s%s%s/%s%s%s%s", protocol, host, port?":":"", port?port:"", samehost?base_path:"", &path[6], fragment?"#":"", fragment?fragment:"");
    }
    else if (uri[0] == '.' && uri[1] == '.')
    {
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      if (base_path[strlen (base_path)-1] == '/')
        base_path[strlen (base_path)-1] = 0;
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      else
        base_path[0]=0;

      sprintf (ret, "%s://%s%s%s/%s%s%s%s", protocol, host, port?":":"", port?port:"", samehost?base_path:"", &path[3], fragment?"#":"", fragment?fragment:"");
    }
    else
   {
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      else if (ctx_strchr (base_path, '/'))
        ctx_strchr (base_path, '/')[1] = 0;
      else
        base_path[0] = 0;

      if (host)
      sprintf (ret, "%s://%s%s%s/%s%s%s%s", protocol, host, port?":":"", port?port:"", samehost?base_path:"", path, fragment?"#":"", fragment?fragment:"");
      else
      sprintf (ret, "%s:%s%s%s%s", protocol, samehost?base_path:"", path, fragment?"#":"", fragment?fragment:"");

    }
  }
  else
  {
    if (uri[0] == '/')
      sprintf (ret, "/%s", path);
    else
    {
      if (strrchr (base_path, '/'))
        strrchr (base_path, '/')[1] = 0;
      sprintf (ret, "/%s%s", base_path, path);
    }
  }

  free (uri_dup);
  free (base_dup);
  return ret;
}

static float
_ctx_str_get_float (const char *string, int no)
{
  float ret = 0.0f;
  int number_no = 0;
  const char *s = string;
  if (!string) return ret;

  while (*s == ' ')s++;

  while (*s && number_no < no)
  {
     while ( *s && ((*s >= '0' && *s <= '9') || (*s=='.') || (*s=='-'))) s ++;
     number_no ++;
     while (*s == ' ')s++;
  }
  if (*s)
    return atof (s);

  return ret;
}


void css_xml_render (Css *mrg,
                     char *uri_base,
                     void (*link_cb) (CtxEvent *event, void *href, void *link_data),
                     void *link_data,
                     void *(finalize)(void *listen_data, void *listen_data2, void *finalize_data),
                     void *finalize_data,
                     char *html_)
{
  CssXml *xmltok;
  CtxString *svg_text = ctx_string_new ("");
  uint32_t tag[CTX_MAX_STATE_DEPTH];
  int pos             = 0;
  int type            = t_none;
  static int depth    = 0;
  int in_style        = 0;
  int in_defs         = 0;
  int should_be_empty = 0;
  int tagpos          = 0;
  ItkCssDef *defs = NULL;

  if (mrg->uri_base)
          free (mrg->uri_base);
  mrg->uri_base = NULL;
  if (uri_base)
    mrg->uri_base = strdup (uri_base);

  CtxString *style = ctx_string_new ("");
  int whitespaces = 0;
  uint32_t att = 0;


////////////////////////////////////////////////////
  CtxString *str = NULL;

  whitespaces = 0;
  att = 0;
  pos = 0;
#if 1
  xmltok = xmltok_buf_new (html_);

  ctx_save (mrg->ctx);
  while (type != t_eof && type != t_error)
  {
    char *data = NULL;
    type = xmltok_get (xmltok, &data, &pos);
    switch (type)
    {
      case t_word:
      case t_whitespace:
        if (in_style)
        {
          ctx_stylesheet_add (mrg, data, uri_base, CTX_STYLE_XML, NULL);
        }
        break;
      case t_att:
#if 0
        for (int i = 0; data[i]; i++)
          if (data[i]=='-')data[i]='_';
#endif
        att = ctx_strhash (data);
        break;
      case t_val:
        if (in_defs)
        {
          ctx_set_string (mrg->ctx, att, data);
        }
        break;
      case t_endtag:
        {
        //int i;
        uint32_t data_hash = ctx_strhash (data);
     // for (i = 0; data[i]; i++)
     //   data[i] = tolower (data[i]);
        in_style = (data_hash == SQZ_style);

        if (data_hash == SQZ_defs)
        {
          in_defs = 1;
        }

        if (in_defs)
        {

          switch (data_hash)
          {
            case SQZ_stop:
            {
               const char *offset     = ctx_get_string (mrg->ctx, SQZ_offset);
               const char *stop_color = ctx_get_string (mrg->ctx, SQZ_stop_color);
               const char *stop_opacity = ctx_get_string (mrg->ctx, SQZ_stop_opacity);

               float off = 0.0;
               float rgba[4] = {0,0,0,1.0f};
               if (!stop_color)
                 break;

               if (!strcmp (stop_color, "red"))
               {
                 rgba[0] = 1.0f;
               }
               else if (!strcmp (stop_color, "gold"))
               {
                 rgba[0] = 1.0f;
                 rgba[1] = 0.7f;
               }
               else
               {
                  CtxColor *color = ctx_color_new ();
                  ctx_color_set_from_string (mrg->ctx, color, stop_color);
                  ctx_color_get_rgba (ctx_get_state (mrg->ctx), color, rgba);
               }

               if (stop_opacity)
               {
                 if (strchr(stop_opacity, '%'))
                   rgba[3] *= (atof (stop_opacity) / 100.0f);
                 else 
                   rgba[3] *= (atof (stop_opacity));
               }

               if (offset)
               {
                 if (strchr(offset, '%'))
                   off = atof (offset) / 100.0f;
                 else 
                   off = atof (offset);
               }

               if (str)
              ctx_string_append_printf (str, "addStop %.3f %.3f %.3f %.3f %.3f\n",
                   off, rgba[0], rgba[1], rgba[2], rgba[3]);
            }
            break;
            case SQZ_radialGradient:
            {
              const char *id = ctx_get_string (mrg->ctx, SQZ_id);
#define GRAD_PROP_STR(name, def_val) \
              const char *name = def_val;\
              if (ctx_is_set(mrg->ctx, SQZ_##name)) name = PROPS(name);
#define GRAD_PROP_X(name, def_val) \
              float name; const char *str_##name = def_val;\
              if (ctx_is_set(mrg->ctx, SQZ_##name)) str_##name = PROPS(name);\
              name = mrg_parse_px_x (mrg, str_##name, NULL);
#define GRAD_PROP_Y(name, def_val) \
              float name; const char *str_##name = def_val;\
              if (ctx_is_set(mrg->ctx, SQZ_##name)) str_##name = PROPS(name);\
              name = mrg_parse_px_y (mrg, str_##name, NULL);
              

              // TODO : gradientUnits='userSpaceOnUse'  
              // TODO : gradientUnits='objectBoundingBox'  (default)
              // SQZ_gradientUnits
              // SQZ_gradientTransform
              // SQZ_spreadMethod  =  pad, reflect, repeat
              //
              // SQZ_fy,
              // SQZ_fx,
              // SQZ_fr,
              if (id)
              {
           // GRAD_PROP_STR(gradientUnits, "userSpaceOnUse");
           // GRAD_PROP_STR(spreadMethod, "pad");
                const char *transform = ctx_get_string (mrg->ctx, SQZ_gradientTransform);

              GRAD_PROP_X(cx, "50%");
              GRAD_PROP_Y(cy, "50%");
              GRAD_PROP_Y(r,  "100%");
              GRAD_PROP_Y(fr, "0%");
              GRAD_PROP_X(fx, "50%"); // XXX should be inherited from cx/cy
              GRAD_PROP_Y(fy, "50%"); // not 50% ..
            
              css_svg_add_def (&defs, ctx_strhash (id));

               str = css_svg_add_def (&defs, ctx_strhash (id));
               ctx_string_append_printf (str, " radialGradient %f %f %f %f %f %f\n",
                               cx,cy,r,fx,fy,fr);

               ctx_string_append_printf (str, " rgba ");
               if (transform)
               {
                 CtxMatrix matrix;
                 if (mrg_parse_transform (mrg, &matrix, transform))
                 {
               ctx_string_append_printf (str, " sourceTransform %f %f %f %f %f %f %f %f %f\n",
                        matrix.m[0][0], matrix.m[0][1], matrix.m[0][2],
                        matrix.m[1][0], matrix.m[1][1], matrix.m[1][2],
                        matrix.m[2][0], matrix.m[2][1], matrix.m[2][2]
                    );
                 }
                 
               }
              }
            }
            break;
            case SQZ_linearGradient:
            {
              const char *id = ctx_get_string (mrg->ctx, SQZ_id);

              if (id)
              {
                //GRAD_PROP_STR(gradientUnits, "userSpaceOnUse");
                //GRAD_PROP_STR(spreadMethod, "pad");
                const char *transform = ctx_get_string (mrg->ctx, SQZ_gradientTransform);
                GRAD_PROP_X(x1, "0%");
                GRAD_PROP_Y(y1, "0%");
                GRAD_PROP_X(x2, "100%");
                GRAD_PROP_Y(y2, "0%");

               str = css_svg_add_def (&defs, ctx_strhash (id));
               ctx_string_append_printf (str, " linearGradient %f %f %f %f\n",
                               x1,y1,x2,y2);
               ctx_string_append_printf (str, " rgba ");
               if (transform)
               {
                 CtxMatrix matrix;
                 if (mrg_parse_transform (mrg, &matrix, transform))
                 {
                    ctx_string_append_printf (str, " sourceTransform %f %f %f %f %f %f %f %f %f\n",
                        matrix.m[0][0], matrix.m[0][1], matrix.m[0][2],
                        matrix.m[1][0], matrix.m[1][1], matrix.m[1][2],
                        matrix.m[2][0], matrix.m[2][1], matrix.m[2][2]
                    );
                 }
                 
               }
              }
            }
            break;
          }

        }

        if (in_style)
        {
          if (mrg->css_parse_state)
                  free (mrg->css_parse_state);
          mrg->css_parse_state = NULL;
        }
        }
        break;
      case t_tag:

        if (in_defs)
          ctx_save (mrg->ctx);
        break;

      case t_closetag:
      case t_closeemptytag:
        {
          uint32_t data_hash = ctx_strhash (data);
          if (data_hash == SQZ_defs)
            in_defs = 0;
          if (in_defs)
          {
            ctx_restore (mrg->ctx);
          }
        }
        break;
      default:
        break;
    }
  }
  ctx_restore (mrg->ctx);
  in_defs = 0;
  in_style = 0;

  xmltok_free (xmltok);
#endif


////////////////////////////////////////////////////


  type = t_none;
  whitespaces = 0;
  att = 0;
  in_style = 0;
  xmltok = xmltok_buf_new (html_);

  {
    int no = mrg->text_listen_count;
    mrg->text_listen_data1[no] = link_data;
    mrg->text_listen_data2[no] = html_;
    mrg->text_listen_finalize[no] = (void*)finalize;
    mrg->text_listen_finalize_data[no] = finalize_data;
    mrg->text_listen_count++;
  }

  _mrg_set_wrap_edge_vfuncs (mrg, wrap_edge_left, wrap_edge_right, mrg);
  mrg->state = &mrg->states[0];


  //css_start (mrg, "fjo", NULL);
  //ctx_stylesheet_add (mrg, style_sheets->str, uri_base, CTX_STYLE_XML, NULL);

  while (type != t_eof && type != t_error)
  {
    char *data = NULL;
    type = xmltok_get (xmltok, &data, &pos);

    if (type == t_tag ||
        //type == t_att ||
        type == t_endtag ||
        type == t_closeemptytag ||
        type == t_closetag)
    {
      int i;
      for (i = 0; data[i]; i++)
        data[i] = tolower (data[i]);
    }

    switch (type)
    {
      case t_entity:
        {
          int i;
          int dealt_with = 0;
          if (data[0]=='#')
          {
            int c = atoi (&data[1]);
            css_printf (mrg, "%c", c);
          }
          else
          {
            uint32_t hash = ctx_strhash (data);
          for (i = 0; entities[i].name && !dealt_with; i++)
            if (hash == entities[i].name)
            {
              css_print (mrg, entities[i].value);
              dealt_with = 1;
            }
          }

          if (!dealt_with){
            css_start (mrg, "dim", (void*)((size_t)pos));
            css_print (mrg, data);
            css_end (mrg, NULL);
          }
        }
        break;
      case t_word:
        if (in_style)
        {
          //ctx_stylesheet_add (mrg, data, uri_base, CTX_STYLE_XML, NULL);
        }
        else
        {
          if (mrg->in_svg)
          {
            ctx_string_append_str(svg_text, data);
          }
          else
          css_print (mrg, data);
        }
        whitespaces = 0;
        break;

      case t_whitespace:
        if (in_style)
        {
          //ctx_stylesheet_add (mrg, data, uri_base, CTX_STYLE_XML, NULL);
        }
        else
        {
          if (mrg->in_svg)
          {
            //if (whitespaces == 0)
            {
              ctx_string_append_str (svg_text, data);
            }
            whitespaces ++;
          }
          else
          switch (ctx_style (mrg)->white_space)
          {
            case CTX_WHITE_SPACE_PRE: /* handles as pre-wrap for now */
            case CTX_WHITE_SPACE_PRE_WRAP:
              css_print (mrg, data);
              break;
            case CTX_WHITE_SPACE_PRE_LINE:
              switch (*data)
              {
                case ' ':
                  whitespaces ++;
                  if (whitespaces == 1)
                    css_print (mrg, " ");
                  break;
                case '\n':
                  whitespaces = 0;
                  break;
              }
              break;
            case CTX_WHITE_SPACE_NOWRAP: /* XXX: handled like normal, this is bad.. */
            case CTX_WHITE_SPACE_NORMAL: 
              whitespaces ++;
              if (whitespaces == 1)
              {
                int save = mrg->unresolved_line;
                css_print (mrg, " ");
                mrg->unresolved_line = save;
              }
              break;
          }
        }
        break;
      case t_tag:
        //htmlctx->attributes = 0;
        //ctx_save (mrg->ctx);
        {
          uint32_t data_hash = ctx_strhash (data);
          tagpos = pos;
          ctx_string_clear (style);
          ctx_set_string (mrg->ctx, SQZ_style, "");
          ctx_set_string (mrg->ctx, SQZ_transform, "");

          if (data_hash == SQZ_html)
          {
          }
          else if (data_hash == SQZ_defs)
          {
            in_defs = 1;
          }
          else if (data_hash == SQZ_svg)
          {
             mrg->in_svg++;
          }
        }
        break;
      case t_att:
#if 0
        for (int i = 0; data[i]; i++)
          if (data[i]=='-')data[i]='_';
#endif
        att = ctx_strhash (data);
        break;
      case t_val:
        ctx_set_string (mrg->ctx, att, data);
        {
            uint32_t style_attribute[] ={
              SQZ_fill_rule,
              SQZ_font_size,
              SQZ_font_family,
              SQZ_fill_color,
              SQZ_fill,
              SQZ_stroke_width,
              SQZ_stroke_color,
              SQZ_stroke_linecap,
              SQZ_stroke_miterlimit,
              SQZ_stroke_linejoin,
              SQZ_stroke,
              // SQZ_viewBox,  // SQZ_version
              SQZ_color,
              SQZ_background_color,
              SQZ_background,
              SQZ_text_anchor,
              0};
            char *style_attribute_names[] ={
              "fill-rule",
              "font-size",
              "font-family",
              "fill-color",
              "fill",
              "stroke-width",
              "stroke-color",
              "stroke-linecap",
              "stroke-miterlimit",
              "stroke-linejoin",
              "stroke",
              //"viewBox",
              "color",
              "background-color",
              "background",
              "text-anchor",
              0};

              int j;
              for (j = 0; style_attribute[j]; j++)
                if (att == style_attribute[j])
                {
                  ctx_string_append_printf (style, "%s: %s;",
                      style_attribute_names[j], data);
                  break;
                }
          }
        break;
      case t_endtag:
        {
          uint32_t data_hash = ctx_strhash (data);
#if 0
          int prev_is_self_closing = 0;

          if (depth) switch (tag[depth-1])
          {
            case SQZ_p:
            case SQZ_li:
            case SQZ_dt:
            case SQZ_dd:
            case SQZ_option:
            case SQZ_thead:
            case SQZ_tbody:
            case SQZ_head:
            case SQZ_tfoot:
            case SQZ_colgroup:
            case SQZ_th:
              prev_is_self_closing = 1;
              break;
          }

          if (prev_is_self_closing)
          {
             int is_block = 0;
             switch (data_hash)
             {
                case SQZ_tr:
                case SQZ_li:
                case SQZ_p:
                case SQZ_div:
                //case SQZ_td:
                  is_block = 1;
                  break;
             }
             if (is_block)
             {
               css_end (mrg, NULL);
               depth--;
             }

          }

#else

        if (depth && (data_hash == SQZ_tr && tag[depth-1] == SQZ_td))
        {
          css_end (mrg, NULL);
          depth--;
          css_end (mrg, NULL);
          depth--;
        }
        if (depth && (data_hash == SQZ_tr && tag[depth-1] == SQZ_td))
        {
          css_end (mrg, NULL);
          depth--;
          css_end (mrg, NULL);
          depth--;
        }
        else if (depth && ((data_hash == SQZ_dd && tag[depth-1] == SQZ_dt) ||
                      (data_hash == SQZ_li && tag[depth-1] == SQZ_li) ||
                      (data_hash == SQZ_dt && tag[depth-1] == SQZ_dd) ||
                      (data_hash == SQZ_td && tag[depth-1] == SQZ_td) ||
                      (data_hash == SQZ_tr && tag[depth-1] == SQZ_tr) ||
                      (data_hash == SQZ_dd && tag[depth-1] == SQZ_dd) ||
                      (data_hash == SQZ_p &&  tag[depth-1] == SQZ_p)))
        {
          css_end (mrg, NULL);
          depth--;
        }
#endif

        tag[depth] = data_hash;
        depth ++;
        depth = ctx_mini(depth, CTX_MAX_STATE_DEPTH-1);

        {
          char combined[512]="";
          char *klass = (char*)PROPS(class);
          /* XXX: spaces in class should be turned into .s making
           * it possible to use multiple classes
           */
          const char *id = PROPS(id);

          const char *pseudo = "";

          if (klass)
          {
            klass = strdup (klass);
            if(1){
              int i;
              for (i = 0; klass[i]; i++)
                if (klass[i] == ' ')
                  klass[i]='.';
            }
          }

          combined[511]=0;
          snprintf (combined, 511, "%s%s%s%s%s%s",
              data,
              klass?".":"",
              klass?klass:"",
              id?"#":"",
              id?id:"", pseudo);

          //fprintf (stderr,"[%s]", combined);
          if (klass)
            free (klass);
            /* collect XML attributes and convert into CSS declarations */
          ctx_string_append_str (style, PROPS(style));
          css_start_with_style (mrg, combined, (void*)((size_t)tagpos), style->str);
        }

        if (data_hash == SQZ_g)
        {
          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
        }

        else if (data_hash == SQZ_svg)
        {
          const char *vbox = PROPS(viewbox);
          if (vbox && 0)
          {
            float x = _ctx_str_get_float (vbox, 0);
            float y = _ctx_str_get_float (vbox, 1);
            float width = _ctx_str_get_float (vbox, 2);
            float height = _ctx_str_get_float (vbox, 3);
            //fprintf (stderr, "viewBox:%s   %f %f %f %f\n", vbox, x, y, width, height);
            ctx_view_box (mrg->ctx, x, y, width, height);
          }
        }

        else if (data_hash == SQZ_polygon)
        {
          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          mrg_parse_polygon (mrg, PROPS(d));
          ctx_close_path (mrg->ctx);
          mrg_path_fill_stroke (mrg, &defs);
        }
        else if (data_hash == SQZ_polyline)
        {
          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          mrg_parse_polygon (mrg, PROPS(d));
          mrg_path_fill_stroke (mrg, &defs);
        }

        else if (data_hash == SQZ_path)
        {
          const char *transform;
          ctx_reset_path (mrg_ctx (mrg)); // XXX: eeeek!
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          mrg_parse_svg_path (mrg, PROPS(d));
          mrg_path_fill_stroke (mrg, &defs);
        }

        else if (data_hash == SQZ_line)
        {
          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          // SQZ_x1
          // SQZ_y1
          // SQZ_x2
          // SQZ_y2
          ctx_move_to (mrg->ctx, PROP(x1), PROP(y1));
          ctx_line_to (mrg->ctx, PROP(x2), PROP(y2));
          mrg_path_fill_stroke (mrg, &defs);
        }
        else if (data_hash == SQZ_ellipse)
        {
          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          ctx_save (mrg->ctx);
          ctx_translate (mrg->ctx, PROP(cx), PROP(cy));
          ctx_scale (mrg->ctx, PROP(rx), PROP(ry));
          ctx_arc (mrg->ctx, 0.0f, 0.0f, 1.0f, 0.0f, M_PI*2, 0);
          ctx_restore (mrg->ctx);
          mrg_path_fill_stroke (mrg, &defs);
        }

        else if (data_hash == SQZ_circle)
        {
          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          ctx_arc (mrg->ctx, PROP(cx), PROP(cy), PROP(r), 0.0f, M_PI*2.0f, 0);
          mrg_path_fill_stroke (mrg, &defs);
        }

        else if (data_hash == SQZ_rect && !in_defs)
        {
          float width  = PROP(width);
          float height = PROP(height);
          float x      = PROP(x);
          float y      = PROP(y);
          float rx     = PROP(rx);

          const char *transform;
          if ((transform = PROPS(transform)))
            {
              CtxMatrix matrix;
              if (mrg_parse_transform (mrg, &matrix, transform))
                ctx_apply_matrix (mrg_ctx (mrg), &matrix);
            }
          if (rx > 0.001f)
            ctx_round_rectangle (mrg_ctx (mrg), x, y, width, height, rx);
          else
            ctx_rectangle (mrg_ctx (mrg), x, y, width, height);
          mrg_path_fill_stroke (mrg, &defs);
        }

        else if (data_hash == SQZ_text)
        {
          ctx_string_set (svg_text, "");
        }

        if (data_hash == SQZ_a)
        {
          if (link_cb && ctx_is_set_now (mrg->ctx, SQZ_href))
            mrg_text_listen_full (mrg, CTX_CLICK, link_cb, _mrg_resolve_uri (uri_base, ctx_get_string (mrg->ctx, SQZ_href)), link_data, (void*)free, NULL); //XXX: free is not invoked according to valgrind
        }

        else if (data_hash == SQZ_style)
        {
          in_style = 1;
#if 1
          if (mrg->css_parse_state)
                  free (mrg->css_parse_state);
          mrg->css_parse_state = NULL;
#endif
        }
        else
          in_style = 0;

        should_be_empty = 0;

        if (data_hash == SQZ_link)
        {
          const char *rel;
          if ((rel=PROPS(rel)) && !strcmp (rel, "stylesheet") && ctx_is_set_now (mrg->ctx, SQZ_href))
          {
            char *contents;
            long length;
            mrg_get_contents (mrg, uri_base, ctx_get_string (mrg->ctx, SQZ_href), &contents, &length);
            if (contents)
            {
              ctx_stylesheet_add (mrg, contents, uri_base, CTX_STYLE_XML, NULL);
              free (contents);
            }
          }
        }

        if (data_hash == SQZ_img && ctx_is_set_now (mrg->ctx, SQZ_src))
        {
          int img_width, img_height;
          const char *src = ctx_get_string (mrg->ctx, SQZ_src);

          if (mrg_query_image (mrg, src, &img_width, &img_height))
          {
            float width  = PROP(width);
            float height = PROP(height);

            if (width < 1)
            {
               width = img_width;
            }
            if (height < 1)
            {
               height = img_height *1.0 / img_width * width;
            }

            mrg->y += height;

            mrg_image (mrg,
            mrg->x,
            mrg->y - height,
            width,
            height,
            1.0f,
            src, NULL, NULL);

            mrg->x += width;
          }
          else
          {
            css_printf (mrg, "![%s]", src);
          }
        }
#if 1
        switch (data_hash)
        {
          case SQZ_link:
          case SQZ_meta:
          case SQZ_input:
          case SQZ_img:
          case SQZ_br:
          case SQZ_hr:
            should_be_empty = 1;
            css_end (mrg, NULL);
            depth--;
        }
#endif
        }
        break;

      case t_closeemptytag:
      case t_closetag:
        if (!should_be_empty)
        {
          uint32_t data_hash = ctx_strhash (data);
          if (!strcmp (data, "a"))
          {
            mrg_text_listen_done (mrg);
          }
          in_style = 0;
          css_end (mrg, NULL);
          //ctx_restore (mrg->ctx);
          depth--;

        if (data_hash == SQZ_defs)
        {
          in_defs = 0;
        }
        else if (data_hash == SQZ_svg)
        {
          mrg->in_svg--;
        }
        else if (data_hash == SQZ_text)
        {
          ctx_move_to (mrg->ctx, PROP(x), PROP(y));

          //fprintf (stderr, "%f %f\n", PROP(text_align), PROP(text_anchor));
          ctx_font_size (mrg->ctx, PROP(font_size));
          ctx_text (mrg->ctx, svg_text->str);
        }

          if (depth<0)depth=0; // XXX
#if 1
          if (tag[depth] != data_hash)
          {
            if (tag[depth] == SQZ_p)
            {
              css_end (mrg, NULL);
              depth --;
            } else 
            if (depth > 0 && tag[depth-1] == data_hash)
            {
              css_end (mrg, NULL);
              depth --;
            }
            else if (depth > 1 && tag[depth-2] == data_hash)
            {
              int i;
              for (i = 0; i < 2; i ++)
              {
                depth --;
                css_end (mrg, NULL);
                //nctx_restore (mrg->ctx);
              }
            }
#if 0
            else if (depth > 2 && tag[depth-3] == data_hash)
            {
              int i;
              fprintf (stderr, "%i: fixing close of %s when %s wass open\n", pos, data, tag[depth]);

              for (i = 0; i < 3; i ++)
              {
                depth --;
                css_end (mrg, NULL);
               // ctx_restore (mrg->ctx);
              }
            }
            else if (depth > 3 && tag[depth-3] == data_hash)
            {
              int i;
              fprintf (stderr, "%i: fixing close of %s when %s wasss open\n", pos, data, tag[depth]);

              for (i = 0; i < 4; i ++)
              {
                depth --;
                css_end (mrg, NULL);
                //ctx_restore (mrg->ctx);
              }
            }
            else if (depth > 4 && tag[depth-5] == data_hash)
            {
              int i;
              fprintf (stderr, "%i: fixing close of %s when %s wassss open\n", pos, data, tag[depth]);

              for (i = 0; i < 5; i ++)
              {
                depth --;
                css_end (mrg, NULL);
              }
            }
#endif
            else
            {
              if (data_hash == SQZ_table && tag[depth] == SQZ_td)
              {
                depth--;
                css_end (mrg, NULL);
                depth--;
                css_end (mrg, NULL);
              }
              else if (data_hash == SQZ_table && tag[depth] == SQZ_tr)
              {
                depth--;
                css_end (mrg, NULL);
              }
            }
          }
#endif
        }
        else
          should_be_empty = 0;
        break;
    }
  }
  //css_end (mrg,  NULL);

  xmltok_free (xmltok);

  if (depth!=0){
    //fprintf (stderr, "xml parsing unbalanced, %i open tags.. \n", depth);
    while (depth > 0)
    {
      //fprintf (stderr, " %s ", ctx_str_decode (tag[depth-1]));
      css_end (mrg, NULL);
      depth--;
    }
    //fprintf (stderr, "\n");
  }

  ctx_string_free (style, 1);
  ctx_string_free (svg_text, 1);

  if (mrg->absolute_ctx)
  {
     ctx_render_ctx (mrg->absolute_ctx, mrg->ctx);
     ctx_destroy (mrg->absolute_ctx);
  }
  if (mrg->fixed_ctx)
  {
     ctx_render_ctx (mrg->fixed_ctx, mrg->ctx);
     ctx_destroy (mrg->fixed_ctx);
  }

  while (defs)
  {
    ItkCssDef *temp =defs;
    ctx_string_free (temp->str, 1);
    defs = temp->next;
    ctx_free (temp);
  }
}

int css_xml_extent (Css *mrg, uint8_t *contents, float *width, float *height, float *vb_x, float *vb_y, float *vb_width, float *vb_height)
{
  CssXml *xmltok;
  int pos             = 0;
  int type            = t_none;

  float c_width = 0.0f;
  float c_height = 0.0f;

   int in_svg = 0;
////////////////////////////////////////////////////

  type = t_none;
  unsigned int att = 0;
  xmltok = xmltok_buf_new ((char*)contents);

  while (type != t_eof)
  {
    char *data = NULL;
    type = xmltok_get (xmltok, &data, &pos);

    if (type == t_tag ||
        //type == t_att ||
        type == t_endtag ||
        type == t_closeemptytag ||
        type == t_closetag)
    {
      int i;
      for (i = 0; data[i]; i++)
        data[i] = tolower (data[i]);
    }

    switch (type)
    {
      case t_tag:
        //htmlctx->attributes = 0;
        //ctx_save (mrg->ctx);
        {
          uint32_t data_hash = ctx_strhash (data);

          in_svg = 0;
          if (data_hash == SQZ_html)
          {
          }
          else if (data_hash == SQZ_svg)
          {
             in_svg = 1;
          }
        }
        break;
      case t_att:
#if 0
        for (int i = 0; data[i]; i++)
          if (data[i]=='-')data[i]='_';
#endif
        att = ctx_strhash (data);

        break;
      case t_val:
        if (in_svg && att == SQZ_viewBox)
        {
            if(vb_x) *vb_x = _ctx_str_get_float (data, 0);
            if(vb_y) *vb_y = _ctx_str_get_float (data, 1);
            if(vb_width) *vb_width = _ctx_str_get_float (data, 2);
            if(vb_height) *vb_height = _ctx_str_get_float (data, 3);
        }
        else if (in_svg && att == SQZ_width)
        {
            c_width = mrg_parse_px_x (mrg, data, NULL);
            if(width) *width = c_width;
        }
        else if (in_svg && att == SQZ_height)
        {
            c_height = mrg_parse_px_y (mrg, data, NULL);
            if(height) *height = c_height;
        }
        break;
      case t_endtag:
        in_svg = 0;
        break;
    }
  }

  xmltok_free (xmltok);

  if (vb_width && (*vb_width == 0.0f)){
    if (vb_x) *vb_x = 0;
    *vb_width = c_width;
  }
  if (vb_height && (*vb_height == 0.0f)){
    if (vb_y) *vb_y = 0;
    *vb_height = c_height;
  }
  if (width && (*width == 0.0f) && vb_width)
  {
    *width = *vb_width;
  }
  if (height && (*height == 0.0f) && vb_height)
  {
    *height = *vb_height;
  }

  return 0;
}

void css_xml_renderf (Css *mrg,
                      char *uri_base,
                      void (*link_cb) (CtxEvent *event, void *href, void *link_data),
                      void *link_data,
                      char *format,
                      ...)
{
  va_list ap;
  size_t needed;
  char  *buffer;
  va_start(ap, format);
  needed = vsnprintf(NULL, 0, format, ap) + 1;
  buffer = malloc(needed);
  va_end (ap);
  va_start(ap, format);
  vsnprintf(buffer, needed, format, ap);
  va_end (ap);
  css_xml_render (mrg, uri_base, link_cb, link_data, NULL, NULL, buffer);
  free (buffer);
}
void css_init (Css *mrg, Ctx *ctx, int width, int height);

void css_print_xml (Css *mrg, const char *xml)
{
  css_xml_render (mrg, NULL, NULL, NULL, NULL, NULL, (char*)xml);
}

void
css_printf_xml (Css *mrg, const char *format, ...)
{
  va_list ap;
  size_t needed;
  char  *buffer;
  va_start(ap, format);
  needed = vsnprintf(NULL, 0, format, ap) + 1;
  buffer = malloc(needed);
  va_end (ap);
  va_start(ap, format);
  vsnprintf(buffer, needed, format, ap);
  va_end (ap);
  css_print_xml (mrg, buffer);
  free (buffer);
}

void mrg_set_size (Css *mrg, int width, int height)
{
  if (ctx_width (mrg->ctx) != width ||
      ctx_height (mrg->ctx) != height)
  {
    ctx_set_size (mrg->ctx, width, height);
    mrg_queue_draw (mrg, NULL);
  }
}

int
_mrg_file_get_contents (const char  *path,
                        char       **contents,
                        long        *length)
{
  FILE *file;
  long  size;
  long  remaining;
  char *buffer;

  file = fopen (path,"rb");

  if (!file)
    return -1;

  if (!strncmp (path, "/proc", 4))
  {
    buffer = calloc(1, 2048);
    *contents = buffer;
    *length = fread (buffer, 1, 2047, file);
    buffer[*length] = 0;
    return 0;
  }
  else
  {
    fseek (file, 0, SEEK_END);
    *length = size = remaining = ftell (file);
    rewind (file);
    buffer = malloc(size + 8);
  }

  if (!buffer)
    {
      fclose(file);
      return -1;
    }

  remaining -= fread (buffer, 1, remaining, file);
  if (remaining)
    {
      fclose (file);
      free (buffer);
      return -1;
    }
  fclose (file);
  *contents = buffer;
  buffer[size] = 0;
  return 0;
}

#if 0
static int
_mr_get_contents (const char  *referer,
                 const char  *uri,
                 char       **contents,
                 long        *length)
{
  char *uri_dup;
  char *protocol = NULL;
  char *host = NULL;
  char *port = NULL;
  char *path = NULL;
  char *fragment = NULL;
  uint32_t protocol_hash;
#if 0
  if (!strncmp (uri, "mrg:", 4))
  {
    return _mrg_internal_get_contents (referer, uri, contents, length);
  }
#endif

  uri_dup = strdup (uri);
  split_uri (uri_dup, &protocol, &host, &port, &path, &fragment);
  protocol_hash = protocol?ctx_strhash (protocol):0;
#if 0
  if (protocol && protocol_hash == SQZ_http)
  {
    int len;
    char *pathdup = malloc (strlen (path) + 2);
    pathdup[0] = '/';
    strcpy (&pathdup[1], path);
   // fprintf (stderr, "%s %i\n",host, port?atoi(port):80);
    char *cont = _mrg_http (NULL, host, port?atoi(port):80, pathdup, &len);
    *contents = cont;
    *length = len;
    //fprintf (stderr, "%s\n", cont);
    //
    fprintf (stderr, "%i\n", len);
    free (uri_dup);
    return 0;
  } else
#endif
  if (protocol && protocol_hash == SQZ_file)
  {
    char *path2 = malloc (strlen (path) + 2);
    int ret;
    sprintf (path2, "/%s", path);
    ret = ctx_get_contents (path2, (uint8_t**)contents, length);

    free (path2);
    free (uri_dup);
    fprintf (stderr, "a%i\n", (int)*length);
    return ret;
  }
  else
  {
    char *c = NULL;
    long  l = 0;
    int ret;
    free (uri_dup);
    ret = _mrg_file_get_contents (uri, &c, &l);
    if (contents) *contents = c;
    if (length) *length = l;
    return ret;
  }

  return -1;
}
#endif


typedef struct _CacheEntry {
  char *uri;
  long  length;
  char *contents;
} CacheEntry;

static CtxList *cache = NULL;



/* caching uri fetcher
 */
int
mrg_get_contents_default (const char  *referer,
                          const char  *input_uri,
                          char       **contents,
                          long        *length,
                          void        *ignored_user_data)
{
  Css *mrg = ignored_user_data;
  char *uri =  _mrg_resolve_uri (mrg->uri_base, input_uri);
#if 0 // without caching
  int ret = 0;
  ctx_get_contents (uri, (uint8_t**)contents, length);
  free (uri);
  return *contents!=NULL;
#else
  /* should resolve before mrg_get_contents  */
  //fprintf (stderr, "%s %s\n", uri, input_uri);

  for (CtxList *i = cache; i; i = i->next)
  {
    CacheEntry *entry = i->data;
    if (!strcmp (entry->uri, uri))
    {
      if (!entry->contents)
        {
          *contents = NULL;
          if (length) *length = 0;
  free (uri);
          return -1;
        }

      *contents = malloc (entry->length + 1);
      memcpy (*contents, entry->contents, entry->length);
      (*contents)[entry->length]=0;
      free (uri);
      if (length)
        *length = entry->length;
      if (*length)
      {
        return 0;
      }
      else
      {
        return -1;
      }
    }
  }

  {
    CacheEntry *entry = calloc (1, sizeof (CacheEntry));
    char *c = NULL;
    long  l = 0;

    entry->uri = uri;

    ctx_get_contents (uri, (unsigned char**)&c, &l);
   
    if (c){
      entry->contents = c;
      entry->length = l;
    } else
    {
      entry->contents = NULL;
      entry->length = 0;
    }
    ctx_list_prepend (&cache, entry);

#if MRG_URI_LOG
    if (c)
      fprintf (stderr, "%li\t%s\n", l, uri);
    else
      fprintf (stderr, "FAIL\t%s\n", uri);
#endif
  }

  int ret = mrg_get_contents_default (referer, uri, contents, length, ignored_user_data);
  return ret;
#endif
}

void css_init (Css *mrg, Ctx *ctx, int width, int height)
{
  //memset (mrg, 0, sizeof (Css));
  mrg->do_clip = 1;
  mrg->ctx = mrg->document_ctx = ctx;
  _ctx_events_init (mrg->ctx);
  mrg->state_no = 0;
  mrg->line_level=0;
  mrg->line_max_height[0]=0.0f;
  mrg->state = &mrg->states[mrg->state_no];
  mrg->state->float_base = 0;

  mrg->floats = 0;
#if 0
  mrg->state->children = 0;
  mrg->state->overflowed = 0;
  mrg->state->span_bg_started = 0;
#endif
  //memset (mrg->state, 0, sizeof (CssState));
  //memset (mrg->states, 0, sizeof (mrg->states));
  /* XXX: is there a better place to set the default text color to black? */
#if 0
  mrg->state->style.color.red =
  mrg->state->style.color.green =
  mrg->state->style.color.blue = 0;
  mrg->state->style.color.alpha = 1;
#endif
  if(1){
    CtxColor *color = ctx_color_new ();
    ctx_color_set_rgba (ctx_get_state (mrg->ctx), color, 1, 1, 1, 1);
    ctx_set_color (mrg->ctx, SQZ_color, color);
    ctx_color_free (color);
  }

  mrg->ddpx = 1;
#if 0
  if (getenv ("MRG_DDPX"))
  {
    mrg->ddpx = strtod (getenv ("MRG_DDPX"), NULL);
  }
#endif
  mrg_set_size (mrg, width, height);
  _mrg_text_init (mrg);

  if (!mrg->style)
    mrg->style = ctx_string_new ("");

  mrg_set_mrg_get_contents (mrg, mrg_get_contents_default, mrg);
  if (mrg->style_global)
    ctx_string_free (mrg->style_global, 1);
  mrg->style_global = ctx_string_new ("");


  if(0){
    const char *global_css_uri = "mrg:theme.css";

    if (getenv ("MRG_CSS"))
      global_css_uri = getenv ("MRG_CSS");

    char *contents;
    long length;
    mrg_get_contents (mrg, NULL, global_css_uri, &contents, &length);
    if (contents)
    {
      ctx_string_set (mrg->style_global, contents);
      free (contents);
    }
  }

  _mrg_clear_text_closures (mrg);
}

#if 0
Css *mrg_new (Ctx *ctx, int width, int height)
{
  Css *mrg;

  mrg = calloc (1, sizeof (Css));
  mrg->do_clip = 1;
  css_init (mrg, ctx, width, height);
  ctx_style_defaults (mrg);

#if 0
  printf ("%f %i %i\n", mrg->state->style.font_size, mrg_width(mrg), mrg_height(mrg));
  printf ("sizeof(Css) %li (was: 1142496)\n", sizeof(Css));
  printf ("sizeof(CssState) %li\n", sizeof(CssState));
  printf ("sizeof(CtxStyle) %li\n", sizeof(CtxStyle));
  printf ("sizeof(CssHtml) %li\n", sizeof(CssHtml));
  printf ("sizeof(CtxCssParseState) %li\n", sizeof(CtxCssParseState));
#endif

  return mrg;
}
#endif

void mrg_destroy (Css *mrg)
{
  if (mrg->edited_str)
    ctx_string_free (mrg->edited_str, 1);
  if (mrg->stylesheet)
    ctx_list_free (&mrg->stylesheet);
  if (mrg->style_global)
    ctx_string_free (mrg->style_global, 1);
  if (mrg->style)
    ctx_string_free (mrg->style, 1);
  if (mrg->css_parse_state)
    free (mrg->css_parse_state);
  mrg->edited_str = NULL;
  free (mrg);
}

typedef struct _UiChoice  UiChoice;
struct _UiChoice
{
  int   val;
  char *label;
};

void css_begin_menu_bar (Css *itk, const char *title)
{
  if (itk->menu_path)
    free (itk->menu_path);
  itk->menu_path = title?strdup (title):NULL;
}

void css_begin_menu (Css *itk, const char *title)
{
  char *tmp = malloc (strlen (title) + (itk->menu_path?strlen (itk->menu_path):0) + 2);
  sprintf (tmp, "%s/%s", itk->menu_path?itk->menu_path:"", title);
  if (itk->menu_path)
          free (itk->menu_path);
  itk->menu_path = tmp;
  if (css_button (itk, title))
  {
     if (itk->active_menu_path) free (itk->active_menu_path);
     itk->active_menu_path = strdup (itk->menu_path);
  }; 
}

void css_menu_item (Css *itk, const char *title)
{
  char *tmp = malloc (strlen (title) + (itk->menu_path?strlen (itk->menu_path):0) + 2);
  sprintf (tmp, "%s/%s", itk->menu_path?itk->menu_path:"", title);
  //fprintf (stderr, "[%s]\n", tmp);
  free (tmp);
}

void css_end_menu (Css *itk)
{
  if (itk->menu_path)
  {
    char *split = strrchr (itk->menu_path, '/');
    if (split) *split = 0;
  }
}

void css_end_menu_bar (Css *itk)
{
  css_newline (itk);
}

static char *css_style=NULL;

const char *css_style_string (const char *name)
{
  if (!css_style)
    return NULL;
  char *p = css_style;
  static char ret[64];
  int name_len = strlen (name);
  while (p && *p)
  {
    while (*p == ' ')p++;
    if (!strncmp (p, name, name_len))
    {
      if (p[name_len]==':')
      {
        for (int i = 2; p[name_len+i] && (p[name_len+i] != ';')
                        && (p[name_len+i] != '\n'); i++)
        {
          ret[i-2]=p[name_len+i];
          ret[i-1]=0;
        }
        return ret;
      }
    }
    else
    {
      p = strchr (p, '\n');
      if (p) p++;
    }
  }
  return NULL;
}

float css_style_float (char *name)
{
   const char *str = css_style_string (name);
   if (str)
   {
     return atof (str);
   }
   return 0.0f;
}

#if 1
void css_style_color (Ctx *ctx, const char *name)
{
   const char *str = css_style_string (name);
   if (str)
   {
     while (*str == ' ')str++;
     ctx_color (ctx, str);
     //ctx_stroke_source (ctx);
     //ctx_color (ctx, str);
   }
   else
   {
     ctx_rgb (ctx, 0, 0, 0); // XXX : this shows up in thumbnails
     //ctx_rgb_stroke (ctx, 1, 0, 1);
   }
}
#endif

static void css_style_color3 (Css *itk, const char *klass, uint32_t attr)
{           
   Ctx *ctx = itk->ctx;
   CtxStyleNode ancestor;
   CtxStyleNode *ancestry[2] = {&ancestor, NULL};
   memset(&ancestor, 0, sizeof (CtxStyleNode));
   ancestry[0]->element_hash = ctx_strhash ("div");
   ancestry[0]->classes_hash[0] = ctx_strhash (klass);
   // XXX : fix this casting hack, some stack waste is better then type mismatch?
   char *collated = _ctx_css_compute_style (itk, ancestry, 1);
   ctx_save (itk->ctx);
   css_set_style (itk, collated);
   CtxColor *color = ctx_color_new ();
   ctx_get_color (ctx, attr, color);
   ctx_restore (itk->ctx);
   mrg_ctx_set_source_color (ctx, color);
   ctx_color_free (color);
   free (collated);
}

void css_style_bg (Css *itk, const char *klass)
{
  css_style_color3 (itk, klass, SQZ_background_color);
}

void css_style_fg (Css *itk, const char *klass)
{
  css_style_color3 (itk, klass, SQZ_color);
}

float css_rel_ver_advance (Css *itk)
{
  return itk->rel_ver_advance;
}

Css *css_new (Ctx *ctx)
{
  Css *itk              = calloc (1, sizeof (Css));
  //itk->ctx              = ctx;
  //itk->panels = NULL;
  itk->focus_wraparound = 1;
  itk->scale            = 1.0;
  itk->font_size        = getenv("CSS_FONT_SIZE")?atoi(getenv("CSS_FONT_SIZE")):ctx_get_font_size(ctx);
  itk->label_width      = 0.5;
  itk->rel_vmargin      = 0.5;
  itk->rel_hmargin      = 0.5;
  itk->rel_ver_advance  = 1.2;
  itk->menu_path = strdup ("main/foo");
  itk->rel_hpad         = 0.3;
  itk->rel_vgap         = 0.2;
  itk->scroll_speed     = 1.0/8.0;
  itk->light_mode       = 1;
  ctx_queue_draw (ctx);
  if (ctx_backend_type (ctx) == CTX_BACKEND_TERM)
  {
    itk->scale     = 1.0;
    itk->font_size = 3;
    itk->rel_vgap = 0.0;
    itk->rel_ver_advance = 1.0;
    itk->rel_hpad = 0.0;
  }
  itk->width = itk->font_size * 15;

  Css *mrg = (Css*)itk;
  css_init (mrg, ctx, ctx_width(ctx), ctx_height(ctx));


  //ctx_stylesheet_clear (mrg);
  ctx_style_defaults (mrg);

  //printf ("%f %i %i\n", mrg->state->style.font_size, mrg_width(mrg), mrg_height(mrg));

  return itk;
}

float css_em (Css *itk)
{
  return itk->font_size * itk->scale;
}

void css_destroy (Css *itk)
{
  if (itk->menu_path)
    free (itk->menu_path);
  if (itk->stylesheet)
    ctx_list_free (&itk->stylesheet);
  if (itk->style_global)
    ctx_string_free (itk->style_global, 1);
  if (itk->style)
    ctx_string_free (itk->style, 1);
  if (itk->css_parse_state)
    free (itk->css_parse_state);
 

  free (itk);
}

static inline void control_ref (CtxControl *control)
{
  control->ref_count ++;
}

static inline void control_unref (CtxControl *control)
{
  if (control->ref_count <= 0)
  {
    CtxControl *w = control;

    if (w->label)
      free (w->label);
    if (w->fallback)
      free (w->fallback);
    if (w->entry_value)
      free (w->entry_value);

    free (w);
    return;
  }
  control->ref_count--;
}

void control_finalize (void *control, void *foo, void *bar)
{
  control_unref (control);
}

void css_reset (Css *itk)
{
  Ctx *ctx = itk->ctx = itk->document_ctx;
  ctx_start_frame           (ctx);

  if (css_style)
    free (css_style);
  unsigned char *style = NULL;
#if CTX_FONTS_FROM_FILE
  //ctx_get_contents ("/tmp/itk-style", &style, NULL);
#endif
  if (style)
  {
    css_style = (void*)style;
  }
  else
  {
    css_style = strdup (
"\n"
"itk-font-size: 32.0;\n"

"titlebar-bg:          #0007;\n"
"titlebar-fg:          #999a;\n"
"titlebar-close:       #fff9;\n"
"titlebar-focused-close: #c44;\n"
"titlebar-focused-bg:  #333b;\n"
"titlebar-focused-fg:  #ffff;\n"
"\n"
"terminal-bg:         #000f;\n"
"terminal-bg-reverse: #ddde;\n"
"terminal-active-bg:         #000b;\n"
"terminal-active-bg-reverse: #dddb;\n"
"\n"
"itk-bg:             rgba(30,40,50, 1.0);\n"
"itk-fg:             rgb(225,225,225);\n"
"\n"
    );

  }

  ctx_save (ctx);
  ctx_font (ctx, "Regular");
  ctx_font_size (ctx, css_em (itk));

  itk->next_flags = CSS_FLAG_DEFAULT;
  itk->panel      = NULL;

  while (itk->old_controls)
  {
    CtxControl *control = itk->old_controls->data;
    control_unref (control);
    ctx_list_remove (&itk->old_controls, control);
  }
  itk->old_controls = itk->controls;
  itk->controls = NULL;
  while (itk->choices)
  {
    UiChoice *choice = itk->choices->data;
    ctx_list_remove (&itk->choices, choice);
    free (choice->label);
    free (choice);
  }
  itk->control_no = 0;

  css_init ((Css*)itk, ctx, ctx_width (itk->ctx), ctx_height (itk->ctx));
  //mrg_clear (itk);
  ctx_clear_bindings (itk->ctx);
#if 0
  ctx_stylesheet_clear ((Css*)itk);
  ctx_style_defaults ((Css*)itk);
#endif
}

CssPanel *add_panel (Css *itk, const char *label, float x, float y, float width, float height)
{
  CssPanel *panel;
  for (CtxList *l = itk->panels; l; l = l->next)
  {
    CssPanel *panel = l->data;
    if (!strcmp (panel->title, label))
      return panel;
  }
  panel = calloc (1, sizeof (CssPanel));
  panel->title = strdup (label);
  panel->x = x;
  panel->y = y;
  panel->width = width;
  panel->height = height;
  ctx_list_prepend (&itk->panels, panel);

  itk->panel = panel;
  return panel;
}

void
css_panels_reset_scroll (Css *itk)
{
  if (!itk || !itk->panels)
          return;
  for (CtxList *l = itk->panels; l; l = l->next)
  {
    CssPanel *panel = l->data;
    panel->scroll = 0.0;
    panel->do_scroll_jump = 1;
  }
}


/* adds a control - should be done before the drawing of the
 * control itself - as this call might draw a highlight in
 * the background.
 *
 * This also allocats a runtime control, used for focus handling
 * and ephemreal persistance of possible interaction states -
 * useful for accesibility.
 */
CtxControl *css_add_control (Css *itk,
                             int type,
                             const char *label,
                             float x, float y,
                             float width, float height)
{
  CtxControl *control = calloc (1, sizeof (CtxControl));
  float em = css_em (itk);
  control->flags = itk->next_flags;
  itk->next_flags = CSS_FLAG_DEFAULT;
  control->label = strdup (label);
  if (itk->next_id)
  {
    control->id = itk->next_id;
    itk->next_id = NULL;
  }

  control->type = type;
  control->ref_count=0;
  control->x = x;
  control->y = y;
  control->no = itk->control_no;
  itk->control_no++;
  control->width = width;
  control->height = height;
  ctx_list_prepend (&itk->controls, control);

  if (itk->focus_no == control->no && itk->focus_no >= 0)
  {
     if (itk->y - itk->panel->scroll < em * 2)
     {
        if (itk->panel->scroll != 0.0f)
        {
          itk->panel->scroll -= itk->scroll_speed * itk->panel->height * (itk->panel->do_scroll_jump?5:1);
          if (itk->panel->scroll<0.0)
            itk->panel->scroll=0.0;
          ctx_queue_draw (itk->ctx);
        }
     }
     else if (itk->y - itk->panel->scroll +  control->height > itk->panel->y + itk->panel->height - em * 2 && control->height < itk->panel->height - em * 2)
     {
          itk->panel->scroll += itk->scroll_speed * itk->panel->height * (itk->panel->do_scroll_jump?5:1);

        ctx_queue_draw (itk->ctx);
     }
     else
     {
       itk->panel->do_scroll_jump = 0;
     }

  }

  //ctx_rectangle (itk->ctx, x, y, width, height);
  if (itk->focus_no == control->no &&
      control->type == UI_LABEL)   // own-bg
  {
#if 1
    //css_style_bg (itk, "focused");
    //ctx_fill (itk->ctx);
#if 0
    ctx_rectangle (itk->ctx, x, y, width, height);
    css_style_color (itk->ctx, "itk-fg");
    ctx_line_width (itk->ctx, 2.0f);
    ctx_stroke (itk->ctx);
#endif
#endif
  }
  else
  {
    if (control->flags & CSS_FLAG_ACTIVE)
    if (control->type != UI_LABEL && // no-bg
        control->type != UI_BUTTON)  // own-bg
    {
     // css_style_bg (itk, "interactive");
     // ctx_fill (itk->ctx);
    }
  }

  switch (control->type)
  {
    case UI_SLIDER:
      control->ref_count++;
      break;
    default:
      break;
  }

  return control;
}

#if 0
static void css_base (Css *itk, const char *label, float x, float y, float width, float height, int focused)
{
  Ctx *ctx = itk->ctx;
  if (focused)
  {
    css_style_color (itk->ctx, "itk-focused-bg");

    ctx_rectangle (ctx, x, y, width, height);
    ctx_fill (ctx);
  }
#if 0
  else
    css_style_color (itk->ctx, "itk-bg");

  if (itk->line_no >= itk->lines_drawn)
  {
    ctx_rectangle (ctx, x, y, width, height);
    ctx_fill (ctx);
    itk->lines_drawn = itk->line_no -1;
  }
#endif
}
#endif

void css_newline (Css *itk)
{
  itk->y += css_em (itk) * (itk->rel_ver_advance + itk->rel_vgap);
  itk->x = itk->edge_left;
  itk->line_no++;
}

void css_seperator (Css *itk)
{
  Css *mrg = (Css*)itk;
  css_start (mrg, "hr", NULL);
  css_end (mrg, NULL);
}

void css_label (Css *itk, const char *label)
{
  Css *mrg = (Css*)itk;
  //css_start (mrg, "label", NULL);
  css_print (mrg, label);
  //css_end (mrg, NULL);
}

void css_labelf (Css *itk, const char *format, ...)
{
  va_list ap;
  size_t needed;
  char *buffer;
  va_start (ap, format);
  needed = vsnprintf (NULL, 0, format, ap) + 1;
  buffer = malloc (needed);
  va_end (ap);
  va_start (ap, format);
  vsnprintf (buffer, needed, format, ap);
  va_end (ap);
  css_label (itk, buffer);
  free (buffer);
}

static void titlebar_drag (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CssPanel *panel = userdata;
  
#if 1
  //fprintf (stderr, "%d %f %f\n", event->delta_x, event->delta_y);
  panel->x += event->delta_x;
  panel->y += event->delta_y;
  if (panel->y < 0) panel->y = 0;
#else
  panel->x = event->x - panel->width / 2;
  panel->y = event->y;
#endif

  event->stop_propagate = 1;
  ctx_queue_draw (itk->ctx);
}

void css_titlebar (Css *itk, const char *label)
{
  Ctx *ctx = itk->ctx;
  float em = css_em (itk);

  //CtxControl *control = css_add_control (itk, UI_TITLEBAR, label, itk->x, itk->y, itk->width, em * itk->rel_ver_advance);

  ctx_rectangle (ctx, itk->x, itk->y, itk->width, em * itk->rel_ver_advance);
  ctx_listen_with_finalize (ctx, CTX_DRAG, titlebar_drag, itk->panel, itk, NULL, NULL);

  ctx_reset_path (ctx);
  itk->line_no = 0;
  itk->lines_drawn = 0;
  //css_base (itk, label, control->x, control->y, control->width - em * itk->rel_hmargin, em * itk->rel_ver_advance, itk->focus_no == control->no);
  css_label (itk, label);
  //itk->lines_drawn = 1;

  css_newline (itk);
}

void css_scroll_start (Css *itk, float height)
{
  CssPanel *panel = itk->panel;
  Ctx *ctx = itk->ctx;
  ctx_save (ctx);
  itk->panel->scroll_start_y = itk->y;
  ctx_rectangle (ctx, itk->edge_left - itk->rel_hmargin*css_em(itk), itk->y, panel->width, panel->height - (itk->y - panel->y));
  ctx_clip (ctx);
  ctx_reset_path (ctx);
  ctx_translate (ctx, 0.0, -panel->scroll);
}

// applies to next created control
void css_id (Css *itk, void *id)
{
  itk->next_id = id; 
}

// applies to next created control
void css_set_flag (Css *itk, int flag, int on)
{
  if (on)
  {
    itk->next_flags |= flag;
  }
  else
  {
    if (itk->next_flags & flag)
      itk->next_flags -= flag;
  }
}

void css_scroll_drag (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CssPanel *panel = data2;
  float scrollbar_height = panel->height - (panel->scroll_start_y - panel->y);
  float th = scrollbar_height * (scrollbar_height /  (panel->max_y-panel->scroll_start_y));
  if (th > scrollbar_height)
  {
    panel->scroll = 0;
    event->stop_propagate = 1;
    ctx_queue_draw (itk->ctx);
    return;
  }
  panel->scroll = ((event->y - panel->scroll_start_y - th / 2) / (scrollbar_height-th)) *
               (panel->max_y - panel->scroll_start_y - scrollbar_height)
          ;
  itk->focus_no = -1;
  ctx_queue_draw (itk->ctx);

  if (panel->scroll < 0) panel->scroll = 0;

  event->stop_propagate = 1;
}

void css_scroll_end (Css *itk)
{
  CssPanel *panel = itk->panel;
  Ctx *ctx = itk->ctx;
  float em = css_em (itk);
  ctx_restore (ctx);
  itk->panel->max_y = itk->y;

  float scrollbar_height = panel->height - (panel->scroll_start_y - panel->y);
  float scrollbar_width = em;

#if 1
  ctx_reset_path (ctx);
  ctx_rectangle (ctx, panel->x + panel->width- scrollbar_width,
                      panel->scroll_start_y,
                      scrollbar_width,
                      scrollbar_height);
  ctx_listen (ctx, CTX_DRAG, css_scroll_drag, itk, panel);
  css_style_bg (itk, "scroll");
  ctx_fill (ctx);
#endif

  ctx_reset_path (ctx);
  float th = scrollbar_height * (scrollbar_height /  (panel->max_y-panel->scroll_start_y));
  if (th > scrollbar_height) th = scrollbar_height;

  ctx_rectangle (ctx, panel->x + panel->width- scrollbar_width,
                      panel->scroll_start_y +
                      (panel->scroll / (panel->max_y-panel->scroll_start_y)) * ( scrollbar_height ),
                      scrollbar_width,
                      th
                      
                      );

  css_style_fg (itk, "scroll");
  ctx_fill (ctx);


}

CssPanel *css_panel_start (Css *itk, const char *title,
                      int x, int y, int width, int height)
{
  Ctx *ctx = itk->ctx;
  CssPanel *panel = add_panel (itk, title, x, y, width, height);
  float em = css_em (itk);
  css_set_edge_left (itk, panel->x + em * itk->rel_hmargin);
  css_set_edge_top (itk, panel->y);
  css_set_xy (itk, css_edge_left (itk), panel->y);
  //itk->edge_left = itk->x = panel->x + em * itk->rel_hmargin;
  //itk->edge_top = itk->y = panel->y;

  if (panel->width != 0)
  {
    panel->width = width;
    panel->height = height;
  }
  itk->width = panel->width;
  itk->height = panel->height;
  css_set_wrap_width (itk, panel->width - em);
  //css_set_height (itk, panel->height);

  itk->panel = panel;

  css_style_fg (itk, "itk");
  ctx_reset_path (ctx);
  ctx_rectangle (ctx, panel->x, panel->y, panel->width, panel->height);
  ctx_line_width (ctx, 2);
  ctx_stroke (ctx);

  css_style_bg (itk, "wallpaper");
  ctx_rectangle (ctx, panel->x, panel->y, panel->width, panel->height);
  ctx_fill (ctx);

  if (title[0])
    css_titlebar (itk, title);

  css_scroll_start (itk, panel->height - (itk->y - panel->y));
  css_start (itk, "div", NULL);
  return panel;
}

void css_panel_resize_drag (CtxEvent *event, void *data, void *data2)
{
  CssPanel *panel = data;
  panel->width += event->delta_x;
  panel->height += event->delta_y;
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void css_panel_end (Css *itk)
{
  Ctx *ctx = itk->ctx;
  CssPanel *panel = itk->panel;
  float em = css_em (itk);
  css_end ((Css*)itk, NULL);
  css_scroll_end (itk);

  ctx_rectangle (ctx, panel->x + panel->width - em,
                      panel->y + panel->height - em,
                      em,
                      em);
  ctx_listen (ctx, CTX_DRAG, css_panel_resize_drag, panel, itk);
  css_style_fg (itk, "wallpaper");
  ctx_reset_path (ctx);
  ctx_move_to (ctx, panel->x + panel->width,
                    panel->y + panel->height);
#if 1
  ctx_rel_line_to (ctx, -em, 0);
  ctx_rel_line_to (ctx, em, -em);
  ctx_rel_line_to (ctx, 0, em);
#endif
  ctx_fill (ctx);

  itk->panel = NULL;
}

#if 0
static void css_float_constrain (CtxControl *control, float *val)
{
  float new_val = *val;
  if (new_val < control->min) new_val = control->min;
  if (new_val > control->max) new_val = control->max;
  if (new_val > 0)
  {
     if (control->step > 0.0)
     {
       new_val = (int)(new_val / control->step) * control->step;
     }
  }
  else
  {
     if (control->step > 0.0)
     {
       new_val = -new_val;
       new_val = (int)(new_val / control->step) * control->step;
       new_val = -new_val;
     }
  }
  *val = new_val;
}

static void css_slider_cb_drag (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CtxControl  *control = userdata;
  float new_val;

  css_set_focus_no (itk, control->no);
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
  new_val = ((event->x - control->x) / (control->width)) * (control->max-control->min) + control->min;

  css_float_constrain (control, &new_val);

  itk->return_value = 1;
  control->value = new_val;
  itk->slider_value = new_val;
  //if (control->set_val)
  //  control->set_val (control->val, new_val, control->data);
}
#endif

float css_slider (Css *itk, const char *label, float value, double min, double max, double step)
{
#if 0
  Ctx *ctx = itk->ctx;
  char buf[100] = "";
  float em = css_em (itk);

  float new_x = itk->x + (itk->label_width) * itk->width;
  itk->x = new_x;

  CtxControl *control = css_add_control (itk, UI_SLIDER, label, itk->x, itk->y, itk->width * (1.0 - itk->label_width) - em * 1.5, em * itk->rel_ver_advance);
  //control->data = data;
  //
  control->value  = value;
  control->min  = min;
  control->max  = max;
  control->step = step;

  if (itk->focus_no == control->no)
    css_style_color (itk->ctx, "itk-focused-bg");
  else
    css_style_color (itk->ctx, "itk-interactive-bg");
  ctx_rectangle (ctx, itk->x, itk->y, control->width, em * itk->rel_ver_advance);
  ctx_fill (ctx);
  control_ref (control);
  ctx_rectangle (ctx, itk->x, itk->y, control->width, em * itk->rel_ver_advance);
  ctx_listen_with_finalize (ctx, CTX_DRAG, css_slider_cb_drag, control, itk, control_finalize, NULL);
  ctx_reset_path (ctx);

  double fval = value;

  if (step == 1.0)
  {
    sprintf (buf, "%.0f", fval);
  }
  else
  {
    sprintf (buf, "%.3f", fval);
  }
  css_style_color (itk->ctx, "itk-slider-text");
  ctx_text (ctx, buf);

  float rel_val = ((fval) - min) / (max-min);
  css_style_color (itk->ctx, "itk-slider-cursor");
  ctx_rectangle (ctx, itk->x + control->width * rel_val, itk->y, em/8, control->height);
  ctx_fill (ctx);
  ctx_rectangle (ctx, itk->x, itk->y + em*5/6, control->width, em/8);
  ctx_fill (ctx);

  itk->x += (1.0 - itk->label_width) * itk->width;
  css_newline (itk);

  if (control->no == itk->focus_no && itk->return_value)
  {
    itk->return_value = 0;
    ctx_queue_draw (ctx);
    return itk->slider_value;
  }
  return value;
#else
  Css *mrg = (Css*)itk;
  Ctx *ctx = itk->ctx;

  if (itk->focus_no == itk->control_no)
    css_start (mrg, "propline:focused", NULL);
  else
    css_start (mrg, "propline", NULL);
  css_label (itk, label);

  CtxFloatRectangle extent;
  css_start (mrg, "slider", NULL);
  css_printf (mrg, "%f", value);
  css_end (mrg, &extent);
  CtxControl *control = css_add_control (itk, UI_SLIDER, label,
                                         extent.x, extent.y, extent.width, extent.height);
  control->value  = value;
  control->min  = min;
  control->max  = max;
  control->step = step;
  css_end (mrg, NULL);

  if (control->no == itk->focus_no && itk->return_value)
  {
    itk->return_value = 0;
    ctx_queue_draw (ctx);
    return itk->slider_value;
  }
  return value;
#endif
}

void css_slider_float (Css *itk, const char *label, float *val, float min, float max, float step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_int (Css *itk, const char *label, int *val, int min, int max, int step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_double (Css *itk, const char *label, double *val, double min, double max, double step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_uint8 (Css *itk, const char *label, uint8_t *val, uint8_t min, uint8_t max, uint8_t step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_uint16 (Css *itk, const char *label, uint16_t *val, uint16_t min, uint16_t max, uint16_t step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_uint32 (Css *itk, const char *label, uint32_t *val, uint32_t min, uint32_t max, uint32_t step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_int8 (Css *itk, const char *label, int8_t *val, int8_t min, int8_t max, int8_t step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_int16 (Css *itk, const char *label, int16_t *val, int16_t min, int16_t max, int16_t step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

void css_slider_int32 (Css *itk, const char *label, int32_t *val, int32_t min, int32_t max, int32_t step)
{
  *val = css_slider (itk, label, *val, min, max, step);
}

CtxControl *css_find_control (Css *itk, int no)
{
  for (CtxList *l = itk->controls; l; l=l->next)
  {
    CtxControl *control = l->data;
    if (control->no == no)
     return control;
  }
  return NULL;
}


void css_entry_commit (Css *itk)
{
  if (itk->active_entry<0)
     return;

  for (CtxList *l = itk->controls; l; l=l->next)
  {
    CtxControl *control = l->data;
    if (control->no == itk->active_entry)
    {
      switch (control->type)
      {
        case UI_ENTRY:
         if (itk->entry_copy)
         {
  //fprintf (stderr, "ec %i %s\n", itk->active_entry, itk->entry_copy);
  //         strcpy (control->val, itk->entry_copy);
 //          free (itk->entry_copy);
 //          itk->entry_copy = NULL;
           itk->active = 2;
           ctx_queue_draw (itk->ctx);
         }
      }
      return;
    }
  }
}

void css_lost_focus (Css *itk)
{
  for (CtxList *l = itk->controls; l; l=l->next)
  {
    CtxControl *control = l->data;
    if (control->no == itk->active_entry)
    {
      switch (control->type)
      {
        case UI_ENTRY:
         if (itk->active_entry < 0)
           return;
         if (control->flags & CSS_FLAG_CANCEL_ON_LOST_FOCUS)
         {
           itk->active_entry = -1;
           itk->active = 0;
         }
         else if (itk->entry_copy)
         {
           itk->active = 2;
         }
         ctx_queue_draw (itk->ctx);
         break;
        default :
         itk->active = 0;
         itk->choice_active = 0;
         ctx_queue_draw (itk->ctx);
         break;
      }
      return;
    }
  }
}

void entry_clicked (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CtxControl *control = userdata;
  event->stop_propagate = 1;

  if (itk->active)
  {
    css_lost_focus (itk);
  }
  else
  {
    itk->entry_copy = strdup (control->entry_value);
    itk->entry_pos = strlen (itk->entry_copy);
    itk->active = 1;
    itk->active_entry = control->no;
  }

  css_set_focus_no (itk, control->no);
  ctx_queue_draw (event->ctx);
}


char *css_entry (Css        *itk,
                 const char *label,
                 const char *fallback,
                 const char *in_val)
{
  Css *mrg = (Css*)itk;
#if 1
  if (itk->focus_no == itk->control_no)
    css_start (mrg, "propline:focused", NULL);
  else
    css_start (mrg, "propline", NULL);
  css_label (itk, label);

  if (itk->active &&
      itk->entry_copy && itk->focus_no == itk->control_no)
  {
    int backup = itk->entry_copy[itk->entry_pos];
    char buf[4]="|";
    itk->entry_copy[itk->entry_pos]=0;
    css_label (itk, itk->entry_copy);
    css_label (itk, buf);

    buf[0]=backup;
    if (backup)
    {
      css_label (itk, buf);
      css_label (itk, &itk->entry_copy[itk->entry_pos+1]);
      itk->entry_copy[itk->entry_pos] = backup;
    }
  }
  else
  {
    if (in_val[0])
    {
      css_label (itk, in_val);
    }
    else
    {
      if (fallback)
      {
        css_label (itk, fallback);
      }
    }
  }

  CtxFloatRectangle extent;
  css_end (mrg, &extent);
  CtxControl *control = css_add_control (itk, UI_ENTRY, label,
                  extent.x, extent.y, extent.width, extent.height);
  control->entry_value = strdup (in_val);
  if (fallback)
    control->fallback = strdup (fallback);
  control->ref_count++;
#else
  float new_x = itk->x + itk->label_width * itk->width;

  float ewidth = itk->width * (1.0 - itk->label_width);

  if (label[0]) {
    css_label (itk, label);
    itk->x = new_x;
  }
  else
  {
    ewidth = itk->width;
  }
  CtxControl *control = css_add_control (itk, UI_ENTRY, label, itk->x, itk->y, ewidth, em * itk->rel_ver_advance);
  control->entry_value = strdup (in_val);
  if (fallback)
    control->fallback = strdup (fallback);
  control->ref_count++;

  ctx_rectangle (ctx, itk->x, itk->y, itk->width, em * itk->rel_ver_advance);

  if (control->flags & CSS_FLAG_ACTIVE)
  {
    ctx_listen_with_finalize (ctx, CTX_CLICK, entry_clicked, control, itk, control_finalize, NULL);
    control_ref (control);
  }

  ctx_reset_path (ctx);
  ctx_move_to (ctx, itk->x, itk->y + em);
  if (itk->active &&
      itk->entry_copy && itk->focus_no == control->no)
  {
    int backup = itk->entry_copy[itk->entry_pos];
    char buf[4]="|";
    itk->entry_copy[itk->entry_pos]=0;
    css_style_color (itk->ctx, "itk-interactive");
    ctx_text (ctx, itk->entry_copy);
    css_style_color (itk->ctx, "itk-entry-cursor");
    ctx_text (ctx, buf);

    buf[0]=backup;
    if (backup)
    {
      css_style_color (itk->ctx, "itk-interactive");
      ctx_text (ctx, buf);
      ctx_text (ctx, &itk->entry_copy[itk->entry_pos+1]);
      itk->entry_copy[itk->entry_pos] = backup;
    }
  }
  else
  {
    if (in_val[0])
    {
      if (control->flags & CSS_FLAG_ACTIVE)
        css_style_color (itk->ctx, "itk-interactive");
      else
        css_style_color (itk->ctx, "itk-fg");
      ctx_text (ctx, in_val);
    }
    else
    {
      if (control->fallback)
      {
        css_style_color (itk->ctx, "itk-entry-fallback");
        ctx_text (ctx, control->fallback);
      }
    }
  }
  itk->x += ewidth;
  css_newline (itk);
#endif

  if (itk->active == 2 && control->no == itk->active_entry)
  {
    itk->active = 0;
    itk->active_entry = -1;
    char *copy = itk->entry_copy;
    itk->entry_copy = NULL;
    ctx_queue_draw (itk->ctx); // queue a draw - since it is likely the
                               // response triggers computation
    return copy;
  }
  return NULL;
}

int css_entry_str_len (Css *itk, const char *label, const char *fallback, char *val, int maxlen)
{
   char *new_val;
   if ((new_val = css_entry (itk, label, fallback, val)))
   {
      if ((int)strlen (new_val) > maxlen -1)
        new_val[maxlen-1]=0;
      strcpy (val, new_val);
      free (new_val);
      return 1;
   }
   return 0;
}

void toggle_clicked (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CtxControl *control = userdata;
  int *val = control->val;
  itk->return_value = 1; // reusing despite name
  *val = (*val)?0:1;
  event->stop_propagate = 1;
  css_set_focus_no (itk, control->no);
  ctx_queue_draw (event->ctx);
}

static void button_clicked (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CtxControl *control = userdata;
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
  css_set_focus_no (itk, control->no);
  itk->return_value = 1;
}

int css_toggle (Css *itk, const char *label, int input_val)
{
  Ctx *ctx = itk->ctx;
  Css *mrg = (Css*)itk;
  //float em = css_em (itk);
  //float width = ctx_text_width (ctx, label) + em * itk->rel_hpad * 2;
  CtxFloatRectangle extent;
  
  if (itk->focus_no == itk->control_no)
    css_start (mrg, "propline:focused", NULL);
  else
    css_start (mrg, "propline", NULL);
  css_start (mrg, "toggle", NULL);

  css_print (mrg, label);

  if (input_val)
  {
      css_print (mrg, "[x]");
  }
  else
  {
      css_print (mrg, "[ ]");
  }

  css_end (mrg, &extent);
  css_end (mrg, NULL);
  CtxControl *control = css_add_control (itk, UI_TOGGLE, label,
                  extent.x, extent.y, extent.width, extent.height);

  control_ref (control);
  control->type = UI_TOGGLE;
  ctx_rectangle (ctx, extent.x, extent.y, extent.width, extent.height);
  ctx_listen_with_finalize (ctx, CTX_CLICK, button_clicked, control, itk, control_finalize, NULL);
  ctx_reset_path (ctx);

  if (control->no == itk->focus_no && itk->return_value)
  {
    itk->return_value = 0;
    ctx_queue_draw (ctx);
    return !input_val;
  }
  return input_val;
}


int css_radio (Css *itk, const char *label, int set)
{
  Ctx *ctx = itk->ctx;
  Css *mrg = (Css*)itk;
  //float em = css_em (itk);
  //float width = ctx_text_width (ctx, label) + em * itk->rel_hpad * 2;
  CtxFloatRectangle extent;
  
  if (itk->focus_no == itk->control_no)
    css_start (mrg, "propline:focused", NULL);
  else
    css_start (mrg, "propline", NULL);
  css_start (mrg, "toggle", NULL);

  css_print (mrg, label);

  if (set)
  {
      css_print (mrg, "(x)");
  }
  else
  {
      css_print (mrg, "( )");
  }

  css_end (mrg, &extent);
  css_end (mrg, NULL);
  CtxControl *control = css_add_control (itk, UI_TOGGLE, label,
                  extent.x, extent.y, extent.width, extent.height);

  control_ref (control);
  control->type = UI_TOGGLE;
  ctx_rectangle (ctx, extent.x, extent.y, extent.width, extent.height);
  ctx_listen_with_finalize (ctx, CTX_CLICK, button_clicked, control, itk, control_finalize, NULL);
  ctx_reset_path (ctx);

  if (control->no == itk->focus_no && itk->return_value)
  {
    itk->return_value = 0;
    ctx_queue_draw (ctx);
    return !set;
  }
  return set;
}

void expander_clicked (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CtxControl *control = userdata;
  int *val = control->val;
  *val = (*val)?0:1;
  css_set_focus_no (itk, control->no);
  ctx_queue_draw (event->ctx);
}

int css_expander (Css *itk, const char *label, int *val)
{
  Css *mrg = (Css*)itk;
  CtxFloatRectangle extent;
  if (itk->focus_no == itk->control_no)
    css_start (mrg, "propline:focused", NULL);
  else
    css_start (mrg, "propline", NULL);

  css_labelf (itk, "%s %s", *val?"V":">", label);

  css_end (mrg, &extent);
  CtxControl *control = css_add_control (itk, UI_EXPANDER, label,
                  extent.x, extent.y, extent.width, extent.height);
  control->val = val;

  return *val;
}

int css_button (Css *itk, const char *label)
{
#if 1
  Ctx *ctx = itk->ctx;
  Css *mrg = (Css*)itk;
  //float em = css_em (itk);
  //float width = ctx_text_width (ctx, label) + em * itk->rel_hpad * 2;
  CtxFloatRectangle extent;
   
  css_start (mrg, itk->focus_no == itk->control_no ? "button:focused" : "button", NULL);

//  css_label (itk, label);
  css_print (mrg, label);

  css_end (mrg, &extent);

  CtxControl *control = css_add_control (itk, UI_BUTTON, label,
                  extent.x, extent.y, extent.width, extent.height);
                             //itk->x, itk->y, width, em * itk->rel_ver_advance);

  control_ref (control);
  control->type = UI_BUTTON;
  ctx_rectangle (ctx, extent.x, extent.y, extent.width, extent.height);
  ctx_listen_with_finalize (ctx, CTX_CLICK, button_clicked, control, itk, control_finalize, NULL);
  ctx_reset_path (ctx);

  //css_newline (itk);
  if (control->no == itk->focus_no && itk->return_value)
  {
    itk->return_value = 0;
    ctx_queue_draw (ctx);
    return 1;
  }
  return 0;
#else

  Ctx *ctx = itk->ctx;
  float em = css_em (itk);
  float width = ctx_text_width (ctx, label) + em * itk->rel_hpad * 2;



  CtxControl *control = css_add_control (itk, UI_BUTTON, label,
                             itk->x, itk->y, width, em * itk->rel_ver_advance);

  css_style_color (itk->ctx, "itk-button-shadow");
  ctx_reset_path (ctx);
  ctx_round_rectangle (ctx, itk->x + em * 0.1, itk->y + em * 0.1, width, em * itk->rel_ver_advance, em*0.33);
  ctx_fill (ctx);

  {
    float px = ctx_pointer_x (itk->ctx);
    float py = ctx_pointer_y (itk->ctx);
    if (px >= control->x && px <= control->x + control->width &&
        py >= control->y && py <= control->y + control->height)
    {
      css_style_color (itk->ctx, "itk-button-hover-bg");
    }
  else
    {
  if (itk->focus_no == control->no)
    css_style_color (itk->ctx, "itk-button-focused-bg");
  else
    css_style_color (itk->ctx, "itk-interactive-bg");
  }
  }

  ctx_round_rectangle (ctx, itk->x, itk->y, width, em * itk->rel_ver_advance, em * 0.33);
  ctx_fill (ctx);


  css_style_color (itk->ctx, "itk-button-fg");
  ctx_move_to (ctx, itk->x + em * itk->rel_hpad,  itk->y + em * itk->rel_baseline);
  ctx_text (ctx, label);

  control_ref (control);
  control->type = UI_BUTTON;
  ctx_rectangle (ctx, itk->x, itk->y, width, em * itk->rel_ver_advance);
  ctx_listen_with_finalize (ctx, CTX_CLICK, button_clicked, control, itk, control_finalize, NULL);
  ctx_reset_path (ctx);

//  css_newline (itk);
  if (control->no == itk->focus_no && itk->return_value)
  {
    itk->return_value = 0;
    ctx_queue_draw (ctx);
    return 1;
  }
  return 0;

#endif
}

static void css_choice_clicked (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata2;
  CtxControl *control = userdata;
  itk->choice_active = 1;
  itk->choice_no = control->value;
  css_set_focus_no (itk, control->no);
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

int css_choice (Css *itk, const char *label, int val)
{
  Ctx *ctx = itk->ctx;
  Css *mrg = (Css*)itk;
  //float em = css_em (itk);
  //float width = ctx_text_width (ctx, label) + em * itk->rel_hpad * 2;
  CtxFloatRectangle extent;
  
  if (itk->focus_no == itk->control_no)
    css_start (mrg, "propline:focused", NULL);
  else
    css_start (mrg, "propline", NULL);

  for (CtxList *l = itk->choices; l; l=l?l->next:NULL)
  {
    UiChoice *choice = l->data;
    if (choice->val == val)
      css_printf (mrg, "%s %s", label, choice->label);
  }

  //css_end (mrg, NULL);
  css_end (mrg, &extent);
  CtxControl *control = css_add_control (itk, UI_CHOICE, label,
                  extent.x, extent.y, extent.width, extent.height);
  control->value = val;
  control_ref (control);


  ctx_rectangle (ctx, extent.x, extent.y, extent.width, extent.height);
  ctx_listen_with_finalize (ctx, CTX_CLICK, css_choice_clicked, control, itk, control_finalize, NULL);
  ctx_reset_path (ctx);
  if (itk->focus_no == itk->control_no-1)
  {
    Css *mrg = (Css*)itk;
    if (itk->choice_active)
    {
      css_start (mrg, "div.choice_menu_wrap", NULL);
      css_start (mrg, "div.choice_menu", NULL);

      for (CtxList *l = itk->choices; l; l=l?l->next:NULL)
      {
        UiChoice *choice = l->data;
       if (((int)control->value) == choice->val)
         css_start (mrg, "div.choice:chosen", NULL);
       else
         css_start (mrg, "div.choice", NULL);
       css_print (mrg, choice->label);
       css_end (mrg, NULL);
     }
     css_end (mrg, NULL);
     css_end (mrg, NULL);
    }
    if (!itk->choice_active)
    {
      itk->choice_no = val;
    }
    else
    {
      control->value = val;
    }
    itk->popup_x = control->x;
    itk->popup_y = control->y + (itk->panel?-itk->panel->scroll:0);
    itk->popup_width = control->width;
    itk->popup_height = control->height;
    if (itk->return_value)
    {
      itk->return_value = 0;
      ctx_queue_draw (itk->ctx);
      return itk->choice_no;
    }
  }

  return val;
}

void css_choice_add (Css *itk, int value, const char *label)
{
  UiChoice *choice= calloc (1, sizeof (UiChoice));
  choice->val = value;
  choice->label = strdup (label);
  ctx_list_append (&itk->choices, choice);
}


void css_set_focus_no (Css *itk, int pos)
{
   if (itk->focus_no != pos)
   {
     itk->focus_no = pos;

     css_lost_focus (itk);
     ctx_queue_draw (itk->ctx);
   }
}

CtxControl *css_hovered_control(Css *itk)
{
  float px = ctx_pointer_x (itk->ctx);
  float py = ctx_pointer_y (itk->ctx);
  for (CtxList *l = itk->controls; l; l=l->next)
  {
    CtxControl *control = l->data;
    if (px >= control->x && px <= control->x + control->width &&
        py >= control->y && py <= control->y + control->height)
    {
      return control;
    }
  }
  return NULL;
}

CtxControl *css_focused_control(Css *itk)
{
  for (CtxList *l = itk->controls; l; l=l->next)
  {
    CtxControl *control = l->data;
    if (control->no == itk->focus_no)
    {
      return control;
    }
  }


  return NULL;
}

#define CSS_DIRECTION_PREVIOUS  -1
#define CSS_DIRECTION_NEXT       1
#define CSS_DIRECTION_LEFT       2
#define CSS_DIRECTION_RIGHT      3
#define CSS_DIRECTION_UP         4
#define CSS_DIRECTION_DOWN       5

void css_focus (Css *itk, int dir)
{
   css_lost_focus (itk);
   if (itk->focus_no < 0)
   {
     itk->focus_no = 0;
     return;
   }

   if (dir == CSS_DIRECTION_PREVIOUS ||
       dir == CSS_DIRECTION_NEXT)
   {
     itk->focus_no += dir;

     int n_controls = ctx_list_length (itk->controls);
     CtxList *iter = ctx_list_nth (itk->controls, n_controls-itk->focus_no-1);
     if (iter)
     {
       CtxControl *control = iter->data;
       itk->focus_no = control->no;
     }
     else
     {
       if (itk->focus_wraparound)
       {
         if (itk->focus_no > 1)
           itk->focus_no = 0;
         else
           itk->focus_no = itk->control_no - 1;
       }
       else
       {
         if (itk->focus_no <= 1)
           itk->focus_no = 0;
         else
           itk->focus_no = itk->control_no - 1;
       }
     }
     // XXX no control means inifinie loop?
     CtxControl *control =
             css_focused_control (itk);
#if 1
     if (!control || 
         !(control->flags & CSS_FLAG_ACTIVE)){
       css_focus (itk, dir);
     }
#endif
   }
  else 
  {
    /* this implements the non-inner element portions of:
     *   https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance
     *
     * validity is determined by the centers of the items.
     */

    CtxControl *control = css_focused_control (itk);
    CtxControl *best = control;

    if (!best)
       best = itk->controls->data;

    float best_dist = 10000000000.0;
    {
      //float mid_ref_x = control->x + control->width/2;
      //float mid_ref_y = control->y + control->height/2;
      for (CtxList *iter = itk->controls; iter; iter=iter->next)
      {
        CtxControl *candidate = iter->data;
        //float mid_cand_x = candidate->x + candidate->width/2;
        //float mid_cand_y = candidate->y + candidate->height/2;

        int valid = 0;
        if (candidate != control)
        switch (dir)
        {
          case CSS_DIRECTION_DOWN:
            valid = candidate->y > control->y;
            break;
          case CSS_DIRECTION_UP:
            valid = candidate->y < control->y;
            break;
          case CSS_DIRECTION_LEFT:
            valid = candidate->x < control->x;
            break;
          case CSS_DIRECTION_RIGHT:
            valid = candidate->x > control->x;
            break;
        }

        if (valid)
        {
          float cand_coord[2]={0.f,0.f};
          float control_coord[2]={0.f,0.f};

          float overlap = 0.0f;
          float orthogonalSize = 1.0f;
          float orthogonalBias = 1.0f;
          float orthogonalWeight = 1.0f;
          float alignWeight = 5.0f;


        switch (dir)
        {
          case CSS_DIRECTION_DOWN:
            control_coord[1] = control->y + control->height;
            cand_coord[1]    = candidate->y;
            orthogonalSize   = control->width;
            orthogonalBias   = orthogonalSize / 2.0f;
            orthogonalWeight = 2.0f;

            if (candidate->x + candidate->width < control->x)
            {
////    ---------- control
///  --            candidate
              cand_coord[0]    = candidate->x + candidate->width;
              control_coord[0] = control->x;
            }
            else if (candidate->x < control->x &&
                     candidate->x + candidate->width < control->x + control->width)
            {
///     ----------
///  ------
              cand_coord[0]    = control->x;
              control_coord[0] = control->x;
              overlap = (candidate->x+candidate->width) - (control->x);
            }
            else if (candidate->x > control->x &&
                     candidate->x + candidate->width < control->x + control->width)
            {
///     ----------
///       ------
              cand_coord[0]    = candidate->x;
              control_coord[0] = candidate->x;
              overlap          = candidate->width;
            }
            else if (candidate->x < control->x &&
                     candidate->x + candidate->width > control->x + control->width)
            {
///     ----------
///   --------------
              cand_coord[0]    = control->x;
              control_coord[0] = control->x;
              overlap          = control->width;
            }
            else if (candidate->x > control->x &&
                     candidate->x < control->x + control->width &&
                     candidate->x + candidate->width > control->x + control->width)
            {
///     ----------
///         ----------
              cand_coord[0]    = candidate->x;
              control_coord[0] = candidate->x;
              overlap          = control->x + control->width -
                                 candidate->x;
            }
            else if (candidate->x > control->x + control->width)
            {
///     ----------
///                  ------
              cand_coord[0]    = candidate->x;
              control_coord[0] = control->x + control->width;
            }
            else
            {
              cand_coord[0]    = candidate->x;
              control_coord[0] = candidate->x;
              overlap          = candidate->width;
            }

            break;
          case CSS_DIRECTION_UP:

            control_coord[1] = control->y;
            cand_coord[1]    = candidate->y + candidate->height;
            orthogonalSize   = control->width;
            orthogonalBias   = orthogonalSize / 2.0f;
            orthogonalWeight = 2.0f;

            if (candidate->x + candidate->width < control->x)
            {
////    ---------- control
///  --            candidate
              cand_coord[0]    = candidate->x + candidate->width;
              control_coord[0] = control->x;
            }
            else if (candidate->x < control->x &&
                     candidate->x + candidate->width < control->x + control->width)
            {
///     ----------
///  ------
              cand_coord[0]    = control->x;
              control_coord[0] = control->x;
              overlap = (candidate->x+candidate->width) - (control->x);
            }
            else if (candidate->x > control->x &&
                     candidate->x + candidate->width < control->x + control->width)
            {
///     ----------
///       ------
              cand_coord[0]    = candidate->x;
              control_coord[0] = candidate->x;
              overlap          = candidate->width;
            }
            else if (candidate->x < control->x &&
                     candidate->x + candidate->width > control->x + control->width)
            {
///     ----------
///   --------------
              cand_coord[0]    = control->x;
              control_coord[0] = control->x;
              overlap          = control->width;
            }
            else if (candidate->x > control->x &&
                     candidate->x < control->x + control->width &&
                     candidate->x + candidate->width > control->x + control->width)
            {
///     ----------
///         ----------
              cand_coord[0]    = candidate->x;
              control_coord[0] = candidate->x;
              overlap          = control->x + control->width -
                                 candidate->x;
            }
            else if (candidate->x > control->x + control->width)
            {
///     ----------
///                  ------
              cand_coord[0]    = candidate->x;
              control_coord[0] = control->x + control->width;
            }
            else
            {
              cand_coord[0]    = candidate->x;
              control_coord[0] = candidate->x;
              overlap          = candidate->width;
            }

            break;
          case CSS_DIRECTION_LEFT:
            control_coord[0] = control->x;
            cand_coord[0]    = candidate->x + candidate->width;
            orthogonalSize   = control->height;
            orthogonalBias   = orthogonalSize / 2.0f;
            orthogonalWeight = 30.0f;

            if (candidate->y + candidate->height < control->y)
            {
////    ---------- control
///  --            candidate
              cand_coord[1]    = candidate->y + candidate->height;
              control_coord[1] = control->y;
            }
            else if (candidate->y < control->y &&
                     candidate->y + candidate->height < control->y + control->height)
            {
///     ----------
///  ------
              cand_coord[1]    = control->y;
              control_coord[1] = control->y;
              overlap = (candidate->y+candidate->height) - (control->y);
            }
            else if (candidate->y > control->y &&
                     candidate->y + candidate->height < control->y + control->height)
            {
///     ----------
///       ------
              cand_coord[1]    = candidate->y;
              control_coord[1] = candidate->y;
              overlap = candidate->height;
            }
            else if (candidate->y < control->y &&
                     candidate->y + candidate->height > control->y + control->height)
            {
///     ----------
///   --------------
              cand_coord[1]    = control->y;
              control_coord[1] = control->y;
              overlap = control->height;
            }
            else if (candidate->y > control->y &&
                     candidate->y < control->y + control->height &&
                     candidate->y + candidate->height > control->y + control->height)
            {
///     ----------
///         ----------
              cand_coord[1]    = candidate->y;
              control_coord[1] = candidate->y;
              overlap = control->y + control->height - candidate->y;
            }
            else if (candidate->y > control->y + control->height)
            {
///     ----------
///                  ------
              cand_coord[1]    = candidate->y;
              control_coord[1] = control->y + control->height;
            }
            else
            {
              cand_coord[1]    = candidate->y;
              control_coord[1] = candidate->y;
              overlap          = candidate->height;
            }




            break;
          case CSS_DIRECTION_RIGHT:
            control_coord[0] = control->x + control->width;
            cand_coord[0]    = candidate->x;
            orthogonalSize   = control->height;
            orthogonalBias   = orthogonalSize / 2.0f;
            orthogonalWeight = 30.0f;

            if (candidate->y + candidate->height < control->y)
            {
////    ---------- control
///  --            candidate
              cand_coord[1]    = candidate->y + candidate->height;
              control_coord[1] = control->y;
            }
            else if (candidate->y < control->y &&
                     candidate->y + candidate->height < control->y + control->height)
            {
///     ----------
///  ------
              cand_coord[1]    = control->y;
              control_coord[1] = control->y;
              overlap = (candidate->y+candidate->height) - (control->y);
            }
            else if (candidate->y > control->y &&
                     candidate->y + candidate->height < control->y + control->height)
            {
///     ----------
///       ------
              cand_coord[1]    = candidate->y;
              control_coord[1] = candidate->y;
              overlap = candidate->height;
            }
            else if (candidate->y < control->y &&
                     candidate->y + candidate->height > control->y + control->height)
            {
///     ----------
///   --------------
              cand_coord[1]    = control->y;
              control_coord[1] = control->y;
              overlap = control->height;
            }
            else if (candidate->y > control->y &&
                     candidate->y < control->y + control->height &&
                     candidate->y + candidate->height > control->y + control->height)
            {
///     ----------
///         ----------
              cand_coord[1]    = candidate->y;
              control_coord[1] = candidate->y;
              overlap = control->y + control->height - candidate->y;
            }
            else if (candidate->y > control->y + control->height)
            {
///     ----------
///                  ------
              cand_coord[1]    = candidate->y;
              control_coord[1] = control->y + control->height;
            }
            else
            {
              cand_coord[1]    = candidate->y;
              control_coord[1] = candidate->y;
              overlap          = candidate->height;
            }

            break;
        }

        float displacement =  0.0f;

        switch (dir)
        {
          case CSS_DIRECTION_DOWN:
          case CSS_DIRECTION_UP:
            displacement = (fabsf(cand_coord[0]-control_coord[0]) +
                    orthogonalBias) * orthogonalWeight;
            break;
          case CSS_DIRECTION_LEFT:
          case CSS_DIRECTION_RIGHT:
            displacement = (fabsf(cand_coord[1]-control_coord[1]) +
                    orthogonalBias) * orthogonalWeight;
            break;
        }

        float alignBias = overlap / orthogonalSize;
        float alignment = alignWeight * alignBias;

        float euclidian = hypotf (cand_coord[0]-control_coord[0],
                                  cand_coord[1]-control_coord[1]);


        float dist = euclidian  + displacement - alignment - sqrtf(sqrtf(overlap));
        // here we deviate from the algorithm - giving a smaller bonus to overlap
        // to ensure more intermediate small ones miht be chosen
        //float dist = euclidian  + displacement - alignment - sqrtf(overlap);
          if (dist <= best_dist)
          {
             best_dist = dist;
             best = candidate;
          }
        }
      }
    }

    css_set_focus_no (itk, best->no);
  }
}

void css_key_tab (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;
  css_focus (itk, CSS_DIRECTION_NEXT);

  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_key_shift_tab (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;
  css_focus (itk, CSS_DIRECTION_PREVIOUS);

  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_key_return (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;
  if (control->no == itk->focus_no)
  {
    switch (control->type)
    {
      case UI_CHOICE:
       {
          itk->choice_active = !itk->choice_active;
       }
       break;
      case UI_ENTRY:
       {
         if (itk->active)
         {
           css_entry_commit (itk);
         }
         else
         {
           itk->entry_copy = strdup (control->entry_value);
           itk->entry_pos = strlen (itk->entry_copy);
           itk->active = 1;
           itk->active_entry = control->no;
         }
       }
       break;
      case UI_SLIDER:
        if (itk->active)
        {
          itk->active = 0;
        }
        else
        {
          itk->active = 1;
        }
        break;
      case UI_TOGGLE:
          itk->return_value=1;
          break;
      case UI_EXPANDER:
        {
          int *val = control->val;
          *val = !(*val);
        }
        break;
      case UI_RADIO:
      case UI_BUTTON:
        {
          itk->return_value=1;
        }
        break;
    }
  }
  event->stop_propagate=1;
  ctx_queue_draw (event->ctx);
}

void css_key_left (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;

  if (itk->active)
  {
  switch (control->type)
  {
    case UI_TOGGLE:
    case UI_EXPANDER:
    case UI_CHOICE:
      css_key_return (event, data, data2);
      break;
    case UI_ENTRY:
      itk->entry_pos --;
      if (itk->entry_pos < 0)
        itk->entry_pos = 0;
      break;
    case UI_SLIDER:
      {
        double val = control->value;
        val -= control->step;
        if (val < control->min)
          val = control->min;

        itk->slider_value = control->value = val;
        itk->return_value = 1;
      }
      break;
  }
  }
  else
  {
    css_focus (itk, CSS_DIRECTION_LEFT);
  }

  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_key_right (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;

  if (itk->active)
  {
  switch (control->type)
  {
    case UI_TOGGLE:
    case UI_EXPANDER:
    case UI_BUTTON:
    case UI_CHOICE:
    case UI_RADIO:
      // css_key_return (event, data, data2);
      break;
    case UI_ENTRY:
     itk->entry_pos ++;
     if (itk->entry_pos > (int)strlen (itk->entry_copy))
       itk->entry_pos = strlen (itk->entry_copy);
      break;
    case UI_SLIDER:
      {
        double val = control->value;
        val += control->step;
        if (val > control->max) val = control->max;

        itk->slider_value = control->value = val;
        itk->return_value = 1;
      }
      break;
  }
  }
  else
  {
    css_focus (itk, CSS_DIRECTION_RIGHT);
  }

  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_key_up (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);

  if (control && control->type == UI_CHOICE && itk->choice_active)
  {
    int old_val = itk->choice_no;
    int prev_val = old_val;
    for (CtxList *l = itk->choices; l; l=l?l->next:NULL)
    {
      UiChoice *choice = l->data;
      if (choice->val == old_val)
      {
        itk->choice_no = prev_val;
        itk->return_value = 1;
        l=NULL;
      }
      prev_val = choice->val;
    }
  }
  else if (control)
  {
    css_focus (itk, CSS_DIRECTION_UP);
  }
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}

void css_key_down (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (control && control->type == UI_CHOICE && itk->choice_active)
  {
    {
    int old_val = itk->choice_no;
    for (CtxList *l = itk->choices; l; l=l?l->next:NULL)
    {
      UiChoice *choice = l->data;
      if (choice->val == old_val)
      {
         if (l->next)
         {
           l = l->next;
           choice = l->data;
           itk->choice_no = choice->val;
           itk->return_value = 1;
         }
      }
    }
    }
  }
  else if (control)
  {
    css_focus (itk, CSS_DIRECTION_DOWN);
  }
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}


void css_key_backspace (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;
  if (!itk->entry_copy) return;
  if (!itk->active) return;

  switch (control->type)
  {
    case UI_ENTRY:
     {
       if (itk->active && itk->entry_pos > 0)
       {
         memmove (&itk->entry_copy[itk->entry_pos-1], &itk->entry_copy[itk->entry_pos],
                   strlen (&itk->entry_copy[itk->entry_pos] )+ 1);
         itk->entry_pos --;
       }
     }
     break;
  }
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_key_delete (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  CtxControl *control = css_focused_control (itk);
  if (!control) return;
  if (!itk->entry_copy) return;
  if (!itk->active) return;
  if ((int)strlen (itk->entry_copy) > itk->entry_pos)
  {
    css_key_right (event, data, data2);
    css_key_backspace (event, data, data2);
  }
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_key_unhandled (CtxEvent *event, void *userdata, void *userdata2)
{
  Css *itk = userdata;

  if (itk->active && itk->entry_copy)
    {
      const char *str = event->string;
      if (!strcmp (str, "space"))
        str = " ";

      if (ctx_utf8_strlen (str) == 1)
      {

      char *tmp = malloc (strlen (itk->entry_copy) + strlen (str) + 1);

      char *rest = strdup (&itk->entry_copy[itk->entry_pos]);
      itk->entry_copy[itk->entry_pos]=0;

      sprintf (tmp, "%s%s%s", itk->entry_copy, str, rest);
      free (rest);
      itk->entry_pos+=strlen(str);
      free (itk->entry_copy);
      itk->entry_copy = tmp;
      ctx_queue_draw (event->ctx);
      }
      else
      {
              printf ("unhandled %s\n", str);
      }
    }
  event->stop_propagate = 1;
}

void css_key_bindings (Css *itk)
{
  Ctx *ctx = itk->ctx;
  ctx_add_key_binding (ctx, "tab", NULL, "focus next",            css_key_tab,       itk);
  ctx_add_key_binding (ctx, "shift-tab", NULL, "focus previous",      css_key_shift_tab, itk);

  ctx_add_key_binding (ctx, "up", NULL, "spatial focus up",        css_key_up,    itk);
  ctx_add_key_binding (ctx, "down", NULL, "spatical focus down",   css_key_down,  itk);
  ctx_add_key_binding (ctx, "right", NULL, "spatial focus right",  css_key_right, itk);
  ctx_add_key_binding (ctx, "left", NULL, "spatial focus left",    css_key_left,  itk);

  ctx_add_key_binding (ctx, "return", NULL, "enter/edit", css_key_return,    itk);
  ctx_add_key_binding (ctx, "backspace", NULL, NULL,    css_key_backspace, itk);
  ctx_add_key_binding (ctx, "delete", NULL, NULL,       css_key_delete,    itk);
  ctx_add_key_binding (ctx, "any", NULL, NULL,          css_key_unhandled, itk);
}

#if 0
static void css_choice_set (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  itk->choice_no = (size_t)(data2);
  itk->return_value = 1;
  ctx_queue_draw (event->ctx);
  event->stop_propagate = 1;
}
#endif

void ctx_event_block (CtxEvent *event, void *data, void *data2)
{
  Css *itk = data;
  itk->choice_active = 0;
  event->stop_propagate = 1;
  ctx_queue_draw (event->ctx);
}

void css_done (Css *itk)
{
  Ctx *ctx = itk->ctx;

  CtxControl *control = css_focused_control (itk);
#if 0
  CtxControl *hovered_control = css_hovered_control (itk);
  int hovered_no = hovered_control ? hovered_control->no : -1;

  if (itk->hovered_no != hovered_no)
  {
    itk->hovered_no = hovered_no;
    ctx_queue_draw (ctx);
  }
#endif

  if (!control){
    ctx_restore (ctx);
    return;
  }

  ctx_restore (ctx);
}

int ctx_renderer_is_sdl (Ctx *ctx);
int ctx_renderer_is_fb  (Ctx *ctx);

void
css_ctx_settings (Css *itk)
{
#ifdef CTX_MAX_THREADS
  static int ctx_settings = 0;
  static int inited = 0;
  static int threads;
  //static int hash_cache_enabled;
  Ctx *ctx = itk->ctx;

  if (!inited){
    inited = 1;
    threads = ctx_get_render_threads (ctx);
    //hash_cache_enabled = ctx_get_hash_cache (ctx);
  }
  if (css_expander (itk, "CTX settings", &ctx_settings))
  {
    
    threads = css_slider (itk, "threads", threads, 1, CTX_MAX_THREADS, 1);
    if (threads != ctx_get_render_threads (ctx))
    {
      ctx_set_render_threads (ctx, threads);
    }
  }
#endif
}

void
css_css_settings (Css *itk)
{
   static int css_settings = 0;
   if (css_expander (itk, "Css settings", &css_settings))
   {
     //itk->focus_wraparound = css_toggle (itk, "focus wraparound", itk->focus_wraparound);
     //enable_keybindings = css_toggle (itk, "enable keybindings", enable_keybindings);
     //itk->light_mode = css_toggle (itk, "light mode", itk->light_mode);

     itk->scale     = css_slider (itk, "global scale", itk->scale, 0.1, 8.0, 0.1);
     itk->font_size = css_slider (itk, "font size ", itk->font_size, 3.0, 60.0, 0.25);

     // these will go away with css styling merged.
     css_slider_float (itk, "vgap", &itk->rel_vgap, 0.0, 3.0, 0.02);
     css_slider_float (itk, "scroll speed", &itk->scroll_speed, 0.0, 1.0, 0.01);
     css_slider_float (itk, "ver advance", &itk->rel_ver_advance, 0.1, 4.0, 0.01);
     css_slider_float (itk, "hmargin", &itk->rel_hmargin, 0.0, 40.0, 0.1);
     css_slider_float (itk, "vmargin", &itk->rel_vmargin, 0.0, 40.0, 0.1);
     css_slider_float (itk, "label width", &itk->label_width, 0.0, 40.0, 0.02);
   }
}

void css_key_quit (CtxEvent *event, void *userdata, void *userdata2)
{
  ctx_exit (event->ctx);
}

int _css_key_bindings_active = 1;

static int
css_iteration (double time, void *data)
{
  Css *itk = (Css*)data;
  Ctx *ctx = itk->ctx;
  int   ret_val = 1;

    if (1 || ctx_need_redraw (ctx))
    {
      css_reset (itk);
      if (_css_key_bindings_active)
        css_key_bindings (itk);
      ctx_add_key_binding (itk->ctx, "control-q", NULL, "Quit", css_key_quit, NULL);
      if (itk->ui_fun)
      ret_val = itk->ui_fun (itk, itk->ui_data);

      css_done (itk);
      ctx_end_frame (ctx);
    }

    return ret_val;
}

#ifdef EMSCRIPTEN
#include <emscripten/html5.h>
#endif

void css_run_ui (Css *itk, int (*ui_fun)(Css *itk, void *data), void *ui_data)
{
  itk->ui_fun  = ui_fun;
  itk->ui_data = ui_data;
  int  ret_val = 1;

#ifdef EMSCRIPTEN
#ifdef ASYNCIFY
  while (!ctx_has_exited (itk->ctx) && (ret_val == 1))
  {
    ret_val = css_iteration (0.0, itk);
  }
#else
  emscripten_request_animation_frame_loop (css_iteration, itk);
  return;
#endif
#else
  while (!ctx_has_exited (itk->ctx) && (ret_val == 1))
  {
    ret_val = css_iteration (0.0, itk);
  }
#endif
}

void css_main (int (*ui_fun)(Css *itk, void *data), void *ui_data)
{
  Ctx *ctx = ctx_new (-1, -1, NULL);
  Css  *itk = css_new (ctx);
  css_run_ui (itk, ui_fun, ui_data);
  css_destroy (itk);
  ctx_destroy (ctx);
}


float       css_x            (Css *itk)
{
  return itk->x;
}
float       css_y            (Css *itk)
{
  return itk->y;
}
void css_set_x  (Css *itk, float x)
{
  itk->x = x;
}
void css_set_y  (Css *itk, float y)
{
  itk->y = y;
}
void css_set_xy  (Css *itk, float x, float y)
{
  itk->x = x;
  itk->y = y;
}


void css_set_height (Css *itk, float height)
{
   itk->height = height;
   itk->edge_bottom = itk->edge_top + height;
   css_set_edge_top ((Css*)itk, itk->edge_top);
   css_set_edge_bottom ((Css*)itk, itk->edge_bottom);
}

float css_edge_bottom (Css *itk)
{
   return itk->edge_bottom ;
}
float css_edge_top (Css *itk)
{
   return itk->edge_top ;
}
float css_edge_left (Css *itk)
{
   return itk->edge_left;
}
float css_height (Css *itk)
{
   return itk->height;
}
float css_wrap_width (Css *itk)
{
    return itk->width; // XXX compute from edges:w
}
void css_set_wrap_width (Css *itk, float wwidth)
{
    itk->width = wwidth;
    itk->edge_right = itk->edge_left + wwidth;
    css_set_edge_right ((Css*)itk, itk->edge_right);
    css_set_edge_left ((Css*)itk, itk->edge_left);
}

float css_edge_right (Css *itk)
{
   return itk->edge_right;
}

Ctx *css_ctx (Css *itk)
{
  return itk->ctx;
}

void css_set_scale (Css *itk, float scale)
{
  itk->scale = scale;
  ctx_queue_draw (itk->ctx);
}

float css_scale (Css *itk)
{
  return itk->scale;
}

int css_focus_no (Css *itk)
{
  return itk->focus_no;
}

int css_is_editing_entry (Css *itk)
{
  return itk->entry_copy != NULL;
}

int  css_control_no (Css *itk)
{
  return itk->control_no;
}

float css_panel_scroll (Css *itk)
{
  CssPanel *panel = itk->panel;
  if (!panel)
    panel = itk->panels?itk->panels->data:NULL;
  if (!panel) return 0.0f;
  return panel->scroll;
}

void css_panel_set_scroll (Css *itk, float scroll)
{
  CssPanel *panel = itk->panel;
  if (!panel)
    panel = itk->panels?itk->panels->data:NULL;
  if (!panel) return;
  if (scroll < 0.0) scroll = 0.0f;
    panel->scroll = scroll;
  ctx_queue_draw (itk->ctx);
}

#endif

#endif // CTX_IMPLEMENTATION
#endif //  __CTX_H__
